[
  {
    "function_name": "ppc_warn_emulated_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1931-1962",
    "snippet": "static int __init ppc_warn_emulated_init(void)\n{\n\tstruct dentry *dir, *d;\n\tunsigned int i;\n\tstruct ppc_emulated_entry *entries = (void *)&ppc_emulated;\n\n\tif (!powerpc_debugfs_root)\n\t\treturn -ENODEV;\n\n\tdir = debugfs_create_dir(\"emulated_instructions\",\n\t\t\t\t powerpc_debugfs_root);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\td = debugfs_create_u32(\"do_warn\", S_IRUGO | S_IWUSR, dir,\n\t\t\t       &ppc_warn_emulated);\n\tif (!d)\n\t\tgoto fail;\n\n\tfor (i = 0; i < sizeof(ppc_emulated)/sizeof(*entries); i++) {\n\t\td = debugfs_create_u32(entries[i].name, S_IRUGO | S_IWUSR, dir,\n\t\t\t\t       (u32 *)&entries[i].val.counter);\n\t\tif (!d)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdebugfs_remove_recursive(dir);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "entries[i].name",
            "S_IRUGO | S_IWUSR",
            "dir",
            "(u32 *)&entries[i].val.counter"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"do_warn\"",
            "S_IRUGO | S_IWUSR",
            "dir",
            "&ppc_warn_emulated"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"emulated_instructions\"",
            "powerpc_debugfs_root"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init ppc_warn_emulated_init(void)\n{\n\tstruct dentry *dir, *d;\n\tunsigned int i;\n\tstruct ppc_emulated_entry *entries = (void *)&ppc_emulated;\n\n\tif (!powerpc_debugfs_root)\n\t\treturn -ENODEV;\n\n\tdir = debugfs_create_dir(\"emulated_instructions\",\n\t\t\t\t powerpc_debugfs_root);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\td = debugfs_create_u32(\"do_warn\", S_IRUGO | S_IWUSR, dir,\n\t\t\t       &ppc_warn_emulated);\n\tif (!d)\n\t\tgoto fail;\n\n\tfor (i = 0; i < sizeof(ppc_emulated)/sizeof(*entries); i++) {\n\t\td = debugfs_create_u32(entries[i].name, S_IRUGO | S_IWUSR, dir,\n\t\t\t\t       (u32 *)&entries[i].val.counter);\n\t\tif (!d)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdebugfs_remove_recursive(dir);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ppc_warn_emulated_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1925-1929",
    "snippet": "void ppc_warn_emulated_print(const char *type)\n{\n\tpr_warn_ratelimited(\"%s used emulated %s instruction\\n\", current->comm,\n\t\t\t    type);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"%s used emulated %s instruction\\n\"",
            "current->comm",
            "type"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid ppc_warn_emulated_print(const char *type)\n{\n\tpr_warn_ratelimited(\"%s used emulated %s instruction\\n\", current->comm,\n\t\t\t    type);\n}"
  },
  {
    "function_name": "trap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1885-1887",
    "snippet": "void __init trap_init(void)\n{\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __init trap_init(void)\n{\n}"
  },
  {
    "function_name": "kernel_bad_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1878-1883",
    "snippet": "void kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Bad kernel stack pointer\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\"",
            "regs->gpr[1]",
            "regs->nip"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "WatchdogException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1867-1871",
    "snippet": "void WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WatchdogHandler",
          "args": [
            "regs"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "WatchdogHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1860-1865",
          "snippet": "void __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\""
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}"
  },
  {
    "function_name": "WatchdogHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1860-1865",
    "snippet": "void __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_TCR",
            "mfspr(SPRN_TCR)&(~TCR_WIE)"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_TCR"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}"
  },
  {
    "function_name": "unrecoverable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1848-1853",
    "snippet": "void unrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable exception %lx at %lx\\n\",\n\t       regs->trap, regs->nip);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable exception %lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid unrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable exception %lx at %lx\\n\",\n\t       regs->trap, regs->nip);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "SPEFloatingPointRoundException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1810-1839",
    "snippet": "void SPEFloatingPointRoundException(struct pt_regs *regs)\n{\n\textern int speround_handler(struct pt_regs *regs);\n\tint err;\n\n\tpreempt_disable();\n\tif (regs->msr & MSR_SPE)\n\t\tgiveup_spe(current);\n\tpreempt_enable();\n\n\tregs->nip -= 4;\n\terr = speround_handler(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, 0, regs->nip);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "0",
            "regs->nip"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "speround_handler",
          "args": [
            "regs"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "current"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SPEFloatingPointRoundException(struct pt_regs *regs)\n{\n\textern int speround_handler(struct pt_regs *regs);\n\tint err;\n\n\tpreempt_disable();\n\tif (regs->msr & MSR_SPE)\n\t\tgiveup_spe(current);\n\tpreempt_enable();\n\n\tregs->nip -= 4;\n\terr = speround_handler(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, 0, regs->nip);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "SPEFloatingPointException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1762-1808",
    "snippet": "void SPEFloatingPointException(struct pt_regs *regs)\n{\n\textern int do_spe_mathemu(struct pt_regs *regs);\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = 0;\n\tint err;\n\n\tflush_spe_to_thread(current);\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\terr = do_spe_mathemu(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "code",
            "regs->nip"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_spe_mathemu",
          "args": [
            "regs"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SPEFloatingPointException(struct pt_regs *regs)\n{\n\textern int do_spe_mathemu(struct pt_regs *regs);\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = 0;\n\tint err;\n\n\tflush_spe_to_thread(current);\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\terr = do_spe_mathemu(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "CacheLockingException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1748-1758",
    "snippet": "void CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_PRVOPC",
            "regs->nip"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}"
  },
  {
    "function_name": "altivec_assist_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1714-1744",
    "snippet": "void altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\tPPC_WARN_EMULATED(altivec, regs);\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tprintk_ratelimited(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vr_state.vscr.u[3] |= 0x10000;\n\t}\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGSEGV",
            "regs",
            "SEGV_ACCERR",
            "regs->nip"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_altivec",
          "args": [
            "regs"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_altivec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "259-345",
          "snippet": "int emulate_altivec(struct pt_regs *regs)\n{\n\tunsigned int instr, i;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user(instr, (unsigned int __user *) regs->nip))\n\t\treturn -EFAULT;\n\tif ((instr >> 26) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (instr >> 21) & 0x1f;\n\tva = (instr >> 16) & 0x1f;\n\tvb = (instr >> 11) & 0x1f;\n\tvc = (instr >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (instr & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint emulate_altivec(struct pt_regs *regs)\n{\n\tunsigned int instr, i;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user(instr, (unsigned int __user *) regs->nip))\n\t\treturn -EFAULT;\n\tif ((instr >> 26) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (instr >> 21) & 0x1f;\n\tva = (instr >> 16) & 0x1f;\n\tvb = (instr >> 11) & 0x1f;\n\tvc = (instr >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (instr & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "altivec",
            "regs"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Kernel VMX/Altivec assist exception\"",
            "regs",
            "SIGILL"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\"",
            "regs->nip"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\tPPC_WARN_EMULATED(altivec, regs);\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tprintk_ratelimited(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vr_state.vscr.u[3] |= 0x10000;\n\t}\n}"
  },
  {
    "function_name": "TAUException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1706-1710",
    "snippet": "void TAUException(struct pt_regs *regs)\n{\n\tprintk(\"TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\\n\",\n\t       regs->nip, regs->msr, regs->trap, print_tainted());\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\\n\"",
            "regs->nip",
            "regs->msr",
            "regs->trap",
            "print_tainted()"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid TAUException(struct pt_regs *regs)\n{\n\tprintk(\"TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\\n\",\n\t       regs->nip, regs->msr, regs->trap, print_tainted());\n}"
  },
  {
    "function_name": "DebugException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1642-1702",
    "snippet": "void __kprobes DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tcurrent->thread.debug.dbsr = debug_status;\n\n\t/* Hack alert: On BookE, Branch Taken stops on the branch itself, while\n\t * on server, it stops on the target of the branch. In order to simulate\n\t * the server behaviour, we thus restart right away with a single step\n\t * instead of stopping here when hitting a BT\n\t */\n\tif (debug_status & DBSR_BT) {\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable BT */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_BT);\n\t\t/* Clear the BT event */\n\t\tmtspr(SPRN_DBSR, DBSR_BT);\n\n\t\t/* Do the single step trick only when coming from userspace */\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\t\tcurrent->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\t\tregs->msr |= MSR_DE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (notify_die(DIE_SSTEP, \"block_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\t} else if (debug_status & DBSR_IC) { \t/* Instruction complete */\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable instruction completion */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t/* Clear the instruction completion event */\n\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\n\t\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\t\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t\t\t       current->thread.debug.dbcr1))\n\t\t\t\tregs->msr |= MSR_DE;\n\t\t\telse\n\t\t\t\t/* Make sure the IDM bit is off */\n\t\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\t} else\n\t\thandle_debug(regs, debug_status);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_debug",
          "args": [
            "regs",
            "debug_status"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "handle_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1583-1640",
          "snippet": "static void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status, TRAP_HWBKPT,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status, TRAP_HWBKPT,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status, TRAP_HWBKPT,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status, TRAP_HWBKPT,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_TRACE",
            "regs->nip"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "current->thread.debug.dbcr0",
            "current->thread.debug.dbcr1"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"single_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBSR",
            "DBSR_IC"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "mfspr(SPRN_DBCR0) & ~DBCR0_IC"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DBCR0"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"block_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBSR",
            "DBSR_BT"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "mfspr(SPRN_DBCR0) & ~DBCR0_BT"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DBCR0"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __kprobes DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tcurrent->thread.debug.dbsr = debug_status;\n\n\t/* Hack alert: On BookE, Branch Taken stops on the branch itself, while\n\t * on server, it stops on the target of the branch. In order to simulate\n\t * the server behaviour, we thus restart right away with a single step\n\t * instead of stopping here when hitting a BT\n\t */\n\tif (debug_status & DBSR_BT) {\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable BT */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_BT);\n\t\t/* Clear the BT event */\n\t\tmtspr(SPRN_DBSR, DBSR_BT);\n\n\t\t/* Do the single step trick only when coming from userspace */\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\t\tcurrent->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\t\tregs->msr |= MSR_DE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (notify_die(DIE_SSTEP, \"block_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\t} else if (debug_status & DBSR_IC) { \t/* Instruction complete */\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable instruction completion */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t/* Clear the instruction completion event */\n\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\n\t\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\t\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t\t\t       current->thread.debug.dbcr1))\n\t\t\t\tregs->msr |= MSR_DE;\n\t\t\telse\n\t\t\t\t/* Make sure the IDM bit is off */\n\t\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\t} else\n\t\thandle_debug(regs, debug_status);\n}"
  },
  {
    "function_name": "handle_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1583-1640",
    "snippet": "static void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status, TRAP_HWBKPT,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status, TRAP_HWBKPT,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "current->thread.debug.dbcr0"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "current->thread.debug.dbcr0",
            "current->thread.debug.dbcr1"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send_trap",
          "args": [
            "regs",
            "mfspr(SPRN_IAC4)",
            "debug_status",
            "TRAP_HWBKPT",
            "4"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "306-322",
          "snippet": "void do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int signal_code, int breakpt)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = signal_code;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = breakpt;\t/* breakpoint or watchpoint id */\n\tinfo.si_code = signal_code;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int signal_code, int breakpt)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = signal_code;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = breakpt;\t/* breakpoint or watchpoint id */\n\tinfo.si_code = signal_code;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC4"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC3"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "current"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC2"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC1"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "current"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DAC2"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "current"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DAC1"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "current"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status, TRAP_HWBKPT,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status, TRAP_HWBKPT,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status, TRAP_HWBKPT,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status, TRAP_HWBKPT,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}"
  },
  {
    "function_name": "SoftwareEmulation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1565-1579",
    "snippet": "void SoftwareEmulation(struct pt_regs *regs)\n{\n\tCHECK_FULL_REGS(regs);\n\n\tif (!user_mode(regs)) {\n\t\tdebugger(regs);\n\t\tdie(\"Kernel Mode Unimplemented Instruction or SW FPU Emulation\",\n\t\t\tregs, SIGFPE);\n\t}\n\n\tif (!emulate_math(regs))\n\t\treturn;\n\n\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_math",
          "args": [
            "regs"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_math",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1134-1134",
          "snippet": "static inline int emulate_math(struct pt_regs *regs) { return -1; }",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int emulate_math(struct pt_regs *regs) { return -1; }"
        }
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Kernel Mode Unimplemented Instruction or SW FPU Emulation\"",
            "regs",
            "SIGFPE"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "133-137",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SoftwareEmulation(struct pt_regs *regs)\n{\n\tCHECK_FULL_REGS(regs);\n\n\tif (!user_mode(regs)) {\n\t\tdebugger(regs);\n\t\tdie(\"Kernel Mode Unimplemented Instruction or SW FPU Emulation\",\n\t\t\tregs, SIGFPE);\n\t}\n\n\tif (!emulate_math(regs))\n\t\treturn;\n\n\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}"
  },
  {
    "function_name": "performance_monitor_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1557-1562",
    "snippet": "void performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_irq",
          "args": [
            "regs"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.pmu_irqs"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}"
  },
  {
    "function_name": "vsx_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1516-1554",
    "snippet": "void vsx_unavailable_tm(struct pt_regs *regs)\n{\n\tunsigned long orig_msr = regs->msr;\n\n\t/* See the comments in fp_unavailable_tm().  This works similarly,\n\t * though we're loading both FP and VEC registers in here.\n\t *\n\t * If FP isn't in use, load FP regs.  If VEC isn't in use, load VEC\n\t * regs.  Either way, set MSR_VSX.\n\t */\n\n\tTM_DEBUG(\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n\tcurrent->thread.used_vsr = 1;\n\n\t/* If FP and VMX are already loaded, we have all the state we need */\n\tif ((orig_msr & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC)) {\n\t\tregs->msr |= MSR_VSX;\n\t\treturn;\n\t}\n\n\t/* This reclaims FP and/or VR regs if they're already enabled */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\tregs->msr |= MSR_VEC | MSR_FP | current->thread.fpexc_mode |\n\t\tMSR_VSX;\n\n\t/* This loads & recheckpoints FP and VRs; but we have\n\t * to be sure not to overwrite previously-valid state.\n\t */\n\ttm_recheckpoint(&current->thread, regs->msr & ~orig_msr);\n\n\tif (orig_msr & MSR_FP)\n\t\tdo_load_up_transact_fpu(&current->thread);\n\tif (orig_msr & MSR_VEC)\n\t\tdo_load_up_transact_altivec(&current->thread);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_load_up_transact_altivec",
          "args": [
            "&current->thread"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_load_up_transact_fpu",
          "args": [
            "&current->thread"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread",
            "regs->msr & ~orig_msr"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "565-569",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid vsx_unavailable_tm(struct pt_regs *regs)\n{\n\tunsigned long orig_msr = regs->msr;\n\n\t/* See the comments in fp_unavailable_tm().  This works similarly,\n\t * though we're loading both FP and VEC registers in here.\n\t *\n\t * If FP isn't in use, load FP regs.  If VEC isn't in use, load VEC\n\t * regs.  Either way, set MSR_VSX.\n\t */\n\n\tTM_DEBUG(\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n\tcurrent->thread.used_vsr = 1;\n\n\t/* If FP and VMX are already loaded, we have all the state we need */\n\tif ((orig_msr & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC)) {\n\t\tregs->msr |= MSR_VSX;\n\t\treturn;\n\t}\n\n\t/* This reclaims FP and/or VR regs if they're already enabled */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\tregs->msr |= MSR_VEC | MSR_FP | current->thread.fpexc_mode |\n\t\tMSR_VSX;\n\n\t/* This loads & recheckpoints FP and VRs; but we have\n\t * to be sure not to overwrite previously-valid state.\n\t */\n\ttm_recheckpoint(&current->thread, regs->msr & ~orig_msr);\n\n\tif (orig_msr & MSR_FP)\n\t\tdo_load_up_transact_fpu(&current->thread);\n\tif (orig_msr & MSR_VEC)\n\t\tdo_load_up_transact_altivec(&current->thread);\n}"
  },
  {
    "function_name": "altivec_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1496-1514",
    "snippet": "void altivec_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This function operates\n\t * the same way.\n\t */\n\n\tTM_DEBUG(\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\tregs->msr |= MSR_VEC;\n\ttm_recheckpoint(&current->thread, MSR_VEC);\n\tcurrent->thread.used_vr = 1;\n\n\tif (regs->msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= MSR_VSX;\n\t}\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_load_up_transact_fpu",
          "args": [
            "&current->thread"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread",
            "MSR_VEC"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "565-569",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This function operates\n\t * the same way.\n\t */\n\n\tTM_DEBUG(\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\tregs->msr |= MSR_VEC;\n\ttm_recheckpoint(&current->thread, MSR_VEC);\n\tcurrent->thread.used_vr = 1;\n\n\tif (regs->msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= MSR_VSX;\n\t}\n}"
  },
  {
    "function_name": "fp_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1460-1494",
    "snippet": "void fp_unavailable_tm(struct pt_regs *regs)\n{\n\t/* Note:  This does not handle any kind of FP laziness. */\n\n\tTM_DEBUG(\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n        /* We can only have got here if the task started using FP after\n         * beginning the transaction.  So, the transactional regs are just a\n         * copy of the checkpointed ones.  But, we still need to recheckpoint\n         * as we're enabling FP for the process; it will return, abort the\n         * transaction, and probably retry but now with FP enabled.  So the\n         * checkpointed FP registers need to be loaded.\n\t */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\t/* Reclaim didn't save out any FPRs to transact_fprs. */\n\n\t/* Enable FP for the task: */\n\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\n\t/* This loads and recheckpoints the FP registers from\n\t * thread.fpr[].  They will remain in registers after the\n\t * checkpoint so we don't need to reload them after.\n\t * If VMX is in use, the VRs now hold checkpointed values,\n\t * so we don't want to load the VRs from the thread_struct.\n\t */\n\ttm_recheckpoint(&current->thread, MSR_FP);\n\n\t/* If VMX is in use, get the transactional values back */\n\tif (regs->msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\t/* At this point all the VSX state is loaded, so enable it */\n\t\tregs->msr |= MSR_VSX;\n\t}\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_load_up_transact_altivec",
          "args": [
            "&current->thread"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread",
            "MSR_FP"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "565-569",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid fp_unavailable_tm(struct pt_regs *regs)\n{\n\t/* Note:  This does not handle any kind of FP laziness. */\n\n\tTM_DEBUG(\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n        /* We can only have got here if the task started using FP after\n         * beginning the transaction.  So, the transactional regs are just a\n         * copy of the checkpointed ones.  But, we still need to recheckpoint\n         * as we're enabling FP for the process; it will return, abort the\n         * transaction, and probably retry but now with FP enabled.  So the\n         * checkpointed FP registers need to be loaded.\n\t */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\t/* Reclaim didn't save out any FPRs to transact_fprs. */\n\n\t/* Enable FP for the task: */\n\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\n\t/* This loads and recheckpoints the FP registers from\n\t * thread.fpr[].  They will remain in registers after the\n\t * checkpoint so we don't need to reload them after.\n\t * If VMX is in use, the VRs now hold checkpointed values,\n\t * so we don't want to load the VRs from the thread_struct.\n\t */\n\ttm_recheckpoint(&current->thread, MSR_FP);\n\n\t/* If VMX is in use, get the transactional values back */\n\tif (regs->msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\t/* At this point all the VSX state is loaded, so enable it */\n\t\tregs->msr |= MSR_VSX;\n\t}\n}"
  },
  {
    "function_name": "facility_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1368-1455",
    "snippet": "void facility_unavailable_exception(struct pt_regs *regs)\n{\n\tstatic char *facility_strings[] = {\n\t\t[FSCR_FP_LG] = \"FPU\",\n\t\t[FSCR_VECVSX_LG] = \"VMX/VSX\",\n\t\t[FSCR_DSCR_LG] = \"DSCR\",\n\t\t[FSCR_PM_LG] = \"PMU SPRs\",\n\t\t[FSCR_BHRB_LG] = \"BHRB\",\n\t\t[FSCR_TM_LG] = \"TM\",\n\t\t[FSCR_EBB_LG] = \"EBB\",\n\t\t[FSCR_TAR_LG] = \"TAR\",\n\t};\n\tchar *facility = \"unknown\";\n\tu64 value;\n\tu32 instword, rd;\n\tu8 status;\n\tbool hv;\n\n\thv = (regs->trap == 0xf80);\n\tif (hv)\n\t\tvalue = mfspr(SPRN_HFSCR);\n\telse\n\t\tvalue = mfspr(SPRN_FSCR);\n\n\tstatus = value >> 56;\n\tif (status == FSCR_DSCR_LG) {\n\t\t/*\n\t\t * User is accessing the DSCR register using the problem\n\t\t * state only SPR number (0x03) either through a mfspr or\n\t\t * a mtspr instruction. If it is a write attempt through\n\t\t * a mtspr, then we set the inherit bit. This also allows\n\t\t * the user to write or read the register directly in the\n\t\t * future by setting via the FSCR DSCR bit. But in case it\n\t\t * is a read DSCR attempt through a mfspr instruction, we\n\t\t * just emulate the instruction instead. This code path will\n\t\t * always emulate all the mfspr instructions till the user\n\t\t * has attempted atleast one mtspr instruction. This way it\n\t\t * preserves the same behaviour when the user is accessing\n\t\t * the DSCR through privilege level only SPR number (0x11)\n\t\t * which is emulated through illegal instruction exception.\n\t\t * We always leave HFSCR DSCR set.\n\t\t */\n\t\tif (get_user(instword, (u32 __user *)(regs->nip))) {\n\t\t\tpr_err(\"Failed to fetch the user instruction\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write into DSCR (mtspr 0x03, RS) */\n\t\tif ((instword & PPC_INST_MTSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MTSPR_DSCR_USER) {\n\t\t\trd = (instword >> 21) & 0x1f;\n\t\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\t\tcurrent->thread.dscr_inherit = 1;\n\t\t\tmtspr(SPRN_FSCR, value | FSCR_DSCR);\n\t\t}\n\n\t\t/* Read from DSCR (mfspr RT, 0x03) */\n\t\tif ((instword & PPC_INST_MFSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MFSPR_DSCR_USER) {\n\t\t\tif (emulate_instruction(regs)) {\n\t\t\t\tpr_err(\"DSCR based mfspr emulation failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((status < ARRAY_SIZE(facility_strings)) &&\n\t    facility_strings[status])\n\t\tfacility = facility_strings[status];\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tpr_err_ratelimited(\n\t\t\"%sFacility '%s' unavailable, exception at 0x%lx, MSR=%lx\\n\",\n\t\thv ? \"Hypervisor \" : \"\", facility, regs->nip, regs->msr);\n\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tdie(\"Unexpected facility unavailable exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unexpected facility unavailable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"%sFacility '%s' unavailable, exception at 0x%lx, MSR=%lx\\n\"",
            "hv ? \"Hypervisor \" : \"\"",
            "facility",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "facility_strings"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DSCR based mfspr emulation failed\\n\""
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "regs"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1006-1099",
          "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_FSCR",
            "value | FSCR_DSCR"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to fetch the user instruction\\n\""
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "instword",
            "(u32 __user *)(regs->nip)"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_FSCR"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HFSCR"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid facility_unavailable_exception(struct pt_regs *regs)\n{\n\tstatic char *facility_strings[] = {\n\t\t[FSCR_FP_LG] = \"FPU\",\n\t\t[FSCR_VECVSX_LG] = \"VMX/VSX\",\n\t\t[FSCR_DSCR_LG] = \"DSCR\",\n\t\t[FSCR_PM_LG] = \"PMU SPRs\",\n\t\t[FSCR_BHRB_LG] = \"BHRB\",\n\t\t[FSCR_TM_LG] = \"TM\",\n\t\t[FSCR_EBB_LG] = \"EBB\",\n\t\t[FSCR_TAR_LG] = \"TAR\",\n\t};\n\tchar *facility = \"unknown\";\n\tu64 value;\n\tu32 instword, rd;\n\tu8 status;\n\tbool hv;\n\n\thv = (regs->trap == 0xf80);\n\tif (hv)\n\t\tvalue = mfspr(SPRN_HFSCR);\n\telse\n\t\tvalue = mfspr(SPRN_FSCR);\n\n\tstatus = value >> 56;\n\tif (status == FSCR_DSCR_LG) {\n\t\t/*\n\t\t * User is accessing the DSCR register using the problem\n\t\t * state only SPR number (0x03) either through a mfspr or\n\t\t * a mtspr instruction. If it is a write attempt through\n\t\t * a mtspr, then we set the inherit bit. This also allows\n\t\t * the user to write or read the register directly in the\n\t\t * future by setting via the FSCR DSCR bit. But in case it\n\t\t * is a read DSCR attempt through a mfspr instruction, we\n\t\t * just emulate the instruction instead. This code path will\n\t\t * always emulate all the mfspr instructions till the user\n\t\t * has attempted atleast one mtspr instruction. This way it\n\t\t * preserves the same behaviour when the user is accessing\n\t\t * the DSCR through privilege level only SPR number (0x11)\n\t\t * which is emulated through illegal instruction exception.\n\t\t * We always leave HFSCR DSCR set.\n\t\t */\n\t\tif (get_user(instword, (u32 __user *)(regs->nip))) {\n\t\t\tpr_err(\"Failed to fetch the user instruction\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write into DSCR (mtspr 0x03, RS) */\n\t\tif ((instword & PPC_INST_MTSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MTSPR_DSCR_USER) {\n\t\t\trd = (instword >> 21) & 0x1f;\n\t\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\t\tcurrent->thread.dscr_inherit = 1;\n\t\t\tmtspr(SPRN_FSCR, value | FSCR_DSCR);\n\t\t}\n\n\t\t/* Read from DSCR (mfspr RT, 0x03) */\n\t\tif ((instword & PPC_INST_MFSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MFSPR_DSCR_USER) {\n\t\t\tif (emulate_instruction(regs)) {\n\t\t\t\tpr_err(\"DSCR based mfspr emulation failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((status < ARRAY_SIZE(facility_strings)) &&\n\t    facility_strings[status])\n\t\tfacility = facility_strings[status];\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tpr_err_ratelimited(\n\t\t\"%sFacility '%s' unavailable, exception at 0x%lx, MSR=%lx\\n\",\n\t\thv ? \"Hypervisor \" : \"\", facility, regs->nip, regs->msr);\n\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tdie(\"Unexpected facility unavailable exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "vsx_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1353-1365",
    "snippet": "void vsx_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an vsx instruction,\n\t\t   but this kernel doesn't support vsx. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VSX Unavailable Exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable VSX Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid vsx_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an vsx instruction,\n\t\t   but this kernel doesn't support vsx. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VSX Unavailable Exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "altivec_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1334-1351",
    "snippet": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\tgoto bail;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable VMX/Altivec Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\tgoto bail;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "kernel_fp_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1323-1332",
    "snippet": "void kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable FP Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "trace_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1316-1321",
    "snippet": "void trace_syscall(struct pt_regs *regs)\n{\n\tprintk(\"Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\\n\",\n\t       current, task_pid_nr(current), regs->nip, regs->link, regs->gpr[0],\n\t       regs->ccr&0x10000000?\"Error=\":\"\", regs->gpr[3], print_tainted());\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\\n\"",
            "current",
            "task_pid_nr(current)",
            "regs->nip",
            "regs->link",
            "regs->gpr[0]",
            "regs->ccr&0x10000000?\"Error=\":\"\"",
            "regs->gpr[3]",
            "print_tainted()"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid trace_syscall(struct pt_regs *regs)\n{\n\tprintk(\"Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\\n\",\n\t       current, task_pid_nr(current), regs->nip, regs->link, regs->gpr[0],\n\t       regs->ccr&0x10000000?\"Error=\":\"\", regs->gpr[3], print_tainted());\n}"
  },
  {
    "function_name": "nonrecoverable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1308-1314",
    "snippet": "void nonrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_ERR \"Non-recoverable exception at PC=%lx MSR=%lx\\n\",\n\t       regs->nip, regs->msr);\n\tdebugger(regs);\n\tdie(\"nonrecoverable exception\", regs, SIGKILL);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"nonrecoverable exception\"",
            "regs",
            "SIGKILL"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "133-137",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Non-recoverable exception at PC=%lx MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid nonrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_ERR \"Non-recoverable exception at PC=%lx MSR=%lx\\n\",\n\t       regs->nip, regs->msr);\n\tdebugger(regs);\n\tdie(\"nonrecoverable exception\", regs, SIGKILL);\n}"
  },
  {
    "function_name": "StackOverflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1299-1306",
    "snippet": "void StackOverflow(struct pt_regs *regs)\n{\n\tprintk(KERN_CRIT \"Kernel stack overflow in process %p, r1=%lx\\n\",\n\t       current, regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"kernel stack overflow\""
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "993-1042",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [
            "static struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nstatic struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "133-137",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"Kernel stack overflow in process %p, r1=%lx\\n\"",
            "current",
            "regs->gpr[1]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid StackOverflow(struct pt_regs *regs)\n{\n\tprintk(KERN_CRIT \"Kernel stack overflow in process %p, r1=%lx\\n\",\n\t       current, regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}"
  },
  {
    "function_name": "alignment_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1260-1297",
    "snippet": "void alignment_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint sig, code, fixed = 0;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tif (tm_abort_check(regs, TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT))\n\t\tgoto bail;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\tregs->nip += 4;\t/* skip over emulated instruction */\n\t\temulate_single_step(regs);\n\t\tgoto bail;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tsig = SIGSEGV;\n\t\tcode = SEGV_ACCERR;\n\t} else {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t}\n\tif (user_mode(regs))\n\t\t_exception(sig, regs, code, regs->dar);\n\telse\n\t\tbad_page_fault(regs, regs->dar, sig);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_page_fault",
          "args": [
            "regs",
            "regs->dar",
            "sig"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "sig",
            "regs",
            "code",
            "regs->dar"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fix_alignment",
          "args": [
            "regs"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "fix_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "736-1042",
          "snippet": "int fix_alignment(struct pt_regs *regs)\n{\n\tunsigned int instr, nb, flags, instruction = 0;\n\tunsigned int reg, areg;\n\tunsigned int dsisr;\n\tunsigned char __user *addr;\n\tunsigned long p, swiz;\n\tint ret, i;\n\tunion data {\n\t\tu64 ll;\n\t\tdouble dd;\n\t\tunsigned char v[8];\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tint\t low32;\n\t\t\tunsigned hi32;\n#else\n\t\t\tunsigned hi32;\n\t\t\tint\t low32;\n#endif\n\t\t} x32;\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tshort\t      low16;\n\t\t\tunsigned char hi48[6];\n#else\n\t\t\tunsigned char hi48[6];\n\t\t\tshort\t      low16;\n#endif\n\t\t} x16;\n\t} data;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tdsisr = regs->dsisr;\n\n\t/* Some processors don't provide us with a DSISR we can use here,\n\t * let's make one up from the instruction\n\t */\n\tif (cpu_has_feature(CPU_FTR_NODSISRALIGN)) {\n\t\tunsigned long pc = regs->nip;\n\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE) && (regs->msr & MSR_LE))\n\t\t\tpc ^= 4;\n\t\tif (unlikely(__get_user_inatomic(instr,\n\t\t\t\t\t\t (unsigned int __user *)pc)))\n\t\t\treturn -EFAULT;\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE) && (regs->msr & MSR_LE))\n\t\t\tinstr = cpu_to_le32(instr);\n\t\tdsisr = make_dsisr(instr);\n\t\tinstruction = instr;\n\t}\n\n\t/* extract the operation and registers from the dsisr */\n\treg = (dsisr >> 5) & 0x1f;\t/* source/dest register */\n\tareg = dsisr & 0x1f;\t\t/* register to update */\n\n#ifdef CONFIG_SPE\n\tif ((instr >> 26) == 0x4) {\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\tinstr = (dsisr >> 10) & 0x7f;\n\tinstr |= (dsisr >> 13) & 0x60;\n\n\t/* Lookup the operation in our table */\n\tnb = aligninfo[instr].len;\n\tflags = aligninfo[instr].flags;\n\n\t/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */\n\tif (IS_XFORM(instruction) && ((instruction >> 1) & 0x3ff) == 532) {\n\t\tnb = 8;\n\t\tflags = LD+SW;\n\t} else if (IS_XFORM(instruction) &&\n\t\t   ((instruction >> 1) & 0x3ff) == 660) {\n\t\tnb = 8;\n\t\tflags = ST+SW;\n\t}\n\n\t/* Byteswap little endian loads and stores */\n\tswiz = 0;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\tflags ^= SW;\n#ifdef __BIG_ENDIAN__\n\t\t/*\n\t\t * So-called \"PowerPC little endian\" mode works by\n\t\t * swizzling addresses rather than by actually doing\n\t\t * any byte-swapping.  To emulate this, we XOR each\n\t\t * byte address with 7.  We also byte-swap, because\n\t\t * the processor's address swizzling depends on the\n\t\t * operand size (it xors the address with 7 for bytes,\n\t\t * 6 for halfwords, 4 for words, 0 for doublewords) but\n\t\t * we will xor with 7 and load/store each byte separately.\n\t\t */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\tswiz = 7;\n#endif\n\t}\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n#ifdef CONFIG_VSX\n\tif ((instruction & 0xfc00003e) == 0x7c000018) {\n\t\tunsigned int elsize;\n\n\t\t/* Additional register addressing bit (64 VSX vs 32 FPR/GPR) */\n\t\treg |= (instruction & 0x1) << 5;\n\t\t/* Simple inline decoder instead of a table */\n\t\t/* VSX has only 8 and 16 byte memory accesses */\n\t\tnb = 8;\n\t\tif (instruction & 0x200)\n\t\t\tnb = 16;\n\n\t\t/* Vector stores in little-endian mode swap individual\n\t\t   elements, so process them separately */\n\t\telsize = 4;\n\t\tif (instruction & 0x80)\n\t\t\telsize = 8;\n\n\t\tflags = 0;\n\t\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE))\n\t\t\tflags |= SW;\n\t\tif (instruction & 0x100)\n\t\t\tflags |= ST;\n\t\tif (instruction & 0x040)\n\t\t\tflags |= U;\n\t\t/* splat load needs a special decoder */\n\t\tif ((instruction & 0x400) == 0){\n\t\t\tflags |= SPLT;\n\t\t\tnb = 8;\n\t\t}\n\t\tPPC_WARN_ALIGNMENT(vsx, regs);\n\t\treturn emulate_vsx(addr, reg, areg, regs, flags, nb, elsize);\n\t}\n#endif\n\t/* A size of 0 indicates an instruction we don't support, with\n\t * the exception of DCBZ which is handled as a special case here\n\t */\n\tif (instr == DCBZ) {\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\treturn emulate_dcbz(regs, addr);\n\t}\n\tif (unlikely(nb == 0))\n\t\treturn 0;\n\n\t/* Load/Store Multiple instructions are handled in their own\n\t * function\n\t */\n\tif (flags & M) {\n\t\tPPC_WARN_ALIGNMENT(multiple, regs);\n\t\treturn emulate_multiple(regs, addr, reg, nb,\n\t\t\t\t\tflags, instr, swiz);\n\t}\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* Force the fprs into the save area so we can reference them */\n\tif (flags & F) {\n\t\t/* userland only */\n\t\tif (unlikely(!user_mode(regs)))\n\t\t\treturn 0;\n\t\tflush_fp_to_thread(current);\n\t}\n\n\tif (nb == 16) {\n\t\tif (flags & F) {\n\t\t\t/* Special case for 16-byte FP loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(fp_pair, regs);\n\t\t\treturn emulate_fp_pair(addr, reg, flags);\n\t\t} else {\n#ifdef CONFIG_PPC64\n\t\t\t/* Special case for 16-byte loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(lq_stq, regs);\n\t\t\treturn emulate_lq_stq(regs, addr, reg, flags);\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t}\n\n\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (!(flags & ST)) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata.ll = 0;\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __get_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\n\t} else if (flags & F) {\n\t\tdata.ll = current->thread.TS_FPR(reg);\n\t\tif (flags & S) {\n\t\t\t/* Single-precision FP store requires conversion... */\n#ifdef CONFIG_PPC_FPU\n\t\t\tpreempt_disable();\n\t\t\tenable_kernel_fp();\n\t\t\tcvt_df(&data.dd, (float *)&data.x32.low32);\n\t\t\tpreempt_enable();\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t} else\n\t\tdata.ll = regs->gpr[reg];\n\n\tif (flags & SW) {\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata.x32.low32 = swab32(data.x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata.x16.low16 = swab16(data.x16.low16);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Perform other misc operations like sign extension\n\t * or floating point single precision conversion\n\t */\n\tswitch (flags & ~(U|SW)) {\n\tcase LD+SE:\t/* sign extending integer loads */\n\tcase LD+F+SE:\t/* sign extend for lfiwax */\n\t\tif ( nb == 2 )\n\t\t\tdata.ll = data.x16.low16;\n\t\telse\t/* nb must be 4 */\n\t\t\tdata.ll = data.x32.low32;\n\t\tbreak;\n\n\t/* Single-precision FP load requires conversion... */\n\tcase LD+F+S:\n#ifdef CONFIG_PPC_FPU\n\t\tpreempt_disable();\n\t\tenable_kernel_fp();\n\t\tcvt_fd((float *)&data.x32.low32, &data.dd);\n\t\tpreempt_enable();\n#else\n\t\treturn 0;\n#endif\n\t\tbreak;\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __put_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else if (flags & F)\n\t\tcurrent->thread.TS_FPR(reg) = data.ll;\n\telse\n\t\tregs->gpr[reg] = data.ll;\n\n\t/* Update RA as needed */\n\tif (flags & U)\n\t\tregs->gpr[areg] = regs->dar;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define DCBZ\t0x5f\t/* 8xx/82xx dcbz faults when cache not enabled */",
            "#define SPLT\t0x80\t/* VSX SPLAT load */",
            "#define S\t0x40\t/* single-precision fp or... */",
            "#define SW\t0x20\t/* byte swap */",
            "#define M\t0x10\t/* multiple load/store */",
            "#define U\t8\t/* update index register */",
            "#define F\t4\t/* to/from fp regs */",
            "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
            "#define ST\t1\t/* store */",
            "#define LD\t0\t/* load */"
          ],
          "globals_used": [
            "static struct aligninfo aligninfo[128] = {\n\t{ 4, LD },\t\t/* 00 0 0000: lwz / lwarx */\n\tINVALID,\t\t/* 00 0 0001 */\n\t{ 4, ST },\t\t/* 00 0 0010: stw */\n\tINVALID,\t\t/* 00 0 0011 */\n\t{ 2, LD },\t\t/* 00 0 0100: lhz */\n\t{ 2, LD+SE },\t\t/* 00 0 0101: lha */\n\t{ 2, ST },\t\t/* 00 0 0110: sth */\n\t{ 4, LD+M },\t\t/* 00 0 0111: lmw */\n\t{ 4, LD+F+S },\t\t/* 00 0 1000: lfs */\n\t{ 8, LD+F },\t\t/* 00 0 1001: lfd */\n\t{ 4, ST+F+S },\t\t/* 00 0 1010: stfs */\n\t{ 8, ST+F },\t\t/* 00 0 1011: stfd */\n\t{ 16, LD },\t\t/* 00 0 1100: lq */\n\t{ 8, LD },\t\t/* 00 0 1101: ld/ldu/lwa */\n\tINVALID,\t\t/* 00 0 1110 */\n\t{ 8, ST },\t\t/* 00 0 1111: std/stdu */\n\t{ 4, LD+U },\t\t/* 00 1 0000: lwzu */\n\tINVALID,\t\t/* 00 1 0001 */\n\t{ 4, ST+U },\t\t/* 00 1 0010: stwu */\n\tINVALID,\t\t/* 00 1 0011 */\n\t{ 2, LD+U },\t\t/* 00 1 0100: lhzu */\n\t{ 2, LD+SE+U },\t\t/* 00 1 0101: lhau */\n\t{ 2, ST+U },\t\t/* 00 1 0110: sthu */\n\t{ 4, ST+M },\t\t/* 00 1 0111: stmw */\n\t{ 4, LD+F+S+U },\t/* 00 1 1000: lfsu */\n\t{ 8, LD+F+U },\t\t/* 00 1 1001: lfdu */\n\t{ 4, ST+F+S+U },\t/* 00 1 1010: stfsu */\n\t{ 8, ST+F+U },\t\t/* 00 1 1011: stfdu */\n\t{ 16, LD+F },\t\t/* 00 1 1100: lfdp */\n\tINVALID,\t\t/* 00 1 1101 */\n\t{ 16, ST+F },\t\t/* 00 1 1110: stfdp */\n\tINVALID,\t\t/* 00 1 1111 */\n\t{ 8, LD },\t\t/* 01 0 0000: ldx */\n\tINVALID,\t\t/* 01 0 0001 */\n\t{ 8, ST },\t\t/* 01 0 0010: stdx */\n\tINVALID,\t\t/* 01 0 0011 */\n\tINVALID,\t\t/* 01 0 0100 */\n\t{ 4, LD+SE },\t\t/* 01 0 0101: lwax */\n\tINVALID,\t\t/* 01 0 0110 */\n\tINVALID,\t\t/* 01 0 0111 */\n\t{ 4, LD+M+HARD+SX },\t/* 01 0 1000: lswx */\n\t{ 4, LD+M+HARD },\t/* 01 0 1001: lswi */\n\t{ 4, ST+M+HARD+SX },\t/* 01 0 1010: stswx */\n\t{ 4, ST+M+HARD },\t/* 01 0 1011: stswi */\n\tINVALID,\t\t/* 01 0 1100 */\n\t{ 8, LD+U },\t\t/* 01 0 1101: ldu */\n\tINVALID,\t\t/* 01 0 1110 */\n\t{ 8, ST+U },\t\t/* 01 0 1111: stdu */\n\t{ 8, LD+U },\t\t/* 01 1 0000: ldux */\n\tINVALID,\t\t/* 01 1 0001 */\n\t{ 8, ST+U },\t\t/* 01 1 0010: stdux */\n\tINVALID,\t\t/* 01 1 0011 */\n\tINVALID,\t\t/* 01 1 0100 */\n\t{ 4, LD+SE+U },\t\t/* 01 1 0101: lwaux */\n\tINVALID,\t\t/* 01 1 0110 */\n\tINVALID,\t\t/* 01 1 0111 */\n\tINVALID,\t\t/* 01 1 1000 */\n\tINVALID,\t\t/* 01 1 1001 */\n\tINVALID,\t\t/* 01 1 1010 */\n\tINVALID,\t\t/* 01 1 1011 */\n\tINVALID,\t\t/* 01 1 1100 */\n\tINVALID,\t\t/* 01 1 1101 */\n\tINVALID,\t\t/* 01 1 1110 */\n\tINVALID,\t\t/* 01 1 1111 */\n\tINVALID,\t\t/* 10 0 0000 */\n\tINVALID,\t\t/* 10 0 0001 */\n\tINVALID,\t\t/* 10 0 0010: stwcx. */\n\tINVALID,\t\t/* 10 0 0011 */\n\tINVALID,\t\t/* 10 0 0100 */\n\tINVALID,\t\t/* 10 0 0101 */\n\tINVALID,\t\t/* 10 0 0110 */\n\tINVALID,\t\t/* 10 0 0111 */\n\t{ 4, LD+SW },\t\t/* 10 0 1000: lwbrx */\n\tINVALID,\t\t/* 10 0 1001 */\n\t{ 4, ST+SW },\t\t/* 10 0 1010: stwbrx */\n\tINVALID,\t\t/* 10 0 1011 */\n\t{ 2, LD+SW },\t\t/* 10 0 1100: lhbrx */\n\t{ 4, LD+SE },\t\t/* 10 0 1101  lwa */\n\t{ 2, ST+SW },\t\t/* 10 0 1110: sthbrx */\n\t{ 16, ST },\t\t/* 10 0 1111: stq */\n\tINVALID,\t\t/* 10 1 0000 */\n\tINVALID,\t\t/* 10 1 0001 */\n\tINVALID,\t\t/* 10 1 0010 */\n\tINVALID,\t\t/* 10 1 0011 */\n\tINVALID,\t\t/* 10 1 0100 */\n\tINVALID,\t\t/* 10 1 0101 */\n\tINVALID,\t\t/* 10 1 0110 */\n\tINVALID,\t\t/* 10 1 0111 */\n\tINVALID,\t\t/* 10 1 1000 */\n\tINVALID,\t\t/* 10 1 1001 */\n\tINVALID,\t\t/* 10 1 1010 */\n\tINVALID,\t\t/* 10 1 1011 */\n\tINVALID,\t\t/* 10 1 1100 */\n\tINVALID,\t\t/* 10 1 1101 */\n\tINVALID,\t\t/* 10 1 1110 */\n\t{ 0, ST+HARD },\t\t/* 10 1 1111: dcbz */\n\t{ 4, LD },\t\t/* 11 0 0000: lwzx */\n\tINVALID,\t\t/* 11 0 0001 */\n\t{ 4, ST },\t\t/* 11 0 0010: stwx */\n\tINVALID,\t\t/* 11 0 0011 */\n\t{ 2, LD },\t\t/* 11 0 0100: lhzx */\n\t{ 2, LD+SE },\t\t/* 11 0 0101: lhax */\n\t{ 2, ST },\t\t/* 11 0 0110: sthx */\n\tINVALID,\t\t/* 11 0 0111 */\n\t{ 4, LD+F+S },\t\t/* 11 0 1000: lfsx */\n\t{ 8, LD+F },\t\t/* 11 0 1001: lfdx */\n\t{ 4, ST+F+S },\t\t/* 11 0 1010: stfsx */\n\t{ 8, ST+F },\t\t/* 11 0 1011: stfdx */\n\t{ 16, LD+F },\t\t/* 11 0 1100: lfdpx */\n\t{ 4, LD+F+SE },\t\t/* 11 0 1101: lfiwax */\n\t{ 16, ST+F },\t\t/* 11 0 1110: stfdpx */\n\t{ 4, ST+F },\t\t/* 11 0 1111: stfiwx */\n\t{ 4, LD+U },\t\t/* 11 1 0000: lwzux */\n\tINVALID,\t\t/* 11 1 0001 */\n\t{ 4, ST+U },\t\t/* 11 1 0010: stwux */\n\tINVALID,\t\t/* 11 1 0011 */\n\t{ 2, LD+U },\t\t/* 11 1 0100: lhzux */\n\t{ 2, LD+SE+U },\t\t/* 11 1 0101: lhaux */\n\t{ 2, ST+U },\t\t/* 11 1 0110: sthux */\n\tINVALID,\t\t/* 11 1 0111 */\n\t{ 4, LD+F+S+U },\t/* 11 1 1000: lfsux */\n\t{ 8, LD+F+U },\t\t/* 11 1 1001: lfdux */\n\t{ 4, ST+F+S+U },\t/* 11 1 1010: stfsux */\n\t{ 8, ST+F+U },\t\t/* 11 1 1011: stfdux */\n\tINVALID,\t\t/* 11 1 1100 */\n\t{ 4, LD+F },\t\t/* 11 1 1101: lfiwzx */\n\tINVALID,\t\t/* 11 1 1110 */\n\tINVALID,\t\t/* 11 1 1111 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define DCBZ\t0x5f\t/* 8xx/82xx dcbz faults when cache not enabled */\n#define SPLT\t0x80\t/* VSX SPLAT load */\n#define S\t0x40\t/* single-precision fp or... */\n#define SW\t0x20\t/* byte swap */\n#define M\t0x10\t/* multiple load/store */\n#define U\t8\t/* update index register */\n#define F\t4\t/* to/from fp regs */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n#define LD\t0\t/* load */\n\nstatic struct aligninfo aligninfo[128] = {\n\t{ 4, LD },\t\t/* 00 0 0000: lwz / lwarx */\n\tINVALID,\t\t/* 00 0 0001 */\n\t{ 4, ST },\t\t/* 00 0 0010: stw */\n\tINVALID,\t\t/* 00 0 0011 */\n\t{ 2, LD },\t\t/* 00 0 0100: lhz */\n\t{ 2, LD+SE },\t\t/* 00 0 0101: lha */\n\t{ 2, ST },\t\t/* 00 0 0110: sth */\n\t{ 4, LD+M },\t\t/* 00 0 0111: lmw */\n\t{ 4, LD+F+S },\t\t/* 00 0 1000: lfs */\n\t{ 8, LD+F },\t\t/* 00 0 1001: lfd */\n\t{ 4, ST+F+S },\t\t/* 00 0 1010: stfs */\n\t{ 8, ST+F },\t\t/* 00 0 1011: stfd */\n\t{ 16, LD },\t\t/* 00 0 1100: lq */\n\t{ 8, LD },\t\t/* 00 0 1101: ld/ldu/lwa */\n\tINVALID,\t\t/* 00 0 1110 */\n\t{ 8, ST },\t\t/* 00 0 1111: std/stdu */\n\t{ 4, LD+U },\t\t/* 00 1 0000: lwzu */\n\tINVALID,\t\t/* 00 1 0001 */\n\t{ 4, ST+U },\t\t/* 00 1 0010: stwu */\n\tINVALID,\t\t/* 00 1 0011 */\n\t{ 2, LD+U },\t\t/* 00 1 0100: lhzu */\n\t{ 2, LD+SE+U },\t\t/* 00 1 0101: lhau */\n\t{ 2, ST+U },\t\t/* 00 1 0110: sthu */\n\t{ 4, ST+M },\t\t/* 00 1 0111: stmw */\n\t{ 4, LD+F+S+U },\t/* 00 1 1000: lfsu */\n\t{ 8, LD+F+U },\t\t/* 00 1 1001: lfdu */\n\t{ 4, ST+F+S+U },\t/* 00 1 1010: stfsu */\n\t{ 8, ST+F+U },\t\t/* 00 1 1011: stfdu */\n\t{ 16, LD+F },\t\t/* 00 1 1100: lfdp */\n\tINVALID,\t\t/* 00 1 1101 */\n\t{ 16, ST+F },\t\t/* 00 1 1110: stfdp */\n\tINVALID,\t\t/* 00 1 1111 */\n\t{ 8, LD },\t\t/* 01 0 0000: ldx */\n\tINVALID,\t\t/* 01 0 0001 */\n\t{ 8, ST },\t\t/* 01 0 0010: stdx */\n\tINVALID,\t\t/* 01 0 0011 */\n\tINVALID,\t\t/* 01 0 0100 */\n\t{ 4, LD+SE },\t\t/* 01 0 0101: lwax */\n\tINVALID,\t\t/* 01 0 0110 */\n\tINVALID,\t\t/* 01 0 0111 */\n\t{ 4, LD+M+HARD+SX },\t/* 01 0 1000: lswx */\n\t{ 4, LD+M+HARD },\t/* 01 0 1001: lswi */\n\t{ 4, ST+M+HARD+SX },\t/* 01 0 1010: stswx */\n\t{ 4, ST+M+HARD },\t/* 01 0 1011: stswi */\n\tINVALID,\t\t/* 01 0 1100 */\n\t{ 8, LD+U },\t\t/* 01 0 1101: ldu */\n\tINVALID,\t\t/* 01 0 1110 */\n\t{ 8, ST+U },\t\t/* 01 0 1111: stdu */\n\t{ 8, LD+U },\t\t/* 01 1 0000: ldux */\n\tINVALID,\t\t/* 01 1 0001 */\n\t{ 8, ST+U },\t\t/* 01 1 0010: stdux */\n\tINVALID,\t\t/* 01 1 0011 */\n\tINVALID,\t\t/* 01 1 0100 */\n\t{ 4, LD+SE+U },\t\t/* 01 1 0101: lwaux */\n\tINVALID,\t\t/* 01 1 0110 */\n\tINVALID,\t\t/* 01 1 0111 */\n\tINVALID,\t\t/* 01 1 1000 */\n\tINVALID,\t\t/* 01 1 1001 */\n\tINVALID,\t\t/* 01 1 1010 */\n\tINVALID,\t\t/* 01 1 1011 */\n\tINVALID,\t\t/* 01 1 1100 */\n\tINVALID,\t\t/* 01 1 1101 */\n\tINVALID,\t\t/* 01 1 1110 */\n\tINVALID,\t\t/* 01 1 1111 */\n\tINVALID,\t\t/* 10 0 0000 */\n\tINVALID,\t\t/* 10 0 0001 */\n\tINVALID,\t\t/* 10 0 0010: stwcx. */\n\tINVALID,\t\t/* 10 0 0011 */\n\tINVALID,\t\t/* 10 0 0100 */\n\tINVALID,\t\t/* 10 0 0101 */\n\tINVALID,\t\t/* 10 0 0110 */\n\tINVALID,\t\t/* 10 0 0111 */\n\t{ 4, LD+SW },\t\t/* 10 0 1000: lwbrx */\n\tINVALID,\t\t/* 10 0 1001 */\n\t{ 4, ST+SW },\t\t/* 10 0 1010: stwbrx */\n\tINVALID,\t\t/* 10 0 1011 */\n\t{ 2, LD+SW },\t\t/* 10 0 1100: lhbrx */\n\t{ 4, LD+SE },\t\t/* 10 0 1101  lwa */\n\t{ 2, ST+SW },\t\t/* 10 0 1110: sthbrx */\n\t{ 16, ST },\t\t/* 10 0 1111: stq */\n\tINVALID,\t\t/* 10 1 0000 */\n\tINVALID,\t\t/* 10 1 0001 */\n\tINVALID,\t\t/* 10 1 0010 */\n\tINVALID,\t\t/* 10 1 0011 */\n\tINVALID,\t\t/* 10 1 0100 */\n\tINVALID,\t\t/* 10 1 0101 */\n\tINVALID,\t\t/* 10 1 0110 */\n\tINVALID,\t\t/* 10 1 0111 */\n\tINVALID,\t\t/* 10 1 1000 */\n\tINVALID,\t\t/* 10 1 1001 */\n\tINVALID,\t\t/* 10 1 1010 */\n\tINVALID,\t\t/* 10 1 1011 */\n\tINVALID,\t\t/* 10 1 1100 */\n\tINVALID,\t\t/* 10 1 1101 */\n\tINVALID,\t\t/* 10 1 1110 */\n\t{ 0, ST+HARD },\t\t/* 10 1 1111: dcbz */\n\t{ 4, LD },\t\t/* 11 0 0000: lwzx */\n\tINVALID,\t\t/* 11 0 0001 */\n\t{ 4, ST },\t\t/* 11 0 0010: stwx */\n\tINVALID,\t\t/* 11 0 0011 */\n\t{ 2, LD },\t\t/* 11 0 0100: lhzx */\n\t{ 2, LD+SE },\t\t/* 11 0 0101: lhax */\n\t{ 2, ST },\t\t/* 11 0 0110: sthx */\n\tINVALID,\t\t/* 11 0 0111 */\n\t{ 4, LD+F+S },\t\t/* 11 0 1000: lfsx */\n\t{ 8, LD+F },\t\t/* 11 0 1001: lfdx */\n\t{ 4, ST+F+S },\t\t/* 11 0 1010: stfsx */\n\t{ 8, ST+F },\t\t/* 11 0 1011: stfdx */\n\t{ 16, LD+F },\t\t/* 11 0 1100: lfdpx */\n\t{ 4, LD+F+SE },\t\t/* 11 0 1101: lfiwax */\n\t{ 16, ST+F },\t\t/* 11 0 1110: stfdpx */\n\t{ 4, ST+F },\t\t/* 11 0 1111: stfiwx */\n\t{ 4, LD+U },\t\t/* 11 1 0000: lwzux */\n\tINVALID,\t\t/* 11 1 0001 */\n\t{ 4, ST+U },\t\t/* 11 1 0010: stwux */\n\tINVALID,\t\t/* 11 1 0011 */\n\t{ 2, LD+U },\t\t/* 11 1 0100: lhzux */\n\t{ 2, LD+SE+U },\t\t/* 11 1 0101: lhaux */\n\t{ 2, ST+U },\t\t/* 11 1 0110: sthux */\n\tINVALID,\t\t/* 11 1 0111 */\n\t{ 4, LD+F+S+U },\t/* 11 1 1000: lfsux */\n\t{ 8, LD+F+U },\t\t/* 11 1 1001: lfdux */\n\t{ 4, ST+F+S+U },\t/* 11 1 1010: stfsux */\n\t{ 8, ST+F+U },\t\t/* 11 1 1011: stfdux */\n\tINVALID,\t\t/* 11 1 1100 */\n\t{ 4, LD+F },\t\t/* 11 1 1101: lfiwzx */\n\tINVALID,\t\t/* 11 1 1110 */\n\tINVALID,\t\t/* 11 1 1111 */\n};\n\nint fix_alignment(struct pt_regs *regs)\n{\n\tunsigned int instr, nb, flags, instruction = 0;\n\tunsigned int reg, areg;\n\tunsigned int dsisr;\n\tunsigned char __user *addr;\n\tunsigned long p, swiz;\n\tint ret, i;\n\tunion data {\n\t\tu64 ll;\n\t\tdouble dd;\n\t\tunsigned char v[8];\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tint\t low32;\n\t\t\tunsigned hi32;\n#else\n\t\t\tunsigned hi32;\n\t\t\tint\t low32;\n#endif\n\t\t} x32;\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tshort\t      low16;\n\t\t\tunsigned char hi48[6];\n#else\n\t\t\tunsigned char hi48[6];\n\t\t\tshort\t      low16;\n#endif\n\t\t} x16;\n\t} data;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tdsisr = regs->dsisr;\n\n\t/* Some processors don't provide us with a DSISR we can use here,\n\t * let's make one up from the instruction\n\t */\n\tif (cpu_has_feature(CPU_FTR_NODSISRALIGN)) {\n\t\tunsigned long pc = regs->nip;\n\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE) && (regs->msr & MSR_LE))\n\t\t\tpc ^= 4;\n\t\tif (unlikely(__get_user_inatomic(instr,\n\t\t\t\t\t\t (unsigned int __user *)pc)))\n\t\t\treturn -EFAULT;\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE) && (regs->msr & MSR_LE))\n\t\t\tinstr = cpu_to_le32(instr);\n\t\tdsisr = make_dsisr(instr);\n\t\tinstruction = instr;\n\t}\n\n\t/* extract the operation and registers from the dsisr */\n\treg = (dsisr >> 5) & 0x1f;\t/* source/dest register */\n\tareg = dsisr & 0x1f;\t\t/* register to update */\n\n#ifdef CONFIG_SPE\n\tif ((instr >> 26) == 0x4) {\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\tinstr = (dsisr >> 10) & 0x7f;\n\tinstr |= (dsisr >> 13) & 0x60;\n\n\t/* Lookup the operation in our table */\n\tnb = aligninfo[instr].len;\n\tflags = aligninfo[instr].flags;\n\n\t/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */\n\tif (IS_XFORM(instruction) && ((instruction >> 1) & 0x3ff) == 532) {\n\t\tnb = 8;\n\t\tflags = LD+SW;\n\t} else if (IS_XFORM(instruction) &&\n\t\t   ((instruction >> 1) & 0x3ff) == 660) {\n\t\tnb = 8;\n\t\tflags = ST+SW;\n\t}\n\n\t/* Byteswap little endian loads and stores */\n\tswiz = 0;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\tflags ^= SW;\n#ifdef __BIG_ENDIAN__\n\t\t/*\n\t\t * So-called \"PowerPC little endian\" mode works by\n\t\t * swizzling addresses rather than by actually doing\n\t\t * any byte-swapping.  To emulate this, we XOR each\n\t\t * byte address with 7.  We also byte-swap, because\n\t\t * the processor's address swizzling depends on the\n\t\t * operand size (it xors the address with 7 for bytes,\n\t\t * 6 for halfwords, 4 for words, 0 for doublewords) but\n\t\t * we will xor with 7 and load/store each byte separately.\n\t\t */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\tswiz = 7;\n#endif\n\t}\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n#ifdef CONFIG_VSX\n\tif ((instruction & 0xfc00003e) == 0x7c000018) {\n\t\tunsigned int elsize;\n\n\t\t/* Additional register addressing bit (64 VSX vs 32 FPR/GPR) */\n\t\treg |= (instruction & 0x1) << 5;\n\t\t/* Simple inline decoder instead of a table */\n\t\t/* VSX has only 8 and 16 byte memory accesses */\n\t\tnb = 8;\n\t\tif (instruction & 0x200)\n\t\t\tnb = 16;\n\n\t\t/* Vector stores in little-endian mode swap individual\n\t\t   elements, so process them separately */\n\t\telsize = 4;\n\t\tif (instruction & 0x80)\n\t\t\telsize = 8;\n\n\t\tflags = 0;\n\t\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE))\n\t\t\tflags |= SW;\n\t\tif (instruction & 0x100)\n\t\t\tflags |= ST;\n\t\tif (instruction & 0x040)\n\t\t\tflags |= U;\n\t\t/* splat load needs a special decoder */\n\t\tif ((instruction & 0x400) == 0){\n\t\t\tflags |= SPLT;\n\t\t\tnb = 8;\n\t\t}\n\t\tPPC_WARN_ALIGNMENT(vsx, regs);\n\t\treturn emulate_vsx(addr, reg, areg, regs, flags, nb, elsize);\n\t}\n#endif\n\t/* A size of 0 indicates an instruction we don't support, with\n\t * the exception of DCBZ which is handled as a special case here\n\t */\n\tif (instr == DCBZ) {\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\treturn emulate_dcbz(regs, addr);\n\t}\n\tif (unlikely(nb == 0))\n\t\treturn 0;\n\n\t/* Load/Store Multiple instructions are handled in their own\n\t * function\n\t */\n\tif (flags & M) {\n\t\tPPC_WARN_ALIGNMENT(multiple, regs);\n\t\treturn emulate_multiple(regs, addr, reg, nb,\n\t\t\t\t\tflags, instr, swiz);\n\t}\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* Force the fprs into the save area so we can reference them */\n\tif (flags & F) {\n\t\t/* userland only */\n\t\tif (unlikely(!user_mode(regs)))\n\t\t\treturn 0;\n\t\tflush_fp_to_thread(current);\n\t}\n\n\tif (nb == 16) {\n\t\tif (flags & F) {\n\t\t\t/* Special case for 16-byte FP loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(fp_pair, regs);\n\t\t\treturn emulate_fp_pair(addr, reg, flags);\n\t\t} else {\n#ifdef CONFIG_PPC64\n\t\t\t/* Special case for 16-byte loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(lq_stq, regs);\n\t\t\treturn emulate_lq_stq(regs, addr, reg, flags);\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t}\n\n\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (!(flags & ST)) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata.ll = 0;\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __get_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\n\t} else if (flags & F) {\n\t\tdata.ll = current->thread.TS_FPR(reg);\n\t\tif (flags & S) {\n\t\t\t/* Single-precision FP store requires conversion... */\n#ifdef CONFIG_PPC_FPU\n\t\t\tpreempt_disable();\n\t\t\tenable_kernel_fp();\n\t\t\tcvt_df(&data.dd, (float *)&data.x32.low32);\n\t\t\tpreempt_enable();\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t} else\n\t\tdata.ll = regs->gpr[reg];\n\n\tif (flags & SW) {\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata.x32.low32 = swab32(data.x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata.x16.low16 = swab16(data.x16.low16);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Perform other misc operations like sign extension\n\t * or floating point single precision conversion\n\t */\n\tswitch (flags & ~(U|SW)) {\n\tcase LD+SE:\t/* sign extending integer loads */\n\tcase LD+F+SE:\t/* sign extend for lfiwax */\n\t\tif ( nb == 2 )\n\t\t\tdata.ll = data.x16.low16;\n\t\telse\t/* nb must be 4 */\n\t\t\tdata.ll = data.x32.low32;\n\t\tbreak;\n\n\t/* Single-precision FP load requires conversion... */\n\tcase LD+F+S:\n#ifdef CONFIG_PPC_FPU\n\t\tpreempt_disable();\n\t\tenable_kernel_fp();\n\t\tcvt_fd((float *)&data.x32.low32, &data.dd);\n\t\tpreempt_enable();\n#else\n\t\treturn 0;\n#endif\n\t\tbreak;\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __put_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else if (flags & F)\n\t\tcurrent->thread.TS_FPR(reg) = data.ll;\n\telse\n\t\tregs->gpr[reg] = data.ll;\n\n\t/* Update RA as needed */\n\tif (flags & U)\n\t\tregs->gpr[areg] = regs->dar;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_abort_check",
          "args": [
            "regs",
            "TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "tm_abort_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1000-1003",
          "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid alignment_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint sig, code, fixed = 0;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tif (tm_abort_check(regs, TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT))\n\t\tgoto bail;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\tregs->nip += 4;\t/* skip over emulated instruction */\n\t\temulate_single_step(regs);\n\t\tgoto bail;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tsig = SIGSEGV;\n\t\tcode = SEGV_ACCERR;\n\t} else {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t}\n\tif (user_mode(regs))\n\t\t_exception(sig, regs, code, regs->dar);\n\telse\n\t\tbad_page_fault(regs, regs->dar, sig);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "emulation_assist_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1254-1258",
    "snippet": "void __kprobes emulation_assist_interrupt(struct pt_regs *regs)\n{\n\tregs->msr |= REASON_ILLEGAL;\n\tprogram_check_exception(regs);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REASON_ILLEGAL\t\t0x80000",
      "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "program_check_exception",
          "args": [
            "regs"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "program_check_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1137-1248",
          "snippet": "void __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t */\n\t\tif (!user_mode(regs) &&\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%x)\\n\", regs->nip, reason);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define REASON_TRAP\t\t0x20000",
            "#define REASON_PRIVILEGED\t0x40000",
            "#define REASON_ILLEGAL\t\t0x80000",
            "#define REASON_FP\t\t0x100000",
            "#define REASON_TM\t\t0x200000",
            "#define REASON_TRAP\t\tESR_PTR",
            "#define REASON_PRIVILEGED\tESR_PPR",
            "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)",
            "#define REASON_FP\t\tESR_FP"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_TRAP\t\t0x20000\n#define REASON_PRIVILEGED\t0x40000\n#define REASON_ILLEGAL\t\t0x80000\n#define REASON_FP\t\t0x100000\n#define REASON_TM\t\t0x200000\n#define REASON_TRAP\t\tESR_PTR\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_FP\t\tESR_FP\n\nvoid __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t */\n\t\tif (!user_mode(regs) &&\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%x)\\n\", regs->nip, reason);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_ILLEGAL\t\t0x80000\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n\nvoid __kprobes emulation_assist_interrupt(struct pt_regs *regs)\n{\n\tregs->msr |= REASON_ILLEGAL;\n\tprogram_check_exception(regs);\n}"
  },
  {
    "function_name": "program_check_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1137-1248",
    "snippet": "void __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t */\n\t\tif (!user_mode(regs) &&\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%x)\\n\", regs->nip, reason);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REASON_TRAP\t\t0x20000",
      "#define REASON_PRIVILEGED\t0x40000",
      "#define REASON_ILLEGAL\t\t0x80000",
      "#define REASON_FP\t\t0x100000",
      "#define REASON_TM\t\t0x200000",
      "#define REASON_TRAP\t\tESR_PTR",
      "#define REASON_PRIVILEGED\tESR_PPR",
      "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)",
      "#define REASON_FP\t\tESR_FP"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "regs"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1006-1099",
          "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_math",
          "args": [
            "regs"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_math",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1134-1134",
          "snippet": "static inline int emulate_math(struct pt_regs *regs) { return -1; }",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int emulate_math(struct pt_regs *regs) { return -1; }"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%x)\\n\"",
            "regs->nip",
            "reason"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_bug",
          "args": [
            "regs->nip",
            "regs"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_bug",
          "args": [
            "regs->nip",
            "regs"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_BPT",
            "\"breakpoint\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_bpt",
          "args": [
            "regs"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_fpe",
          "args": [
            "regs"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "parse_fpe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "856-865",
          "snippet": "static void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reason",
          "args": [
            "regs"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_TRAP\t\t0x20000\n#define REASON_PRIVILEGED\t0x40000\n#define REASON_ILLEGAL\t\t0x80000\n#define REASON_FP\t\t0x100000\n#define REASON_TM\t\t0x200000\n#define REASON_TRAP\t\tESR_PTR\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_FP\t\tESR_FP\n\nvoid __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t */\n\t\tif (!user_mode(regs) &&\n\t\t    report_bug(regs->nip, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%x)\\n\", regs->nip, reason);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "emulate_math",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1134-1134",
    "snippet": "static inline int emulate_math(struct pt_regs *regs) { return -1; }",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int emulate_math(struct pt_regs *regs) { return -1; }"
  },
  {
    "function_name": "emulate_math",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1107-1132",
    "snippet": "static int emulate_math(struct pt_regs *regs)\n{\n\tint ret;\n\textern int do_mathemu(struct pt_regs *regs);\n\n\tret = do_mathemu(regs);\n\tif (ret >= 0)\n\t\tPPC_WARN_EMULATED(math, regs);\n\n\tswitch (ret) {\n\tcase 0:\n\t\temulate_single_step(regs);\n\t\treturn 0;\n\tcase 1: {\n\t\t\tint code = 0;\n\t\t\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\t\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t\t\treturn 0;\n\t\t}\n\tcase -EFAULT:\n\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGSEGV",
            "regs",
            "SEGV_MAPERR",
            "regs->nip"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_fpscr",
          "args": [
            "current->thread.fp_state.fpscr"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "823-827",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "math",
            "regs"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mathemu",
          "args": [
            "regs"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_math(struct pt_regs *regs)\n{\n\tint ret;\n\textern int do_mathemu(struct pt_regs *regs);\n\n\tret = do_mathemu(regs);\n\tif (ret >= 0)\n\t\tPPC_WARN_EMULATED(math, regs);\n\n\tswitch (ret) {\n\tcase 0:\n\t\temulate_single_step(regs);\n\t\treturn 0;\n\tcase 1: {\n\t\t\tint code = 0;\n\t\t\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\t\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t\t\treturn 0;\n\t\t}\n\tcase -EFAULT:\n\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "is_valid_bugaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1101-1104",
    "snippet": "int is_valid_bugaddr(unsigned long addr)\n{\n\treturn is_kernel_addr(addr);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "addr"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint is_valid_bugaddr(unsigned long addr)\n{\n\treturn is_kernel_addr(addr);\n}"
  },
  {
    "function_name": "emulate_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1006-1099",
    "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DSCR",
            "current->thread.dscr"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mtdscr",
            "regs"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DSCR"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DSCR"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mfdscr",
            "regs"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DSCR"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "sync",
            "regs"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_isel",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_isel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "967-982",
          "snippet": "static int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "isel",
            "regs"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_popcntb_inst",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popcntb_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "950-965",
          "snippet": "static int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "popcntb",
            "regs"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_string_inst",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_string_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "878-948",
          "snippet": "static int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "string",
            "regs"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_abort_check",
          "args": [
            "regs",
            "TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "tm_abort_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "1000-1003",
          "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mcrxr",
            "regs"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "dcba",
            "regs"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mfpvr",
            "regs"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "instword",
            "(u32 __user *)(regs->nip)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "tm_abort_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "1000-1003",
    "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "tm_abort_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "985-998",
    "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int cause)\n{\n        /* If we're emulating a load/store in an active transaction, we cannot\n         * emulate it as the kernel operates in transaction suspended context.\n         * We need to abort the transaction.  This creates a persistent TM\n         * abort so tell the user what caused it with a new code.\n\t */\n\tif (MSR_TM_TRANSACTIONAL(regs->msr)) {\n\t\ttm_enable();\n\t\ttm_abort(cause);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_abort",
          "args": [
            "cause"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_TRANSACTIONAL",
          "args": [
            "regs->msr"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int cause)\n{\n        /* If we're emulating a load/store in an active transaction, we cannot\n         * emulate it as the kernel operates in transaction suspended context.\n         * We need to abort the transaction.  This creates a persistent TM\n         * abort so tell the user what caused it with a new code.\n\t */\n\tif (MSR_TM_TRANSACTIONAL(regs->msr)) {\n\t\ttm_enable();\n\t\ttm_abort(cause);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "emulate_isel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "967-982",
    "snippet": "static int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulate_popcntb_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "950-965",
    "snippet": "static int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulate_string_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "878-948",
    "snippet": "static int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "(u8 __user *)EA"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "val",
            "(u8 __user *)EA"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_fpe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "856-865",
    "snippet": "static void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "code",
            "regs->nip"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_fpscr",
          "args": [
            "current->thread.fp_state.fpscr"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}"
  },
  {
    "function_name": "__parse_fpscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "829-854",
    "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "emulate_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "823-827",
    "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_step_exception",
          "args": [
            "regs"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "single_step_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "799-815",
          "snippet": "void __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "single_stepping",
          "args": [
            "regs"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
  },
  {
    "function_name": "single_step_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "799-815",
    "snippet": "void __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_TRACE",
            "regs->nip"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"single_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_single_step",
          "args": [
            "regs"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "RunModeException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "794-797",
    "snippet": "void RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, 0, 0);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "0",
            "0"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, 0, 0);\n}"
  },
  {
    "function_name": "instruction_breakpoint_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "779-792",
    "snippet": "void instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_iabr_match(regs))\n\t\tgoto bail;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_BRKPT",
            "regs->nip"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_iabr_match",
          "args": [
            "regs"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_IABR_MATCH",
            "\"iabr_match\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_iabr_match(regs))\n\t\tgoto bail;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "unknown_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "767-777",
    "snippet": "void unknown_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, 0, 0);\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "0",
            "0"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "241-269",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\"",
            "regs->nip",
            "regs->msr",
            "regs->trap"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid unknown_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, 0, 0);\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "handle_hmi_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "753-765",
    "snippet": "void handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.handle_hmi_exception",
          "args": [
            "regs"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "handle_hmi_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "753-765",
          "snippet": "void handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "regs"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}"
  },
  {
    "function_name": "SMIException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "748-751",
    "snippet": "void SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"System Management Interrupt\"",
            "regs",
            "SIGABRT"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "machine_check_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "700-746",
    "snippet": "void machine_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint recover = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n#if defined(CONFIG_8xx) && defined(CONFIG_PCI)\n\t/* the qspan pci read routines can cause machine checks -- Cort\n\t *\n\t * yuck !!! that totally needs to go away ! There are better ways\n\t * to deal with that than having a wart in the mcheck handler.\n\t * -- BenH\n\t */\n\tbad_page_fault(regs, regs->dar, SIGBUS);\n\tgoto bail;\n#endif\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable Machine check\");\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Unrecoverable Machine check\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Machine check\"",
            "regs",
            "SIGBUS"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_io_access",
          "args": [
            "regs"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "check_io_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "329-366",
          "snippet": "static inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_fault_handler",
          "args": [
            "regs"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_page_fault",
          "args": [
            "regs",
            "regs->dar",
            "SIGBUS"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_cpu_spec->machine_check",
          "args": [
            "regs"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.machine_check_exception",
          "args": [
            "regs"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "700-746",
          "snippet": "void machine_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint recover = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n#if defined(CONFIG_8xx) && defined(CONFIG_PCI)\n\t/* the qspan pci read routines can cause machine checks -- Cort\n\t *\n\t * yuck !!! that totally needs to go away ! There are better ways\n\t * to deal with that than having a wart in the mcheck handler.\n\t * -- BenH\n\t */\n\tbad_page_fault(regs, regs->dar, SIGBUS);\n\tgoto bail;\n#endif\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable Machine check\");\n\nbail:\n\texception_exit(prev_state);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.mce_exceptions"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid machine_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint recover = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n#if defined(CONFIG_8xx) && defined(CONFIG_PCI)\n\t/* the qspan pci read routines can cause machine checks -- Cort\n\t *\n\t * yuck !!! that totally needs to go away ! There are better ways\n\t * to deal with that than having a wart in the mcheck handler.\n\t * -- BenH\n\t */\n\tbad_page_fault(regs, regs->dar, SIGBUS);\n\tgoto bail;\n#endif\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable Machine check\");\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "machine_check_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "663-697",
    "snippet": "int machine_check_generic(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tprintk(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tprintk(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tprintk(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tprintk(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tprintk(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tprintk(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tprintk(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unknown values in msr\\n\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Unknown values in msr\\n\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"L2 data cache parity error\\n\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"L1 Instruction Cache error\\n\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"L1 Data Cache error\\n\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Address parity error signal\\n\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data parity error signal\\n\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Transfer error ack signal\\n\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check signal\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from SRR1=%lx): \"",
            "reason"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_generic(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tprintk(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tprintk(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tprintk(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tprintk(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tprintk(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tprintk(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tprintk(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unknown values in msr\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e200",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "638-661",
    "snippet": "int machine_check_e200(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tprintk(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tprintk(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tprintk(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tprintk(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tprintk(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tprintk(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Write Bus Error on buffered store or cache line push\\n\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Read Bus Error on data load\\n\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Read Bus Error on instruction fetch\\n\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cache Parity Error\\n\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cache Push Parity Error\\n\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e200(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tprintk(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tprintk(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tprintk(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tprintk(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tprintk(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tprintk(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "633-636",
    "snippet": "int machine_check_generic(struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_generic(struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e500",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "591-631",
    "snippet": "int machine_check_e500(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tif (reason & MCSR_BUS_RBERR) {\n\t\tif (fsl_rio_mcheck_exception(regs))\n\t\t\treturn 1;\n\t\tif (fsl_pci_mcheck_exception(regs))\n\t\t\treturn 1;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tprintk(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tprintk(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tprintk(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tprintk(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tprintk(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tprintk(\"Bus - Write Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tprintk(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tprintk(\"Bus - Read Parity Error\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Read Parity Error\\n\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Instruction Parity Error\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Write Data Bus Error\\n\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Read Data Bus Error\\n\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Instruction Data Error\\n\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Write Address Error\\n\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Read Address Error\\n\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bus - Instruction Address Error\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data Cache Parity Error\\n\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data Cache Push Parity Error\\n\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction Cache Parity Error\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_pci_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_rio_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e500(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tif (reason & MCSR_BUS_RBERR) {\n\t\tif (fsl_rio_mcheck_exception(regs))\n\t\t\treturn 1;\n\t\tif (fsl_pci_mcheck_exception(regs))\n\t\t\treturn 1;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tprintk(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tprintk(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tprintk(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tprintk(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tprintk(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tprintk(\"Bus - Write Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tprintk(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tprintk(\"Bus - Read Parity Error\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e500mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "492-589",
    "snippet": "int machine_check_e500mc(struct pt_regs *regs)\n{\n\tunsigned long mcsr = mfspr(SPRN_MCSR);\n\tunsigned long reason = mcsr;\n\tint recoverable = 1;\n\n\tif (reason & MCSR_LD) {\n\t\trecoverable = fsl_rio_mcheck_exception(regs);\n\t\tif (recoverable == 1)\n\t\t\tgoto silent_out;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\n\tif (reason & MCSR_ICPERR) {\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * This is recoverable by invalidating the i-cache.\n\t\t */\n\t\tmtspr(SPRN_L1CSR1, mfspr(SPRN_L1CSR1) | L1CSR1_ICFI);\n\t\twhile (mfspr(SPRN_L1CSR1) & L1CSR1_ICFI)\n\t\t\t;\n\n\t\t/*\n\t\t * This will generally be accompanied by an instruction\n\t\t * fetch error report -- only treat MCSR_IF as fatal\n\t\t * if it wasn't due to an L1 parity error.\n\t\t */\n\t\treason &= ~MCSR_IF;\n\t}\n\n\tif (reason & MCSR_DCPERR_MC) {\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * In write shadow mode we auto-recover from the error, but it\n\t\t * may still get logged and cause a machine check.  We should\n\t\t * only treat the non-write shadow case as non-recoverable.\n\t\t */\n\t\tif (!(mfspr(SPRN_L1CSR2) & L1CSR2_DCWS))\n\t\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_L2MMU_MHIT) {\n\t\tprintk(\"Hit on multiple TLB entries\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_NMI)\n\t\tprintk(\"Non-maskable interrupt\\n\");\n\n\tif (reason & MCSR_IF) {\n\t\tprintk(\"Instruction Fetch Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LD) {\n\t\tprintk(\"Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_ST) {\n\t\tprintk(\"Store Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LDG) {\n\t\tprintk(\"Guarded Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_TLBSYNC)\n\t\tprintk(\"Simultaneous tlbsync operations\\n\");\n\n\tif (reason & MCSR_BSL2_ERR) {\n\t\tprintk(\"Level 2 Cache Error\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_MAV) {\n\t\tu64 addr;\n\n\t\taddr = mfspr(SPRN_MCAR);\n\t\taddr |= (u64)mfspr(SPRN_MCARU) << 32;\n\n\t\tprintk(\"Machine Check %s Address: %#llx\\n\",\n\t\t       reason & MCSR_MEA ? \"Effective\" : \"Physical\", addr);\n\t}\n\nsilent_out:\n\tmtspr(SPRN_MCSR, mcsr);\n\treturn mfspr(SPRN_MCSR) == 0 && recoverable;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MCSR",
            "mcsr"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine Check %s Address: %#llx\\n\"",
            "reason & MCSR_MEA ? \"Effective\" : \"Physical\"",
            "addr"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCARU"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCAR"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Level 2 Cache Error\\n\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Simultaneous tlbsync operations\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Guarded Load Error Report\\n\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Store Error Report\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Load Error Report\\n\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction Fetch Error Report\\n\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Non-maskable interrupt\\n\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Hit on multiple TLB entries\\n\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR2"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data Cache Parity Error\\n\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR1"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_L1CSR1",
            "mfspr(SPRN_L1CSR1) | L1CSR1_ICFI"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR1"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction Cache Parity Error\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_rio_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e500mc(struct pt_regs *regs)\n{\n\tunsigned long mcsr = mfspr(SPRN_MCSR);\n\tunsigned long reason = mcsr;\n\tint recoverable = 1;\n\n\tif (reason & MCSR_LD) {\n\t\trecoverable = fsl_rio_mcheck_exception(regs);\n\t\tif (recoverable == 1)\n\t\t\tgoto silent_out;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\n\tif (reason & MCSR_ICPERR) {\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * This is recoverable by invalidating the i-cache.\n\t\t */\n\t\tmtspr(SPRN_L1CSR1, mfspr(SPRN_L1CSR1) | L1CSR1_ICFI);\n\t\twhile (mfspr(SPRN_L1CSR1) & L1CSR1_ICFI)\n\t\t\t;\n\n\t\t/*\n\t\t * This will generally be accompanied by an instruction\n\t\t * fetch error report -- only treat MCSR_IF as fatal\n\t\t * if it wasn't due to an L1 parity error.\n\t\t */\n\t\treason &= ~MCSR_IF;\n\t}\n\n\tif (reason & MCSR_DCPERR_MC) {\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * In write shadow mode we auto-recover from the error, but it\n\t\t * may still get logged and cause a machine check.  We should\n\t\t * only treat the non-write shadow case as non-recoverable.\n\t\t */\n\t\tif (!(mfspr(SPRN_L1CSR2) & L1CSR2_DCWS))\n\t\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_L2MMU_MHIT) {\n\t\tprintk(\"Hit on multiple TLB entries\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_NMI)\n\t\tprintk(\"Non-maskable interrupt\\n\");\n\n\tif (reason & MCSR_IF) {\n\t\tprintk(\"Instruction Fetch Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LD) {\n\t\tprintk(\"Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_ST) {\n\t\tprintk(\"Store Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LDG) {\n\t\tprintk(\"Guarded Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_TLBSYNC)\n\t\tprintk(\"Simultaneous tlbsync operations\\n\");\n\n\tif (reason & MCSR_BSL2_ERR) {\n\t\tprintk(\"Level 2 Cache Error\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_MAV) {\n\t\tu64 addr;\n\n\t\taddr = mfspr(SPRN_MCAR);\n\t\taddr |= (u64)mfspr(SPRN_MCARU) << 32;\n\n\t\tprintk(\"Machine Check %s Address: %#llx\\n\",\n\t\t       reason & MCSR_MEA ? \"Effective\" : \"Physical\", addr);\n\t}\n\nsilent_out:\n\tmtspr(SPRN_MCSR, mcsr);\n\treturn mfspr(SPRN_MCSR) == 0 && recoverable;\n}"
  },
  {
    "function_name": "machine_check_47x",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "452-490",
    "snippet": "int machine_check_47x(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\tu32 mcsr;\n\n\tprintk(KERN_ERR \"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP) {\n\t\tprintk(KERN_ERR\n\t\t       \"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t\treturn 0;\n\t}\n\tmcsr = mfspr(SPRN_MCSR);\n\tif (mcsr & MCSR_IB)\n\t\tprintk(KERN_ERR \"Instruction Read PLB Error\\n\");\n\tif (mcsr & MCSR_DRB)\n\t\tprintk(KERN_ERR \"Data Read PLB Error\\n\");\n\tif (mcsr & MCSR_DWB)\n\t\tprintk(KERN_ERR \"Data Write PLB Error\\n\");\n\tif (mcsr & MCSR_TLBP)\n\t\tprintk(KERN_ERR \"TLB Parity Error\\n\");\n\tif (mcsr & MCSR_ICP) {\n\t\tflush_instruction_cache();\n\t\tprintk(KERN_ERR \"I-Cache Parity Error\\n\");\n\t}\n\tif (mcsr & MCSR_DCSP)\n\t\tprintk(KERN_ERR \"D-Cache Search Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_GPR)\n\t\tprintk(KERN_ERR \"GPR Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_FPR)\n\t\tprintk(KERN_ERR \"FPR Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_IPR)\n\t\tprintk(KERN_ERR \"Machine Check exception is imprecise\\n\");\n\n\t/* Clear MCSR */\n\tmtspr(SPRN_MCSR, mcsr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MCSR",
            "mcsr"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Machine Check exception is imprecise\\n\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"FPR Parity Error\\n\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"GPR Parity Error\\n\""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"D-Cache Search Parity Error\\n\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"I-Cache Parity Error\\n\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_instruction_cache",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"TLB Parity Error\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Data Write PLB Error\\n\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Data Read PLB Error\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Instruction Read PLB Error\\n\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_ESR",
            "reason & ~ESR_IMCP"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Instruction Synchronous Machine Check exception\\n\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Machine check in kernel mode.\\n\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_47x(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\tu32 mcsr;\n\n\tprintk(KERN_ERR \"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP) {\n\t\tprintk(KERN_ERR\n\t\t       \"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t\treturn 0;\n\t}\n\tmcsr = mfspr(SPRN_MCSR);\n\tif (mcsr & MCSR_IB)\n\t\tprintk(KERN_ERR \"Instruction Read PLB Error\\n\");\n\tif (mcsr & MCSR_DRB)\n\t\tprintk(KERN_ERR \"Data Read PLB Error\\n\");\n\tif (mcsr & MCSR_DWB)\n\t\tprintk(KERN_ERR \"Data Write PLB Error\\n\");\n\tif (mcsr & MCSR_TLBP)\n\t\tprintk(KERN_ERR \"TLB Parity Error\\n\");\n\tif (mcsr & MCSR_ICP) {\n\t\tflush_instruction_cache();\n\t\tprintk(KERN_ERR \"I-Cache Parity Error\\n\");\n\t}\n\tif (mcsr & MCSR_DCSP)\n\t\tprintk(KERN_ERR \"D-Cache Search Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_GPR)\n\t\tprintk(KERN_ERR \"GPR Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_FPR)\n\t\tprintk(KERN_ERR \"FPR Parity Error\\n\");\n\tif (mcsr & PPC47x_MCSR_IPR)\n\t\tprintk(KERN_ERR \"Machine Check exception is imprecise\\n\");\n\n\t/* Clear MCSR */\n\tmtspr(SPRN_MCSR, mcsr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_440A",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "416-450",
    "snippet": "int machine_check_440A(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP){\n\t\tprintk(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t}\n\telse {\n\t\tu32 mcsr = mfspr(SPRN_MCSR);\n\t\tif (mcsr & MCSR_IB)\n\t\t\tprintk(\"Instruction Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DRB)\n\t\t\tprintk(\"Data Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DWB)\n\t\t\tprintk(\"Data Write PLB Error\\n\");\n\t\tif (mcsr & MCSR_TLBP)\n\t\t\tprintk(\"TLB Parity Error\\n\");\n\t\tif (mcsr & MCSR_ICP){\n\t\t\tflush_instruction_cache();\n\t\t\tprintk(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (mcsr & MCSR_DCSP)\n\t\t\tprintk(\"D-Cache Search Parity Error\\n\");\n\t\tif (mcsr & MCSR_DCFP)\n\t\t\tprintk(\"D-Cache Flush Parity Error\\n\");\n\t\tif (mcsr & MCSR_IMPE)\n\t\t\tprintk(\"Machine Check exception is imprecise\\n\");\n\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, mcsr);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MCSR",
            "mcsr"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine Check exception is imprecise\\n\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"D-Cache Flush Parity Error\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"D-Cache Search Parity Error\\n\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"I-Cache Parity Error\\n\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_instruction_cache",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"TLB Parity Error\\n\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data Write PLB Error\\n\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data Read PLB Error\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction Read PLB Error\\n\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_ESR",
            "reason & ~ESR_IMCP"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction Synchronous Machine Check exception\\n\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_440A(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP){\n\t\tprintk(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t}\n\telse {\n\t\tu32 mcsr = mfspr(SPRN_MCSR);\n\t\tif (mcsr & MCSR_IB)\n\t\t\tprintk(\"Instruction Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DRB)\n\t\t\tprintk(\"Data Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DWB)\n\t\t\tprintk(\"Data Write PLB Error\\n\");\n\t\tif (mcsr & MCSR_TLBP)\n\t\t\tprintk(\"TLB Parity Error\\n\");\n\t\tif (mcsr & MCSR_ICP){\n\t\t\tflush_instruction_cache();\n\t\t\tprintk(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (mcsr & MCSR_DCSP)\n\t\t\tprintk(\"D-Cache Search Parity Error\\n\");\n\t\tif (mcsr & MCSR_DCFP)\n\t\t\tprintk(\"D-Cache Flush Parity Error\\n\");\n\t\tif (mcsr & MCSR_IMPE)\n\t\t\tprintk(\"Machine Check exception is imprecise\\n\");\n\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, mcsr);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_4xx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "402-414",
    "snippet": "int machine_check_4xx(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tif (reason & ESR_IMCP) {\n\t\tprintk(\"Instruction\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t} else\n\t\tprintk(\"Data\");\n\tprintk(\" machine check in kernel mode.\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" machine check in kernel mode.\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Data\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_ESR",
            "reason & ~ESR_IMCP"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mc_reason",
          "args": [
            "regs"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_4xx(struct pt_regs *regs)\n{\n\tunsigned long reason = get_mc_reason(regs);\n\n\tif (reason & ESR_IMCP) {\n\t\tprintk(\"Instruction\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t} else\n\t\tprintk(\"Data\");\n\tprintk(\" machine check in kernel mode.\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_io_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "329-366",
    "snippet": "static inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s bad port %lx at %p\\n\"",
            "(*nip & 0x100)? \"OUT to\": \"IN from\"",
            "regs->gpr[rb] - _IO_BASE",
            "nip"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_exception_tables",
          "args": [
            "regs->nip"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}"
  },
  {
    "function_name": "hmi_exception_realmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "307-315",
    "snippet": "long hmi_exception_realmode(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.hmi_exceptions);\n\n\tif (ppc_md.hmi_exception_early)\n\t\tppc_md.hmi_exception_early(regs);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.hmi_exception_early",
          "args": [
            "regs"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.hmi_exceptions"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nlong hmi_exception_realmode(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.hmi_exceptions);\n\n\tif (ppc_md.hmi_exception_early)\n\t\tppc_md.hmi_exception_early(regs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "294-305",
    "snippet": "long machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\tif (cur_cpu_spec && cur_cpu_spec->machine_check_early)\n\t\thandled = cur_cpu_spec->machine_check_early(regs);\n\treturn handled;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_cpu_spec->machine_check_early",
          "args": [
            "regs"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "294-305",
          "snippet": "long machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\tif (cur_cpu_spec && cur_cpu_spec->machine_check_early)\n\t\thandled = cur_cpu_spec->machine_check_early(regs);\n\treturn handled;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_MACHINE_CHECK",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.mce_exceptions"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nlong machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\tif (cur_cpu_spec && cur_cpu_spec->machine_check_early)\n\t\thandled = cur_cpu_spec->machine_check_early(regs);\n\treturn handled;\n}"
  },
  {
    "function_name": "system_reset_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "272-287",
    "snippet": "void system_reset_exception(struct pt_regs *regs)\n{\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\treturn;\n\t}\n\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable System Reset\");\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Unrecoverable System Reset\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"System Reset\"",
            "regs",
            "SIGABRT"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.system_reset_exception",
          "args": [
            "regs"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "system_reset_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "272-287",
          "snippet": "void system_reset_exception(struct pt_regs *regs)\n{\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\treturn;\n\t}\n\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable System Reset\");\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid system_reset_exception(struct pt_regs *regs)\n{\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\treturn;\n\t}\n\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable System Reset\");\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}"
  },
  {
    "function_name": "_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "241-269",
    "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "signr",
            "&info",
            "current"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irqs_disabled",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "regs->msr & MSR_64BIT ? fmt64 : fmt32",
            "current->comm",
            "current->pid",
            "signr",
            "addr",
            "regs->nip",
            "regs->link",
            "code"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhandled_signal",
          "args": [
            "current",
            "signr"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Exception in kernel mode\"",
            "regs",
            "signr"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "223-230",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\tconst char fmt32[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %08lx nip %08lx lr %08lx code %x\\n\";\n\tconst char fmt64[] = KERN_INFO \"%s[%d]: unhandled signal %d \" \\\n\t\t\t\"at %016lx nip %016lx lr %016lx code %x\\n\";\n\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn;\n\t}\n\n\tif (show_unhandled_signals && unhandled_signal(current, signr)) {\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, signr,\n\t\t\t\t   addr, regs->nip, regs->link, code);\n\t}\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n}"
  },
  {
    "function_name": "user_single_step_siginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "232-239",
    "snippet": "void user_single_step_siginfo(struct task_struct *tsk,\n\t\t\t\tstruct pt_regs *regs, siginfo_t *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->si_signo = SIGTRAP;\n\tinfo->si_code = TRAP_TRACE;\n\tinfo->si_addr = (void __user *)regs->nip;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid user_single_step_siginfo(struct task_struct *tsk,\n\t\t\t\tstruct pt_regs *regs, siginfo_t *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->si_signo = SIGTRAP;\n\tinfo->si_code = TRAP_TRACE;\n\tinfo->si_addr = (void __user *)regs->nip;\n}"
  },
  {
    "function_name": "die",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "223-230",
    "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oops_end",
          "args": [
            "flags",
            "regs",
            "err"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "oops_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "145-195",
          "snippet": "static void __kprobes oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tdie_owner = -1;\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count)\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tarch_spin_unlock(&die_lock);\n\traw_local_irq_restore(flags);\n\n\tcrash_fadump(regs, \"die oops\");\n\n\t/*\n\t * A system reset (0x100) is a request to dump, so we always send\n\t * it through the crashdump code.\n\t */\n\tif (kexec_should_crash(current) || (TRAP(regs) == 0x100)) {\n\t\tcrash_kexec(regs);\n\n\t\t/*\n\t\t * We aren't the primary crash CPU. We need to send it\n\t\t * to a holding pattern to avoid it ending up in the panic\n\t\t * code.\n\t\t */\n\t\tcrash_kexec_secondary(regs);\n\t}\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
            "static int die_owner = -1;",
            "static unsigned int die_nest_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic void __kprobes oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tdie_owner = -1;\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count)\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tarch_spin_unlock(&die_lock);\n\traw_local_irq_restore(flags);\n\n\tcrash_fadump(regs, \"die oops\");\n\n\t/*\n\t * A system reset (0x100) is a request to dump, so we always send\n\t * it through the crashdump code.\n\t */\n\tif (kexec_should_crash(current) || (TRAP(regs) == 0x100)) {\n\t\tcrash_kexec(regs);\n\n\t\t/*\n\t\t * We aren't the primary crash CPU. We need to send it\n\t\t * to a holding pattern to avoid it ending up in the panic\n\t\t * code.\n\t\t */\n\t\tcrash_kexec_secondary(regs);\n\t}\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__die",
          "args": [
            "str",
            "regs",
            "err"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "197-221",
          "snippet": "static int __kprobes __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int die_counter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int die_counter;\n\nstatic int __kprobes __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oops_begin",
          "args": [
            "regs"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "oops_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "117-143",
          "snippet": "static unsigned __kprobes long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
            "static int die_owner = -1;",
            "static unsigned int die_nest_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic unsigned __kprobes long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags = oops_begin(regs);\n\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
  },
  {
    "function_name": "__die",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "197-221",
    "snippet": "static int __kprobes __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int die_counter;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "993-1042",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [
            "static struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nstatic struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_OOPS",
            "str",
            "regs",
            "err",
            "255",
            "SIGSEGV"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s\\n\"",
            "ppc_md.name ? ppc_md.name : \"\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NUMA \""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"DEBUG_PAGEALLOC \""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"PREEMPT \""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Oops: %s, sig: %ld [#%d]\\n\"",
            "str",
            "err",
            "++die_counter"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int die_counter;\n\nstatic int __kprobes __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "oops_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "145-195",
    "snippet": "static void __kprobes oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tdie_owner = -1;\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count)\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tarch_spin_unlock(&die_lock);\n\traw_local_irq_restore(flags);\n\n\tcrash_fadump(regs, \"die oops\");\n\n\t/*\n\t * A system reset (0x100) is a request to dump, so we always send\n\t * it through the crashdump code.\n\t */\n\tif (kexec_should_crash(current) || (TRAP(regs) == 0x100)) {\n\t\tcrash_kexec(regs);\n\n\t\t/*\n\t\t * We aren't the primary crash CPU. We need to send it\n\t\t * to a holding pattern to avoid it ending up in the panic\n\t\t * code.\n\t\t */\n\t\tcrash_kexec_secondary(regs);\n\t}\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
      "static int die_owner = -1;",
      "static unsigned int die_nest_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "signr"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Fatal exception\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Fatal exception in interrupt\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "MSEC_PER_SEC"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "current"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_kexec_secondary",
          "args": [
            "regs"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "crash_kexec_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "218-220",
          "snippet": "void crash_kexec_secondary(struct pt_regs *regs)\n{\n}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nvoid crash_kexec_secondary(struct pt_regs *regs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "crash_kexec",
          "args": [
            "regs"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "crash_kexec_wait_realmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "246-246",
          "snippet": "static inline void crash_kexec_wait_realmode(int cpu) {}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic inline void crash_kexec_wait_realmode(int cpu) {}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_should_crash",
          "args": [
            "current"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_fadump",
          "args": [
            "regs",
            "\"die oops\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "crash_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "401-422",
          "snippet": "void crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tstruct fadump_crash_info_header *fdh = NULL;\n\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn;\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tcrashing_cpu = smp_processor_id();\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->cpu_online_mask = *cpu_online_mask;\n\n\t/* Call ibm,os-term rtas call to trigger firmware assisted dump */\n\trtas_os_term((char *)str);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tstruct fadump_crash_info_header *fdh = NULL;\n\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn;\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tcrashing_cpu = smp_processor_id();\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->cpu_online_mask = *cpu_online_mask;\n\n\t/* Call ibm,os-term rtas call to trigger firmware assisted dump */\n\trtas_os_term((char *)str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&die_lock"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oops_exit",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_DIE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic void __kprobes oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tdie_owner = -1;\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count)\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tarch_spin_unlock(&die_lock);\n\traw_local_irq_restore(flags);\n\n\tcrash_fadump(regs, \"die oops\");\n\n\t/*\n\t * A system reset (0x100) is a request to dump, so we always send\n\t * it through the crashdump code.\n\t */\n\tif (kexec_should_crash(current) || (TRAP(regs) == 0x100)) {\n\t\tcrash_kexec(regs);\n\n\t\t/*\n\t\t * We aren't the primary crash CPU. We need to send it\n\t\t * to a holding pattern to avoid it ending up in the panic\n\t\t * code.\n\t\t */\n\t\tcrash_kexec_secondary(regs);\n\t}\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}"
  },
  {
    "function_name": "oops_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "117-143",
    "snippet": "static unsigned __kprobes long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
      "static int die_owner = -1;",
      "static unsigned int die_nest_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmac_backlight_unblank",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "pmac_backlight_unblank",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "109-109",
          "snippet": "static inline void pmac_backlight_unblank(void) { }",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void pmac_backlight_unblank(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powermac"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_verbose",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&die_lock"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_trylock",
          "args": [
            "&die_lock"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oops_enter",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "133-137",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic unsigned __kprobes long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}"
  },
  {
    "function_name": "pmac_backlight_unblank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "109-109",
    "snippet": "static inline void pmac_backlight_unblank(void) { }",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void pmac_backlight_unblank(void) { }"
  },
  {
    "function_name": "pmac_backlight_unblank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
    "lines": "95-107",
    "snippet": "static void pmac_backlight_unblank(void)\n{\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tprops = &pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(pmac_backlight);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n}",
    "includes": [
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pmac_backlight_mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backlight_update_status",
          "args": [
            "pmac_backlight"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pmac_backlight_mutex"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void pmac_backlight_unblank(void)\n{\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tprops = &pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(pmac_backlight);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n}"
  }
]