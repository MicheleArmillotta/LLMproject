[
  {
    "function_name": "kexec_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "258-280",
    "snippet": "static int __init kexec_setup(void)\n{\n\tstruct device_node *node;\n\tstruct property *prop;\n\n\tnode = of_find_node_by_path(\"/chosen\");\n\tif (!node)\n\t\treturn -ENOENT;\n\n\t/* remove any stale properties so ours can be found */\n\tprop = of_find_property(node, kernel_end_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\t/* information needed by userspace when using default_machine_kexec */\n\tkernel_end = cpu_to_be_ulong(__pa(_end));\n\tof_add_property(node, &kernel_end_prop);\n\n\texport_crashk_values(node);\n\n\tof_node_put(node);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [
      "#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)"
    ],
    "globals_used": [
      "static phys_addr_t kernel_end;",
      "static struct property kernel_end_prop = {\n\t.name = \"linux,kernel-end\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &kernel_end,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "node"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "export_crashk_values",
          "args": [
            "node"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "export_crashk_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "229-256",
          "snippet": "static void __init export_crashk_values(struct device_node *node)\n{\n\tstruct property *prop;\n\n\t/* There might be existing crash kernel properties, but we can't\n\t * be sure what's in them, so remove them. */\n\tprop = of_find_property(node, \"linux,crashkernel-base\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tprop = of_find_property(node, \"linux,crashkernel-size\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tif (crashk_res.start != 0) {\n\t\tcrashk_base = cpu_to_be_ulong(crashk_res.start),\n\t\tof_add_property(node, &crashk_base_prop);\n\t\tcrashk_size = cpu_to_be_ulong(resource_size(&crashk_res));\n\t\tof_add_property(node, &crashk_size_prop);\n\t}\n\n\t/*\n\t * memory_limit is required by the kexec-tools to limit the\n\t * crash regions to the actual memory used.\n\t */\n\tmem_limit = cpu_to_be_ulong(memory_limit);\n\tof_update_property(node, &memory_limit_prop);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [
            "#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)"
          ],
          "globals_used": [
            "static phys_addr_t crashk_base;",
            "static phys_addr_t crashk_size;",
            "static unsigned long long mem_limit;",
            "static struct property crashk_base_prop = {\n\t.name = \"linux,crashkernel-base\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_base\n};",
            "static struct property crashk_size_prop = {\n\t.name = \"linux,crashkernel-size\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_size,\n};",
            "static struct property memory_limit_prop = {\n\t.name = \"linux,memory-limit\",\n\t.length = sizeof(unsigned long long),\n\t.value = &mem_limit,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\n#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)\n\nstatic phys_addr_t crashk_base;\nstatic phys_addr_t crashk_size;\nstatic unsigned long long mem_limit;\nstatic struct property crashk_base_prop = {\n\t.name = \"linux,crashkernel-base\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_base\n};\nstatic struct property crashk_size_prop = {\n\t.name = \"linux,crashkernel-size\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_size,\n};\nstatic struct property memory_limit_prop = {\n\t.name = \"linux,memory-limit\",\n\t.length = sizeof(unsigned long long),\n\t.value = &mem_limit,\n};\n\nstatic void __init export_crashk_values(struct device_node *node)\n{\n\tstruct property *prop;\n\n\t/* There might be existing crash kernel properties, but we can't\n\t * be sure what's in them, so remove them. */\n\tprop = of_find_property(node, \"linux,crashkernel-base\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tprop = of_find_property(node, \"linux,crashkernel-size\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tif (crashk_res.start != 0) {\n\t\tcrashk_base = cpu_to_be_ulong(crashk_res.start),\n\t\tof_add_property(node, &crashk_base_prop);\n\t\tcrashk_size = cpu_to_be_ulong(resource_size(&crashk_res));\n\t\tof_add_property(node, &crashk_size_prop);\n\t}\n\n\t/*\n\t * memory_limit is required by the kexec-tools to limit the\n\t * crash regions to the actual memory used.\n\t */\n\tmem_limit = cpu_to_be_ulong(memory_limit);\n\tof_update_property(node, &memory_limit_prop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "node",
            "&kernel_end_prop"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be_ulong",
          "args": [
            "__pa(_end)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "_end"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_remove_property",
          "args": [
            "node",
            "prop"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "node",
            "kernel_end_prop.name",
            "NULL"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/chosen\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\n#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)\n\nstatic phys_addr_t kernel_end;\nstatic struct property kernel_end_prop = {\n\t.name = \"linux,kernel-end\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &kernel_end,\n};\n\nstatic int __init kexec_setup(void)\n{\n\tstruct device_node *node;\n\tstruct property *prop;\n\n\tnode = of_find_node_by_path(\"/chosen\");\n\tif (!node)\n\t\treturn -ENOENT;\n\n\t/* remove any stale properties so ours can be found */\n\tprop = of_find_property(node, kernel_end_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\t/* information needed by userspace when using default_machine_kexec */\n\tkernel_end = cpu_to_be_ulong(__pa(_end));\n\tof_add_property(node, &kernel_end_prop);\n\n\texport_crashk_values(node);\n\n\tof_node_put(node);\n\treturn 0;\n}"
  },
  {
    "function_name": "export_crashk_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "229-256",
    "snippet": "static void __init export_crashk_values(struct device_node *node)\n{\n\tstruct property *prop;\n\n\t/* There might be existing crash kernel properties, but we can't\n\t * be sure what's in them, so remove them. */\n\tprop = of_find_property(node, \"linux,crashkernel-base\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tprop = of_find_property(node, \"linux,crashkernel-size\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tif (crashk_res.start != 0) {\n\t\tcrashk_base = cpu_to_be_ulong(crashk_res.start),\n\t\tof_add_property(node, &crashk_base_prop);\n\t\tcrashk_size = cpu_to_be_ulong(resource_size(&crashk_res));\n\t\tof_add_property(node, &crashk_size_prop);\n\t}\n\n\t/*\n\t * memory_limit is required by the kexec-tools to limit the\n\t * crash regions to the actual memory used.\n\t */\n\tmem_limit = cpu_to_be_ulong(memory_limit);\n\tof_update_property(node, &memory_limit_prop);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [
      "#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)"
    ],
    "globals_used": [
      "static phys_addr_t crashk_base;",
      "static phys_addr_t crashk_size;",
      "static unsigned long long mem_limit;",
      "static struct property crashk_base_prop = {\n\t.name = \"linux,crashkernel-base\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_base\n};",
      "static struct property crashk_size_prop = {\n\t.name = \"linux,crashkernel-size\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_size,\n};",
      "static struct property memory_limit_prop = {\n\t.name = \"linux,memory-limit\",\n\t.length = sizeof(unsigned long long),\n\t.value = &mem_limit,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_update_property",
          "args": [
            "node",
            "&memory_limit_prop"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be_ulong",
          "args": [
            "memory_limit"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "node",
            "&crashk_size_prop"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be_ulong",
          "args": [
            "resource_size(&crashk_res)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "&crashk_res"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "node",
            "&crashk_base_prop"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be_ulong",
          "args": [
            "crashk_res.start"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_remove_property",
          "args": [
            "node",
            "prop"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "node",
            "\"linux,crashkernel-size\"",
            "NULL"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_remove_property",
          "args": [
            "node",
            "prop"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "node",
            "\"linux,crashkernel-base\"",
            "NULL"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\n#define cpu_to_be_ulong\t__PASTE(cpu_to_be, BITS_PER_LONG)\n\nstatic phys_addr_t crashk_base;\nstatic phys_addr_t crashk_size;\nstatic unsigned long long mem_limit;\nstatic struct property crashk_base_prop = {\n\t.name = \"linux,crashkernel-base\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_base\n};\nstatic struct property crashk_size_prop = {\n\t.name = \"linux,crashkernel-size\",\n\t.length = sizeof(phys_addr_t),\n\t.value = &crashk_size,\n};\nstatic struct property memory_limit_prop = {\n\t.name = \"linux,memory-limit\",\n\t.length = sizeof(unsigned long long),\n\t.value = &mem_limit,\n};\n\nstatic void __init export_crashk_values(struct device_node *node)\n{\n\tstruct property *prop;\n\n\t/* There might be existing crash kernel properties, but we can't\n\t * be sure what's in them, so remove them. */\n\tprop = of_find_property(node, \"linux,crashkernel-base\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tprop = of_find_property(node, \"linux,crashkernel-size\", NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\tif (crashk_res.start != 0) {\n\t\tcrashk_base = cpu_to_be_ulong(crashk_res.start),\n\t\tof_add_property(node, &crashk_base_prop);\n\t\tcrashk_size = cpu_to_be_ulong(resource_size(&crashk_res));\n\t\tof_add_property(node, &crashk_size_prop);\n\t}\n\n\t/*\n\t * memory_limit is required by the kexec-tools to limit the\n\t * crash regions to the actual memory used.\n\t */\n\tmem_limit = cpu_to_be_ulong(memory_limit);\n\tof_update_property(node, &memory_limit_prop);\n}"
  },
  {
    "function_name": "overlaps_crashkernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "192-195",
    "snippet": "int overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nint overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}"
  },
  {
    "function_name": "reserve_crashkernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "114-190",
    "snippet": "void __init reserve_crashkernel(void)\n{\n\tunsigned long long crash_size, crash_base;\n\tint ret;\n\n\t/* use common parsing */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t&crash_size, &crash_base);\n\tif (ret == 0 && crash_size > 0) {\n\t\tcrashk_res.start = crash_base;\n\t\tcrashk_res.end = crash_base + crash_size - 1;\n\t}\n\n\tif (crashk_res.end == crashk_res.start) {\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* We might have got these values via the command line or the\n\t * device tree, either way sanitise them now. */\n\n\tcrash_size = resource_size(&crashk_res);\n\n#ifndef CONFIG_NONSTATIC_KERNEL\n\tif (crashk_res.start != KDUMP_KERNELBASE)\n\t\tprintk(\"Crash kernel location must be 0x%x\\n\",\n\t\t\t\tKDUMP_KERNELBASE);\n\n\tcrashk_res.start = KDUMP_KERNELBASE;\n#else\n\tif (!crashk_res.start) {\n#ifdef CONFIG_PPC64\n\t\t/*\n\t\t * On 64bit we split the RMO in half but cap it at half of\n\t\t * a small SLB (128MB) since the crash kernel needs to place\n\t\t * itself and some stacks to be in the first segment.\n\t\t */\n\t\tcrashk_res.start = min(0x8000000ULL, (ppc64_rma_size / 2));\n#else\n\t\tcrashk_res.start = KDUMP_KERNELBASE;\n#endif\n\t}\n\n\tcrash_base = PAGE_ALIGN(crashk_res.start);\n\tif (crash_base != crashk_res.start) {\n\t\tprintk(\"Crash kernel base must be aligned to 0x%lx\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tcrashk_res.start = crash_base;\n\t}\n\n#endif\n\tcrash_size = PAGE_ALIGN(crash_size);\n\tcrashk_res.end = crashk_res.start + crash_size - 1;\n\n\t/* The crash region must not overlap the current kernel */\n\tif (overlaps_crashkernel(__pa(_stext), _end - _stext)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Crash kernel can not overlap current kernel\\n\");\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* Crash kernel trumps memory limit */\n\tif (memory_limit && memory_limit <= crashk_res.end) {\n\t\tmemory_limit = crashk_res.end + 1;\n\t\tprintk(\"Adjusted memory limit for crashkernel, now 0x%llx\\n\",\n\t\t       memory_limit);\n\t}\n\n\tprintk(KERN_INFO \"Reserving %ldMB of memory at %ldMB \"\n\t\t\t\"for crashkernel (System RAM: %ldMB)\\n\",\n\t\t\t(unsigned long)(crash_size >> 20),\n\t\t\t(unsigned long)(crashk_res.start >> 20),\n\t\t\t(unsigned long)(memblock_phys_mem_size() >> 20));\n\n\tmemblock_reserve(crashk_res.start, crash_size);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "crashk_res.start",
            "crash_size"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Reserving %ldMB of memory at %ldMB \"\n\t\t\t\"for crashkernel (System RAM: %ldMB)\\n\"",
            "(unsigned long)(crash_size >> 20)",
            "(unsigned long)(crashk_res.start >> 20)",
            "(unsigned long)(memblock_phys_mem_size() >> 20)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Adjusted memory limit for crashkernel, now 0x%llx\\n\"",
            "memory_limit"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"Crash kernel can not overlap current kernel\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overlaps_crashkernel",
          "args": [
            "__pa(_stext)",
            "_end - _stext"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps_crashkernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "192-195",
          "snippet": "int overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nint overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "_stext"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "crash_size"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "crashk_res.start"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "0x8000000ULL",
            "(ppc64_rma_size / 2)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "&crashk_res"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_crashkernel",
          "args": [
            "boot_command_line",
            "memblock_phys_mem_size()",
            "&crash_size",
            "&crash_base"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid __init reserve_crashkernel(void)\n{\n\tunsigned long long crash_size, crash_base;\n\tint ret;\n\n\t/* use common parsing */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t&crash_size, &crash_base);\n\tif (ret == 0 && crash_size > 0) {\n\t\tcrashk_res.start = crash_base;\n\t\tcrashk_res.end = crash_base + crash_size - 1;\n\t}\n\n\tif (crashk_res.end == crashk_res.start) {\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* We might have got these values via the command line or the\n\t * device tree, either way sanitise them now. */\n\n\tcrash_size = resource_size(&crashk_res);\n\n#ifndef CONFIG_NONSTATIC_KERNEL\n\tif (crashk_res.start != KDUMP_KERNELBASE)\n\t\tprintk(\"Crash kernel location must be 0x%x\\n\",\n\t\t\t\tKDUMP_KERNELBASE);\n\n\tcrashk_res.start = KDUMP_KERNELBASE;\n#else\n\tif (!crashk_res.start) {\n#ifdef CONFIG_PPC64\n\t\t/*\n\t\t * On 64bit we split the RMO in half but cap it at half of\n\t\t * a small SLB (128MB) since the crash kernel needs to place\n\t\t * itself and some stacks to be in the first segment.\n\t\t */\n\t\tcrashk_res.start = min(0x8000000ULL, (ppc64_rma_size / 2));\n#else\n\t\tcrashk_res.start = KDUMP_KERNELBASE;\n#endif\n\t}\n\n\tcrash_base = PAGE_ALIGN(crashk_res.start);\n\tif (crash_base != crashk_res.start) {\n\t\tprintk(\"Crash kernel base must be aligned to 0x%lx\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tcrashk_res.start = crash_base;\n\t}\n\n#endif\n\tcrash_size = PAGE_ALIGN(crash_size);\n\tcrashk_res.end = crashk_res.start + crash_size - 1;\n\n\t/* The crash region must not overlap the current kernel */\n\tif (overlaps_crashkernel(__pa(_stext), _end - _stext)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Crash kernel can not overlap current kernel\\n\");\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* Crash kernel trumps memory limit */\n\tif (memory_limit && memory_limit <= crashk_res.end) {\n\t\tmemory_limit = crashk_res.end + 1;\n\t\tprintk(\"Adjusted memory limit for crashkernel, now 0x%llx\\n\",\n\t\t       memory_limit);\n\t}\n\n\tprintk(KERN_INFO \"Reserving %ldMB of memory at %ldMB \"\n\t\t\t\"for crashkernel (System RAM: %ldMB)\\n\",\n\t\t\t(unsigned long)(crash_size >> 20),\n\t\t\t(unsigned long)(crashk_res.start >> 20),\n\t\t\t(unsigned long)(memblock_phys_mem_size() >> 20));\n\n\tmemblock_reserve(crashk_res.start, crash_size);\n}"
  },
  {
    "function_name": "machine_kexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "96-112",
    "snippet": "void machine_kexec(struct kimage *image)\n{\n\tint save_ftrace_enabled;\n\n\tsave_ftrace_enabled = __ftrace_enabled_save();\n\n\tif (ppc_md.machine_kexec)\n\t\tppc_md.machine_kexec(image);\n\telse\n\t\tdefault_machine_kexec(image);\n\n\t__ftrace_enabled_restore(save_ftrace_enabled);\n\n\t/* Fall back to normal restart if we're still alive. */\n\tmachine_restart(NULL);\n\tfor(;;);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_restart",
          "args": [
            "NULL"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "machine_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "126-137",
          "snippet": "void machine_restart(char *cmd)\n{\n\tmachine_shutdown();\n\tif (ppc_md.restart)\n\t\tppc_md.restart(cmd);\n#ifdef CONFIG_SMP\n\tsmp_send_stop();\n#endif\n\tprintk(KERN_EMERG \"System Halted, OK to turn off power\\n\");\n\tlocal_irq_disable();\n\twhile (1) ;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct machdep_calls ppc_md;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/debugfs.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nstruct machdep_calls ppc_md;\n\nvoid machine_restart(char *cmd)\n{\n\tmachine_shutdown();\n\tif (ppc_md.restart)\n\t\tppc_md.restart(cmd);\n#ifdef CONFIG_SMP\n\tsmp_send_stop();\n#endif\n\tprintk(KERN_EMERG \"System Halted, OK to turn off power\\n\");\n\tlocal_irq_disable();\n\twhile (1) ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_enabled_restore",
          "args": [
            "save_ftrace_enabled"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_machine_kexec",
          "args": [
            "image"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "default_machine_kexec_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_32.c",
          "lines": "66-69",
          "snippet": "int default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <asm/hw_irq.h>\n#include <asm/cacheflush.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kexec.h>\n\nint default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.machine_kexec",
          "args": [
            "image"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "96-112",
          "snippet": "void machine_kexec(struct kimage *image)\n{\n\tint save_ftrace_enabled;\n\n\tsave_ftrace_enabled = __ftrace_enabled_save();\n\n\tif (ppc_md.machine_kexec)\n\t\tppc_md.machine_kexec(image);\n\telse\n\t\tdefault_machine_kexec(image);\n\n\t__ftrace_enabled_restore(save_ftrace_enabled);\n\n\t/* Fall back to normal restart if we're still alive. */\n\tmachine_restart(NULL);\n\tfor(;;);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_enabled_save",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_kexec(struct kimage *image)\n{\n\tint save_ftrace_enabled;\n\n\tsave_ftrace_enabled = __ftrace_enabled_save();\n\n\tif (ppc_md.machine_kexec)\n\t\tppc_md.machine_kexec(image);\n\telse\n\t\tdefault_machine_kexec(image);\n\n\t__ftrace_enabled_restore(save_ftrace_enabled);\n\n\t/* Fall back to normal restart if we're still alive. */\n\tmachine_restart(NULL);\n\tfor(;;);\n}"
  },
  {
    "function_name": "arch_crash_save_vmcoreinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "69-90",
    "snippet": "void arch_crash_save_vmcoreinfo(void)\n{\n\n#ifdef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(node_data);\n\tVMCOREINFO_LENGTH(node_data, MAX_NUMNODES);\n#endif\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#if defined(CONFIG_PPC64) && defined(CONFIG_SPARSEMEM_VMEMMAP)\n\tVMCOREINFO_SYMBOL(vmemmap_list);\n\tVMCOREINFO_SYMBOL(mmu_vmemmap_psize);\n\tVMCOREINFO_SYMBOL(mmu_psize_defs);\n\tVMCOREINFO_STRUCT_SIZE(vmemmap_backing);\n\tVMCOREINFO_OFFSET(vmemmap_backing, list);\n\tVMCOREINFO_OFFSET(vmemmap_backing, phys);\n\tVMCOREINFO_OFFSET(vmemmap_backing, virt_addr);\n\tVMCOREINFO_STRUCT_SIZE(mmu_psize_def);\n\tVMCOREINFO_OFFSET(mmu_psize_def, shift);\n#endif\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "mmu_psize_def",
            "shift"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "mmu_psize_def"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "vmemmap_backing",
            "virt_addr"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "vmemmap_backing",
            "phys"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "vmemmap_backing",
            "list"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "vmemmap_backing"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "mmu_psize_defs"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "mmu_vmemmap_psize"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "vmemmap_list"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "contig_page_data"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_LENGTH",
          "args": [
            "node_data",
            "MAX_NUMNODES"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "node_data"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid arch_crash_save_vmcoreinfo(void)\n{\n\n#ifdef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(node_data);\n\tVMCOREINFO_LENGTH(node_data, MAX_NUMNODES);\n#endif\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#if defined(CONFIG_PPC64) && defined(CONFIG_SPARSEMEM_VMEMMAP)\n\tVMCOREINFO_SYMBOL(vmemmap_list);\n\tVMCOREINFO_SYMBOL(mmu_vmemmap_psize);\n\tVMCOREINFO_SYMBOL(mmu_psize_defs);\n\tVMCOREINFO_STRUCT_SIZE(vmemmap_backing);\n\tVMCOREINFO_OFFSET(vmemmap_backing, list);\n\tVMCOREINFO_OFFSET(vmemmap_backing, phys);\n\tVMCOREINFO_OFFSET(vmemmap_backing, virt_addr);\n\tVMCOREINFO_STRUCT_SIZE(mmu_psize_def);\n\tVMCOREINFO_OFFSET(mmu_psize_def, shift);\n#endif\n}"
  },
  {
    "function_name": "machine_kexec_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "65-67",
    "snippet": "void machine_kexec_cleanup(struct kimage *image)\n{\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_kexec_cleanup(struct kimage *image)\n{\n}"
  },
  {
    "function_name": "machine_kexec_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "57-63",
    "snippet": "int machine_kexec_prepare(struct kimage *image)\n{\n\tif (ppc_md.machine_kexec_prepare)\n\t\treturn ppc_md.machine_kexec_prepare(image);\n\telse\n\t\treturn default_machine_kexec_prepare(image);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_machine_kexec_prepare",
          "args": [
            "image"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "default_machine_kexec_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_32.c",
          "lines": "66-69",
          "snippet": "int default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <asm/hw_irq.h>\n#include <asm/cacheflush.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kexec.h>\n\nint default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.machine_kexec_prepare",
          "args": [
            "image"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "57-63",
          "snippet": "int machine_kexec_prepare(struct kimage *image)\n{\n\tif (ppc_md.machine_kexec_prepare)\n\t\treturn ppc_md.machine_kexec_prepare(image);\n\telse\n\t\treturn default_machine_kexec_prepare(image);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nint machine_kexec_prepare(struct kimage *image)\n{\n\tif (ppc_md.machine_kexec_prepare)\n\t\treturn ppc_md.machine_kexec_prepare(image);\n\telse\n\t\treturn default_machine_kexec_prepare(image);\n}"
  },
  {
    "function_name": "machine_crash_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "47-50",
    "snippet": "void machine_crash_shutdown(struct pt_regs *regs)\n{\n\tdefault_machine_crash_shutdown(regs);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_machine_crash_shutdown",
          "args": [
            "regs"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "default_machine_crash_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "302-367",
          "snippet": "void default_machine_crash_shutdown(struct pt_regs *regs)\n{\n\tunsigned int i;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\t/*\n\t * This function is only called after the system\n\t * has panicked or is otherwise in a critical state.\n\t * The minimum amount of code to allow a kexec'd kernel\n\t * to run successfully needs to happen here.\n\t *\n\t * In practice this means stopping other cpus in\n\t * an SMP system.\n\t * The kernel is broken so disable interrupts.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * Make a note of crashing cpu. Will be used in machine_kexec\n\t * such that another IPI will not be sent.\n\t */\n\tcrashing_cpu = smp_processor_id();\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\tmdelay(PRIMARY_TIMEOUT);\n\n\tcrash_kexec_prepare_cpus(crashing_cpu);\n\n\tcrash_save_cpu(regs, crashing_cpu);\n\n\ttime_to_dump = 1;\n\n\tcrash_kexec_wait_realmode(crashing_cpu);\n\n\tmachine_kexec_mask_interrupts();\n\n\t/*\n\t * Call registered shutdown routines safely.  Swap out\n\t * __debugger_fault_handler, and replace on exit.\n\t */\n\told_handler = __debugger_fault_handler;\n\t__debugger_fault_handler = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\tfor (i = 0; crash_shutdown_handles[i]; i++) {\n\t\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\t\t/*\n\t\t\t * Insert syncs and delay to ensure\n\t\t\t * instructions in the dangerous region don't\n\t\t\t * leak away from this protected region.\n\t\t\t */\n\t\t\tasm volatile(\"sync; isync\");\n\t\t\t/* dangerous region */\n\t\t\tcrash_shutdown_handles[i]();\n\t\t\tasm volatile(\"sync; isync\");\n\t\t}\n\t}\n\tcrash_shutdown_cpu = -1;\n\t__debugger_fault_handler = old_handler;\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 0);\n}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRIMARY_TIMEOUT\t\t500"
          ],
          "globals_used": [
            "int crashing_cpu = -1;",
            "static int time_to_dump;",
            "static crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];",
            "static unsigned long crash_shutdown_buf[JMP_BUF_LEN];",
            "static int crash_shutdown_cpu = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define PRIMARY_TIMEOUT\t\t500\n\nint crashing_cpu = -1;\nstatic int time_to_dump;\nstatic crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];\nstatic unsigned long crash_shutdown_buf[JMP_BUF_LEN];\nstatic int crash_shutdown_cpu = -1;\n\nvoid default_machine_crash_shutdown(struct pt_regs *regs)\n{\n\tunsigned int i;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\t/*\n\t * This function is only called after the system\n\t * has panicked or is otherwise in a critical state.\n\t * The minimum amount of code to allow a kexec'd kernel\n\t * to run successfully needs to happen here.\n\t *\n\t * In practice this means stopping other cpus in\n\t * an SMP system.\n\t * The kernel is broken so disable interrupts.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * Make a note of crashing cpu. Will be used in machine_kexec\n\t * such that another IPI will not be sent.\n\t */\n\tcrashing_cpu = smp_processor_id();\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\tmdelay(PRIMARY_TIMEOUT);\n\n\tcrash_kexec_prepare_cpus(crashing_cpu);\n\n\tcrash_save_cpu(regs, crashing_cpu);\n\n\ttime_to_dump = 1;\n\n\tcrash_kexec_wait_realmode(crashing_cpu);\n\n\tmachine_kexec_mask_interrupts();\n\n\t/*\n\t * Call registered shutdown routines safely.  Swap out\n\t * __debugger_fault_handler, and replace on exit.\n\t */\n\told_handler = __debugger_fault_handler;\n\t__debugger_fault_handler = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\tfor (i = 0; crash_shutdown_handles[i]; i++) {\n\t\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\t\t/*\n\t\t\t * Insert syncs and delay to ensure\n\t\t\t * instructions in the dangerous region don't\n\t\t\t * leak away from this protected region.\n\t\t\t */\n\t\t\tasm volatile(\"sync; isync\");\n\t\t\t/* dangerous region */\n\t\t\tcrash_shutdown_handles[i]();\n\t\t\tasm volatile(\"sync; isync\");\n\t\t}\n\t}\n\tcrash_shutdown_cpu = -1;\n\t__debugger_fault_handler = old_handler;\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_crash_shutdown(struct pt_regs *regs)\n{\n\tdefault_machine_crash_shutdown(regs);\n}"
  },
  {
    "function_name": "machine_kexec_mask_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
    "lines": "25-45",
    "snippet": "void machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/irq.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/threads.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_disable",
          "args": [
            "&desc->irq_data"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_eoi",
          "args": [
            "&desc->irq_data"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}"
  }
]