[
  {
    "function_name": "kgdb_arch_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "485-494",
    "snippet": "void kgdb_arch_exit(void)\n{\n\t__debugger_ipi = old__debugger_ipi;\n\t__debugger = old__debugger;\n\t__debugger_bpt = old__debugger_bpt;\n\t__debugger_sstep = old__debugger_sstep;\n\t__debugger_iabr_match = old__debugger_iabr_match;\n\t__debugger_break_match = old__debugger_break_match;\n\t__debugger_fault_handler = old__debugger_fault_handler;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *old__debugger_ipi;",
      "static void *old__debugger;",
      "static void *old__debugger_bpt;",
      "static void *old__debugger_sstep;",
      "static void *old__debugger_iabr_match;",
      "static void *old__debugger_break_match;",
      "static void *old__debugger_fault_handler;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic void *old__debugger_ipi;\nstatic void *old__debugger;\nstatic void *old__debugger_bpt;\nstatic void *old__debugger_sstep;\nstatic void *old__debugger_iabr_match;\nstatic void *old__debugger_break_match;\nstatic void *old__debugger_fault_handler;\n\nvoid kgdb_arch_exit(void)\n{\n\t__debugger_ipi = old__debugger_ipi;\n\t__debugger = old__debugger;\n\t__debugger_bpt = old__debugger_bpt;\n\t__debugger_sstep = old__debugger_sstep;\n\t__debugger_iabr_match = old__debugger_iabr_match;\n\t__debugger_break_match = old__debugger_break_match;\n\t__debugger_fault_handler = old__debugger_fault_handler;\n}"
  },
  {
    "function_name": "kgdb_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "464-483",
    "snippet": "int kgdb_arch_init(void)\n{\n\told__debugger_ipi = __debugger_ipi;\n\told__debugger = __debugger;\n\told__debugger_bpt = __debugger_bpt;\n\told__debugger_sstep = __debugger_sstep;\n\told__debugger_iabr_match = __debugger_iabr_match;\n\told__debugger_break_match = __debugger_break_match;\n\told__debugger_fault_handler = __debugger_fault_handler;\n\n\t__debugger_ipi = kgdb_call_nmi_hook;\n\t__debugger = kgdb_debugger;\n\t__debugger_bpt = kgdb_handle_breakpoint;\n\t__debugger_sstep = kgdb_singlestep;\n\t__debugger_iabr_match = kgdb_iabr_match;\n\t__debugger_break_match = kgdb_break_match;\n\t__debugger_fault_handler = kgdb_not_implemented;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *old__debugger_ipi;",
      "static void *old__debugger;",
      "static void *old__debugger_bpt;",
      "static void *old__debugger_sstep;",
      "static void *old__debugger_iabr_match;",
      "static void *old__debugger_break_match;",
      "static void *old__debugger_fault_handler;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic void *old__debugger_ipi;\nstatic void *old__debugger;\nstatic void *old__debugger_bpt;\nstatic void *old__debugger_sstep;\nstatic void *old__debugger_iabr_match;\nstatic void *old__debugger_break_match;\nstatic void *old__debugger_fault_handler;\n\nint kgdb_arch_init(void)\n{\n\told__debugger_ipi = __debugger_ipi;\n\told__debugger = __debugger;\n\told__debugger_bpt = __debugger_bpt;\n\told__debugger_sstep = __debugger_sstep;\n\told__debugger_iabr_match = __debugger_iabr_match;\n\told__debugger_break_match = __debugger_break_match;\n\told__debugger_fault_handler = __debugger_fault_handler;\n\n\t__debugger_ipi = kgdb_call_nmi_hook;\n\t__debugger = kgdb_debugger;\n\t__debugger_bpt = kgdb_handle_breakpoint;\n\t__debugger_sstep = kgdb_singlestep;\n\t__debugger_iabr_match = kgdb_iabr_match;\n\t__debugger_break_match = kgdb_break_match;\n\t__debugger_fault_handler = kgdb_not_implemented;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_not_implemented",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "451-454",
    "snippet": "static int kgdb_not_implemented(struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_not_implemented(struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_arch_handle_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "407-442",
    "snippet": "int kgdb_arch_handle_exception(int vector, int signo, int err_code,\n\t\t\t       char *remcom_in_buffer, char *remcom_out_buffer,\n\t\t\t       struct pt_regs *linux_regs)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\n\tswitch (remcom_in_buffer[0]) {\n\t\t/*\n\t\t * sAA..AA   Step one instruction from AA..AA\n\t\t * This will return an error to gdb ..\n\t\t */\n\tcase 's':\n\tcase 'c':\n\t\t/* handle the optional parameter */\n\t\tif (kgdb_hex2long(&ptr, &addr))\n\t\t\tlinux_regs->nip = addr;\n\n\t\tatomic_set(&kgdb_cpu_doing_single_step, -1);\n\t\t/* set the trace bit if we're stepping */\n\t\tif (remcom_in_buffer[0] == 's') {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tmtspr(SPRN_DBCR0,\n\t\t\t      mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);\n\t\t\tlinux_regs->msr |= MSR_DE;\n#else\n\t\t\tlinux_regs->msr |= MSR_SE;\n#endif\n\t\t\tatomic_set(&kgdb_cpu_doing_single_step,\n\t\t\t\t   raw_smp_processor_id());\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_cpu_doing_single_step",
            "raw_smp_processor_id()"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DBCR0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_cpu_doing_single_step",
            "-1"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&addr"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nint kgdb_arch_handle_exception(int vector, int signo, int err_code,\n\t\t\t       char *remcom_in_buffer, char *remcom_out_buffer,\n\t\t\t       struct pt_regs *linux_regs)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\n\tswitch (remcom_in_buffer[0]) {\n\t\t/*\n\t\t * sAA..AA   Step one instruction from AA..AA\n\t\t * This will return an error to gdb ..\n\t\t */\n\tcase 's':\n\tcase 'c':\n\t\t/* handle the optional parameter */\n\t\tif (kgdb_hex2long(&ptr, &addr))\n\t\t\tlinux_regs->nip = addr;\n\n\t\tatomic_set(&kgdb_cpu_doing_single_step, -1);\n\t\t/* set the trace bit if we're stepping */\n\t\tif (remcom_in_buffer[0] == 's') {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tmtspr(SPRN_DBCR0,\n\t\t\t      mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);\n\t\t\tlinux_regs->msr |= MSR_DE;\n#else\n\t\t\tlinux_regs->msr |= MSR_SE;\n#endif\n\t\t\tatomic_set(&kgdb_cpu_doing_single_step,\n\t\t\t\t   raw_smp_processor_id());\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "kgdb_arch_set_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "399-402",
    "snippet": "void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)\n{\n\tregs->nip = pc;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)\n{\n\tregs->nip = pc;\n}"
  },
  {
    "function_name": "dbg_set_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "374-397",
    "snippet": "int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn -EINVAL;\n\n\tif (regno < 32 || regno >= 64)\n\t\t/* First 0 -> 31 gpr registers*/\n\t\t/* pc, msr, ls... registers 64 -> 69 */\n\t\tmemcpy((void *)regs + dbg_reg_def[regno].offset, mem,\n\t\t\t\tdbg_reg_def[regno].size);\n\n\tif (regno >= 32 && regno < 64) {\n\t\t/* FP registers 32 -> 63 */\n#if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)\n\t\tmemcpy(&current->thread.evr[regno-32], mem,\n\t\t\t\tdbg_reg_def[regno].size);\n#else\n\t\t/* fp registers not used by kernel, leave zero */\n\t\treturn 0;\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =\n{\n\t{ \"r0\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[0]) },\n\t{ \"r1\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[1]) },\n\t{ \"r2\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[2]) },\n\t{ \"r3\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[3]) },\n\t{ \"r4\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[4]) },\n\t{ \"r5\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[5]) },\n\t{ \"r6\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[6]) },\n\t{ \"r7\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[7]) },\n\t{ \"r8\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[8]) },\n\t{ \"r9\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[9]) },\n\t{ \"r10\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[10]) },\n\t{ \"r11\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[11]) },\n\t{ \"r12\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[12]) },\n\t{ \"r13\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[13]) },\n\t{ \"r14\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[14]) },\n\t{ \"r15\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[15]) },\n\t{ \"r16\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[16]) },\n\t{ \"r17\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[17]) },\n\t{ \"r18\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[18]) },\n\t{ \"r19\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[19]) },\n\t{ \"r20\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[20]) },\n\t{ \"r21\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[21]) },\n\t{ \"r22\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[22]) },\n\t{ \"r23\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[23]) },\n\t{ \"r24\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[24]) },\n\t{ \"r25\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[25]) },\n\t{ \"r26\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[26]) },\n\t{ \"r27\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[27]) },\n\t{ \"r28\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[28]) },\n\t{ \"r29\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[29]) },\n\t{ \"r30\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[30]) },\n\t{ \"r31\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[31]) },\n\n\t{ \"f0\", GDB_SIZEOF_FLOAT_REG, 0 },\n\t{ \"f1\", GDB_SIZEOF_FLOAT_REG, 1 },\n\t{ \"f2\", GDB_SIZEOF_FLOAT_REG, 2 },\n\t{ \"f3\", GDB_SIZEOF_FLOAT_REG, 3 },\n\t{ \"f4\", GDB_SIZEOF_FLOAT_REG, 4 },\n\t{ \"f5\", GDB_SIZEOF_FLOAT_REG, 5 },\n\t{ \"f6\", GDB_SIZEOF_FLOAT_REG, 6 },\n\t{ \"f7\", GDB_SIZEOF_FLOAT_REG, 7 },\n\t{ \"f8\", GDB_SIZEOF_FLOAT_REG, 8 },\n\t{ \"f9\", GDB_SIZEOF_FLOAT_REG, 9 },\n\t{ \"f10\", GDB_SIZEOF_FLOAT_REG, 10 },\n\t{ \"f11\", GDB_SIZEOF_FLOAT_REG, 11 },\n\t{ \"f12\", GDB_SIZEOF_FLOAT_REG, 12 },\n\t{ \"f13\", GDB_SIZEOF_FLOAT_REG, 13 },\n\t{ \"f14\", GDB_SIZEOF_FLOAT_REG, 14 },\n\t{ \"f15\", GDB_SIZEOF_FLOAT_REG, 15 },\n\t{ \"f16\", GDB_SIZEOF_FLOAT_REG, 16 },\n\t{ \"f17\", GDB_SIZEOF_FLOAT_REG, 17 },\n\t{ \"f18\", GDB_SIZEOF_FLOAT_REG, 18 },\n\t{ \"f19\", GDB_SIZEOF_FLOAT_REG, 19 },\n\t{ \"f20\", GDB_SIZEOF_FLOAT_REG, 20 },\n\t{ \"f21\", GDB_SIZEOF_FLOAT_REG, 21 },\n\t{ \"f22\", GDB_SIZEOF_FLOAT_REG, 22 },\n\t{ \"f23\", GDB_SIZEOF_FLOAT_REG, 23 },\n\t{ \"f24\", GDB_SIZEOF_FLOAT_REG, 24 },\n\t{ \"f25\", GDB_SIZEOF_FLOAT_REG, 25 },\n\t{ \"f26\", GDB_SIZEOF_FLOAT_REG, 26 },\n\t{ \"f27\", GDB_SIZEOF_FLOAT_REG, 27 },\n\t{ \"f28\", GDB_SIZEOF_FLOAT_REG, 28 },\n\t{ \"f29\", GDB_SIZEOF_FLOAT_REG, 29 },\n\t{ \"f30\", GDB_SIZEOF_FLOAT_REG, 30 },\n\t{ \"f31\", GDB_SIZEOF_FLOAT_REG, 31 },\n\n\t{ \"pc\", GDB_SIZEOF_REG, offsetof(struct pt_regs, nip) },\n\t{ \"msr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, msr) },\n\t{ \"cr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ccr) },\n\t{ \"lr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, link) },\n\t{ \"ctr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ctr) },\n\t{ \"xer\", GDB_SIZEOF_REG, offsetof(struct pt_regs, xer) },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&current->thread.evr[regno-32]",
            "mem",
            "dbg_reg_def[regno].size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstruct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =\n{\n\t{ \"r0\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[0]) },\n\t{ \"r1\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[1]) },\n\t{ \"r2\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[2]) },\n\t{ \"r3\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[3]) },\n\t{ \"r4\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[4]) },\n\t{ \"r5\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[5]) },\n\t{ \"r6\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[6]) },\n\t{ \"r7\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[7]) },\n\t{ \"r8\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[8]) },\n\t{ \"r9\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[9]) },\n\t{ \"r10\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[10]) },\n\t{ \"r11\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[11]) },\n\t{ \"r12\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[12]) },\n\t{ \"r13\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[13]) },\n\t{ \"r14\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[14]) },\n\t{ \"r15\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[15]) },\n\t{ \"r16\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[16]) },\n\t{ \"r17\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[17]) },\n\t{ \"r18\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[18]) },\n\t{ \"r19\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[19]) },\n\t{ \"r20\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[20]) },\n\t{ \"r21\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[21]) },\n\t{ \"r22\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[22]) },\n\t{ \"r23\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[23]) },\n\t{ \"r24\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[24]) },\n\t{ \"r25\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[25]) },\n\t{ \"r26\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[26]) },\n\t{ \"r27\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[27]) },\n\t{ \"r28\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[28]) },\n\t{ \"r29\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[29]) },\n\t{ \"r30\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[30]) },\n\t{ \"r31\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[31]) },\n\n\t{ \"f0\", GDB_SIZEOF_FLOAT_REG, 0 },\n\t{ \"f1\", GDB_SIZEOF_FLOAT_REG, 1 },\n\t{ \"f2\", GDB_SIZEOF_FLOAT_REG, 2 },\n\t{ \"f3\", GDB_SIZEOF_FLOAT_REG, 3 },\n\t{ \"f4\", GDB_SIZEOF_FLOAT_REG, 4 },\n\t{ \"f5\", GDB_SIZEOF_FLOAT_REG, 5 },\n\t{ \"f6\", GDB_SIZEOF_FLOAT_REG, 6 },\n\t{ \"f7\", GDB_SIZEOF_FLOAT_REG, 7 },\n\t{ \"f8\", GDB_SIZEOF_FLOAT_REG, 8 },\n\t{ \"f9\", GDB_SIZEOF_FLOAT_REG, 9 },\n\t{ \"f10\", GDB_SIZEOF_FLOAT_REG, 10 },\n\t{ \"f11\", GDB_SIZEOF_FLOAT_REG, 11 },\n\t{ \"f12\", GDB_SIZEOF_FLOAT_REG, 12 },\n\t{ \"f13\", GDB_SIZEOF_FLOAT_REG, 13 },\n\t{ \"f14\", GDB_SIZEOF_FLOAT_REG, 14 },\n\t{ \"f15\", GDB_SIZEOF_FLOAT_REG, 15 },\n\t{ \"f16\", GDB_SIZEOF_FLOAT_REG, 16 },\n\t{ \"f17\", GDB_SIZEOF_FLOAT_REG, 17 },\n\t{ \"f18\", GDB_SIZEOF_FLOAT_REG, 18 },\n\t{ \"f19\", GDB_SIZEOF_FLOAT_REG, 19 },\n\t{ \"f20\", GDB_SIZEOF_FLOAT_REG, 20 },\n\t{ \"f21\", GDB_SIZEOF_FLOAT_REG, 21 },\n\t{ \"f22\", GDB_SIZEOF_FLOAT_REG, 22 },\n\t{ \"f23\", GDB_SIZEOF_FLOAT_REG, 23 },\n\t{ \"f24\", GDB_SIZEOF_FLOAT_REG, 24 },\n\t{ \"f25\", GDB_SIZEOF_FLOAT_REG, 25 },\n\t{ \"f26\", GDB_SIZEOF_FLOAT_REG, 26 },\n\t{ \"f27\", GDB_SIZEOF_FLOAT_REG, 27 },\n\t{ \"f28\", GDB_SIZEOF_FLOAT_REG, 28 },\n\t{ \"f29\", GDB_SIZEOF_FLOAT_REG, 29 },\n\t{ \"f30\", GDB_SIZEOF_FLOAT_REG, 30 },\n\t{ \"f31\", GDB_SIZEOF_FLOAT_REG, 31 },\n\n\t{ \"pc\", GDB_SIZEOF_REG, offsetof(struct pt_regs, nip) },\n\t{ \"msr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, msr) },\n\t{ \"cr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ccr) },\n\t{ \"lr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, link) },\n\t{ \"ctr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ctr) },\n\t{ \"xer\", GDB_SIZEOF_REG, offsetof(struct pt_regs, xer) },\n};\n\nint dbg_set_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn -EINVAL;\n\n\tif (regno < 32 || regno >= 64)\n\t\t/* First 0 -> 31 gpr registers*/\n\t\t/* pc, msr, ls... registers 64 -> 69 */\n\t\tmemcpy((void *)regs + dbg_reg_def[regno].offset, mem,\n\t\t\t\tdbg_reg_def[regno].size);\n\n\tif (regno >= 32 && regno < 64) {\n\t\t/* FP registers 32 -> 63 */\n#if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)\n\t\tmemcpy(&current->thread.evr[regno-32], mem,\n\t\t\t\tdbg_reg_def[regno].size);\n#else\n\t\t/* fp registers not used by kernel, leave zero */\n\t\treturn 0;\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_get_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "348-372",
    "snippet": "char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn NULL;\n\n\tif (regno < 32 || regno >= 64)\n\t\t/* First 0 -> 31 gpr registers*/\n\t\t/* pc, msr, ls... registers 64 -> 69 */\n\t\tmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\n\t\t\t\tdbg_reg_def[regno].size);\n\n\tif (regno >= 32 && regno < 64) {\n\t\t/* FP registers 32 -> 63 */\n#if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)\n\t\tif (current)\n\t\t\tmemcpy(mem, &current->thread.evr[regno-32],\n\t\t\t\t\tdbg_reg_def[regno].size);\n#else\n\t\t/* fp registers not used by kernel, leave zero */\n\t\tmemset(mem, 0, dbg_reg_def[regno].size);\n#endif\n\t}\n\n\treturn dbg_reg_def[regno].name;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =\n{\n\t{ \"r0\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[0]) },\n\t{ \"r1\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[1]) },\n\t{ \"r2\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[2]) },\n\t{ \"r3\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[3]) },\n\t{ \"r4\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[4]) },\n\t{ \"r5\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[5]) },\n\t{ \"r6\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[6]) },\n\t{ \"r7\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[7]) },\n\t{ \"r8\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[8]) },\n\t{ \"r9\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[9]) },\n\t{ \"r10\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[10]) },\n\t{ \"r11\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[11]) },\n\t{ \"r12\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[12]) },\n\t{ \"r13\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[13]) },\n\t{ \"r14\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[14]) },\n\t{ \"r15\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[15]) },\n\t{ \"r16\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[16]) },\n\t{ \"r17\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[17]) },\n\t{ \"r18\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[18]) },\n\t{ \"r19\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[19]) },\n\t{ \"r20\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[20]) },\n\t{ \"r21\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[21]) },\n\t{ \"r22\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[22]) },\n\t{ \"r23\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[23]) },\n\t{ \"r24\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[24]) },\n\t{ \"r25\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[25]) },\n\t{ \"r26\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[26]) },\n\t{ \"r27\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[27]) },\n\t{ \"r28\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[28]) },\n\t{ \"r29\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[29]) },\n\t{ \"r30\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[30]) },\n\t{ \"r31\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[31]) },\n\n\t{ \"f0\", GDB_SIZEOF_FLOAT_REG, 0 },\n\t{ \"f1\", GDB_SIZEOF_FLOAT_REG, 1 },\n\t{ \"f2\", GDB_SIZEOF_FLOAT_REG, 2 },\n\t{ \"f3\", GDB_SIZEOF_FLOAT_REG, 3 },\n\t{ \"f4\", GDB_SIZEOF_FLOAT_REG, 4 },\n\t{ \"f5\", GDB_SIZEOF_FLOAT_REG, 5 },\n\t{ \"f6\", GDB_SIZEOF_FLOAT_REG, 6 },\n\t{ \"f7\", GDB_SIZEOF_FLOAT_REG, 7 },\n\t{ \"f8\", GDB_SIZEOF_FLOAT_REG, 8 },\n\t{ \"f9\", GDB_SIZEOF_FLOAT_REG, 9 },\n\t{ \"f10\", GDB_SIZEOF_FLOAT_REG, 10 },\n\t{ \"f11\", GDB_SIZEOF_FLOAT_REG, 11 },\n\t{ \"f12\", GDB_SIZEOF_FLOAT_REG, 12 },\n\t{ \"f13\", GDB_SIZEOF_FLOAT_REG, 13 },\n\t{ \"f14\", GDB_SIZEOF_FLOAT_REG, 14 },\n\t{ \"f15\", GDB_SIZEOF_FLOAT_REG, 15 },\n\t{ \"f16\", GDB_SIZEOF_FLOAT_REG, 16 },\n\t{ \"f17\", GDB_SIZEOF_FLOAT_REG, 17 },\n\t{ \"f18\", GDB_SIZEOF_FLOAT_REG, 18 },\n\t{ \"f19\", GDB_SIZEOF_FLOAT_REG, 19 },\n\t{ \"f20\", GDB_SIZEOF_FLOAT_REG, 20 },\n\t{ \"f21\", GDB_SIZEOF_FLOAT_REG, 21 },\n\t{ \"f22\", GDB_SIZEOF_FLOAT_REG, 22 },\n\t{ \"f23\", GDB_SIZEOF_FLOAT_REG, 23 },\n\t{ \"f24\", GDB_SIZEOF_FLOAT_REG, 24 },\n\t{ \"f25\", GDB_SIZEOF_FLOAT_REG, 25 },\n\t{ \"f26\", GDB_SIZEOF_FLOAT_REG, 26 },\n\t{ \"f27\", GDB_SIZEOF_FLOAT_REG, 27 },\n\t{ \"f28\", GDB_SIZEOF_FLOAT_REG, 28 },\n\t{ \"f29\", GDB_SIZEOF_FLOAT_REG, 29 },\n\t{ \"f30\", GDB_SIZEOF_FLOAT_REG, 30 },\n\t{ \"f31\", GDB_SIZEOF_FLOAT_REG, 31 },\n\n\t{ \"pc\", GDB_SIZEOF_REG, offsetof(struct pt_regs, nip) },\n\t{ \"msr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, msr) },\n\t{ \"cr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ccr) },\n\t{ \"lr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, link) },\n\t{ \"ctr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ctr) },\n\t{ \"xer\", GDB_SIZEOF_REG, offsetof(struct pt_regs, xer) },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem",
            "0",
            "dbg_reg_def[regno].size"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mem",
            "&current->thread.evr[regno-32]",
            "dbg_reg_def[regno].size"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstruct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =\n{\n\t{ \"r0\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[0]) },\n\t{ \"r1\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[1]) },\n\t{ \"r2\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[2]) },\n\t{ \"r3\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[3]) },\n\t{ \"r4\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[4]) },\n\t{ \"r5\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[5]) },\n\t{ \"r6\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[6]) },\n\t{ \"r7\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[7]) },\n\t{ \"r8\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[8]) },\n\t{ \"r9\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[9]) },\n\t{ \"r10\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[10]) },\n\t{ \"r11\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[11]) },\n\t{ \"r12\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[12]) },\n\t{ \"r13\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[13]) },\n\t{ \"r14\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[14]) },\n\t{ \"r15\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[15]) },\n\t{ \"r16\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[16]) },\n\t{ \"r17\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[17]) },\n\t{ \"r18\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[18]) },\n\t{ \"r19\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[19]) },\n\t{ \"r20\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[20]) },\n\t{ \"r21\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[21]) },\n\t{ \"r22\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[22]) },\n\t{ \"r23\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[23]) },\n\t{ \"r24\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[24]) },\n\t{ \"r25\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[25]) },\n\t{ \"r26\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[26]) },\n\t{ \"r27\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[27]) },\n\t{ \"r28\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[28]) },\n\t{ \"r29\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[29]) },\n\t{ \"r30\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[30]) },\n\t{ \"r31\", GDB_SIZEOF_REG, offsetof(struct pt_regs, gpr[31]) },\n\n\t{ \"f0\", GDB_SIZEOF_FLOAT_REG, 0 },\n\t{ \"f1\", GDB_SIZEOF_FLOAT_REG, 1 },\n\t{ \"f2\", GDB_SIZEOF_FLOAT_REG, 2 },\n\t{ \"f3\", GDB_SIZEOF_FLOAT_REG, 3 },\n\t{ \"f4\", GDB_SIZEOF_FLOAT_REG, 4 },\n\t{ \"f5\", GDB_SIZEOF_FLOAT_REG, 5 },\n\t{ \"f6\", GDB_SIZEOF_FLOAT_REG, 6 },\n\t{ \"f7\", GDB_SIZEOF_FLOAT_REG, 7 },\n\t{ \"f8\", GDB_SIZEOF_FLOAT_REG, 8 },\n\t{ \"f9\", GDB_SIZEOF_FLOAT_REG, 9 },\n\t{ \"f10\", GDB_SIZEOF_FLOAT_REG, 10 },\n\t{ \"f11\", GDB_SIZEOF_FLOAT_REG, 11 },\n\t{ \"f12\", GDB_SIZEOF_FLOAT_REG, 12 },\n\t{ \"f13\", GDB_SIZEOF_FLOAT_REG, 13 },\n\t{ \"f14\", GDB_SIZEOF_FLOAT_REG, 14 },\n\t{ \"f15\", GDB_SIZEOF_FLOAT_REG, 15 },\n\t{ \"f16\", GDB_SIZEOF_FLOAT_REG, 16 },\n\t{ \"f17\", GDB_SIZEOF_FLOAT_REG, 17 },\n\t{ \"f18\", GDB_SIZEOF_FLOAT_REG, 18 },\n\t{ \"f19\", GDB_SIZEOF_FLOAT_REG, 19 },\n\t{ \"f20\", GDB_SIZEOF_FLOAT_REG, 20 },\n\t{ \"f21\", GDB_SIZEOF_FLOAT_REG, 21 },\n\t{ \"f22\", GDB_SIZEOF_FLOAT_REG, 22 },\n\t{ \"f23\", GDB_SIZEOF_FLOAT_REG, 23 },\n\t{ \"f24\", GDB_SIZEOF_FLOAT_REG, 24 },\n\t{ \"f25\", GDB_SIZEOF_FLOAT_REG, 25 },\n\t{ \"f26\", GDB_SIZEOF_FLOAT_REG, 26 },\n\t{ \"f27\", GDB_SIZEOF_FLOAT_REG, 27 },\n\t{ \"f28\", GDB_SIZEOF_FLOAT_REG, 28 },\n\t{ \"f29\", GDB_SIZEOF_FLOAT_REG, 29 },\n\t{ \"f30\", GDB_SIZEOF_FLOAT_REG, 30 },\n\t{ \"f31\", GDB_SIZEOF_FLOAT_REG, 31 },\n\n\t{ \"pc\", GDB_SIZEOF_REG, offsetof(struct pt_regs, nip) },\n\t{ \"msr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, msr) },\n\t{ \"cr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ccr) },\n\t{ \"lr\", GDB_SIZEOF_REG, offsetof(struct pt_regs, link) },\n\t{ \"ctr\", GDB_SIZEOF_REG_U32, offsetof(struct pt_regs, ctr) },\n\t{ \"xer\", GDB_SIZEOF_REG, offsetof(struct pt_regs, xer) },\n};\n\nchar *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn NULL;\n\n\tif (regno < 32 || regno >= 64)\n\t\t/* First 0 -> 31 gpr registers*/\n\t\t/* pc, msr, ls... registers 64 -> 69 */\n\t\tmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\n\t\t\t\tdbg_reg_def[regno].size);\n\n\tif (regno >= 32 && regno < 64) {\n\t\t/* FP registers 32 -> 63 */\n#if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)\n\t\tif (current)\n\t\t\tmemcpy(mem, &current->thread.evr[regno-32],\n\t\t\t\t\tdbg_reg_def[regno].size);\n#else\n\t\t/* fp registers not used by kernel, leave zero */\n\t\tmemset(mem, 0, dbg_reg_def[regno].size);\n#endif\n\t}\n\n\treturn dbg_reg_def[regno].name;\n}"
  },
  {
    "function_name": "sleeping_thread_to_gdb_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "220-261",
    "snippet": "void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)(p->thread.ksp +\n\t\t\t\t\t\t  STACK_FRAME_OVERHEAD);\n\tunsigned long *ptr = gdb_regs;\n\tint reg;\n\n\tmemset(gdb_regs, 0, NUMREGBYTES);\n\n\t/* Regs GPR0-2 */\n\tfor (reg = 0; reg < 3; reg++)\n\t\tPACK64(ptr, regs->gpr[reg]);\n\n\t/* Regs GPR3-13 are caller saved, not in regs->gpr[] */\n\tptr += 11;\n\n\t/* Regs GPR14-31 */\n\tfor (reg = 14; reg < 32; reg++)\n\t\tPACK64(ptr, regs->gpr[reg]);\n\n#ifdef CONFIG_FSL_BOOKE\n#ifdef CONFIG_SPE\n\tfor (reg = 0; reg < 32; reg++)\n\t\tPACK64(ptr, p->thread.evr[reg]);\n#else\n\tptr += 32;\n#endif\n#else\n\t/* fp registers not used by kernel, leave zero */\n\tptr += 32 * 8 / sizeof(long);\n#endif\n\n\tPACK64(ptr, regs->nip);\n\tPACK64(ptr, regs->msr);\n\tPACK32(ptr, regs->ccr);\n\tPACK64(ptr, regs->link);\n\tPACK64(ptr, regs->ctr);\n\tPACK32(ptr, regs->xer);\n\n\tBUG_ON((unsigned long)ptr >\n\t       (unsigned long)(((void *)gdb_regs) + NUMREGBYTES));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(unsigned long)ptr >\n\t       (unsigned long)(((void *)gdb_regs) + NUMREGBYTES)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK32",
          "args": [
            "ptr",
            "regs->xer"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->ctr"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->link"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK32",
          "args": [
            "ptr",
            "regs->ccr"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->msr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->nip"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "p->thread.evr[reg]"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->gpr[reg]"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK64",
          "args": [
            "ptr",
            "regs->gpr[reg]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gdb_regs",
            "0",
            "NUMREGBYTES"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)(p->thread.ksp +\n\t\t\t\t\t\t  STACK_FRAME_OVERHEAD);\n\tunsigned long *ptr = gdb_regs;\n\tint reg;\n\n\tmemset(gdb_regs, 0, NUMREGBYTES);\n\n\t/* Regs GPR0-2 */\n\tfor (reg = 0; reg < 3; reg++)\n\t\tPACK64(ptr, regs->gpr[reg]);\n\n\t/* Regs GPR3-13 are caller saved, not in regs->gpr[] */\n\tptr += 11;\n\n\t/* Regs GPR14-31 */\n\tfor (reg = 14; reg < 32; reg++)\n\t\tPACK64(ptr, regs->gpr[reg]);\n\n#ifdef CONFIG_FSL_BOOKE\n#ifdef CONFIG_SPE\n\tfor (reg = 0; reg < 32; reg++)\n\t\tPACK64(ptr, p->thread.evr[reg]);\n#else\n\tptr += 32;\n#endif\n#else\n\t/* fp registers not used by kernel, leave zero */\n\tptr += 32 * 8 / sizeof(long);\n#endif\n\n\tPACK64(ptr, regs->nip);\n\tPACK64(ptr, regs->msr);\n\tPACK32(ptr, regs->ccr);\n\tPACK64(ptr, regs->link);\n\tPACK64(ptr, regs->ctr);\n\tPACK32(ptr, regs->xer);\n\n\tBUG_ON((unsigned long)ptr >\n\t       (unsigned long)(((void *)gdb_regs) + NUMREGBYTES));\n}"
  },
  {
    "function_name": "kgdb_break_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "201-209",
    "snippet": "static int kgdb_break_match(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(0, computeSignal(TRAP(regs)), 0, regs) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_handle_exception",
          "args": [
            "0",
            "computeSignal(TRAP(regs))",
            "0",
            "regs"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "computeSignal",
          "args": [
            "TRAP(regs)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "computeSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "93-102",
          "snippet": "static int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};\n\nstatic int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_break_match(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(0, computeSignal(TRAP(regs)), 0, regs) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_iabr_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "191-199",
    "snippet": "static int kgdb_iabr_match(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(0, computeSignal(TRAP(regs)), 0, regs) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_handle_exception",
          "args": [
            "0",
            "computeSignal(TRAP(regs))",
            "0",
            "regs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "computeSignal",
          "args": [
            "TRAP(regs)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "computeSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "93-102",
          "snippet": "static int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};\n\nstatic int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_iabr_match(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(0, computeSignal(TRAP(regs)), 0, regs) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_singlestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "154-189",
    "snippet": "static int kgdb_singlestep(struct pt_regs *regs)\n{\n\tstruct thread_info *thread_info, *exception_thread_info;\n\tstruct thread_info *backup_current_thread_info =\n\t\tthis_cpu_ptr(&kgdb_thread_info);\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\t/*\n\t * On Book E and perhaps other processors, singlestep is handled on\n\t * the critical exception stack.  This causes current_thread_info()\n\t * to fail, since it it locates the thread_info by masking off\n\t * the low bits of the current stack pointer.  We work around\n\t * this issue by copying the thread_info from the kernel stack\n\t * before calling kgdb_handle_exception, and copying it back\n\t * afterwards.  On most processors the copy is avoided since\n\t * exception_thread_info == thread_info.\n\t */\n\tthread_info = (struct thread_info *)(regs->gpr[1] & ~(THREAD_SIZE-1));\n\texception_thread_info = current_thread_info();\n\n\tif (thread_info != exception_thread_info) {\n\t\t/* Save the original current_thread_info. */\n\t\tmemcpy(backup_current_thread_info, exception_thread_info, sizeof *thread_info);\n\t\tmemcpy(exception_thread_info, thread_info, sizeof *thread_info);\n\t}\n\n\tkgdb_handle_exception(0, SIGTRAP, 0, regs);\n\n\tif (thread_info != exception_thread_info)\n\t\t/* Restore current_thread_info lastly. */\n\t\tmemcpy(exception_thread_info, backup_current_thread_info, sizeof *thread_info);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct thread_info, kgdb_thread_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "exception_thread_info",
            "backup_current_thread_info",
            "sizeof *thread_info"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_handle_exception",
          "args": [
            "0",
            "SIGTRAP",
            "0",
            "regs"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&kgdb_thread_info"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct thread_info, kgdb_thread_info);\n\nstatic int kgdb_singlestep(struct pt_regs *regs)\n{\n\tstruct thread_info *thread_info, *exception_thread_info;\n\tstruct thread_info *backup_current_thread_info =\n\t\tthis_cpu_ptr(&kgdb_thread_info);\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\t/*\n\t * On Book E and perhaps other processors, singlestep is handled on\n\t * the critical exception stack.  This causes current_thread_info()\n\t * to fail, since it it locates the thread_info by masking off\n\t * the low bits of the current stack pointer.  We work around\n\t * this issue by copying the thread_info from the kernel stack\n\t * before calling kgdb_handle_exception, and copying it back\n\t * afterwards.  On most processors the copy is avoided since\n\t * exception_thread_info == thread_info.\n\t */\n\tthread_info = (struct thread_info *)(regs->gpr[1] & ~(THREAD_SIZE-1));\n\texception_thread_info = current_thread_info();\n\n\tif (thread_info != exception_thread_info) {\n\t\t/* Save the original current_thread_info. */\n\t\tmemcpy(backup_current_thread_info, exception_thread_info, sizeof *thread_info);\n\t\tmemcpy(exception_thread_info, thread_info, sizeof *thread_info);\n\t}\n\n\tkgdb_handle_exception(0, SIGTRAP, 0, regs);\n\n\tif (thread_info != exception_thread_info)\n\t\t/* Restore current_thread_info lastly. */\n\t\tmemcpy(exception_thread_info, backup_current_thread_info, sizeof *thread_info);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_handle_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "139-151",
    "snippet": "static int kgdb_handle_breakpoint(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(1, SIGTRAP, 0, regs) != 0)\n\t\treturn 0;\n\n\tif (*(u32 *) (regs->nip) == *(u32 *) (&arch_kgdb_ops.gdb_bpt_instr))\n\t\tregs->nip += BREAK_INSTR_SIZE;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kgdb_arch arch_kgdb_ops = {\n\t.gdb_bpt_instr = {0x7d, 0x82, 0x10, 0x08},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_handle_exception",
          "args": [
            "1",
            "SIGTRAP",
            "0",
            "regs"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstruct kgdb_arch arch_kgdb_ops = {\n\t.gdb_bpt_instr = {0x7d, 0x82, 0x10, 0x08},\n};\n\nstatic int kgdb_handle_breakpoint(struct pt_regs *regs)\n{\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (kgdb_handle_exception(1, SIGTRAP, 0, regs) != 0)\n\t\treturn 0;\n\n\tif (*(u32 *) (regs->nip) == *(u32 *) (&arch_kgdb_ops.gdb_bpt_instr))\n\t\tregs->nip += BREAK_INSTR_SIZE;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_debugger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "133-137",
    "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_handle_exception",
          "args": [
            "1",
            "computeSignal(TRAP(regs))",
            "DIE_OOPS",
            "regs"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "computeSignal",
          "args": [
            "TRAP(regs)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "computeSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "93-102",
          "snippet": "static int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};\n\nstatic int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
  },
  {
    "function_name": "kgdb_roundup_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "126-129",
    "snippet": "void kgdb_roundup_cpus(unsigned long flags)\n{\n\tsmp_send_debugger_break();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_send_debugger_break",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "smp_send_debugger_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp.c",
          "lines": "308-319",
          "snippet": "void smp_send_debugger_break(void)\n{\n\tint cpu;\n\tint me = raw_smp_processor_id();\n\n\tif (unlikely(!smp_ops))\n\t\treturn;\n\n\tfor_each_online_cpu(cpu)\n\t\tif (cpu != me)\n\t\t\tdo_message_pass(cpu, PPC_MSG_DEBUGGER_BREAK);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smp_ops_t *smp_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct smp_ops_t *smp_ops;\n\nvoid smp_send_debugger_break(void)\n{\n\tint cpu;\n\tint me = raw_smp_processor_id();\n\n\tif (unlikely(!smp_ops))\n\t\treturn;\n\n\tfor_each_online_cpu(cpu)\n\t\tif (cpu != me)\n\t\t\tdo_message_pass(cpu, PPC_MSG_DEBUGGER_BREAK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nvoid kgdb_roundup_cpus(unsigned long flags)\n{\n\tsmp_send_debugger_break();\n}"
  },
  {
    "function_name": "kgdb_call_nmi_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "119-123",
    "snippet": "static int kgdb_call_nmi_hook(struct pt_regs *regs)\n{\n\tkgdb_nmicallback(raw_smp_processor_id(), regs);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_nmicallback",
          "args": [
            "raw_smp_processor_id()",
            "regs"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_call_nmi_hook(struct pt_regs *regs)\n{\n\tkgdb_nmicallback(raw_smp_processor_id(), regs);\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_skipexception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "114-117",
    "snippet": "int kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn kgdb_isremovedbreak(regs->nip);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_isremovedbreak",
          "args": [
            "regs->nip"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nint kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn kgdb_isremovedbreak(regs->nip);\n}"
  },
  {
    "function_name": "computeSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
    "lines": "93-102",
    "snippet": "static int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <asm/debug.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <asm/current.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/signal.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic struct hard_trap_info\n{\n\tunsigned int tt;\t\t/* Trap type code for powerpc */\n\tunsigned char signo;\t\t/* Signal that we map this trap into */\n} hard_trap_info[] = {\n\t{ 0x0100, 0x02 /* SIGINT */  },\t\t/* system reset */\n\t{ 0x0200, 0x0b /* SIGSEGV */ },\t\t/* machine check */\n\t{ 0x0300, 0x0b /* SIGSEGV */ },\t\t/* data access */\n\t{ 0x0400, 0x0b /* SIGSEGV */ },\t\t/* instruction access */\n\t{ 0x0500, 0x02 /* SIGINT */  },\t\t/* external interrupt */\n\t{ 0x0600, 0x0a /* SIGBUS */  },\t\t/* alignment */\n\t{ 0x0700, 0x05 /* SIGTRAP */ },\t\t/* program check */\n\t{ 0x0800, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x0900, 0x0e /* SIGALRM */ },\t\t/* decrementer */\n\t{ 0x0c00, 0x14 /* SIGCHLD */ },\t\t/* system call */\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\t{ 0x2002, 0x05 /* SIGTRAP */ },\t\t/* debug */\n#if defined(CONFIG_FSL_BOOKE)\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* spe unavailable */\n\t{ 0x2030, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2040, 0x08 /* SIGFPE */  },\t\t/* spe fp data */\n\t{ 0x2050, 0x08 /* SIGFPE */  },\t\t/* spe fp round */\n\t{ 0x2060, 0x0e /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x2900, 0x08 /* SIGFPE */  },\t\t/* apu unavailable */\n\t{ 0x3100, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x3200, 0x02 /* SIGINT */  }, \t/* watchdog */\n#else /* ! CONFIG_FSL_BOOKE */\n\t{ 0x1000, 0x0e /* SIGALRM */ },\t\t/* prog interval timer */\n\t{ 0x1010, 0x0e /* SIGALRM */ },\t\t/* fixed interval timer */\n\t{ 0x1020, 0x02 /* SIGINT */  }, \t/* watchdog */\n\t{ 0x2010, 0x08 /* SIGFPE */  },\t\t/* fp unavailable */\n\t{ 0x2020, 0x08 /* SIGFPE */  },\t\t/* ap unavailable */\n#endif\n#else /* ! (defined(CONFIG_40x) || defined(CONFIG_BOOKE)) */\n\t{ 0x0d00, 0x05 /* SIGTRAP */ },\t\t/* single-step */\n#if defined(CONFIG_8xx)\n\t{ 0x1000, 0x04 /* SIGILL */  },\t\t/* software emulation */\n#else /* ! CONFIG_8xx */\n\t{ 0x0f00, 0x04 /* SIGILL */  },\t\t/* performance monitor */\n\t{ 0x0f20, 0x08 /* SIGFPE */  },\t\t/* altivec unavailable */\n\t{ 0x1300, 0x05 /* SIGTRAP */ }, \t/* instruction address break */\n#if defined(CONFIG_PPC64)\n\t{ 0x1200, 0x05 /* SIGILL */  },\t\t/* system error */\n\t{ 0x1500, 0x04 /* SIGILL */  },\t\t/* soft patch */\n\t{ 0x1600, 0x04 /* SIGILL */  },\t\t/* maintenance */\n\t{ 0x1700, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1800, 0x04 /* SIGILL */  },\t\t/* thermal */\n#else /* ! CONFIG_PPC64 */\n\t{ 0x1400, 0x02 /* SIGINT */  },\t\t/* SMI */\n\t{ 0x1600, 0x08 /* SIGFPE */  },\t\t/* altivec assist */\n\t{ 0x1700, 0x04 /* SIGILL */  },\t\t/* TAU */\n\t{ 0x2000, 0x05 /* SIGTRAP */ },\t\t/* run mode */\n#endif\n#endif\n#endif\n\t{ 0x0000, 0x00 }\t\t\t/* Must be last */\n};\n\nstatic int computeSignal(unsigned int tt)\n{\n\tstruct hard_trap_info *ht;\n\n\tfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\n\t\tif (ht->tt == tt)\n\t\t\treturn ht->signo;\n\n\treturn SIGHUP;\t\t/* default for things we don't know about */\n}"
  }
]