[
  {
    "function_name": "dma_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "367-378",
    "snippet": "static int __init dma_init(void)\n{\n\tdma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\n#ifdef CONFIG_PCI\n\tdma_debug_add_bus(&pci_bus_type);\n#endif\n#ifdef CONFIG_IBMVIO\n\tdma_debug_add_bus(&vio_bus_type);\n#endif\n\n       return 0;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_debug_add_bus",
          "args": [
            "&vio_bus_type"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_add_bus",
          "args": [
            "&pci_bus_type"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_init",
          "args": [
            "PREALLOC_DMA_DEBUG_ENTRIES"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\n#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)\n\nstatic int __init dma_init(void)\n{\n\tdma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\n#ifdef CONFIG_PCI\n\tdma_debug_add_bus(&pci_bus_type);\n#endif\n#ifdef CONFIG_IBMVIO\n\tdma_debug_add_bus(&vio_bus_type);\n#endif\n\n       return 0;\n}"
  },
  {
    "function_name": "dma_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "351-364",
    "snippet": "u64 dma_get_required_mask(struct device *dev)\n{\n\tif (ppc_md.dma_get_required_mask)\n\t\treturn ppc_md.dma_get_required_mask(dev);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_get_required_mask)\n\t\t\treturn phb->controller_ops.dma_get_required_mask(pdev);\n\t}\n\n\treturn __dma_get_required_mask(dev);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_get_required_mask",
          "args": [
            "dev"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_get_required_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "338-349",
          "snippet": "u64 __dma_get_required_mask(struct device *dev)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif (unlikely(dma_ops == NULL))\n\t\treturn 0;\n\n\tif (dma_ops->get_required_mask)\n\t\treturn dma_ops->get_required_mask(dev);\n\n\treturn DMA_BIT_MASK(8 * sizeof(dma_addr_t));\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nu64 __dma_get_required_mask(struct device *dev)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif (unlikely(dma_ops == NULL))\n\t\treturn 0;\n\n\tif (dma_ops->get_required_mask)\n\t\treturn dma_ops->get_required_mask(dev);\n\n\treturn DMA_BIT_MASK(8 * sizeof(dma_addr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_get_required_mask",
          "args": [
            "pdev"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "dma_get_required_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "351-364",
          "snippet": "u64 dma_get_required_mask(struct device *dev)\n{\n\tif (ppc_md.dma_get_required_mask)\n\t\treturn ppc_md.dma_get_required_mask(dev);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_get_required_mask)\n\t\t\treturn phb->controller_ops.dma_get_required_mask(pdev);\n\t}\n\n\treturn __dma_get_required_mask(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_pci",
          "args": [
            "dev"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nu64 dma_get_required_mask(struct device *dev)\n{\n\tif (ppc_md.dma_get_required_mask)\n\t\treturn ppc_md.dma_get_required_mask(dev);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_get_required_mask)\n\t\t\treturn phb->controller_ops.dma_get_required_mask(pdev);\n\t}\n\n\treturn __dma_get_required_mask(dev);\n}"
  },
  {
    "function_name": "__dma_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "338-349",
    "snippet": "u64 __dma_get_required_mask(struct device *dev)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif (unlikely(dma_ops == NULL))\n\t\treturn 0;\n\n\tif (dma_ops->get_required_mask)\n\t\treturn dma_ops->get_required_mask(dev);\n\n\treturn DMA_BIT_MASK(8 * sizeof(dma_addr_t));\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "8 * sizeof(dma_addr_t)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_ops->get_required_mask",
          "args": [
            "dev"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_ops == NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nu64 __dma_get_required_mask(struct device *dev)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif (unlikely(dma_ops == NULL))\n\t\treturn 0;\n\n\tif (dma_ops->get_required_mask)\n\t\treturn dma_ops->get_required_mask(dev);\n\n\treturn DMA_BIT_MASK(8 * sizeof(dma_addr_t));\n}"
  },
  {
    "function_name": "dma_set_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "322-335",
    "snippet": "int dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tif (ppc_md.dma_set_mask)\n\t\treturn ppc_md.dma_set_mask(dev, dma_mask);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_set_mask)\n\t\t\treturn phb->controller_ops.dma_set_mask(pdev, dma_mask);\n\t}\n\n\treturn __dma_set_mask(dev, dma_mask);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_set_mask",
          "args": [
            "dev",
            "dma_mask"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_set_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "310-320",
          "snippet": "int __dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif ((dma_ops != NULL) && (dma_ops->set_dma_mask != NULL))\n\t\treturn dma_ops->set_dma_mask(dev, dma_mask);\n\tif (!dev->dma_mask || !dma_supported(dev, dma_mask))\n\t\treturn -EIO;\n\t*dev->dma_mask = dma_mask;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nint __dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif ((dma_ops != NULL) && (dma_ops->set_dma_mask != NULL))\n\t\treturn dma_ops->set_dma_mask(dev, dma_mask);\n\tif (!dev->dma_mask || !dma_supported(dev, dma_mask))\n\t\treturn -EIO;\n\t*dev->dma_mask = dma_mask;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_set_mask",
          "args": [
            "pdev",
            "dma_mask"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "322-335",
          "snippet": "int dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tif (ppc_md.dma_set_mask)\n\t\treturn ppc_md.dma_set_mask(dev, dma_mask);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_set_mask)\n\t\t\treturn phb->controller_ops.dma_set_mask(pdev, dma_mask);\n\t}\n\n\treturn __dma_set_mask(dev, dma_mask);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_pci",
          "args": [
            "dev"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nint dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tif (ppc_md.dma_set_mask)\n\t\treturn ppc_md.dma_set_mask(dev, dma_mask);\n\n\tif (dev_is_pci(dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev);\n\t\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\t\tif (phb->controller_ops.dma_set_mask)\n\t\t\treturn phb->controller_ops.dma_set_mask(pdev, dma_mask);\n\t}\n\n\treturn __dma_set_mask(dev, dma_mask);\n}"
  },
  {
    "function_name": "__dma_set_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "310-320",
    "snippet": "int __dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif ((dma_ops != NULL) && (dma_ops->set_dma_mask != NULL))\n\t\treturn dma_ops->set_dma_mask(dev, dma_mask);\n\tif (!dev->dma_mask || !dma_supported(dev, dma_mask))\n\t\treturn -EIO;\n\t*dev->dma_mask = dma_mask;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_supported",
          "args": [
            "dev",
            "dma_mask"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_dma_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "43-63",
          "snippet": "static int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_ops->set_dma_mask",
          "args": [
            "dev",
            "dma_mask"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nint __dma_set_mask(struct device *dev, u64 dma_mask)\n{\n\tstruct dma_map_ops *dma_ops = get_dma_ops(dev);\n\n\tif ((dma_ops != NULL) && (dma_ops->set_dma_mask != NULL))\n\t\treturn dma_ops->set_dma_mask(dev, dma_mask);\n\tif (!dev->dma_mask || !dma_supported(dev, dma_mask))\n\t\treturn -EIO;\n\t*dev->dma_mask = dma_mask;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_set_coherent_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "289-305",
    "snippet": "int dma_set_coherent_mask(struct device *dev, u64 mask)\n{\n\tif (!dma_supported(dev, mask)) {\n\t\t/*\n\t\t * We need to special case the direct DMA ops which can\n\t\t * support a fallback for coherent allocations. There\n\t\t * is no dma_op->set_coherent_mask() so we have to do\n\t\t * things the hard way:\n\t\t */\n\t\tif (get_dma_ops(dev) != &dma_direct_ops ||\n\t\t    get_iommu_table_base(dev) == NULL ||\n\t\t    !dma_iommu_dma_supported(dev, mask))\n\t\t\treturn -EIO;\n\t}\n\tdev->coherent_dma_mask = mask;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dma_map_ops dma_direct_ops = {\n\t.alloc\t\t\t\t= dma_direct_alloc_coherent,\n\t.free\t\t\t\t= dma_direct_free_coherent,\n\t.mmap\t\t\t\t= dma_direct_mmap_coherent,\n\t.map_sg\t\t\t\t= dma_direct_map_sg,\n\t.unmap_sg\t\t\t= dma_direct_unmap_sg,\n\t.dma_supported\t\t\t= dma_direct_dma_supported,\n\t.map_page\t\t\t= dma_direct_map_page,\n\t.unmap_page\t\t\t= dma_direct_unmap_page,\n\t.get_required_mask\t\t= dma_direct_get_required_mask,\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t.sync_single_for_cpu \t\t= dma_direct_sync_single,\n\t.sync_single_for_device \t= dma_direct_sync_single,\n\t.sync_sg_for_cpu \t\t= dma_direct_sync_sg,\n\t.sync_sg_for_device \t\t= dma_direct_sync_sg,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_iommu_dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "vio_dma_iommu_dma_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "608-611",
          "snippet": "static int vio_dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n        return dma_iommu_ops.dma_supported(dev, mask);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n        return dma_iommu_ops.dma_supported(dev, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_dma_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "43-63",
          "snippet": "static int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstruct dma_map_ops dma_direct_ops = {\n\t.alloc\t\t\t\t= dma_direct_alloc_coherent,\n\t.free\t\t\t\t= dma_direct_free_coherent,\n\t.mmap\t\t\t\t= dma_direct_mmap_coherent,\n\t.map_sg\t\t\t\t= dma_direct_map_sg,\n\t.unmap_sg\t\t\t= dma_direct_unmap_sg,\n\t.dma_supported\t\t\t= dma_direct_dma_supported,\n\t.map_page\t\t\t= dma_direct_map_page,\n\t.unmap_page\t\t\t= dma_direct_unmap_page,\n\t.get_required_mask\t\t= dma_direct_get_required_mask,\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t.sync_single_for_cpu \t\t= dma_direct_sync_single,\n\t.sync_single_for_device \t= dma_direct_sync_single,\n\t.sync_sg_for_cpu \t\t= dma_direct_sync_sg,\n\t.sync_sg_for_device \t\t= dma_direct_sync_sg,\n#endif\n};\n\nint dma_set_coherent_mask(struct device *dev, u64 mask)\n{\n\tif (!dma_supported(dev, mask)) {\n\t\t/*\n\t\t * We need to special case the direct DMA ops which can\n\t\t * support a fallback for coherent allocations. There\n\t\t * is no dma_op->set_coherent_mask() so we have to do\n\t\t * things the hard way:\n\t\t */\n\t\tif (get_dma_ops(dev) != &dma_direct_ops ||\n\t\t    get_iommu_table_base(dev) == NULL ||\n\t\t    !dma_iommu_dma_supported(dev, mask))\n\t\t\treturn -EIO;\n\t}\n\tdev->coherent_dma_mask = mask;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_direct_sync_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "262-267",
    "snippet": "static inline void dma_direct_sync_single(struct device *dev,\n\t\t\t\t\t  dma_addr_t dma_handle, size_t size,\n\t\t\t\t\t  enum dma_data_direction direction)\n{\n\t__dma_sync(bus_to_virt(dma_handle), size, direction);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_sync",
          "args": [
            "bus_to_virt(dma_handle)",
            "size",
            "direction"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_to_virt",
          "args": [
            "dma_handle"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline void dma_direct_sync_single(struct device *dev,\n\t\t\t\t\t  dma_addr_t dma_handle, size_t size,\n\t\t\t\t\t  enum dma_data_direction direction)\n{\n\t__dma_sync(bus_to_virt(dma_handle), size, direction);\n}"
  },
  {
    "function_name": "dma_direct_sync_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "251-260",
    "snippet": "static inline void dma_direct_sync_sg(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction direction)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\t__dma_sync_page(sg_page(sg), sg->offset, sg->length, direction);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_sync_page",
          "args": [
            "sg_page(sg)",
            "sg->offset",
            "sg->length",
            "direction"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sg"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline void dma_direct_sync_sg(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction direction)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\t__dma_sync_page(sg_page(sg), sg->offset, sg->length, direction);\n}"
  },
  {
    "function_name": "dma_direct_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "242-248",
    "snippet": "static inline void dma_direct_unmap_page(struct device *dev,\n\t\t\t\t\t dma_addr_t dma_address,\n\t\t\t\t\t size_t size,\n\t\t\t\t\t enum dma_data_direction direction,\n\t\t\t\t\t struct dma_attrs *attrs)\n{\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline void dma_direct_unmap_page(struct device *dev,\n\t\t\t\t\t dma_addr_t dma_address,\n\t\t\t\t\t size_t size,\n\t\t\t\t\t enum dma_data_direction direction,\n\t\t\t\t\t struct dma_attrs *attrs)\n{\n}"
  },
  {
    "function_name": "dma_direct_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "230-240",
    "snippet": "static inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\t\t\t\t     struct page *page,\n\t\t\t\t\t     unsigned long offset,\n\t\t\t\t\t     size_t size,\n\t\t\t\t\t     enum dma_data_direction dir,\n\t\t\t\t\t     struct dma_attrs *attrs)\n{\n\tBUG_ON(dir == DMA_NONE);\n\t__dma_sync_page(page, offset, size, dir);\n\treturn page_to_phys(page) + offset + get_dma_offset(dev);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_sync_page",
          "args": [
            "page",
            "offset",
            "size",
            "dir"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir == DMA_NONE"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\t\t\t\t     struct page *page,\n\t\t\t\t\t     unsigned long offset,\n\t\t\t\t\t     size_t size,\n\t\t\t\t\t     enum dma_data_direction dir,\n\t\t\t\t\t     struct dma_attrs *attrs)\n{\n\tBUG_ON(dir == DMA_NONE);\n\t__dma_sync_page(page, offset, size, dir);\n\treturn page_to_phys(page) + offset + get_dma_offset(dev);\n}"
  },
  {
    "function_name": "dma_direct_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "218-228",
    "snippet": "static u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tu64 end, mask;\n\n\tend = memblock_end_of_DRAM() + get_dma_offset(dev);\n\n\tmask = 1ULL << (fls64(end) - 1);\n\tmask += mask - 1;\n\n\treturn mask;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "end"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tu64 end, mask;\n\n\tend = memblock_end_of_DRAM() + get_dma_offset(dev);\n\n\tmask = 1ULL << (fls64(end) - 1);\n\tmask += mask - 1;\n\n\treturn mask;\n}"
  },
  {
    "function_name": "dma_direct_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "212-216",
    "snippet": "static void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\tint nents, enum dma_data_direction direction,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\tint nents, enum dma_data_direction direction,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n}"
  },
  {
    "function_name": "dma_direct_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "196-210",
    "snippet": "static int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl,\n\t\t\t     int nents, enum dma_data_direction direction,\n\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = sg_phys(sg) + get_dma_offset(dev);\n\t\tsg->dma_length = sg->length;\n\t\t__dma_sync_page(sg_page(sg), sg->offset, sg->length, direction);\n\t}\n\n\treturn nents;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_sync_page",
          "args": [
            "sg_page(sg)",
            "sg->offset",
            "sg->length",
            "direction"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_phys",
          "args": [
            "sg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl,\n\t\t\t     int nents, enum dma_data_direction direction,\n\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = sg_phys(sg) + get_dma_offset(dev);\n\t\tsg->dma_length = sg->length;\n\t\t__dma_sync_page(sg_page(sg), sg->offset, sg->length, direction);\n\t}\n\n\treturn nents;\n}"
  },
  {
    "function_name": "dma_direct_mmap_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "178-194",
    "snippet": "int dma_direct_mmap_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t     void *cpu_addr, dma_addr_t handle, size_t size,\n\t\t\t     struct dma_attrs *attrs)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpfn = __dma_get_coherent_pfn((unsigned long)cpu_addr);\n#else\n\tpfn = page_to_pfn(virt_to_page(cpu_addr));\n#endif\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       pfn + vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "pfn + vma->vm_pgoff",
            "vma->vm_end - vma->vm_start",
            "vma->vm_page_prot"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(cpu_addr)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_get_coherent_pfn",
          "args": [
            "(unsigned long)cpu_addr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nint dma_direct_mmap_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t     void *cpu_addr, dma_addr_t handle, size_t size,\n\t\t\t     struct dma_attrs *attrs)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpfn = __dma_get_coherent_pfn((unsigned long)cpu_addr);\n#else\n\tpfn = page_to_pfn(virt_to_page(cpu_addr));\n#endif\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       pfn + vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}"
  },
  {
    "function_name": "dma_direct_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "157-176",
    "snippet": "static void dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\t     void *vaddr, dma_addr_t dma_handle,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct iommu_table *iommu;\n\n\t/* See comments in dma_direct_alloc_coherent() */\n\tif (dma_direct_dma_supported(dev, dev->coherent_dma_mask))\n\t\treturn __dma_direct_free_coherent(dev, size, vaddr, dma_handle,\n\t\t\t\t\t\t  attrs);\n\t/* Maybe we used an iommu ... */\n\tiommu = get_iommu_table_base(dev);\n\n\t/* If we hit that we should have never allocated in the first\n\t * place so how come we are freeing ?\n\t */\n\tif (WARN_ON(!iommu))\n\t\treturn;\n\tiommu_free_coherent(iommu, size, vaddr, dma_handle);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_free_coherent",
          "args": [
            "iommu",
            "size",
            "vaddr",
            "dma_handle"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "857-869",
          "snippet": "void iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!iommu"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_free_coherent",
          "args": [
            "dev",
            "size",
            "vaddr",
            "dma_handle",
            "attrs"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_free_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "122-131",
          "snippet": "void __dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t__dma_free_coherent(size, vaddr);\n#else\n\tfree_pages((unsigned long)vaddr, get_order(size));\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nvoid __dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t__dma_free_coherent(size, vaddr);\n#else\n\tfree_pages((unsigned long)vaddr, get_order(size));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_dma_supported",
          "args": [
            "dev",
            "dev->coherent_dma_mask"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_dma_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "43-63",
          "snippet": "static int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\t     void *vaddr, dma_addr_t dma_handle,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct iommu_table *iommu;\n\n\t/* See comments in dma_direct_alloc_coherent() */\n\tif (dma_direct_dma_supported(dev, dev->coherent_dma_mask))\n\t\treturn __dma_direct_free_coherent(dev, size, vaddr, dma_handle,\n\t\t\t\t\t\t  attrs);\n\t/* Maybe we used an iommu ... */\n\tiommu = get_iommu_table_base(dev);\n\n\t/* If we hit that we should have never allocated in the first\n\t * place so how come we are freeing ?\n\t */\n\tif (WARN_ON(!iommu))\n\t\treturn;\n\tiommu_free_coherent(iommu, size, vaddr, dma_handle);\n}"
  },
  {
    "function_name": "dma_direct_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "133-155",
    "snippet": "static void *dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t       dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t       struct dma_attrs *attrs)\n{\n\tstruct iommu_table *iommu;\n\n\t/* The coherent mask may be smaller than the real mask, check if\n\t * we can really use the direct ops\n\t */\n\tif (dma_direct_dma_supported(dev, dev->coherent_dma_mask))\n\t\treturn __dma_direct_alloc_coherent(dev, size, dma_handle,\n\t\t\t\t\t\t   flag, attrs);\n\n\t/* Ok we can't ... do we have an iommu ? If not, fail */\n\tiommu = get_iommu_table_base(dev);\n\tif (!iommu)\n\t\treturn NULL;\n\n\t/* Try to use the iommu */\n\treturn iommu_alloc_coherent(dev, iommu, size, dma_handle,\n\t\t\t\t    dev->coherent_dma_mask, flag,\n\t\t\t\t    dev_to_node(dev));\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_alloc_coherent",
          "args": [
            "dev",
            "iommu",
            "size",
            "dma_handle",
            "dev->coherent_dma_mask",
            "flag",
            "dev_to_node(dev)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "810-855",
          "snippet": "void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_alloc_coherent",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "flag",
            "attrs"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_alloc_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "65-120",
          "snippet": "void *__dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tvoid *ret;\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tret = __dma_alloc_coherent(dev, size, dma_handle, flag);\n\tif (ret == NULL)\n\t\treturn NULL;\n\t*dma_handle += get_dma_offset(dev);\n\treturn ret;\n#else\n\tstruct page *page;\n\tint node = dev_to_node(dev);\n#ifdef CONFIG_FSL_SOC\n\tu64 pfn = get_pfn_limit(dev);\n\tint zone;\n\n\t/*\n\t * This code should be OK on other platforms, but we have drivers that\n\t * don't set coherent_dma_mask. As a workaround we just ifdef it. This\n\t * whole routine needs some serious cleanup.\n\t */\n\n\tzone = dma_pfn_limit_to_zone(pfn);\n\tif (zone < 0) {\n\t\tdev_err(dev, \"%s: No suitable zone for pfn %#llx\\n\",\n\t\t\t__func__, pfn);\n\t\treturn NULL;\n\t}\n\n\tswitch (zone) {\n\tcase ZONE_DMA:\n\t\tflag |= GFP_DMA;\n\t\tbreak;\n#ifdef CONFIG_ZONE_DMA32\n\tcase ZONE_DMA32:\n\t\tflag |= GFP_DMA32;\n\t\tbreak;\n#endif\n\t};\n#endif /* CONFIG_FSL_SOC */\n\n\t/* ignore region specifiers */\n\tflag  &= ~(__GFP_HIGHMEM);\n\n\tpage = alloc_pages_node(node, flag, get_order(size));\n\tif (page == NULL)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\t*dma_handle = __pa(ret) + get_dma_offset(dev);\n\n\treturn ret;\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nvoid *__dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tvoid *ret;\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tret = __dma_alloc_coherent(dev, size, dma_handle, flag);\n\tif (ret == NULL)\n\t\treturn NULL;\n\t*dma_handle += get_dma_offset(dev);\n\treturn ret;\n#else\n\tstruct page *page;\n\tint node = dev_to_node(dev);\n#ifdef CONFIG_FSL_SOC\n\tu64 pfn = get_pfn_limit(dev);\n\tint zone;\n\n\t/*\n\t * This code should be OK on other platforms, but we have drivers that\n\t * don't set coherent_dma_mask. As a workaround we just ifdef it. This\n\t * whole routine needs some serious cleanup.\n\t */\n\n\tzone = dma_pfn_limit_to_zone(pfn);\n\tif (zone < 0) {\n\t\tdev_err(dev, \"%s: No suitable zone for pfn %#llx\\n\",\n\t\t\t__func__, pfn);\n\t\treturn NULL;\n\t}\n\n\tswitch (zone) {\n\tcase ZONE_DMA:\n\t\tflag |= GFP_DMA;\n\t\tbreak;\n#ifdef CONFIG_ZONE_DMA32\n\tcase ZONE_DMA32:\n\t\tflag |= GFP_DMA32;\n\t\tbreak;\n#endif\n\t};\n#endif /* CONFIG_FSL_SOC */\n\n\t/* ignore region specifiers */\n\tflag  &= ~(__GFP_HIGHMEM);\n\n\tpage = alloc_pages_node(node, flag, get_order(size));\n\tif (page == NULL)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\t*dma_handle = __pa(ret) + get_dma_offset(dev);\n\n\treturn ret;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_dma_supported",
          "args": [
            "dev",
            "dev->coherent_dma_mask"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_dma_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "43-63",
          "snippet": "static int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic void *dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t       dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t       struct dma_attrs *attrs)\n{\n\tstruct iommu_table *iommu;\n\n\t/* The coherent mask may be smaller than the real mask, check if\n\t * we can really use the direct ops\n\t */\n\tif (dma_direct_dma_supported(dev, dev->coherent_dma_mask))\n\t\treturn __dma_direct_alloc_coherent(dev, size, dma_handle,\n\t\t\t\t\t\t   flag, attrs);\n\n\t/* Ok we can't ... do we have an iommu ? If not, fail */\n\tiommu = get_iommu_table_base(dev);\n\tif (!iommu)\n\t\treturn NULL;\n\n\t/* Try to use the iommu */\n\treturn iommu_alloc_coherent(dev, iommu, size, dma_handle,\n\t\t\t\t    dev->coherent_dma_mask, flag,\n\t\t\t\t    dev_to_node(dev));\n}"
  },
  {
    "function_name": "__dma_direct_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "122-131",
    "snippet": "void __dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t__dma_free_coherent(size, vaddr);\n#else\n\tfree_pages((unsigned long)vaddr, get_order(size));\n#endif\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vaddr",
            "get_order(size)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_free_coherent",
          "args": [
            "size",
            "vaddr"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nvoid __dma_direct_free_coherent(struct device *dev, size_t size,\n\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\tstruct dma_attrs *attrs)\n{\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\t__dma_free_coherent(size, vaddr);\n#else\n\tfree_pages((unsigned long)vaddr, get_order(size));\n#endif\n}"
  },
  {
    "function_name": "__dma_direct_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "65-120",
    "snippet": "void *__dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tvoid *ret;\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tret = __dma_alloc_coherent(dev, size, dma_handle, flag);\n\tif (ret == NULL)\n\t\treturn NULL;\n\t*dma_handle += get_dma_offset(dev);\n\treturn ret;\n#else\n\tstruct page *page;\n\tint node = dev_to_node(dev);\n#ifdef CONFIG_FSL_SOC\n\tu64 pfn = get_pfn_limit(dev);\n\tint zone;\n\n\t/*\n\t * This code should be OK on other platforms, but we have drivers that\n\t * don't set coherent_dma_mask. As a workaround we just ifdef it. This\n\t * whole routine needs some serious cleanup.\n\t */\n\n\tzone = dma_pfn_limit_to_zone(pfn);\n\tif (zone < 0) {\n\t\tdev_err(dev, \"%s: No suitable zone for pfn %#llx\\n\",\n\t\t\t__func__, pfn);\n\t\treturn NULL;\n\t}\n\n\tswitch (zone) {\n\tcase ZONE_DMA:\n\t\tflag |= GFP_DMA;\n\t\tbreak;\n#ifdef CONFIG_ZONE_DMA32\n\tcase ZONE_DMA32:\n\t\tflag |= GFP_DMA32;\n\t\tbreak;\n#endif\n\t};\n#endif /* CONFIG_FSL_SOC */\n\n\t/* ignore region specifiers */\n\tflag  &= ~(__GFP_HIGHMEM);\n\n\tpage = alloc_pages_node(node, flag, get_order(size));\n\tif (page == NULL)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\t*dma_handle = __pa(ret) + get_dma_offset(dev);\n\n\treturn ret;\n#endif\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "ret"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "flag",
            "get_order(size)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"%s: No suitable zone for pfn %#llx\\n\"",
            "__func__",
            "pfn"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_pfn_limit_to_zone",
          "args": [
            "pfn"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pfn_limit",
          "args": [
            "dev"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "get_pfn_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
          "lines": "30-41",
          "snippet": "static u64 __maybe_unused get_pfn_limit(struct device *dev)\n{\n\tu64 pfn = (dev->coherent_dma_mask >> PAGE_SHIFT) + 1;\n\tstruct dev_archdata __maybe_unused *sd = &dev->archdata;\n\n#ifdef CONFIG_SWIOTLB\n\tif (sd->max_direct_dma_addr && sd->dma_ops == &swiotlb_dma_ops)\n\t\tpfn = min_t(u64, pfn, sd->max_direct_dma_addr >> PAGE_SHIFT);\n#endif\n\n\treturn pfn;\n}",
          "includes": [
            "#include <asm/iommu.h>",
            "#include <asm/swiotlb.h>",
            "#include <asm/machdep.h>",
            "#include <asm/bug.h>",
            "#include <asm/vio.h>",
            "#include <linux/pci.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic u64 __maybe_unused get_pfn_limit(struct device *dev)\n{\n\tu64 pfn = (dev->coherent_dma_mask >> PAGE_SHIFT) + 1;\n\tstruct dev_archdata __maybe_unused *sd = &dev->archdata;\n\n#ifdef CONFIG_SWIOTLB\n\tif (sd->max_direct_dma_addr && sd->dma_ops == &swiotlb_dma_ops)\n\t\tpfn = min_t(u64, pfn, sd->max_direct_dma_addr >> PAGE_SHIFT);\n#endif\n\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_alloc_coherent",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "flag"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nvoid *__dma_direct_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tvoid *ret;\n#ifdef CONFIG_NOT_COHERENT_CACHE\n\tret = __dma_alloc_coherent(dev, size, dma_handle, flag);\n\tif (ret == NULL)\n\t\treturn NULL;\n\t*dma_handle += get_dma_offset(dev);\n\treturn ret;\n#else\n\tstruct page *page;\n\tint node = dev_to_node(dev);\n#ifdef CONFIG_FSL_SOC\n\tu64 pfn = get_pfn_limit(dev);\n\tint zone;\n\n\t/*\n\t * This code should be OK on other platforms, but we have drivers that\n\t * don't set coherent_dma_mask. As a workaround we just ifdef it. This\n\t * whole routine needs some serious cleanup.\n\t */\n\n\tzone = dma_pfn_limit_to_zone(pfn);\n\tif (zone < 0) {\n\t\tdev_err(dev, \"%s: No suitable zone for pfn %#llx\\n\",\n\t\t\t__func__, pfn);\n\t\treturn NULL;\n\t}\n\n\tswitch (zone) {\n\tcase ZONE_DMA:\n\t\tflag |= GFP_DMA;\n\t\tbreak;\n#ifdef CONFIG_ZONE_DMA32\n\tcase ZONE_DMA32:\n\t\tflag |= GFP_DMA32;\n\t\tbreak;\n#endif\n\t};\n#endif /* CONFIG_FSL_SOC */\n\n\t/* ignore region specifiers */\n\tflag  &= ~(__GFP_HIGHMEM);\n\n\tpage = alloc_pages_node(node, flag, get_order(size));\n\tif (page == NULL)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\t*dma_handle = __pa(ret) + get_dma_offset(dev);\n\n\treturn ret;\n#endif\n}"
  },
  {
    "function_name": "dma_direct_dma_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "43-63",
    "snippet": "static int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_offset",
          "args": [
            "dev"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic int dma_direct_dma_supported(struct device *dev, u64 mask)\n{\n#ifdef CONFIG_PPC64\n\tu64 limit = get_dma_offset(dev) + (memblock_end_of_DRAM() - 1);\n\n\t/* Limit fits in the mask, we are good */\n\tif (mask >= limit)\n\t\treturn 1;\n\n#ifdef CONFIG_FSL_SOC\n\t/* Freescale gets another chance via ZONE_DMA/ZONE_DMA32, however\n\t * that will have to be refined if/when they support iommus\n\t */\n\treturn 1;\n#endif\n\t/* Sorry ... */\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}"
  },
  {
    "function_name": "get_pfn_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma.c",
    "lines": "30-41",
    "snippet": "static u64 __maybe_unused get_pfn_limit(struct device *dev)\n{\n\tu64 pfn = (dev->coherent_dma_mask >> PAGE_SHIFT) + 1;\n\tstruct dev_archdata __maybe_unused *sd = &dev->archdata;\n\n#ifdef CONFIG_SWIOTLB\n\tif (sd->max_direct_dma_addr && sd->dma_ops == &swiotlb_dma_ops)\n\t\tpfn = min_t(u64, pfn, sd->max_direct_dma_addr >> PAGE_SHIFT);\n#endif\n\n\treturn pfn;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <asm/swiotlb.h>",
      "#include <asm/machdep.h>",
      "#include <asm/bug.h>",
      "#include <asm/vio.h>",
      "#include <linux/pci.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "pfn",
            "sd->max_direct_dma_addr >> PAGE_SHIFT"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <asm/swiotlb.h>\n#include <asm/machdep.h>\n#include <asm/bug.h>\n#include <asm/vio.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/memblock.h>\n#include <linux/gfp.h>\n#include <linux/dma-debug.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n\nstatic u64 __maybe_unused get_pfn_limit(struct device *dev)\n{\n\tu64 pfn = (dev->coherent_dma_mask >> PAGE_SHIFT) + 1;\n\tstruct dev_archdata __maybe_unused *sd = &dev->archdata;\n\n#ifdef CONFIG_SWIOTLB\n\tif (sd->max_direct_dma_addr && sd->dma_ops == &swiotlb_dma_ops)\n\t\tpfn = min_t(u64, pfn, sd->max_direct_dma_addr >> PAGE_SHIFT);\n#endif\n\n\treturn pfn;\n}"
  }
]