[
  {
    "function_name": "__machine_check_early_realmode_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "337-362",
    "snippet": "long __machine_check_early_realmode_p8(struct pt_regs *regs)\n{\n\tuint64_t srr1, nip, addr;\n\tlong handled = 1;\n\tstruct mce_error_info mce_error_info = { 0 };\n\n\tsrr1 = regs->msr;\n\tnip = regs->nip;\n\n\tif (P7_SRR1_MC_LOADSTORE(srr1)) {\n\t\thandled = mce_handle_derror_p8(regs->dsisr);\n\t\tmce_get_derror_p8(&mce_error_info, regs->dsisr);\n\t\taddr = regs->dar;\n\t} else {\n\t\thandled = mce_handle_ierror_p8(srr1);\n\t\tmce_get_ierror_p8(&mce_error_info, srr1);\n\t\taddr = regs->nip;\n\t}\n\n\t/* Handle UE error. */\n\tif (mce_error_info.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs);\n\n\tsave_mce_event(regs, handled, &mce_error_info, nip, addr);\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_mce_event",
          "args": [
            "regs",
            "handled",
            "&mce_error_info",
            "nip",
            "addr"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "save_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "71-125",
          "snippet": "void save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nvoid save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ue_error",
          "args": [
            "regs"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ue_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "250-266",
          "snippet": "static long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_get_ierror_p8",
          "args": [
            "&mce_error_info",
            "srr1"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_ierror_p8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "301-308",
          "snippet": "static void mce_get_ierror_p8(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_ierror_p8(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ierror_p8",
          "args": [
            "srr1"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ierror_p8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "319-330",
          "snippet": "static long mce_handle_ierror_p8(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ierror_p8(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_get_derror_p8",
          "args": [
            "&mce_error_info",
            "regs->dsisr"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_derror_p8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "310-317",
          "snippet": "static void mce_get_derror_p8(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tmce_get_derror_p7(mce_err, dsisr);\n\tif (dsisr & P8_DSISR_MC_ERAT_MULTIHIT_SEC) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_derror_p8(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tmce_get_derror_p7(mce_err, dsisr);\n\tif (dsisr & P8_DSISR_MC_ERAT_MULTIHIT_SEC) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_derror_p8",
          "args": [
            "regs->dsisr"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_derror_p8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "332-335",
          "snippet": "static long mce_handle_derror_p8(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P8_DSISR_MC_SLB_ERRORS);\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror_p8(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P8_DSISR_MC_SLB_ERRORS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P7_SRR1_MC_LOADSTORE",
          "args": [
            "srr1"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nlong __machine_check_early_realmode_p8(struct pt_regs *regs)\n{\n\tuint64_t srr1, nip, addr;\n\tlong handled = 1;\n\tstruct mce_error_info mce_error_info = { 0 };\n\n\tsrr1 = regs->msr;\n\tnip = regs->nip;\n\n\tif (P7_SRR1_MC_LOADSTORE(srr1)) {\n\t\thandled = mce_handle_derror_p8(regs->dsisr);\n\t\tmce_get_derror_p8(&mce_error_info, regs->dsisr);\n\t\taddr = regs->dar;\n\t} else {\n\t\thandled = mce_handle_ierror_p8(srr1);\n\t\tmce_get_ierror_p8(&mce_error_info, srr1);\n\t\taddr = regs->nip;\n\t}\n\n\t/* Handle UE error. */\n\tif (mce_error_info.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs);\n\n\tsave_mce_event(regs, handled, &mce_error_info, nip, addr);\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_derror_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "332-335",
    "snippet": "static long mce_handle_derror_p8(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P8_DSISR_MC_SLB_ERRORS);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_derror",
          "args": [
            "dsisr",
            "P8_DSISR_MC_SLB_ERRORS"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_derror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "115-140",
          "snippet": "static long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror_p8(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P8_DSISR_MC_SLB_ERRORS);\n}"
  },
  {
    "function_name": "mce_handle_ierror_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "319-330",
    "snippet": "static long mce_handle_ierror_p8(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "81-113",
          "snippet": "static void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_handle_common_ierror",
          "args": [
            "srr1"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_common_ierror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "147-171",
          "snippet": "static long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ierror_p8(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_get_derror_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "310-317",
    "snippet": "static void mce_get_derror_p8(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tmce_get_derror_p7(mce_err, dsisr);\n\tif (dsisr & P8_DSISR_MC_ERAT_MULTIHIT_SEC) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_get_derror_p7",
          "args": [
            "mce_err",
            "dsisr"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_derror_p7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "223-248",
          "snippet": "static void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_derror_p8(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tmce_get_derror_p7(mce_err, dsisr);\n\tif (dsisr & P8_DSISR_MC_ERAT_MULTIHIT_SEC) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}"
  },
  {
    "function_name": "mce_get_ierror_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "301-308",
    "snippet": "static void mce_get_ierror_p8(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_get_common_ierror",
          "args": [
            "mce_err",
            "srr1"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_common_ierror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "186-212",
          "snippet": "static void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_ierror_p8(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P8_SRR1_MC_IFETCH_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t}\n}"
  },
  {
    "function_name": "__machine_check_early_realmode_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "268-299",
    "snippet": "long __machine_check_early_realmode_p7(struct pt_regs *regs)\n{\n\tuint64_t srr1, nip, addr;\n\tlong handled = 1;\n\tstruct mce_error_info mce_error_info = { 0 };\n\n\tsrr1 = regs->msr;\n\tnip = regs->nip;\n\n\t/*\n\t * Handle memory errors depending whether this was a load/store or\n\t * ifetch exception. Also, populate the mce error_type and\n\t * type-specific error_type from either SRR1 or DSISR, depending\n\t * whether this was a load/store or ifetch exception\n\t */\n\tif (P7_SRR1_MC_LOADSTORE(srr1)) {\n\t\thandled = mce_handle_derror_p7(regs->dsisr);\n\t\tmce_get_derror_p7(&mce_error_info, regs->dsisr);\n\t\taddr = regs->dar;\n\t} else {\n\t\thandled = mce_handle_ierror_p7(srr1);\n\t\tmce_get_ierror_p7(&mce_error_info, srr1);\n\t\taddr = regs->nip;\n\t}\n\n\t/* Handle UE error. */\n\tif (mce_error_info.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs);\n\n\tsave_mce_event(regs, handled, &mce_error_info, nip, addr);\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_mce_event",
          "args": [
            "regs",
            "handled",
            "&mce_error_info",
            "nip",
            "addr"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "save_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "71-125",
          "snippet": "void save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nvoid save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ue_error",
          "args": [
            "regs"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ue_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "250-266",
          "snippet": "static long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_get_ierror_p7",
          "args": [
            "&mce_error_info",
            "srr1"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_ierror_p7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "214-221",
          "snippet": "static void mce_get_ierror_p7(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_ierror_p7(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ierror_p7",
          "args": [
            "srr1"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ierror_p7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "173-184",
          "snippet": "static long mce_handle_ierror_p7(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ierror_p7(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_get_derror_p7",
          "args": [
            "&mce_error_info",
            "regs->dsisr"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_derror_p7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "223-248",
          "snippet": "static void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_derror_p7",
          "args": [
            "regs->dsisr"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_derror_p7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "142-145",
          "snippet": "static long mce_handle_derror_p7(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P7_DSISR_MC_SLB_ERRORS);\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror_p7(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P7_DSISR_MC_SLB_ERRORS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P7_SRR1_MC_LOADSTORE",
          "args": [
            "srr1"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nlong __machine_check_early_realmode_p7(struct pt_regs *regs)\n{\n\tuint64_t srr1, nip, addr;\n\tlong handled = 1;\n\tstruct mce_error_info mce_error_info = { 0 };\n\n\tsrr1 = regs->msr;\n\tnip = regs->nip;\n\n\t/*\n\t * Handle memory errors depending whether this was a load/store or\n\t * ifetch exception. Also, populate the mce error_type and\n\t * type-specific error_type from either SRR1 or DSISR, depending\n\t * whether this was a load/store or ifetch exception\n\t */\n\tif (P7_SRR1_MC_LOADSTORE(srr1)) {\n\t\thandled = mce_handle_derror_p7(regs->dsisr);\n\t\tmce_get_derror_p7(&mce_error_info, regs->dsisr);\n\t\taddr = regs->dar;\n\t} else {\n\t\thandled = mce_handle_ierror_p7(srr1);\n\t\tmce_get_ierror_p7(&mce_error_info, srr1);\n\t\taddr = regs->nip;\n\t}\n\n\t/* Handle UE error. */\n\tif (mce_error_info.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs);\n\n\tsave_mce_event(regs, handled, &mce_error_info, nip, addr);\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_ue_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "250-266",
    "snippet": "static long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.mce_check_early_recovery",
          "args": [
            "regs"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ue_error(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_get_derror_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "223-248",
    "snippet": "static void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_derror_p7(struct mce_error_info *mce_err, uint64_t dsisr)\n{\n\tif (dsisr & P7_DSISR_MC_UE) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_UE_TABLEWALK) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;\n\t} else if (dsisr & P7_DSISR_MC_ERAT_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_ERAT;\n\t\tmce_err->u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_PARITY_MFSLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t} else if (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t} else if (dsisr & P7_DSISR_MC_SLB_MULTIHIT_PARITY) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}"
  },
  {
    "function_name": "mce_get_ierror_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "214-221",
    "snippet": "static void mce_get_ierror_p7(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_get_common_ierror",
          "args": [
            "mce_err",
            "srr1"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "mce_get_common_ierror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "186-212",
          "snippet": "static void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_ierror_p7(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tmce_get_common_ierror(mce_err, srr1);\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;\n\t}\n}"
  },
  {
    "function_name": "mce_get_common_ierror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "186-212",
    "snippet": "static void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void mce_get_common_ierror(struct mce_error_info *mce_err, uint64_t srr1)\n{\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_PARITY;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_SLB;\n\t\tmce_err->u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_TLB;\n\t\tmce_err->u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE:\n\tcase P7_SRR1_MC_IFETCH_UE_IFU_INTERNAL:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type = MCE_UE_ERROR_IFETCH;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_UE_TLB_RELOAD:\n\t\tmce_err->error_type = MCE_ERROR_TYPE_UE;\n\t\tmce_err->u.ue_error_type =\n\t\t\t\tMCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "mce_handle_ierror_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "173-184",
    "snippet": "static long mce_handle_ierror_p7(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "81-113",
          "snippet": "static void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_handle_common_ierror",
          "args": [
            "srr1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_common_ierror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "147-171",
          "snippet": "static long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ierror_p7(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\thandled = mce_handle_common_ierror(srr1);\n\n\tif (P7_SRR1_MC_IFETCH(srr1) == P7_SRR1_MC_IFETCH_SLB_BOTH) {\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t}\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_common_ierror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "147-171",
    "snippet": "static long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_cpu_spec->flush_tlb",
          "args": [
            "TLB_INVAL_SCOPE_GLOBAL"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "81-113",
          "snippet": "static void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P7_SRR1_MC_IFETCH",
          "args": [
            "srr1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_common_ierror(uint64_t srr1)\n{\n\tlong handled = 0;\n\n\tswitch (P7_SRR1_MC_IFETCH(srr1)) {\n\tcase 0:\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_SLB_PARITY:\n\tcase P7_SRR1_MC_IFETCH_SLB_MULTIHIT:\n\t\t/* flush and reload SLBs for SLB errors. */\n\t\tflush_and_reload_slb();\n\t\thandled = 1;\n\t\tbreak;\n\tcase P7_SRR1_MC_IFETCH_TLB_MULTIHIT:\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb) {\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t\thandled = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_derror_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "142-145",
    "snippet": "static long mce_handle_derror_p7(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P7_DSISR_MC_SLB_ERRORS);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_derror",
          "args": [
            "dsisr",
            "P7_DSISR_MC_SLB_ERRORS"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_derror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "115-140",
          "snippet": "static long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror_p7(uint64_t dsisr)\n{\n\treturn mce_handle_derror(dsisr, P7_DSISR_MC_SLB_ERRORS);\n}"
  },
  {
    "function_name": "mce_handle_derror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "115-140",
    "snippet": "static long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_cpu_spec->flush_tlb",
          "args": [
            "TLB_INVAL_SCOPE_GLOBAL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "81-113",
          "snippet": "static void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_derror(uint64_t dsisr, uint64_t slb_error_bits)\n{\n\tlong handled = 1;\n\n\t/*\n\t * flush and reload SLBs for SLB errors and flush TLBs for TLB errors.\n\t * reset the error bits whenever we handle them so that at the end\n\t * we can check whether we handled all of them or not.\n\t * */\n\tif (dsisr & slb_error_bits) {\n\t\tflush_and_reload_slb();\n\t\t/* reset error bits */\n\t\tdsisr &= ~(slb_error_bits);\n\t}\n\tif (dsisr & P7_DSISR_MC_TLB_MULTIHIT_MFTLB) {\n\t\tif (cur_cpu_spec && cur_cpu_spec->flush_tlb)\n\t\t\tcur_cpu_spec->flush_tlb(TLB_INVAL_SCOPE_GLOBAL);\n\t\t/* reset error bits */\n\t\tdsisr &= ~P7_DSISR_MC_TLB_MULTIHIT_MFTLB;\n\t}\n\t/* Any other errors we don't understand? */\n\tif (dsisr & 0xffffffffUL)\n\t\thandled = 0;\n\n\treturn handled;\n}"
  },
  {
    "function_name": "flush_and_reload_slb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "81-113",
    "snippet": "static void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "slb->save_area[i].vsid"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "slb->save_area[i].esid"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "be32_to_cpu(slb->persistent)",
            "SLB_MIN_SIZE"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "slb->persistent"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_slb_shadow",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_and_reload_slb(void)\n{\n\tstruct slb_shadow *slb;\n\tunsigned long i, n;\n\n\t/* Invalidate all SLBs */\n\tasm volatile(\"slbmte %0,%0; slbia\" : : \"r\" (0));\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\n\t/* For host kernel, reload the SLBs from shadow SLB buffer. */\n\tslb = get_slb_shadow();\n\tif (!slb)\n\t\treturn;\n\n\tn = min_t(u32, be32_to_cpu(slb->persistent), SLB_MIN_SIZE);\n\n\t/* Load up the SLB entries from shadow SLB */\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned long rb = be64_to_cpu(slb->save_area[i].esid);\n\t\tunsigned long rs = be64_to_cpu(slb->save_area[i].vsid);\n\n\t\trb = (rb & ~0xFFFul) | i;\n\t\tasm volatile(\"slbmte %0,%1\" : : \"r\" (rs), \"r\" (rb));\n\t}\n}"
  },
  {
    "function_name": "__flush_tlb_power8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "75-78",
    "snippet": "void __flush_tlb_power8(unsigned int action)\n{\n\tflush_tlb_206(POWER8_TLB_SETS, action);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_206",
          "args": [
            "POWER8_TLB_SETS",
            "action"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_206",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "31-54",
          "snippet": "static void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid __flush_tlb_power8(unsigned int action)\n{\n\tflush_tlb_206(POWER8_TLB_SETS, action);\n}"
  },
  {
    "function_name": "__flush_tlb_power7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "63-66",
    "snippet": "void __flush_tlb_power7(unsigned int action)\n{\n\tflush_tlb_206(POWER7_TLB_SETS, action);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_206",
          "args": [
            "POWER7_TLB_SETS",
            "action"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_206",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "31-54",
          "snippet": "static void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid __flush_tlb_power7(unsigned int action)\n{\n\tflush_tlb_206(POWER7_TLB_SETS, action);\n}"
  },
  {
    "function_name": "flush_tlb_206",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "31-54",
    "snippet": "static void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_tlb_206(unsigned int num_sets, unsigned int action)\n{\n\tunsigned long rb;\n\tunsigned int i;\n\n\tswitch (action) {\n\tcase TLB_INVAL_SCOPE_GLOBAL:\n\t\trb = TLBIEL_INVAL_SET;\n\t\tbreak;\n\tcase TLB_INVAL_SCOPE_LPID:\n\t\trb = TLBIEL_INVAL_SET_LPID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tasm volatile(\"ptesync\" : : : \"memory\");\n\tfor (i = 0; i < num_sets; i++) {\n\t\tasm volatile(\"tlbiel %0\" : : \"r\" (rb));\n\t\trb += 1 << TLBIEL_INVAL_SET_SHIFT;\n\t}\n\tasm volatile(\"ptesync\" : : : \"memory\");\n}"
  }
]