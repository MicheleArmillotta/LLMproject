[
  {
    "function_name": "free_unused_pacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "238-255",
    "snippet": "void __init free_unused_pacas(void)\n{\n\tint new_size;\n\n\tnew_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tif (new_size >= paca_size)\n\t\treturn;\n\n\tmemblock_free(__pa(paca) + new_size, paca_size - new_size);\n\n\tprintk(KERN_DEBUG \"Freed %u bytes for unused pacas\\n\",\n\t\tpaca_size - new_size);\n\n\tpaca_size = new_size;\n\n\tfree_lppacas();\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct paca_struct *paca;",
      "static int __initdata paca_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_lppacas",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "free_lppacas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "92-92",
          "snippet": "static inline void free_lppacas(void) { }",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic inline void free_lppacas(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Freed %u bytes for unused pacas\\n\"",
            "paca_size - new_size"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "__pa(paca) + new_size",
            "paca_size - new_size"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "paca"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct paca_struct) * nr_cpu_ids"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstruct paca_struct *paca;\nstatic int __initdata paca_size;\n\nvoid __init free_unused_pacas(void)\n{\n\tint new_size;\n\n\tnew_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tif (new_size >= paca_size)\n\t\treturn;\n\n\tmemblock_free(__pa(paca) + new_size, paca_size - new_size);\n\n\tprintk(KERN_DEBUG \"Freed %u bytes for unused pacas\\n\",\n\t\tpaca_size - new_size);\n\n\tpaca_size = new_size;\n\n\tfree_lppacas();\n}"
  },
  {
    "function_name": "allocate_pacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "205-236",
    "snippet": "void __init allocate_pacas(void)\n{\n\tu64 limit;\n\tint cpu;\n\n\tlimit = ppc64_rma_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We can't take SLB misses on the paca, and we want to access them\n\t * in real mode, so allocate them within the RMA and also within\n\t * the first segment.\n\t */\n\tlimit = min(0x10000000ULL, limit);\n#endif\n\n\tpaca_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tpaca = __va(memblock_alloc_base(paca_size, PAGE_SIZE, limit));\n\tmemset(paca, 0, paca_size);\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %d pacas at %p\\n\",\n\t\tpaca_size, nr_cpu_ids, paca);\n\n\tallocate_lppacas(nr_cpu_ids, limit);\n\n\tallocate_slb_shadows(nr_cpu_ids, limit);\n\n\t/* Can't use for_each_*_cpu, as they aren't functional yet */\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tinitialise_paca(&paca[cpu], cpu);\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct paca_struct *paca;",
      "static int __initdata paca_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "initialise_paca",
          "args": [
            "&paca[cpu]",
            "cpu"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "initialise_paca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "150-180",
          "snippet": "void __init initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n       /* The TOC register (GPR2) points 32kB into the TOC, so that 64kB\n\t* of the TOC can be addressed using a single machine instruction.\n\t*/\n\tunsigned long kernel_toc = (unsigned long)(&__toc_start) + 0x8000UL;\n\n#ifdef CONFIG_PPC_BOOK3S\n\tnew_paca->lppaca_ptr = new_lppaca(cpu);\n#else\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc;\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_STD_MMU_64\n\tnew_paca->slb_shadow_ptr = init_slb_shadow(cpu);\n#endif /* CONFIG_PPC_STD_MMU_64 */\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n}",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long __toc_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nextern unsigned long __toc_start;\n\nvoid __init initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n       /* The TOC register (GPR2) points 32kB into the TOC, so that 64kB\n\t* of the TOC can be addressed using a single machine instruction.\n\t*/\n\tunsigned long kernel_toc = (unsigned long)(&__toc_start) + 0x8000UL;\n\n#ifdef CONFIG_PPC_BOOK3S\n\tnew_paca->lppaca_ptr = new_lppaca(cpu);\n#else\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc;\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_STD_MMU_64\n\tnew_paca->slb_shadow_ptr = init_slb_shadow(cpu);\n#endif /* CONFIG_PPC_STD_MMU_64 */\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_slb_shadows",
          "args": [
            "nr_cpu_ids",
            "limit"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_slb_shadows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "134-134",
          "snippet": "static void __init allocate_slb_shadows(int nr_cpus, int limit) { }",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic void __init allocate_slb_shadows(int nr_cpus, int limit) { }"
        }
      },
      {
        "call_info": {
          "callee": "allocate_lppacas",
          "args": [
            "nr_cpu_ids",
            "limit"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_lppacas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "91-91",
          "snippet": "static inline void allocate_lppacas(int nr_cpus, unsigned long limit) { }",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic inline void allocate_lppacas(int nr_cpus, unsigned long limit) { }"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Allocated %u bytes for %d pacas at %p\\n\"",
            "paca_size",
            "nr_cpu_ids",
            "paca"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "paca",
            "0",
            "paca_size"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc_base(paca_size, PAGE_SIZE, limit)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "paca_size",
            "PAGE_SIZE",
            "limit"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct paca_struct) * nr_cpu_ids"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "0x10000000ULL",
            "limit"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstruct paca_struct *paca;\nstatic int __initdata paca_size;\n\nvoid __init allocate_pacas(void)\n{\n\tu64 limit;\n\tint cpu;\n\n\tlimit = ppc64_rma_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We can't take SLB misses on the paca, and we want to access them\n\t * in real mode, so allocate them within the RMA and also within\n\t * the first segment.\n\t */\n\tlimit = min(0x10000000ULL, limit);\n#endif\n\n\tpaca_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tpaca = __va(memblock_alloc_base(paca_size, PAGE_SIZE, limit));\n\tmemset(paca, 0, paca_size);\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %d pacas at %p\\n\",\n\t\tpaca_size, nr_cpu_ids, paca);\n\n\tallocate_lppacas(nr_cpu_ids, limit);\n\n\tallocate_slb_shadows(nr_cpu_ids, limit);\n\n\t/* Can't use for_each_*_cpu, as they aren't functional yet */\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tinitialise_paca(&paca[cpu], cpu);\n}"
  },
  {
    "function_name": "setup_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "183-201",
    "snippet": "void setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/* In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_PACA",
            "local_paca"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_HPACA",
            "local_paca"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_TLB_EXFRAME",
            "local_paca->extlb"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/* In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}"
  },
  {
    "function_name": "initialise_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "150-180",
    "snippet": "void __init initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n       /* The TOC register (GPR2) points 32kB into the TOC, so that 64kB\n\t* of the TOC can be addressed using a single machine instruction.\n\t*/\n\tunsigned long kernel_toc = (unsigned long)(&__toc_start) + 0x8000UL;\n\n#ifdef CONFIG_PPC_BOOK3S\n\tnew_paca->lppaca_ptr = new_lppaca(cpu);\n#else\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc;\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_STD_MMU_64\n\tnew_paca->slb_shadow_ptr = init_slb_shadow(cpu);\n#endif /* CONFIG_PPC_STD_MMU_64 */\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned long __toc_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_slb_shadow",
          "args": [
            "cpu"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "init_slb_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "114-130",
          "snippet": "static struct slb_shadow * __init init_slb_shadow(int cpu)\n{\n\tstruct slb_shadow *s = &slb_shadow[cpu];\n\n\t/*\n\t * When we come through here to initialise boot_paca, the slb_shadow\n\t * buffers are not allocated yet. That's OK, we'll get one later in\n\t * boot, but make sure we don't corrupt memory at 0.\n\t */\n\tif (!slb_shadow)\n\t\treturn NULL;\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic struct slb_shadow * __init init_slb_shadow(int cpu)\n{\n\tstruct slb_shadow *s = &slb_shadow[cpu];\n\n\t/*\n\t * When we come through here to initialise boot_paca, the slb_shadow\n\t * buffers are not allocated yet. That's OK, we'll get one later in\n\t * boot, but make sure we don't corrupt memory at 0.\n\t */\n\tif (!slb_shadow)\n\t\treturn NULL;\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_lppaca",
          "args": [
            "cpu"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "new_lppaca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "60-71",
          "snippet": "static struct lppaca * __init new_lppaca(int cpu)\n{\n\tstruct lppaca *lp;\n\n\tif (cpu < NR_LPPACAS)\n\t\treturn &lppaca[cpu];\n\n\tlp = extra_lppacas + (cpu - NR_LPPACAS);\n\t*lp = lppaca[0];\n\n\treturn lp;\n}",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic struct lppaca * __init new_lppaca(int cpu)\n{\n\tstruct lppaca *lp;\n\n\tif (cpu < NR_LPPACAS)\n\t\treturn &lppaca[cpu];\n\n\tlp = extra_lppacas + (cpu - NR_LPPACAS);\n\t*lp = lppaca[0];\n\n\treturn lp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nextern unsigned long __toc_start;\n\nvoid __init initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n       /* The TOC register (GPR2) points 32kB into the TOC, so that 64kB\n\t* of the TOC can be addressed using a single machine instruction.\n\t*/\n\tunsigned long kernel_toc = (unsigned long)(&__toc_start) + 0x8000UL;\n\n#ifdef CONFIG_PPC_BOOK3S\n\tnew_paca->lppaca_ptr = new_lppaca(cpu);\n#else\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc;\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_STD_MMU_64\n\tnew_paca->slb_shadow_ptr = init_slb_shadow(cpu);\n#endif /* CONFIG_PPC_STD_MMU_64 */\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n}"
  },
  {
    "function_name": "allocate_slb_shadows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "134-134",
    "snippet": "static void __init allocate_slb_shadows(int nr_cpus, int limit) { }",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic void __init allocate_slb_shadows(int nr_cpus, int limit) { }"
  },
  {
    "function_name": "init_slb_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "114-130",
    "snippet": "static struct slb_shadow * __init init_slb_shadow(int cpu)\n{\n\tstruct slb_shadow *s = &slb_shadow[cpu];\n\n\t/*\n\t * When we come through here to initialise boot_paca, the slb_shadow\n\t * buffers are not allocated yet. That's OK, we'll get one later in\n\t * boot, but make sure we don't corrupt memory at 0.\n\t */\n\tif (!slb_shadow)\n\t\treturn NULL;\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sizeof(*s)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "SLB_NUM_BOLTED"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic struct slb_shadow * __init init_slb_shadow(int cpu)\n{\n\tstruct slb_shadow *s = &slb_shadow[cpu];\n\n\t/*\n\t * When we come through here to initialise boot_paca, the slb_shadow\n\t * buffers are not allocated yet. That's OK, we'll get one later in\n\t * boot, but make sure we don't corrupt memory at 0.\n\t */\n\tif (!slb_shadow)\n\t\treturn NULL;\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}"
  },
  {
    "function_name": "allocate_slb_shadows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "107-112",
    "snippet": "static void __init allocate_slb_shadows(int nr_cpus, int limit)\n{\n\tint size = PAGE_ALIGN(sizeof(struct slb_shadow) * nr_cpus);\n\tslb_shadow = __va(memblock_alloc_base(size, PAGE_SIZE, limit));\n\tmemset(slb_shadow, 0, size);\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "slb_shadow",
            "0",
            "size"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc_base(size, PAGE_SIZE, limit)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "size",
            "PAGE_SIZE",
            "limit"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct slb_shadow) * nr_cpus"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic void __init allocate_slb_shadows(int nr_cpus, int limit)\n{\n\tint size = PAGE_ALIGN(sizeof(struct slb_shadow) * nr_cpus);\n\tslb_shadow = __va(memblock_alloc_base(size, PAGE_SIZE, limit));\n\tmemset(slb_shadow, 0, size);\n}"
  },
  {
    "function_name": "free_lppacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "92-92",
    "snippet": "static inline void free_lppacas(void) { }",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic inline void free_lppacas(void) { }"
  },
  {
    "function_name": "allocate_lppacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "91-91",
    "snippet": "static inline void allocate_lppacas(int nr_cpus, unsigned long limit) { }",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic inline void allocate_lppacas(int nr_cpus, unsigned long limit) { }"
  },
  {
    "function_name": "free_lppacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "73-87",
    "snippet": "static void __init free_lppacas(void)\n{\n\tlong new_size = 0, nr;\n\n\tif (!lppaca_size)\n\t\treturn;\n\tnr = num_possible_cpus() - NR_LPPACAS;\n\tif (nr > 0)\n\t\tnew_size = PAGE_ALIGN(nr * sizeof(struct lppaca));\n\tif (new_size >= lppaca_size)\n\t\treturn;\n\n\tmemblock_free(__pa(extra_lppacas) + new_size, lppaca_size - new_size);\n\tlppaca_size = new_size;\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "__pa(extra_lppacas) + new_size",
            "lppaca_size - new_size"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "extra_lppacas"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "nr * sizeof(struct lppaca)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic void __init free_lppacas(void)\n{\n\tlong new_size = 0, nr;\n\n\tif (!lppaca_size)\n\t\treturn;\n\tnr = num_possible_cpus() - NR_LPPACAS;\n\tif (nr > 0)\n\t\tnew_size = PAGE_ALIGN(nr * sizeof(struct lppaca));\n\tif (new_size >= lppaca_size)\n\t\treturn;\n\n\tmemblock_free(__pa(extra_lppacas) + new_size, lppaca_size - new_size);\n\tlppaca_size = new_size;\n}"
  },
  {
    "function_name": "new_lppaca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "60-71",
    "snippet": "static struct lppaca * __init new_lppaca(int cpu)\n{\n\tstruct lppaca *lp;\n\n\tif (cpu < NR_LPPACAS)\n\t\treturn &lppaca[cpu];\n\n\tlp = extra_lppacas + (cpu - NR_LPPACAS);\n\t*lp = lppaca[0];\n\n\treturn lp;\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic struct lppaca * __init new_lppaca(int cpu)\n{\n\tstruct lppaca *lp;\n\n\tif (cpu < NR_LPPACAS)\n\t\treturn &lppaca[cpu];\n\n\tlp = extra_lppacas + (cpu - NR_LPPACAS);\n\t*lp = lppaca[0];\n\n\treturn lp;\n}"
  },
  {
    "function_name": "allocate_lppacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
    "lines": "49-58",
    "snippet": "static void __init allocate_lppacas(int nr_cpus, unsigned long limit)\n{\n\tif (nr_cpus <= NR_LPPACAS)\n\t\treturn;\n\n\tlppaca_size = PAGE_ALIGN(sizeof(struct lppaca) *\n\t\t\t\t (nr_cpus - NR_LPPACAS));\n\textra_lppacas = __va(memblock_alloc_base(lppaca_size,\n\t\t\t\t\t\t PAGE_SIZE, limit));\n}",
    "includes": [
      "#include <asm/kexec.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc_base(lppaca_size,\n\t\t\t\t\t\t PAGE_SIZE, limit)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "lppaca_size",
            "PAGE_SIZE",
            "limit"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct lppaca) *\n\t\t\t\t (nr_cpus - NR_LPPACAS)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstatic void __init allocate_lppacas(int nr_cpus, unsigned long limit)\n{\n\tif (nr_cpus <= NR_LPPACAS)\n\t\treturn;\n\n\tlppaca_size = PAGE_ALIGN(sizeof(struct lppaca) *\n\t\t\t\t (nr_cpus - NR_LPPACAS));\n\textra_lppacas = __va(memblock_alloc_base(lppaca_size,\n\t\t\t\t\t\t PAGE_SIZE, limit));\n}"
  }
]