[
  {
    "function_name": "arch_syscall_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "547-550",
    "snippet": "unsigned long __init arch_syscall_addr(int nr)\n{\n\treturn sys_call_table[nr*2];\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nunsigned long __init arch_syscall_addr(int nr)\n{\n\treturn sys_call_table[nr*2];\n}"
  },
  {
    "function_name": "prepare_ftrace_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "517-543",
    "snippet": "unsigned long prepare_ftrace_return(unsigned long parent, unsigned long ip)\n{\n\tstruct ftrace_graph_ent trace;\n\tunsigned long return_hooker;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\tgoto out;\n\n\tif (unlikely(atomic_read(&current->tracing_graph_pause)))\n\t\tgoto out;\n\n\treturn_hooker = ppc_function_entry(return_to_handler);\n\n\ttrace.func = ip;\n\ttrace.depth = current->curr_ret_stack + 1;\n\n\t/* Only trace if the calling function expects to */\n\tif (!ftrace_graph_entry(&trace))\n\t\tgoto out;\n\n\tif (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)\n\t\tgoto out;\n\n\tparent = return_hooker;\nout:\n\treturn parent;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_push_return_trace",
          "args": [
            "parent",
            "ip",
            "&trace.depth",
            "0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_entry",
          "args": [
            "&trace"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "return_to_handler"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&current->tracing_graph_pause)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->tracing_graph_pause"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_graph_is_dead()"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_is_dead",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nunsigned long prepare_ftrace_return(unsigned long parent, unsigned long ip)\n{\n\tstruct ftrace_graph_ent trace;\n\tunsigned long return_hooker;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\tgoto out;\n\n\tif (unlikely(atomic_read(&current->tracing_graph_pause)))\n\t\tgoto out;\n\n\treturn_hooker = ppc_function_entry(return_to_handler);\n\n\ttrace.func = ip;\n\ttrace.depth = current->curr_ret_stack + 1;\n\n\t/* Only trace if the calling function expects to */\n\tif (!ftrace_graph_entry(&trace))\n\t\tgoto out;\n\n\tif (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)\n\t\tgoto out;\n\n\tparent = return_hooker;\nout:\n\treturn parent;\n}"
  },
  {
    "function_name": "ftrace_disable_ftrace_graph_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "499-510",
    "snippet": "int ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "44-72",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "stub",
            "0"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "31-42",
          "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
  },
  {
    "function_name": "ftrace_enable_ftrace_graph_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "486-497",
    "snippet": "int ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "44-72",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "0"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "31-42",
          "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
  },
  {
    "function_name": "ftrace_dyn_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "474-477",
    "snippet": "int __init ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint __init ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_ftrace_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "458-472",
    "snippet": "void arch_ftrace_update_code(int command)\n{\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (command & FTRACE_UPDATE_TRACE_FUNC)\n\t\tftrace_update_ftrace_func(ftrace_trace_function);\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\tftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\tftrace_disable_ftrace_graph_caller();\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_disable_ftrace_graph_caller",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_disable_ftrace_graph_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "499-510",
          "snippet": "int ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_enable_ftrace_graph_caller",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_enable_ftrace_graph_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "486-497",
          "snippet": "int ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tunsigned int old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_ftrace_func",
          "args": [
            "ftrace_trace_function"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_ftrace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "409-420",
          "snippet": "int ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tunsigned int old, new;\n\tint ret;\n\n\told = *(unsigned int *)&ftrace_call;\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tunsigned int old, new;\n\tint ret;\n\n\told = *(unsigned int *)&ftrace_call;\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_replace_code",
          "args": [
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_replace_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "441-456",
          "snippet": "void ftrace_replace_code(int enable)\n{\n\tstruct ftrace_rec_iter *iter;\n\tstruct dyn_ftrace *rec;\n\tint ret;\n\n\tfor (iter = ftrace_rec_iter_start(); iter;\n\t     iter = ftrace_rec_iter_next(iter)) {\n\t\trec = ftrace_rec_iter_record(iter);\n\t\tret = __ftrace_replace_code(rec, enable);\n\t\tif (ret) {\n\t\t\tftrace_bug(ret, rec);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nvoid ftrace_replace_code(int enable)\n{\n\tstruct ftrace_rec_iter *iter;\n\tstruct dyn_ftrace *rec;\n\tint ret;\n\n\tfor (iter = ftrace_rec_iter_start(); iter;\n\t     iter = ftrace_rec_iter_next(iter)) {\n\t\trec = ftrace_rec_iter_record(iter);\n\t\tret = __ftrace_replace_code(rec, enable);\n\t\tif (ret) {\n\t\t\tftrace_bug(ret, rec);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nvoid arch_ftrace_update_code(int command)\n{\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (command & FTRACE_UPDATE_TRACE_FUNC)\n\t\tftrace_update_ftrace_func(ftrace_trace_function);\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\tftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\tftrace_disable_ftrace_graph_caller();\n}"
  },
  {
    "function_name": "ftrace_replace_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "441-456",
    "snippet": "void ftrace_replace_code(int enable)\n{\n\tstruct ftrace_rec_iter *iter;\n\tstruct dyn_ftrace *rec;\n\tint ret;\n\n\tfor (iter = ftrace_rec_iter_start(); iter;\n\t     iter = ftrace_rec_iter_next(iter)) {\n\t\trec = ftrace_rec_iter_record(iter);\n\t\tret = __ftrace_replace_code(rec, enable);\n\t\tif (ret) {\n\t\t\tftrace_bug(ret, rec);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "ret",
            "rec"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_replace_code",
          "args": [
            "rec",
            "enable"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_replace_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "422-439",
          "snippet": "static int __ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_addr = (unsigned long)FTRACE_ADDR;\n\tint ret;\n\n\tret = ftrace_update_record(rec, enable);\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_addr);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_addr = (unsigned long)FTRACE_ADDR;\n\tint ret;\n\n\tret = ftrace_update_record(rec, enable);\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_addr);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_iter_record",
          "args": [
            "iter"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_iter_next",
          "args": [
            "iter"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_iter_start",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nvoid ftrace_replace_code(int enable)\n{\n\tstruct ftrace_rec_iter *iter;\n\tstruct dyn_ftrace *rec;\n\tint ret;\n\n\tfor (iter = ftrace_rec_iter_start(); iter;\n\t     iter = ftrace_rec_iter_next(iter)) {\n\t\trec = ftrace_rec_iter_record(iter);\n\t\tret = __ftrace_replace_code(rec, enable);\n\t\tif (ret) {\n\t\t\tftrace_bug(ret, rec);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__ftrace_replace_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "422-439",
    "snippet": "static int __ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_addr = (unsigned long)FTRACE_ADDR;\n\tint ret;\n\n\tret = ftrace_update_record(rec, enable);\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_addr);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_make_nop",
          "args": [
            "NULL",
            "rec",
            "ftrace_addr"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_make_nop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "241-286",
          "snippet": "int ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = PPC_INST_NOP;\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = PPC_INST_NOP;\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_make_call",
          "args": [
            "rec",
            "ftrace_addr"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "374-407",
          "snippet": "int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = PPC_INST_NOP;\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = PPC_INST_NOP;\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_record",
          "args": [
            "rec",
            "enable"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_addr = (unsigned long)FTRACE_ADDR;\n\tint ret;\n\n\tret = ftrace_update_record(rec, enable);\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_addr);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_update_ftrace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "409-420",
    "snippet": "int ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tunsigned int old, new;\n\tint ret;\n\n\told = *(unsigned int *)&ftrace_call;\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "44-72",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "(unsigned long)func",
            "1"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "31-42",
          "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tunsigned int old, new;\n\tint ret;\n\n\told = *(unsigned int *)&ftrace_call;\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "374-407",
    "snippet": "int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = PPC_INST_NOP;\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_make_call",
          "args": [
            "rec",
            "addr"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "334-370",
          "snippet": "static int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (op != PPC_INST_NOP) {\n\t\tpr_err(\"Expected NOP but have %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\top = create_branch((unsigned int *)ip,\n\t\t\t   rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (!op) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (op != PPC_INST_NOP) {\n\t\tpr_err(\"Expected NOP but have %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\top = create_branch((unsigned int *)ip,\n\t\t\t   rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (!op) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No module loaded\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "44-72",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "1"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "31-42",
          "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "addr"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "77-83",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = PPC_INST_NOP;\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
  },
  {
    "function_name": "__ftrace_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "334-370",
    "snippet": "static int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (op != PPC_INST_NOP) {\n\t\tpr_err(\"Expected NOP but have %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\top = create_branch((unsigned int *)ip,\n\t\t\t   rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (!op) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(unsigned int *)ip",
            "op"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"write to %lx\\n\"",
            "rec->ip"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "(unsigned int *)ip",
            "rec->arch.mod->arch.tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampoline\\n\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Expected NOP but have %x\\n\"",
            "op"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&op",
            "(void *)ip",
            "MCOUNT_INSN_SIZE"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (op != PPC_INST_NOP) {\n\t\tpr_err(\"Expected NOP but have %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\top = create_branch((unsigned int *)ip,\n\t\t\t   rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (!op) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "290-332",
    "snippet": "static int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op[2];\n\tvoid *ip = (void *)rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(op, ip, sizeof(op)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * We expect to see:\n\t *\n\t * b +8\n\t * ld r2,XX(r1)\n\t *\n\t * The load offset is different depending on the ABI. For simplicity\n\t * just mask it out when doing the compare.\n\t */\n\tif ((op[0] != 0x48000008) || ((op[1] & 0xffff0000) != 0xe8410000)) {\n\t\tpr_err(\"Unexpected call sequence: %x %x\\n\", op[0], op[1]);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (!create_branch(ip, rec->arch.mod->arch.tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, rec->arch.mod->arch.tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "ip",
            "rec->arch.mod->arch.tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Branch out of range\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "ip",
            "rec->arch.mod->arch.tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampoline\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unexpected call sequence: %x %x\\n\"",
            "op[0]",
            "op[1]"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "op",
            "ip",
            "sizeof(op)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op[2];\n\tvoid *ip = (void *)rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(op, ip, sizeof(op)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * We expect to see:\n\t *\n\t * b +8\n\t * ld r2,XX(r1)\n\t *\n\t * The load offset is different depending on the ABI. For simplicity\n\t * just mask it out when doing the compare.\n\t */\n\tif ((op[0] != 0x48000008) || ((op[1] & 0xffff0000) != 0xe8410000)) {\n\t\tpr_err(\"Unexpected call sequence: %x %x\\n\", op[0], op[1]);\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (!create_branch(ip, rec->arch.mod->arch.tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, rec->arch.mod->arch.tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "241-286",
    "snippet": "int ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = PPC_INST_NOP;\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_make_nop",
          "args": [
            "mod",
            "rec",
            "addr"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_make_nop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "170-237",
          "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (probe_kernel_read(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = PPC_INST_NOP;\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (probe_kernel_read(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = PPC_INST_NOP;\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Record mod %p not equal to passed in mod %p\\n\"",
            "rec->arch.mod",
            "mod"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No module loaded addr=%lx\\n\"",
            "addr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "44-72",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "1"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "31-42",
          "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "addr"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "77-83",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tunsigned int old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = PPC_INST_NOP;\n\t\treturn ftrace_modify_code(ip, old, new);\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
  },
  {
    "function_name": "__ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "170-237",
    "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (probe_kernel_read(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = PPC_INST_NOP;\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(unsigned int *)ip",
            "op"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Trampoline location %08lx does not match addr\\n\"",
            "tramp"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\" %lx \"",
            "tramp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not a trampoline\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\" %08x %08x \"",
            "jmp[0]",
            "jmp[1]"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to read %lx\\n\"",
            "tramp"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "jmp",
            "(void *)tramp",
            "sizeof(jmp)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %lx\"",
            "ip",
            "tramp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "92-102",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %x\\n\"",
            "op"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "87-90",
          "snippet": "static int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&op",
            "(void *)ip",
            "MCOUNT_INSN_SIZE"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (probe_kernel_read(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (probe_kernel_read(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = PPC_INST_NOP;\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "105-167",
    "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long entry, ptr;\n\tunsigned long ip = rec->ip;\n\tvoid *tramp;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, sizeof(int)))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = (void *)find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %p\", ip, tramp);\n\n\tif (!is_module_trampoline(tramp)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Our original call site looks like:\n\t *\n\t * bl <tramp>\n\t * ld r2,XX(r1)\n\t *\n\t * Milton Miller pointed out that we can not simply nop the branch.\n\t * If a task was preempted when calling a trace function, the nops\n\t * will remove the way to restore the TOC in r2 and the r2 TOC will\n\t * get corrupted.\n\t *\n\t * Use a b +8 to jump over the load.\n\t */\n\top = 0x48000008;\t/* b +8 */\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(unsigned int *)ip",
            "op"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"addr %lx does not match expected %lx\\n\"",
            "ptr",
            "entry"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"trampoline target %lx\"",
            "ptr"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to get trampoline target\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_trampoline_target",
          "args": [
            "mod",
            "tramp",
            "&ptr"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "module_trampoline_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "177-204",
          "snippet": "int module_trampoline_target(struct module *mod, u32 *trampoline,\n\t\t\t     unsigned long *target)\n{\n\tu32 buf[2];\n\tu16 upper, lower;\n\tlong offset;\n\tvoid *toc_entry;\n\n\tif (probe_kernel_read(buf, trampoline, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tupper = buf[0] & 0xffff;\n\tlower = buf[1] & 0xffff;\n\n\t/* perform the addis/addi, both signed */\n\toffset = ((short)upper << 16) + (short)lower;\n\n\t/*\n\t * Now get the address this trampoline jumps to. This\n\t * is always 32 bytes into our trampoline stub.\n\t */\n\ttoc_entry = (void *)mod->arch.toc + offset + 32;\n\n\tif (probe_kernel_read(target, toc_entry, sizeof(*target)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint module_trampoline_target(struct module *mod, u32 *trampoline,\n\t\t\t     unsigned long *target)\n{\n\tu32 buf[2];\n\tu16 upper, lower;\n\tlong offset;\n\tvoid *toc_entry;\n\n\tif (probe_kernel_read(buf, trampoline, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tupper = buf[0] & 0xffff;\n\tlower = buf[1] & 0xffff;\n\n\t/* perform the addis/addi, both signed */\n\toffset = ((short)upper << 16) + (short)lower;\n\n\t/*\n\t * Now get the address this trampoline jumps to. This\n\t * is always 32 bytes into our trampoline stub.\n\t */\n\ttoc_entry = (void *)mod->arch.toc + offset + 32;\n\n\tif (probe_kernel_read(target, toc_entry, sizeof(*target)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not a trampoline\\n\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_module_trampoline",
          "args": [
            "tramp"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "is_module_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "155-175",
          "snippet": "bool is_module_trampoline(u32 *p)\n{\n\tunsigned int i;\n\tu32 insns[ARRAY_SIZE(ppc64_stub_insns)];\n\n\tBUILD_BUG_ON(sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask));\n\n\tif (probe_kernel_read(insns, p, sizeof(insns)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppc64_stub_insns); i++) {\n\t\tu32 insna = insns[i];\n\t\tu32 insnb = ppc64_stub_insns[i];\n\t\tu32 mask = ppc64_stub_mask[i];\n\n\t\tif ((insna & mask) != (insnb & mask))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};\n\nbool is_module_trampoline(u32 *p)\n{\n\tunsigned int i;\n\tu32 insns[ARRAY_SIZE(ppc64_stub_insns)];\n\n\tBUILD_BUG_ON(sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask));\n\n\tif (probe_kernel_read(insns, p, sizeof(insns)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppc64_stub_insns); i++) {\n\t\tu32 insna = insns[i];\n\t\tu32 insnb = ppc64_stub_insns[i];\n\t\tu32 mask = ppc64_stub_mask[i];\n\n\t\tif ((insna & mask) != (insnb & mask))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %p\"",
            "ip",
            "tramp"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "92-102",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %x\\n\"",
            "op"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
          "lines": "87-90",
          "snippet": "static int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&op",
            "(void *)ip",
            "sizeof(int)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned int op;\n\tunsigned long entry, ptr;\n\tunsigned long ip = rec->ip;\n\tvoid *tramp;\n\n\t/* read where this goes */\n\tif (probe_kernel_read(&op, (void *)ip, sizeof(int)))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %x\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = (void *)find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %p\", ip, tramp);\n\n\tif (!is_module_trampoline(tramp)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Our original call site looks like:\n\t *\n\t * bl <tramp>\n\t * ld r2,XX(r1)\n\t *\n\t * Milton Miller pointed out that we can not simply nop the branch.\n\t * If a task was preempted when calling a trace function, the nops\n\t * will remove the way to restore the TOC in r2 and the r2 TOC will\n\t * get corrupted.\n\t *\n\t * Use a b +8 to jump over the load.\n\t */\n\top = 0x48000008;\t/* b +8 */\n\n\tif (patch_instruction((unsigned int *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_bl_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "92-102",
    "snippet": "static unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, unsigned int op)\n{\n\tstatic int offset;\n\n\toffset = (op & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
  },
  {
    "function_name": "is_bl_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "87-90",
    "snippet": "static int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(unsigned int op)\n{\n\treturn (op & 0xfc000003) == 0x48000001;\n}"
  },
  {
    "function_name": "test_24bit_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "77-83",
    "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "(unsigned int *)ip",
            "addr",
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch((unsigned int *)ip, addr, 0);\n}"
  },
  {
    "function_name": "ftrace_modify_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "44-72",
    "snippet": "static int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(unsigned int *)ip",
            "new"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&replaced",
            "(void *)ip",
            "MCOUNT_INSN_SIZE"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, unsigned int old, unsigned int new)\n{\n\tunsigned int replaced;\n\n\t/*\n\t * Note: Due to modules and __init, code can\n\t *  disappear and change, we need to protect against faulting\n\t *  as well as code changing. We do this by using the\n\t *  probe_kernel_* functions.\n\t *\n\t * No real locking needed, this code is run through\n\t * kstop_machine, or before SMP starts.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read(&replaced, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (replaced != old)\n\t\treturn -EINVAL;\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((unsigned int *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_call_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ftrace.c",
    "lines": "31-42",
    "snippet": "static unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
    "includes": [
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "(unsigned int *)ip",
            "addr",
            "link ? 1 : 0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned int\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tunsigned int op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\top = create_branch((unsigned int *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
  }
]