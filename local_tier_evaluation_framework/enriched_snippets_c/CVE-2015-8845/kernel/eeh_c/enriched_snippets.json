[
  {
    "function_name": "eeh_init_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1777-1792",
    "snippet": "static int __init eeh_init_proc(void)\n{\n\tif (machine_is(pseries) || machine_is(powernv)) {\n\t\tproc_create(\"powerpc/eeh\", 0, NULL, &proc_eeh_operations);\n#ifdef CONFIG_DEBUG_FS\n\t\tdebugfs_create_file(\"eeh_enable\", 0600,\n                                    powerpc_debugfs_root, NULL,\n                                    &eeh_enable_dbgfs_ops);\n\t\tdebugfs_create_file(\"eeh_max_freezes\", 0600,\n\t\t\t\t    powerpc_debugfs_root, NULL,\n\t\t\t\t    &eeh_freeze_dbgfs_ops);\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int eeh_max_freezes = 5;",
      "static const struct file_operations proc_eeh_operations = {\n\t.open      = proc_eeh_open,\n\t.read      = seq_read,\n\t.llseek    = seq_lseek,\n\t.release   = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"eeh_max_freezes\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_freeze_dbgfs_ops"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"eeh_enable\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_enable_dbgfs_ops"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/eeh\"",
            "0",
            "NULL",
            "&proc_eeh_operations"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powernv"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_max_freezes = 5;\nstatic const struct file_operations proc_eeh_operations = {\n\t.open      = proc_eeh_open,\n\t.read      = seq_read,\n\t.llseek    = seq_lseek,\n\t.release   = single_release,\n};\n\nstatic int __init eeh_init_proc(void)\n{\n\tif (machine_is(pseries) || machine_is(powernv)) {\n\t\tproc_create(\"powerpc/eeh\", 0, NULL, &proc_eeh_operations);\n#ifdef CONFIG_DEBUG_FS\n\t\tdebugfs_create_file(\"eeh_enable\", 0600,\n                                    powerpc_debugfs_root, NULL,\n                                    &eeh_enable_dbgfs_ops);\n\t\tdebugfs_create_file(\"eeh_max_freezes\", 0600,\n\t\t\t\t    powerpc_debugfs_root, NULL,\n\t\t\t\t    &eeh_freeze_dbgfs_ops);\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_freeze_dbgfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1765-1769",
    "snippet": "static int eeh_freeze_dbgfs_get(void *data, u64 *val)\n{\n\t*val = eeh_max_freezes;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int eeh_max_freezes = 5;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_max_freezes = 5;\n\nstatic int eeh_freeze_dbgfs_get(void *data, u64 *val)\n{\n\t*val = eeh_max_freezes;\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_freeze_dbgfs_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1759-1763",
    "snippet": "static int eeh_freeze_dbgfs_set(void *data, u64 val)\n{\n\teeh_max_freezes = val;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int eeh_max_freezes = 5;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_max_freezes = 5;\n\nstatic int eeh_freeze_dbgfs_set(void *data, u64 val)\n{\n\teeh_max_freezes = val;\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_enable_dbgfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1750-1757",
    "snippet": "static int eeh_enable_dbgfs_get(void *data, u64 *val)\n{\n\tif (eeh_enabled())\n\t\t*val = 0x1ul;\n\telse\n\t\t*val = 0x0ul;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int eeh_enable_dbgfs_get(void *data, u64 *val)\n{\n\tif (eeh_enabled())\n\t\t*val = 0x1ul;\n\telse\n\t\t*val = 0x0ul;\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_enable_dbgfs_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1736-1748",
    "snippet": "static int eeh_enable_dbgfs_set(void *data, u64 val)\n{\n\tif (val)\n\t\teeh_clear_flag(EEH_FORCE_DISABLED);\n\telse\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\n\t/* Notify the backend */\n\tif (eeh_ops->post_init)\n\t\teeh_ops->post_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->post_init",
          "args": [],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_clear_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic int eeh_enable_dbgfs_set(void *data, u64 val)\n{\n\tif (val)\n\t\teeh_clear_flag(EEH_FORCE_DISABLED);\n\telse\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\n\t/* Notify the backend */\n\tif (eeh_ops->post_init)\n\t\teeh_ops->post_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_eeh_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1723-1726",
    "snippet": "static int proc_eeh_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, proc_eeh_show, NULL);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "proc_eeh_show",
            "NULL"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int proc_eeh_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, proc_eeh_show, NULL);\n}"
  },
  {
    "function_name": "proc_eeh_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1696-1721",
    "snippet": "static int proc_eeh_show(struct seq_file *m, void *v)\n{\n\tif (!eeh_enabled()) {\n\t\tseq_printf(m, \"EEH Subsystem is globally disabled\\n\");\n\t\tseq_printf(m, \"eeh_total_mmio_ffs=%llu\\n\", eeh_stats.total_mmio_ffs);\n\t} else {\n\t\tseq_printf(m, \"EEH Subsystem is enabled\\n\");\n\t\tseq_printf(m,\n\t\t\t\t\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\",\n\t\t\t\teeh_stats.no_device,\n\t\t\t\teeh_stats.no_dn,\n\t\t\t\teeh_stats.no_cfg_addr,\n\t\t\t\teeh_stats.ignored_check,\n\t\t\t\teeh_stats.total_mmio_ffs,\n\t\t\t\teeh_stats.false_positives,\n\t\t\t\teeh_stats.slot_resets);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\"",
            "eeh_stats.no_device",
            "eeh_stats.no_dn",
            "eeh_stats.no_cfg_addr",
            "eeh_stats.ignored_check",
            "eeh_stats.total_mmio_ffs",
            "eeh_stats.false_positives",
            "eeh_stats.slot_resets"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EEH Subsystem is enabled\\n\""
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"eeh_total_mmio_ffs=%llu\\n\"",
            "eeh_stats.total_mmio_ffs"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EEH Subsystem is globally disabled\\n\""
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic struct eeh_stats eeh_stats;\n\nstatic int proc_eeh_show(struct seq_file *m, void *v)\n{\n\tif (!eeh_enabled()) {\n\t\tseq_printf(m, \"EEH Subsystem is globally disabled\\n\");\n\t\tseq_printf(m, \"eeh_total_mmio_ffs=%llu\\n\", eeh_stats.total_mmio_ffs);\n\t} else {\n\t\tseq_printf(m, \"EEH Subsystem is enabled\\n\");\n\t\tseq_printf(m,\n\t\t\t\t\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\",\n\t\t\t\teeh_stats.no_device,\n\t\t\t\teeh_stats.no_dn,\n\t\t\t\teeh_stats.no_cfg_addr,\n\t\t\t\teeh_stats.ignored_check,\n\t\t\t\teeh_stats.total_mmio_ffs,\n\t\t\t\teeh_stats.false_positives,\n\t\t\t\teeh_stats.slot_resets);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_inject_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1673-1693",
    "snippet": "int eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,\n\t\t      unsigned long addr, unsigned long mask)\n{\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/* Unsupported operation ? */\n\tif (!eeh_ops || !eeh_ops->err_inject)\n\t\treturn -ENOENT;\n\n\t/* Check on PCI error type */\n\tif (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)\n\t\treturn -EINVAL;\n\n\t/* Check on PCI error function */\n\tif (func < EEH_ERR_FUNC_MIN || func > EEH_ERR_FUNC_MAX)\n\t\treturn -EINVAL;\n\n\treturn eeh_ops->err_inject(pe, type, func, addr, mask);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->err_inject",
          "args": [
            "pe",
            "type",
            "func",
            "addr",
            "mask"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,\n\t\t      unsigned long addr, unsigned long mask)\n{\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/* Unsupported operation ? */\n\tif (!eeh_ops || !eeh_ops->err_inject)\n\t\treturn -ENOENT;\n\n\t/* Check on PCI error type */\n\tif (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)\n\t\treturn -EINVAL;\n\n\t/* Check on PCI error function */\n\tif (func < EEH_ERR_FUNC_MIN || func > EEH_ERR_FUNC_MAX)\n\t\treturn -EINVAL;\n\n\treturn eeh_ops->err_inject(pe, type, func, addr, mask);\n}"
  },
  {
    "function_name": "eeh_pe_configure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1649-1658",
    "snippet": "int eeh_pe_configure(struct eeh_pe *pe)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_pe_configure(struct eeh_pe *pe)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1599-1638",
    "snippet": "int eeh_pe_reset(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Unsupported option %d\\n\"",
            "__func__",
            "option"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "option"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_reenable_devices",
          "args": [
            "pe"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reenable_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1560-1588",
          "snippet": "static int eeh_pe_reenable_devices(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\t/* Restore config space */\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\treturn eeh_unfreeze_pe(pe, true);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_reenable_devices(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\t/* Restore config space */\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\treturn eeh_unfreeze_pe(pe, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "option"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_reset(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_reenable_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1560-1588",
    "snippet": "static int eeh_pe_reenable_devices(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\t/* Restore config space */\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\treturn eeh_unfreeze_pe(pe, true);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe",
            "true"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1265-1288",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d reenabling %s\\n\"",
            "__func__",
            "ret",
            "pci_name(pdev)"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_reenable_device",
          "args": [
            "pdev"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "865-872",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_reenable_devices(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\t/* Restore config space */\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\treturn eeh_unfreeze_pe(pe, true);\n}"
  },
  {
    "function_name": "eeh_pe_get_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1528-1557",
    "snippet": "int eeh_pe_get_state(struct eeh_pe *pe)\n{\n\tint result, ret = 0;\n\tbool rst_active, dma_en, mmio_en;\n\n\t/* Existing PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->get_state)\n\t\treturn -ENOENT;\n\n\tresult = eeh_ops->get_state(pe, NULL);\n\trst_active = !!(result & EEH_STATE_RESET_ACTIVE);\n\tdma_en = !!(result & EEH_STATE_DMA_ENABLED);\n\tmmio_en = !!(result & EEH_STATE_MMIO_ENABLED);\n\n\tif (rst_active)\n\t\tret = EEH_PE_STATE_RESET;\n\telse if (dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_NORMAL;\n\telse if (!dma_en && !mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_IO_DMA;\n\telse if (!dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_DMA;\n\telse\n\t\tret = EEH_PE_STATE_UNAVAIL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_get_state(struct eeh_pe *pe)\n{\n\tint result, ret = 0;\n\tbool rst_active, dma_en, mmio_en;\n\n\t/* Existing PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->get_state)\n\t\treturn -ENOENT;\n\n\tresult = eeh_ops->get_state(pe, NULL);\n\trst_active = !!(result & EEH_STATE_RESET_ACTIVE);\n\tdma_en = !!(result & EEH_STATE_DMA_ENABLED);\n\tmmio_en = !!(result & EEH_STATE_MMIO_ENABLED);\n\n\tif (rst_active)\n\t\tret = EEH_PE_STATE_RESET;\n\telse if (dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_NORMAL;\n\telse if (!dma_en && !mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_IO_DMA;\n\telse if (!dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_DMA;\n\telse\n\t\tret = EEH_PE_STATE_UNAVAIL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_set_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1479-1518",
    "snippet": "int eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Option %d out of range (%d, %d)\\n\"",
            "__func__",
            "option",
            "EEH_OPT_DISABLE",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "option"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "623-690",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "pe"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1298-1343",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_iommu_group_to_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1446-1466",
    "snippet": "struct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct eeh_dev *edev;\n\tint ret;\n\n\t/* No IOMMU group ? */\n\tif (!group)\n\t\treturn NULL;\n\n\tret = iommu_group_for_each_dev(group, &pdev, dev_has_iommu_table);\n\tif (!ret || !pdev)\n\t\treturn NULL;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\treturn NULL;\n\n\treturn edev->pe;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_for_each_dev",
          "args": [
            "group",
            "&pdev",
            "dev_has_iommu_table"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct eeh_dev *edev;\n\tint ret;\n\n\t/* No IOMMU group ? */\n\tif (!group)\n\t\treturn NULL;\n\n\tret = iommu_group_for_each_dev(group, &pdev, dev_has_iommu_table);\n\tif (!ret || !pdev)\n\t\treturn NULL;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\treturn NULL;\n\n\treturn edev->pe;\n}"
  },
  {
    "function_name": "dev_has_iommu_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1424-1438",
    "snippet": "static int dev_has_iommu_table(struct device *dev, void *data)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_dev **ppdev = data;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->iommu_group) {\n\t\t*ppdev = pdev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int dev_has_iommu_table(struct device *dev, void *data)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_dev **ppdev = data;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->iommu_group) {\n\t\t*ppdev = pdev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_dev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1399-1419",
    "snippet": "void eeh_dev_release(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe || !eeh_pe_passed(edev->pe))\n\t\tgoto out;\n\n\t/* Decrease PE's pass through count */\n\tWARN_ON(atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0);\n\teeh_pe_change_owner(edev->pe);\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(eeh_dev_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "edev->pe"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1298-1343",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&edev->pe->pass_dev_cnt"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "edev->pe"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic DEFINE_MUTEX(eeh_dev_mutex);\n\nvoid eeh_dev_release(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe || !eeh_pe_passed(edev->pe))\n\t\tgoto out;\n\n\t/* Decrease PE's pass through count */\n\tWARN_ON(atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0);\n\teeh_pe_change_owner(edev->pe);\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n}"
  },
  {
    "function_name": "eeh_dev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1354-1388",
    "snippet": "int eeh_dev_open(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\tgoto out;\n\n\t/*\n\t * The PE might have been put into frozen state, but we\n\t * didn't detect that yet. The passed through PCI devices\n\t * in frozen PE won't work properly. Clear the frozen state\n\t * in advance.\n\t */\n\tret = eeh_pe_change_owner(edev->pe);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Increase PE's pass through count */\n\tatomic_inc(&edev->pe->pass_dev_cnt);\n\tmutex_unlock(&eeh_dev_mutex);\n\n\treturn 0;\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(eeh_dev_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&edev->pe->pass_dev_cnt"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "edev->pe"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1298-1343",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic DEFINE_MUTEX(eeh_dev_mutex);\n\nint eeh_dev_open(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\tgoto out;\n\n\t/*\n\t * The PE might have been put into frozen state, but we\n\t * didn't detect that yet. The passed through PCI devices\n\t * in frozen PE won't work properly. Clear the frozen state\n\t * in advance.\n\t */\n\tret = eeh_pe_change_owner(edev->pe);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Increase PE's pass through count */\n\tatomic_inc(&edev->pe->pass_dev_cnt);\n\tmutex_unlock(&eeh_dev_mutex);\n\n\treturn 0;\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_change_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1298-1343",
    "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_reset_and_recover",
          "args": [
            "pe"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reset_and_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "494-538",
          "snippet": "int eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint result, ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Report error */\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\n\t/* Issue reset */\n\tret = eeh_reset_pe(pe);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Notify completion of reset */\n\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Resume */\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nint eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint result, ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Report error */\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\n\t/* Issue reset */\n\tret = eeh_reset_pe(pe);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Notify completion of reset */\n\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Resume */\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe",
            "true"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1265-1288",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint flags, ret;\n\n\t/* Check PE state */\n\tflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif ((ret & flags) == flags)\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\tgoto reset;\n\t\t}\n\t}\n\n\treturn eeh_unfreeze_pe(pe, true);\n\nreset:\n\treturn eeh_pe_reset_and_recover(pe);\n}"
  },
  {
    "function_name": "eeh_unfreeze_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1265-1288",
    "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\"",
            "__func__",
            "ret",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "623-690",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\"",
            "__func__",
            "ret",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_remove_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1223-1263",
    "snippet": "void eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tpr_debug(\"EEH: Removing device %s\\n\", pci_name(dev));\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tpr_debug(\"EEH: Not referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_rmv_from_parent_pe(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\teeh_sysfs_remove_device(dev);\n\tedev->mode &= ~EEH_DEV_SYSFS;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_sysfs_remove_device",
          "args": [
            "dev"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "116-137",
          "snippet": "void eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd) {\n\t\tif (edev)\n\t\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\t\treturn;\n\t}\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (edev)\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd) {\n\t\tif (edev)\n\t\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\t\treturn;\n\t}\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (edev)\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_rmv_dev",
          "args": [
            "dev"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "262-269",
          "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_rmv_from_parent_pe",
          "args": [
            "edev"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_rmv_from_parent_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "439-498",
          "snippet": "int eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Not referenced !\\n\""
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Removing device %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tpr_debug(\"EEH: Removing device %s\\n\", pci_name(dev));\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tpr_debug(\"EEH: Not referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_rmv_from_parent_pe(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\teeh_sysfs_remove_device(dev);\n\tedev->mode &= ~EEH_DEV_SYSFS;\n}"
  },
  {
    "function_name": "eeh_add_sysfs_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1198-1210",
    "snippet": "void eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_sysfs_files",
          "args": [
            "subbus"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_sysfs_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1198-1210",
          "snippet": "void eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "eeh_sysfs_add_device",
          "args": [
            "dev"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "94-114",
          "snippet": "void eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_add_device_tree_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1175-1187",
    "snippet": "void eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_device_tree_late",
          "args": [
            "subbus"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1175-1187",
          "snippet": "void eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "eeh_add_device_late",
          "args": [
            "dev"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1118-1165",
          "snippet": "void eeh_add_device_late(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (edev->pdev == dev) {\n\t\tpr_debug(\"EEH: Already referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The EEH cache might not be removed correctly because of\n\t * unbalanced kref to the device during unplug time, which\n\t * relies on pcibios_release_device(). So we have to remove\n\t * that here explicitly.\n\t */\n\tif (edev->pdev) {\n\t\teeh_rmv_from_parent_pe(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\t\tedev->pdev = NULL;\n\t\tdev->dev.archdata.edev = NULL;\n\t}\n\n\tif (eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\teeh_ops->probe(pdn, NULL);\n\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\n\teeh_addr_cache_insert_dev(dev);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_add_device_late(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (edev->pdev == dev) {\n\t\tpr_debug(\"EEH: Already referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The EEH cache might not be removed correctly because of\n\t * unbalanced kref to the device during unplug time, which\n\t * relies on pcibios_release_device(). So we have to remove\n\t * that here explicitly.\n\t */\n\tif (edev->pdev) {\n\t\teeh_rmv_from_parent_pe(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\t\tedev->pdev = NULL;\n\t\tdev->dev.archdata.edev = NULL;\n\t}\n\n\tif (eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\teeh_ops->probe(pdn, NULL);\n\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\n\teeh_addr_cache_insert_dev(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_add_device_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1118-1165",
    "snippet": "void eeh_add_device_late(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (edev->pdev == dev) {\n\t\tpr_debug(\"EEH: Already referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The EEH cache might not be removed correctly because of\n\t * unbalanced kref to the device during unplug time, which\n\t * relies on pcibios_release_device(). So we have to remove\n\t * that here explicitly.\n\t */\n\tif (edev->pdev) {\n\t\teeh_rmv_from_parent_pe(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\t\tedev->pdev = NULL;\n\t\tdev->dev.archdata.edev = NULL;\n\t}\n\n\tif (eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\teeh_ops->probe(pdn, NULL);\n\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\n\teeh_addr_cache_insert_dev(dev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_addr_cache_insert_dev",
          "args": [
            "dev"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_insert_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "221-232",
          "snippet": "void eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->probe",
          "args": [
            "pdn",
            "NULL"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_PROBE_MODE_DEV"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_sysfs_remove_device",
          "args": [
            "edev->pdev"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "116-137",
          "snippet": "void eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd) {\n\t\tif (edev)\n\t\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\t\treturn;\n\t}\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (edev)\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd) {\n\t\tif (edev)\n\t\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\t\treturn;\n\t}\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (edev)\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_rmv_dev",
          "args": [
            "edev->pdev"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "262-269",
          "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_rmv_from_parent_pe",
          "args": [
            "edev"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_rmv_from_parent_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "439-498",
          "snippet": "int eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Already referenced !\\n\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_pdn_by_devfn",
          "args": [
            "dev->bus",
            "dev->devfn"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Adding device %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_add_device_late(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (edev->pdev == dev) {\n\t\tpr_debug(\"EEH: Already referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The EEH cache might not be removed correctly because of\n\t * unbalanced kref to the device during unplug time, which\n\t * relies on pcibios_release_device(). So we have to remove\n\t * that here explicitly.\n\t */\n\tif (edev->pdev) {\n\t\teeh_rmv_from_parent_pe(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\t\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\t\tedev->pdev = NULL;\n\t\tdev->dev.archdata.edev = NULL;\n\t}\n\n\tif (eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\teeh_ops->probe(pdn, NULL);\n\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\n\teeh_addr_cache_insert_dev(dev);\n}"
  },
  {
    "function_name": "eeh_add_device_tree_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1098-1108",
    "snippet": "void eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_device_early",
          "args": [
            "pdn"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1070-1088",
          "snippet": "void eeh_add_device_early(struct pci_dn *pdn)\n{\n\tstruct pci_controller *phb;\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (!edev || !eeh_enabled())\n\t\treturn;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))\n\t\treturn;\n\n\t/* USB Bus children of PCI devices will not have BUID's */\n\tphb = edev->phb;\n\tif (NULL == phb ||\n\t    (eeh_has_flag(EEH_PROBE_MODE_DEVTREE) && 0 == phb->buid))\n\t\treturn;\n\n\teeh_ops->probe(pdn, NULL);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_add_device_early(struct pci_dn *pdn)\n{\n\tstruct pci_controller *phb;\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (!edev || !eeh_enabled())\n\t\treturn;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))\n\t\treturn;\n\n\t/* USB Bus children of PCI devices will not have BUID's */\n\tphb = edev->phb;\n\tif (NULL == phb ||\n\t    (eeh_has_flag(EEH_PROBE_MODE_DEVTREE) && 0 == phb->buid))\n\t\treturn;\n\n\teeh_ops->probe(pdn, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_add_device_tree_early",
          "args": [
            "n"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1098-1108",
          "snippet": "void eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&pdn->child_list",
            "list"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}"
  },
  {
    "function_name": "eeh_add_device_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1070-1088",
    "snippet": "void eeh_add_device_early(struct pci_dn *pdn)\n{\n\tstruct pci_controller *phb;\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (!edev || !eeh_enabled())\n\t\treturn;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))\n\t\treturn;\n\n\t/* USB Bus children of PCI devices will not have BUID's */\n\tphb = edev->phb;\n\tif (NULL == phb ||\n\t    (eeh_has_flag(EEH_PROBE_MODE_DEVTREE) && 0 == phb->buid))\n\t\treturn;\n\n\teeh_ops->probe(pdn, NULL);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->probe",
          "args": [
            "pdn",
            "NULL"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_PROBE_MODE_DEVTREE"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_PROBE_MODE_DEVTREE"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_add_device_early(struct pci_dn *pdn)\n{\n\tstruct pci_controller *phb;\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (!edev || !eeh_enabled())\n\t\treturn;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))\n\t\treturn;\n\n\t/* USB Bus children of PCI devices will not have BUID's */\n\tphb = edev->phb;\n\tif (NULL == phb ||\n\t    (eeh_has_flag(EEH_PROBE_MODE_DEVTREE) && 0 == phb->buid))\n\t\treturn;\n\n\teeh_ops->probe(pdn, NULL);\n}"
  },
  {
    "function_name": "eeh_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "994-1054",
    "snippet": "int eeh_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tstruct pci_dn *pdn;\n\tstatic int cnt = 0;\n\tint ret = 0;\n\n\t/*\n\t * We have to delay the initialization on PowerNV after\n\t * the PCI hierarchy tree has been built because the PEs\n\t * are figured out based on PCI devices instead of device\n\t * tree nodes\n\t */\n\tif (machine_is(powernv) && cnt++ <= 0)\n\t\treturn ret;\n\n\t/* Register reboot notifier */\n\tret = register_reboot_notifier(&eeh_reboot_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t/* call platform initialization function */\n\tif (!eeh_ops) {\n\t\tpr_warn(\"%s: Platform EEH operation not found\\n\",\n\t\t\t__func__);\n\t\treturn -EEXIST;\n\t} else if ((ret = eeh_ops->init()))\n\t\treturn ret;\n\n\t/* Initialize EEH event */\n\tret = eeh_event_init();\n\tif (ret)\n\t\treturn ret;\n\n\t/* Enable EEH for all adapters */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tpdn = hose->pci_data;\n\t\ttraverse_pci_dn(pdn, eeh_ops->probe, NULL);\n\t}\n\n\t/*\n\t * Call platform post-initialization. Actually, It's good chance\n\t * to inform platform that EEH is ready to supply service if the\n\t * I/O cache stuff has been built up.\n\t */\n\tif (eeh_ops->post_init) {\n\t\tret = eeh_ops->post_init();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (eeh_enabled())\n\t\tpr_info(\"EEH: PCI Enhanced I/O Error Handling Enabled\\n\");\n\telse\n\t\tpr_warn(\"EEH: No capable adapters found\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct notifier_block eeh_reboot_nb = {\n\t.notifier_call = eeh_reboot_notifier,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: No capable adapters found\\n\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: PCI Enhanced I/O Error Handling Enabled\\n\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->post_init",
          "args": [],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverse_pci_dn",
          "args": [
            "pdn",
            "eeh_ops->probe",
            "NULL"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "traverse_pci_dn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "400-416",
          "snippet": "void *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_event_init",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "102-119",
          "snippet": "int eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\t/* Initialize semaphore */\n\tsema_init(&eeh_eventlist_sem, 0);\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct semaphore eeh_eventlist_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic struct semaphore eeh_eventlist_sem;\n\nint eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\t/* Initialize semaphore */\n\tsema_init(&eeh_eventlist_sem, 0);\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->init",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Platform EEH operation not found\\n\"",
            "__func__"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failed to register notifier (%d)\\n\"",
            "__func__",
            "ret"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_reboot_notifier",
          "args": [
            "&eeh_reboot_nb"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powernv"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct notifier_block eeh_reboot_nb = {\n\t.notifier_call = eeh_reboot_notifier,\n};\n\nint eeh_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tstruct pci_dn *pdn;\n\tstatic int cnt = 0;\n\tint ret = 0;\n\n\t/*\n\t * We have to delay the initialization on PowerNV after\n\t * the PCI hierarchy tree has been built because the PEs\n\t * are figured out based on PCI devices instead of device\n\t * tree nodes\n\t */\n\tif (machine_is(powernv) && cnt++ <= 0)\n\t\treturn ret;\n\n\t/* Register reboot notifier */\n\tret = register_reboot_notifier(&eeh_reboot_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t/* call platform initialization function */\n\tif (!eeh_ops) {\n\t\tpr_warn(\"%s: Platform EEH operation not found\\n\",\n\t\t\t__func__);\n\t\treturn -EEXIST;\n\t} else if ((ret = eeh_ops->init()))\n\t\treturn ret;\n\n\t/* Initialize EEH event */\n\tret = eeh_event_init();\n\tif (ret)\n\t\treturn ret;\n\n\t/* Enable EEH for all adapters */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tpdn = hose->pci_data;\n\t\ttraverse_pci_dn(pdn, eeh_ops->probe, NULL);\n\t}\n\n\t/*\n\t * Call platform post-initialization. Actually, It's good chance\n\t * to inform platform that EEH is ready to supply service if the\n\t * I/O cache stuff has been built up.\n\t */\n\tif (eeh_ops->post_init) {\n\t\tret = eeh_ops->post_init();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (eeh_enabled())\n\t\tpr_info(\"EEH: PCI Enhanced I/O Error Handling Enabled\\n\");\n\telse\n\t\tpr_warn(\"EEH: No capable adapters found\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_reboot_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "968-973",
    "snippet": "static int eeh_reboot_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *unused)\n{\n\teeh_clear_flag(EEH_ENABLED);\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_clear_flag",
          "args": [
            "EEH_ENABLED"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int eeh_reboot_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *unused)\n{\n\teeh_clear_flag(EEH_ENABLED);\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "eeh_ops_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "952-966",
    "snippet": "int __exit eeh_ops_unregister(const char *name)\n{\n\tif (!name || !strlen(name)) {\n\t\tpr_warn(\"%s: Invalid EEH ops name\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (eeh_ops && !strcmp(eeh_ops->name, name)) {\n\t\teeh_ops = NULL;\n\t\treturn 0;\n\t}\n\n\treturn -EEXIST;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "eeh_ops->name",
            "name"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid EEH ops name\\n\"",
            "__func__"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint __exit eeh_ops_unregister(const char *name)\n{\n\tif (!name || !strlen(name)) {\n\t\tpr_warn(\"%s: Invalid EEH ops name\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (eeh_ops && !strcmp(eeh_ops->name, name)) {\n\t\teeh_ops = NULL;\n\t\treturn 0;\n\t}\n\n\treturn -EEXIST;\n}"
  },
  {
    "function_name": "eeh_ops_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "926-943",
    "snippet": "int __init eeh_ops_register(struct eeh_ops *ops)\n{\n\tif (!ops->name) {\n\t\tpr_warn(\"%s: Invalid EEH ops name for %p\\n\",\n\t\t\t__func__, ops);\n\t\treturn -EINVAL;\n\t}\n\n\tif (eeh_ops && eeh_ops != ops) {\n\t\tpr_warn(\"%s: EEH ops of platform %s already existing (%s)\\n\",\n\t\t\t__func__, eeh_ops->name, ops->name);\n\t\treturn -EEXIST;\n\t}\n\n\teeh_ops = ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: EEH ops of platform %s already existing (%s)\\n\"",
            "__func__",
            "eeh_ops->name",
            "ops->name"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid EEH ops name for %p\\n\"",
            "__func__",
            "ops"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint __init eeh_ops_register(struct eeh_ops *ops)\n{\n\tif (!ops->name) {\n\t\tpr_warn(\"%s: Invalid EEH ops name for %p\\n\",\n\t\t\t__func__, ops);\n\t\treturn -EINVAL;\n\t}\n\n\tif (eeh_ops && eeh_ops != ops) {\n\t\tpr_warn(\"%s: EEH ops of platform %s already existing (%s)\\n\",\n\t\t\t__func__, eeh_ops->name, ops->name);\n\t\treturn -EEXIST;\n\t}\n\n\teeh_ops = ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_save_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "896-916",
    "snippet": "void eeh_save_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn;\n\tint i;\n\n\tpdn = eeh_dev_to_pdn(edev);\n\tif (!pdn)\n\t\treturn;\n\n\tfor (i = 0; i < 16; i++)\n\t\teeh_ops->read_config(pdn, i * 4, 4, &edev->config_space[i]);\n\n\t/*\n\t * For PCI bridges including root port, we need enable bus\n\t * master explicitly. Otherwise, it can't fetch IODA table\n\t * entries correctly. So we cache the bit in advance so that\n\t * we can restore it after reset, either PHB range or PE range.\n\t */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\tedev->config_space[1] |= PCI_COMMAND_MASTER;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "i * 4",
            "4",
            "&edev->config_space[i]"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_save_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn;\n\tint i;\n\n\tpdn = eeh_dev_to_pdn(edev);\n\tif (!pdn)\n\t\treturn;\n\n\tfor (i = 0; i < 16; i++)\n\t\teeh_ops->read_config(pdn, i * 4, 4, &edev->config_space[i]);\n\n\t/*\n\t * For PCI bridges including root port, we need enable bus\n\t * master explicitly. Otherwise, it can't fetch IODA table\n\t * entries correctly. So we cache the bit in advance so that\n\t * we can restore it after reset, either PHB range or PE range.\n\t */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\tedev->config_space[1] |= PCI_COMMAND_MASTER;\n}"
  },
  {
    "function_name": "eeh_reset_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "847-885",
    "snippet": "int eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
    ],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RESET | EEH_PE_CFG_BLOCKED"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\"",
            "__func__",
            "state",
            "pe->phb->global_number",
            "pe->addr",
            "(i + 1)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\"",
            "__func__",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->wait_state",
          "args": [
            "pe",
            "PCI_BUS_RESET_WAIT_MSEC"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_reset_pe_once",
          "args": [
            "pe"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_reset_pe_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "819-837",
          "snippet": "static void eeh_reset_pe_once(struct eeh_pe *pe)\n{\n\tunsigned int freset = 0;\n\n\t/* Determine type of EEH reset required for\n\t * Partitionable Endpoint, a hot-reset (1)\n\t * or a fundamental reset (3).\n\t * A fundamental reset required by any device under\n\t * Partitionable Endpoint trumps hot-reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\telse\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\n\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void eeh_reset_pe_once(struct eeh_pe *pe)\n{\n\tunsigned int freset = 0;\n\n\t/* Determine type of EEH reset required for\n\t * Partitionable Endpoint, a hot-reset (1)\n\t * or a fundamental reset (3).\n\t * A fundamental reset required by any device under\n\t * Partitionable Endpoint trumps hot-reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\telse\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\n\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RESET | EEH_PE_CFG_BLOCKED"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_reset_pe_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "819-837",
    "snippet": "static void eeh_reset_pe_once(struct eeh_pe *pe)\n{\n\tunsigned int freset = 0;\n\n\t/* Determine type of EEH reset required for\n\t * Partitionable Endpoint, a hot-reset (1)\n\t * or a fundamental reset (3).\n\t * A fundamental reset required by any device under\n\t * Partitionable Endpoint trumps hot-reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\telse\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\n\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_DEACTIVATE"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_HOT"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_FUNDAMENTAL"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_set_dev_freset",
            "&freset"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void eeh_reset_pe_once(struct eeh_pe *pe)\n{\n\tunsigned int freset = 0;\n\n\t/* Determine type of EEH reset required for\n\t * Partitionable Endpoint, a hot-reset (1)\n\t * or a fundamental reset (3).\n\t * A fundamental reset required by any device under\n\t * Partitionable Endpoint trumps hot-reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\telse\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\n\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n}"
  },
  {
    "function_name": "eeh_set_dev_freset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "800-811",
    "snippet": "static void *eeh_set_dev_freset(void *data, void *flag)\n{\n\tstruct pci_dev *dev;\n\tunsigned int *freset = (unsigned int *)flag;\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\n\tdev = eeh_dev_to_pci_dev(edev);\n\tif (dev)\n\t\t*freset |= dev->needs_freset;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic void *eeh_set_dev_freset(void *data, void *flag)\n{\n\tstruct pci_dev *dev;\n\tunsigned int *freset = (unsigned int *)flag;\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\n\tdev = eeh_dev_to_pci_dev(edev);\n\tif (dev)\n\t\t*freset |= dev->needs_freset;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pcibios_set_pcie_reset_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "749-788",
    "snippet": "int pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\tstruct eeh_pe *pe = eeh_dev_to_pe(edev);\n\n\tif (!pe) {\n\t\tpr_err(\"%s: No PE found on PCI device %s\\n\",\n\t\t\t__func__, pci_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state) {\n\tcase pcie_deassert_reset:\n\t\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n\t\teeh_unfreeze_pe(pe, false);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\tbreak;\n\tcase pcie_hot_reset:\n\t\teeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\t\tbreak;\n\tcase pcie_warm_reset:\n\t\teeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\t\tbreak;\n\tdefault:\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED);\n\t\treturn -EINVAL;\n\t};\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_FUNDAMENTAL"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_disable_and_save_dev_state",
            "dev"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_HOT"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe",
            "false"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1265-1288",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_DEACTIVATE"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: No PE found on PCI device %s\\n\"",
            "__func__",
            "pci_name(dev)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\tstruct eeh_pe *pe = eeh_dev_to_pe(edev);\n\n\tif (!pe) {\n\t\tpr_err(\"%s: No PE found on PCI device %s\\n\",\n\t\t\t__func__, pci_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state) {\n\tcase pcie_deassert_reset:\n\t\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n\t\teeh_unfreeze_pe(pe, false);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\tbreak;\n\tcase pcie_hot_reset:\n\t\teeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\t\tbreak;\n\tcase pcie_warm_reset:\n\t\teeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\t\tbreak;\n\tdefault:\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED);\n\t\treturn -EINVAL;\n\t};\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_restore_dev_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "720-739",
    "snippet": "static void *eeh_restore_dev_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\t/* Apply customization from firmware */\n\tif (pdn && eeh_ops->restore_config)\n\t\teeh_ops->restore_config(pdn);\n\n\t/* The caller should restore state for the specified device */\n\tif (pdev != dev)\n\t\tpci_restore_state(pdev);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_restore_state",
          "args": [
            "pdev"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->restore_config",
          "args": [
            "pdn"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void *eeh_restore_dev_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\t/* Apply customization from firmware */\n\tif (pdn && eeh_ops->restore_config)\n\t\teeh_ops->restore_config(pdn);\n\n\t/* The caller should restore state for the specified device */\n\tif (pdev != dev)\n\t\tpci_restore_state(pdev);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_disable_and_save_dev_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "692-718",
    "snippet": "static void *eeh_disable_and_save_dev_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\t/*\n\t * The caller should have disabled and saved the\n\t * state for the specified device\n\t */\n\tif (!pdev || pdev == dev)\n\t\treturn NULL;\n\n\t/* Ensure we have D0 power state */\n\tpci_set_power_state(pdev, PCI_D0);\n\n\t/* Save device state */\n\tpci_save_state(pdev);\n\n\t/*\n\t * Disable device to avoid any DMA traffic and\n\t * interrupt from the device\n\t */\n\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config_word",
          "args": [
            "pdev",
            "PCI_COMMAND",
            "PCI_COMMAND_INTX_DISABLE"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_save_state",
          "args": [
            "pdev"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_set_power_state",
          "args": [
            "pdev",
            "PCI_D0"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic void *eeh_disable_and_save_dev_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\t/*\n\t * The caller should have disabled and saved the\n\t * state for the specified device\n\t */\n\tif (!pdev || pdev == dev)\n\t\treturn NULL;\n\n\t/* Ensure we have D0 power state */\n\tpci_set_power_state(pdev, PCI_D0);\n\n\t/* Save device state */\n\tpci_save_state(pdev);\n\n\t/*\n\t * Disable device to avoid any DMA traffic and\n\t * interrupt from the device\n\t */\n\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pci_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "623-690",
    "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
    ],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->wait_state",
          "args": [
            "pe",
            "PCI_BUS_RESET_WAIT_MSEC"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\"",
            "__func__",
            "function",
            "pe->phb->global_number",
            "pe->addr",
            "rc"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "function"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid function %d\\n\"",
            "__func__",
            "function"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "597-611",
    "snippet": "int eeh_check_failure(const volatile void __iomem *token)\n{\n\tunsigned long addr;\n\tstruct eeh_dev *edev;\n\n\t/* Finding the phys addr + pci device; this is pretty quick. */\n\taddr = eeh_token_to_phys((unsigned long __force) token);\n\tedev = eeh_addr_cache_get_dev(addr);\n\tif (!edev) {\n\t\teeh_stats.no_device++;\n\t\treturn 0;\n\t}\n\n\treturn eeh_dev_check_failure(edev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_check_failure",
          "args": [
            "edev"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "432-582",
          "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_MAX_FAILS\t2100000"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct eeh_stats eeh_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_get_dev",
          "args": [
            "addr"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_get_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "92-101",
          "snippet": "struct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstruct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_token_to_phys",
          "args": [
            "(unsigned long __force) token"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_token_to_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "343-362",
          "snippet": "static inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = __find_linux_pte_or_hugepte(init_mm.pgd, token,\n\t\t\t\t\t   NULL, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\tWARN_ON(hugepage_shift);\n\tpa = pte_pfn(*ptep) << PAGE_SHIFT;\n\n\treturn pa | (token & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = __find_linux_pte_or_hugepte(init_mm.pgd, token,\n\t\t\t\t\t   NULL, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\tWARN_ON(hugepage_shift);\n\tpa = pte_pfn(*ptep) << PAGE_SHIFT;\n\n\treturn pa | (token & (PAGE_SIZE-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic struct eeh_stats eeh_stats;\n\nint eeh_check_failure(const volatile void __iomem *token)\n{\n\tunsigned long addr;\n\tstruct eeh_dev *edev;\n\n\t/* Finding the phys addr + pci device; this is pretty quick. */\n\taddr = eeh_token_to_phys((unsigned long __force) token);\n\tedev = eeh_addr_cache_get_dev(addr);\n\tif (!edev) {\n\t\teeh_stats.no_device++;\n\t\treturn 0;\n\t}\n\n\treturn eeh_dev_check_failure(edev);\n}"
  },
  {
    "function_name": "eeh_dev_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "432-582",
    "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define EEH_MAX_FAILS\t2100000"
    ],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_send_failure_event",
          "args": [
            "pe"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "129-150",
          "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
            "static struct semaphore eeh_eventlist_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic struct semaphore eeh_eventlist_sem;\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: PE location: %s, PHB location: %s\\n\"",
            "eeh_pe_loc_get(pe)",
            "eeh_pe_loc_get(phb_pe)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_loc_get",
          "args": [
            "phb_pe"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_loc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "883-912",
          "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Frozen PHB#%x-PE#%x detected\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "pe->phb"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "120-135",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_ISOLATED"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "parent_pe",
            "NULL"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\"",
            "eeh_driver_name(dev)"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_driver_name",
          "args": [
            "dev"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\"",
            "pe->check_count",
            "location ? location : \"unknown\"",
            "eeh_driver_name(dev)",
            "eeh_pci_name(dev)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_name",
          "args": [
            "dev"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_driver_name",
          "args": [
            "dev"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "pdn->node",
            "\"ibm,loc-code\"",
            "NULL"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_check_failure",
          "args": [
            "pe"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "369-416",
          "snippet": "static int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%d\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    (ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\n\t    (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\tpr_err(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\teeh_send_failure_event(phb_pe);\n\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%d\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    (ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\n\t    (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\tpr_err(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\teeh_send_failure_event(phb_pe);\n\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Ignored check for %s\\n\"",
            "eeh_pci_name(dev)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_name",
          "args": [
            "dev"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_phb_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "369-416",
    "snippet": "static int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%d\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    (ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\n\t    (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\tpr_err(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\teeh_send_failure_event(phb_pe);\n\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_send_failure_event",
          "args": [
            "phb_pe"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "129-150",
          "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
            "static struct semaphore eeh_eventlist_sem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic struct semaphore eeh_eventlist_sem;\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: PHB#%x failure detected, location: %s\\n\"",
            "phb_pe->phb->global_number",
            "eeh_pe_loc_get(phb_pe)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_loc_get",
          "args": [
            "phb_pe"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_loc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "883-912",
          "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "phb_pe",
            "EEH_PE_ISOLATED"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "phb_pe",
            "NULL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s Can't find PE for PHB#%d\\n\"",
            "__func__",
            "pe->phb->global_number"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "pe->phb"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "120-135",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_PROBE_MODE_DEV"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%d\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    (ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\n\t    (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\tpr_err(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\teeh_send_failure_event(phb_pe);\n\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_token_to_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "343-362",
    "snippet": "static inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = __find_linux_pte_or_hugepte(init_mm.pgd, token,\n\t\t\t\t\t   NULL, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\tWARN_ON(hugepage_shift);\n\tpa = pte_pfn(*ptep) << PAGE_SHIFT;\n\n\treturn pa | (token & (PAGE_SIZE-1));\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hugepage_shift"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_linux_pte_or_hugepte",
          "args": [
            "init_mm.pgd",
            "token",
            "NULL",
            "&hugepage_shift"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = __find_linux_pte_or_hugepte(init_mm.pgd, token,\n\t\t\t\t\t   NULL, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\tWARN_ON(hugepage_shift);\n\tpa = pte_pfn(*ptep) << PAGE_SHIFT;\n\n\treturn pa | (token & (PAGE_SIZE-1));\n}"
  },
  {
    "function_name": "eeh_slot_error_detail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "295-334",
    "snippet": "void eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->get_log",
          "args": [
            "pe",
            "severity",
            "pci_regs_buf",
            "loglen"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "eeh_dump_pe_log",
            "&loglen"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "865-872",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->configure_bridge",
          "args": [
            "pe"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_MMIO"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "623-690",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_ENABLE_IO_FOR_LOG"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}"
  },
  {
    "function_name": "eeh_dump_pe_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "265-283",
    "snippet": "static void *eeh_dump_pe_log(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = data;\n\tstruct eeh_dev *edev, *tmp;\n\tsize_t *plen = flag;\n\n\t/* If the PE's config space is blocked, 0xFF's will be\n\t * returned. It's pointless to collect the log in this\n\t * case.\n\t */\n\tif (pe->state & EEH_PE_CFG_BLOCKED)\n\t\treturn NULL;\n\n\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t*plen += eeh_dump_dev_log(edev, pci_regs_buf + *plen,\n\t\t\t\t\t  EEH_PCI_REGS_LOG_LEN - *plen);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define EEH_PCI_REGS_LOG_LEN 8192"
    ],
    "globals_used": [
      "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dump_dev_log",
          "args": [
            "edev",
            "pci_regs_buf + *plen",
            "EEH_PCI_REGS_LOG_LEN - *plen"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dump_dev_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "163-263",
          "snippet": "static size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x:%01x\\n\",\n\t\t       edev->phb->global_number, pdn->busno,\n\t\t       PCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x:%01x\\n\",\n\t\tedev->phb->global_number, pdn->busno,\n\t\tPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\n\teeh_ops->read_config(pdn, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(pdn, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(pdn, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x:%01x\\n\",\n\t\t       edev->phb->global_number, pdn->busno,\n\t\t       PCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x:%01x\\n\",\n\t\tedev->phb->global_number, pdn->busno,\n\t\tPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\n\teeh_ops->read_config(pdn, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(pdn, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(pdn, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define EEH_PCI_REGS_LOG_LEN 8192\n\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nstatic void *eeh_dump_pe_log(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = data;\n\tstruct eeh_dev *edev, *tmp;\n\tsize_t *plen = flag;\n\n\t/* If the PE's config space is blocked, 0xFF's will be\n\t * returned. It's pointless to collect the log in this\n\t * case.\n\t */\n\tif (pe->state & EEH_PE_CFG_BLOCKED)\n\t\treturn NULL;\n\n\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t*plen += eeh_dump_dev_log(edev, pci_regs_buf + *plen,\n\t\t\t\t\t  EEH_PCI_REGS_LOG_LEN - *plen);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_dump_dev_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "163-263",
    "snippet": "static size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x:%01x\\n\",\n\t\t       edev->phb->global_number, pdn->busno,\n\t\t       PCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x:%01x\\n\",\n\t\tedev->phb->global_number, pdn->busno,\n\t\tPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\n\teeh_ops->read_config(pdn, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(pdn, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(pdn, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer+l",
            "sizeof(buffer)-l",
            "\"%08x \"",
            "cfg"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"EEH: PCI-E AER %02x: %08x \"",
            "4*i",
            "cfg"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%02x:%x\\n\"",
            "4*i",
            "cfg"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap+4*i",
            "4",
            "&cfg"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-E AER capability register set follows:\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pci-e AER:\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer+l",
            "sizeof(buffer)-l",
            "\"%08x \"",
            "cfg"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"EEH: PCI-E %02x: %08x \"",
            "4*i",
            "cfg"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%02x:%x\\n\"",
            "4*i",
            "cfg"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap+4*i",
            "4",
            "&cfg"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-E capabilities and status follow:\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pci-e cap10:\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-X status: %08x\\n\"",
            "cfg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pcix-stat:%x\\n\"",
            "cfg"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap+4",
            "4",
            "&cfg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-X cmd: %08x\\n\"",
            "cfg"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pcix-cmd:%x\\n\"",
            "cfg"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap",
            "4",
            "&cfg"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Bridge control: %04x\\n\"",
            "cfg"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"brdg ctl:%x\\n\"",
            "cfg"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "PCI_BRIDGE_CONTROL",
            "2",
            "&cfg"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Bridge secondary status: %04x\\n\"",
            "cfg"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"sec stat:%x\\n\"",
            "cfg"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "PCI_SEC_STATUS",
            "2",
            "&cfg"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI cmd/status register: %08x\\n\"",
            "cfg"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"cmd/stat:%x\\n\"",
            "cfg"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "PCI_COMMAND",
            "4",
            "&cfg"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI device/vendor: %08x\\n\"",
            "cfg"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"dev/vend:%08x\\n\"",
            "cfg"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "PCI_VENDOR_ID",
            "4",
            "&cfg"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: of node=%04x:%02x:%02x:%01x\\n\"",
            "edev->phb->global_number",
            "pdn->busno",
            "PCI_SLOT(pdn->devfn)",
            "PCI_FUNC(pdn->devfn)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "pdn->devfn"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "pdn->devfn"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%04x:%02x:%02x:%01x\\n\"",
            "edev->phb->global_number",
            "pdn->busno",
            "PCI_SLOT(pdn->devfn)",
            "PCI_FUNC(pdn->devfn)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "pdn->devfn"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "pdn->devfn"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x:%01x\\n\",\n\t\t       edev->phb->global_number, pdn->busno,\n\t\t       PCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x:%01x\\n\",\n\t\tedev->phb->global_number, pdn->busno,\n\t\tPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\n\n\teeh_ops->read_config(pdn, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(pdn, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(pdn, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(pdn, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "eeh_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
    "lines": "147-155",
    "snippet": "static int __init eeh_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\telse if (!strcmp(str, \"early_log\"))\n\t\teeh_add_flag(EEH_EARLY_DUMP_LOG);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debug.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_EARLY_DUMP_LOG"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"early_log\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"off\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstatic int __init eeh_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\telse if (!strcmp(str, \"early_log\"))\n\t\teeh_add_flag(EEH_EARLY_DUMP_LOG);\n\n\treturn 1;\n}"
  }
]