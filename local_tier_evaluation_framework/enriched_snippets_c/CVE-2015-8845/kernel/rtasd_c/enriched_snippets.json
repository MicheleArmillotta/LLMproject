[
  {
    "function_name": "rtasmsgs_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "593-601",
    "snippet": "static int __init rtasmsgs_setup(char *str)\n{\n\tif (strcmp(str, \"on\") == 0)\n\t\tfull_rtas_msgs = 1;\n\telse if (strcmp(str, \"off\") == 0)\n\t\tfull_rtas_msgs = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int full_rtas_msgs = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"off\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"on\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\n\nstatic int __init rtasmsgs_setup(char *str)\n{\n\tif (strcmp(str, \"on\") == 0)\n\t\tfull_rtas_msgs = 1;\n\telse if (strcmp(str, \"off\") == 0)\n\t\tfull_rtas_msgs = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "surveillance_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "576-590",
    "snippet": "static int __init surveillance_setup(char *str)\n{\n\tint i;\n\n\t/* We only do surveillance on pseries */\n\tif (!machine_is(pseries))\n\t\treturn 0;\n\n\tif (get_option(&str,&i)) {\n\t\tif (i >= 0 && i <= 255)\n\t\t\tsurveillance_timeout = i;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int surveillance_timeout = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&i"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int surveillance_timeout = -1;\n\nstatic int __init surveillance_setup(char *str)\n{\n\tint i;\n\n\t/* We only do surveillance on pseries */\n\tif (!machine_is(pseries))\n\t\treturn 0;\n\n\tif (get_option(&str,&i)) {\n\t\tif (i >= 0 && i <= 255)\n\t\t\tsurveillance_timeout = i;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "rtas_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "529-573",
    "snippet": "static int __init rtas_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\t/* No RTAS */\n\tevent_scan = rtas_token(\"event-scan\");\n\tif (event_scan == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_INFO \"rtasd: No event-scan on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trtas_event_scan_rate = rtas_token(\"rtas-event-scan-rate\");\n\tif (rtas_event_scan_rate == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!rtas_event_scan_rate) {\n\t\t/* Broken firmware: take a rate of zero to mean don't scan */\n\t\tprintk(KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Make room for the sequence number */\n\trtas_error_log_max = rtas_get_error_log_max();\n\trtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);\n\n\trtas_log_buf = vmalloc(rtas_error_log_buffer_max*LOG_NUMBER);\n\tif (!rtas_log_buf) {\n\t\tprintk(KERN_ERR \"rtasd: no memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = proc_create(\"powerpc/rtas/error_log\", S_IRUSR, NULL,\n\t\t\t    &proc_rtas_log_operations);\n\tif (!entry)\n\t\tprintk(KERN_ERR \"Failed to create error_log proc entry\\n\");\n\n\tstart_event_scan();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_log_buf;",
      "static unsigned int rtas_error_log_max;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static unsigned int event_scan;",
      "static unsigned int rtas_event_scan_rate;",
      "static const struct file_operations proc_rtas_log_operations = {\n\t.read =\t\trtas_log_read,\n\t.poll =\t\trtas_log_poll,\n\t.open =\t\trtas_log_open,\n\t.release =\trtas_log_release,\n\t.llseek =\tnoop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_event_scan",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "start_event_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "509-520",
          "snippet": "static void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretreive_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_event_scan_rate;",
            "static unsigned long event_scan_delay = 1*HZ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_event_scan_rate;\nstatic unsigned long event_scan_delay = 1*HZ;\n\nstatic void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretreive_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to create error_log proc entry\\n\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/error_log\"",
            "S_IRUSR",
            "NULL",
            "&proc_rtas_log_operations"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: no memory\\n\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "rtas_error_log_buffer_max*LOG_NUMBER"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "345-359",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-event-scan-rate\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"rtasd: No event-scan on system\\n\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "chrp"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_log_buf;\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic unsigned int event_scan;\nstatic unsigned int rtas_event_scan_rate;\nstatic const struct file_operations proc_rtas_log_operations = {\n\t.read =\t\trtas_log_read,\n\t.poll =\t\trtas_log_poll,\n\t.open =\t\trtas_log_open,\n\t.release =\trtas_log_release,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic int __init rtas_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\t/* No RTAS */\n\tevent_scan = rtas_token(\"event-scan\");\n\tif (event_scan == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_INFO \"rtasd: No event-scan on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trtas_event_scan_rate = rtas_token(\"rtas-event-scan-rate\");\n\tif (rtas_event_scan_rate == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!rtas_event_scan_rate) {\n\t\t/* Broken firmware: take a rate of zero to mean don't scan */\n\t\tprintk(KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Make room for the sequence number */\n\trtas_error_log_max = rtas_get_error_log_max();\n\trtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);\n\n\trtas_log_buf = vmalloc(rtas_error_log_buffer_max*LOG_NUMBER);\n\tif (!rtas_log_buf) {\n\t\tprintk(KERN_ERR \"rtasd: no memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = proc_create(\"powerpc/rtas/error_log\", S_IRUSR, NULL,\n\t\t\t    &proc_rtas_log_operations);\n\tif (!entry)\n\t\tprintk(KERN_ERR \"Failed to create error_log proc entry\\n\");\n\n\tstart_event_scan();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_cancel_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "523-526",
    "snippet": "void rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&event_scan_work"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nvoid rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}"
  },
  {
    "function_name": "start_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "509-520",
    "snippet": "static void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretreive_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_event_scan_rate;",
      "static unsigned long event_scan_delay = 1*HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpumask_first(cpu_online_mask)",
            "&event_scan_work",
            "event_scan_delay"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retreive_nvram_error_log",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "retreive_nvram_error_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "504-506",
          "snippet": "static void retreive_nvram_error_log(void)\n{\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void retreive_nvram_error_log(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: will sleep for %d milliseconds\\n\"",
            "(30000 / rtas_event_scan_rate)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"RTAS daemon started\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_event_scan_rate;\nstatic unsigned long event_scan_delay = 1*HZ;\n\nstatic void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretreive_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}"
  },
  {
    "function_name": "retreive_nvram_error_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "504-506",
    "snippet": "static void retreive_nvram_error_log(void)\n{\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void retreive_nvram_error_log(void)\n{\n}"
  },
  {
    "function_name": "retreive_nvram_error_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "486-502",
    "snippet": "static void retreive_nvram_error_log(void)\n{\n\tunsigned int err_type ;\n\tint rc ;\n\n\t/* See if we have any error stored in NVRAM */\n\tmemset(logdata, 0, rtas_error_log_max);\n\trc = nvram_read_error_log(logdata, rtas_error_log_max,\n\t                          &err_type, &error_log_cnt);\n\t/* We can use rtas_log_buf now */\n\tlogging_enabled = 1;\n\tif (!rc) {\n\t\tif (err_type != ERR_FLAG_ALREADY_LOGGED) {\n\t\t\tpSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_log_buf;",
      "static unsigned int rtas_error_log_max;",
      "static int logging_enabled;",
      "static int error_log_cnt;",
      "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pSeries_log_error",
          "args": [
            "logdata",
            "err_type | ERR_FLAG_BOOT",
            "0"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "197-273",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_read_error_log",
          "args": [
            "logdata",
            "rtas_error_log_max",
            "&err_type",
            "&error_log_cnt"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "logdata",
            "0",
            "rtas_error_log_max"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_log_buf;\nstatic unsigned int rtas_error_log_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void retreive_nvram_error_log(void)\n{\n\tunsigned int err_type ;\n\tint rc ;\n\n\t/* See if we have any error stored in NVRAM */\n\tmemset(logdata, 0, rtas_error_log_max);\n\trc = nvram_read_error_log(logdata, rtas_error_log_max,\n\t                          &err_type, &error_log_cnt);\n\t/* We can use rtas_log_buf now */\n\tlogging_enabled = 1;\n\tif (!rc) {\n\t\tif (err_type != ERR_FLAG_ALREADY_LOGGED) {\n\t\t\tpSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rtas_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "454-483",
    "snippet": "static void rtas_event_scan(struct work_struct *w)\n{\n\tunsigned int cpu;\n\n\tdo_event_scan();\n\n\tget_online_cpus();\n\n\t/* raw_ OK because just using CPU as starting point. */\n\tcpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n        if (cpu >= nr_cpu_ids) {\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t\tif (first_pass) {\n\t\t\tfirst_pass = 0;\n\t\t\tevent_scan_delay = 30*HZ/rtas_event_scan_rate;\n\n\t\t\tif (surveillance_timeout != -1) {\n\t\t\t\tpr_debug(\"rtasd: enabling surveillance\\n\");\n\t\t\t\tenable_surveillance(surveillance_timeout);\n\t\t\t\tpr_debug(\"rtasd: surveillance enabled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tschedule_delayed_work_on(cpu, &event_scan_work,\n\t\t__round_jiffies_relative(event_scan_delay, cpu));\n\n\tput_online_cpus();\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int surveillance_timeout = -1;",
      "static unsigned int rtas_event_scan_rate;",
      "static void rtas_event_scan(struct work_struct *w);",
      "static unsigned long event_scan_delay = 1*HZ;",
      "static int first_pass = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpu",
            "&event_scan_work",
            "__round_jiffies_relative(event_scan_delay, cpu)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__round_jiffies_relative",
          "args": [
            "event_scan_delay",
            "cpu"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: surveillance enabled\\n\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_surveillance",
          "args": [
            "surveillance_timeout"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "enable_surveillance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "405-421",
          "snippet": "static int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: enabling surveillance\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "raw_smp_processor_id()",
            "cpu_online_mask"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_event_scan",
          "args": [],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "do_event_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "423-442",
          "snippet": "static void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_error_log_max;",
            "static unsigned int event_scan;",
            "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int event_scan;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int surveillance_timeout = -1;\nstatic unsigned int rtas_event_scan_rate;\nstatic void rtas_event_scan(struct work_struct *w);\nstatic unsigned long event_scan_delay = 1*HZ;\nstatic int first_pass = 1;\n\nstatic void rtas_event_scan(struct work_struct *w)\n{\n\tunsigned int cpu;\n\n\tdo_event_scan();\n\n\tget_online_cpus();\n\n\t/* raw_ OK because just using CPU as starting point. */\n\tcpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n        if (cpu >= nr_cpu_ids) {\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t\tif (first_pass) {\n\t\t\tfirst_pass = 0;\n\t\t\tevent_scan_delay = 30*HZ/rtas_event_scan_rate;\n\n\t\t\tif (surveillance_timeout != -1) {\n\t\t\t\tpr_debug(\"rtasd: enabling surveillance\\n\");\n\t\t\t\tenable_surveillance(surveillance_timeout);\n\t\t\t\tpr_debug(\"rtasd: surveillance enabled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tschedule_delayed_work_on(cpu, &event_scan_work,\n\t\t__round_jiffies_relative(event_scan_delay, cpu));\n\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "do_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "423-442",
    "snippet": "static void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_error_log_max;",
      "static unsigned int event_scan;",
      "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_rtas_event",
          "args": [
            "(struct rtas_error_log *)logdata"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rtas_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "309-312",
          "snippet": "static void handle_rtas_event(const struct rtas_error_log *log)\n{\n\treturn;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void handle_rtas_event(const struct rtas_error_log *log)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pSeries_log_error",
          "args": [
            "logdata",
            "ERR_TYPE_RTAS_LOG",
            "0"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "197-273",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"event-scan failed\\n\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "event_scan",
            "4",
            "1",
            "NULL",
            "RTAS_EVENT_SCAN_ALL_EVENTS",
            "0",
            "__pa(logdata)",
            "rtas_error_log_max"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "logdata"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "logdata",
            "0",
            "rtas_error_log_max"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int event_scan;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}"
  },
  {
    "function_name": "enable_surveillance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "405-421",
    "snippet": "static int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: could not update surveillance\\n\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"rtasd: surveillance not supported\\n\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_set_indicator",
          "args": [
            "SURVEILLANCE_TOKEN",
            "0",
            "timeout"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_set_indicator_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "652-669",
          "snippet": "int rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}"
  },
  {
    "function_name": "rtas_log_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "389-395",
    "snippet": "static unsigned int rtas_log_poll(struct file *file, poll_table * wait)\n{\n\tpoll_wait(file, &rtas_log_wait, wait);\n\tif (rtas_log_size)\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static unsigned long rtas_log_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&rtas_log_wait",
            "wait"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic unsigned long rtas_log_size;\n\nstatic unsigned int rtas_log_poll(struct file *file, poll_table * wait)\n{\n\tpoll_wait(file, &rtas_log_wait, wait);\n\tif (rtas_log_size)\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_log_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "330-387",
    "snippet": "static ssize_t rtas_log_read(struct file * file, char __user * buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint error;\n\tchar *tmp;\n\tunsigned long s;\n\tunsigned long offset;\n\n\tif (!buf || count < rtas_error_log_buffer_max)\n\t\treturn -EINVAL;\n\n\tcount = rtas_error_log_buffer_max;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* if it's 0, then we know we got the last one (the one in NVRAM) */\n\twhile (rtas_log_size == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!logging_enabled) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_PPC64\n\t\tnvram_clear_error_log();\n#endif /* CONFIG_PPC64 */\n\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\terror = wait_event_interruptible(rtas_log_wait, rtas_log_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&rtasd_log_lock, s);\n\t}\n\n\toffset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);\n\tmemcpy(tmp, &rtas_log_buf[offset], count);\n\n\trtas_log_start += 1;\n\trtas_log_size -= 1;\n\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\n\terror = copy_to_user(buf, tmp, count) ? -EFAULT : count;\nout:\n\tkfree(tmp);\n\treturn error;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(rtasd_log_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static char *rtas_log_buf;",
      "static unsigned long rtas_log_start;",
      "static unsigned long rtas_log_size;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static int logging_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "tmp",
            "count"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "&rtas_log_buf[offset]",
            "count"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "rtas_log_wait",
            "rtas_log_size"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_clear_error_log",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "count"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\n\nstatic ssize_t rtas_log_read(struct file * file, char __user * buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint error;\n\tchar *tmp;\n\tunsigned long s;\n\tunsigned long offset;\n\n\tif (!buf || count < rtas_error_log_buffer_max)\n\t\treturn -EINVAL;\n\n\tcount = rtas_error_log_buffer_max;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* if it's 0, then we know we got the last one (the one in NVRAM) */\n\twhile (rtas_log_size == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!logging_enabled) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_PPC64\n\t\tnvram_clear_error_log();\n#endif /* CONFIG_PPC64 */\n\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\terror = wait_event_interruptible(rtas_log_wait, rtas_log_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&rtasd_log_lock, s);\n\t}\n\n\toffset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);\n\tmemcpy(tmp, &rtas_log_buf[offset], count);\n\n\trtas_log_start += 1;\n\trtas_log_size -= 1;\n\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\n\terror = copy_to_user(buf, tmp, count) ? -EFAULT : count;\nout:\n\tkfree(tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "rtas_log_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "321-324",
    "snippet": "static int rtas_log_release(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int rtas_log_release(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_log_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "316-319",
    "snippet": "static int rtas_log_open(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int rtas_log_open(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_rtas_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "309-312",
    "snippet": "static void handle_rtas_event(const struct rtas_error_log *log)\n{\n\treturn;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void handle_rtas_event(const struct rtas_error_log *log)\n{\n\treturn;\n}"
  },
  {
    "function_name": "handle_rtas_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "296-305",
    "snippet": "static void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (rtas_error_type(log) != RTAS_TYPE_PRRN || !prrn_is_enabled())\n\t\treturn;\n\n\t/* For PRRN Events the extended log length is used to denote\n\t * the scope for calling rtas update-nodes.\n\t */\n\tprrn_schedule_update(rtas_error_extended_log_length(log));\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prrn_schedule_update",
          "args": [
            "rtas_error_extended_log_length(log)"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "prrn_schedule_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "289-294",
          "snippet": "static void prrn_schedule_update(u32 scope)\n{\n\tflush_work(&prrn_work);\n\tprrn_update_scope = scope;\n\tschedule_work(&prrn_work);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void prrn_schedule_update(u32 scope)\n{\n\tflush_work(&prrn_work);\n\tprrn_update_scope = scope;\n\tschedule_work(&prrn_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_extended_log_length",
          "args": [
            "log"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prrn_is_enabled",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "log"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (rtas_error_type(log) != RTAS_TYPE_PRRN || !prrn_is_enabled())\n\t\treturn;\n\n\t/* For PRRN Events the extended log length is used to denote\n\t * the scope for calling rtas update-nodes.\n\t */\n\tprrn_schedule_update(rtas_error_extended_log_length(log));\n}"
  },
  {
    "function_name": "prrn_schedule_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "289-294",
    "snippet": "static void prrn_schedule_update(u32 scope)\n{\n\tflush_work(&prrn_work);\n\tprrn_update_scope = scope;\n\tschedule_work(&prrn_work);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&prrn_work"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&prrn_work"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void prrn_schedule_update(u32 scope)\n{\n\tflush_work(&prrn_work);\n\tprrn_update_scope = scope;\n\tschedule_work(&prrn_work);\n}"
  },
  {
    "function_name": "prrn_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "278-285",
    "snippet": "static void prrn_work_fn(struct work_struct *work)\n{\n\t/*\n\t * For PRRN, we must pass the negative of the scope value in\n\t * the RTAS event.\n\t */\n\tpseries_devicetree_update(-prrn_update_scope);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pseries_devicetree_update",
          "args": [
            "-prrn_update_scope"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void prrn_work_fn(struct work_struct *work)\n{\n\t/*\n\t * For PRRN, we must pass the negative of the scope value in\n\t * the RTAS event.\n\t */\n\tpseries_devicetree_update(-prrn_update_scope);\n}"
  },
  {
    "function_name": "pSeries_log_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "197-273",
    "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(rtasd_log_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static char *rtas_log_buf;",
      "static unsigned long rtas_log_start;",
      "static unsigned long rtas_log_size;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static int logging_enabled;",
      "static int error_log_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&rtas_log_wait"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rtas_log_buf[offset]",
            "buf",
            "len"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_log_rtas",
          "args": [
            "buf",
            "len"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_write_error_log",
          "args": [
            "buf",
            "len",
            "err_type",
            "error_log_cnt"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rtas_len",
          "args": [
            "buf"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "log_rtas_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "158-181",
          "snippet": "static int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_error_log_max;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\n\nstatic int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: logging event\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "log_rtas_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "158-181",
    "snippet": "static int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_error_log_max;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "345-359",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_extended",
          "args": [
            "err"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_extended_log_length",
          "args": [
            "err"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\n\nstatic int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}"
  },
  {
    "function_name": "printk_log_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "111-156",
    "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int full_rtas_msgs = 0;",
      "static int error_log_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\"",
            "error_log_cnt",
            "rtas_event_type(rtas_error_type(errlog))",
            "rtas_error_severity(errlog)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_severity",
          "args": [
            "errlog"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_event_type",
          "args": [
            "rtas_error_type(errlog)"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_event_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "73-96",
          "snippet": "static char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t}\n\n\treturn rtas_type[0];\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};\n\nstatic char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t}\n\n\treturn rtas_type[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "errlog"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"%d -------- %s end ----------\\n\"",
            "error_log_cnt",
            "str"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s\\n\"",
            "buffer"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer+n",
            "\"%02x\"",
            "(unsigned char)buf[i]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer+n",
            "\" \""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"RTAS %d:\"",
            "i/perline"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"%d -------- %s begin --------\\n\"",
            "error_log_cnt",
            "str"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
  },
  {
    "function_name": "rtas_event_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "73-96",
    "snippet": "static char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t}\n\n\treturn rtas_type[0];\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};\n\nstatic char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t}\n\n\treturn rtas_type[0];\n}"
  }
]