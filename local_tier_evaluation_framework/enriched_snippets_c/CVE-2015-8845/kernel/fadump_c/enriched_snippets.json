[
  {
    "function_name": "setup_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1285-1315",
    "snippet": "int __init setup_fadump(void)\n{\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_ERR \"Firmware-assisted dump is not supported on\"\n\t\t\t\" this hardware\\n\");\n\t\treturn 0;\n\t}\n\n\tfadump_show_config();\n\t/*\n\t * If dump data is available then see if it is valid and prepare for\n\t * saving it to the disk.\n\t */\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * if dump process fails then invalidate the registration\n\t\t * and release memory before proceeding for re-registration.\n\t\t */\n\t\tif (process_fadump(fdm_active) < 0)\n\t\t\tfadump_invalidate_release_mem();\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\telse if (fw_dump.reserve_dump_area_size)\n\t\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n\tfadump_init_files();\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_init_files",
          "args": [],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_init_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1251-1280",
          "snippet": "static void fadump_init_files(void)\n{\n\tstruct dentry *debugfs_file;\n\tint rc = 0;\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_enabled (%d)\\n\", rc);\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_register_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_registered (%d)\\n\", rc);\n\n\tdebugfs_file = debugfs_create_file(\"fadump_region\", 0444,\n\t\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t\t&fadump_region_fops);\n\tif (!debugfs_file)\n\t\tprintk(KERN_ERR \"fadump: unable to create debugfs file\"\n\t\t\t\t\" fadump_region\\n\");\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(kernel_kobj, &fadump_release_attr.attr);\n\t\tif (rc)\n\t\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\t\" fadump_release_mem (%d)\\n\", rc);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct kobj_attribute fadump_release_attr = __ATTR(fadump_release_mem,\n\t\t\t\t\t\t0200, NULL,\n\t\t\t\t\t\tfadump_release_memory_store);",
            "static struct kobj_attribute fadump_attr = __ATTR(fadump_enabled,\n\t\t\t\t\t\t0444, fadump_enabled_show,\n\t\t\t\t\t\tNULL);",
            "static struct kobj_attribute fadump_register_attr = __ATTR(fadump_registered,\n\t\t\t\t\t\t0644, fadump_register_show,\n\t\t\t\t\t\tfadump_register_store);",
            "static const struct file_operations fadump_region_fops = {\n\t.open    = fadump_region_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct kobj_attribute fadump_release_attr = __ATTR(fadump_release_mem,\n\t\t\t\t\t\t0200, NULL,\n\t\t\t\t\t\tfadump_release_memory_store);\nstatic struct kobj_attribute fadump_attr = __ATTR(fadump_enabled,\n\t\t\t\t\t\t0444, fadump_enabled_show,\n\t\t\t\t\t\tNULL);\nstatic struct kobj_attribute fadump_register_attr = __ATTR(fadump_registered,\n\t\t\t\t\t\t0644, fadump_register_show,\n\t\t\t\t\t\tfadump_register_store);\nstatic const struct file_operations fadump_region_fops = {\n\t.open    = fadump_region_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void fadump_init_files(void)\n{\n\tstruct dentry *debugfs_file;\n\tint rc = 0;\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_enabled (%d)\\n\", rc);\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_register_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_registered (%d)\\n\", rc);\n\n\tdebugfs_file = debugfs_create_file(\"fadump_region\", 0444,\n\t\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t\t&fadump_region_fops);\n\tif (!debugfs_file)\n\t\tprintk(KERN_ERR \"fadump: unable to create debugfs file\"\n\t\t\t\t\" fadump_region\\n\");\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(kernel_kobj, &fadump_release_attr.attr);\n\t\tif (rc)\n\t\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\t\" fadump_release_mem (%d)\\n\", rc);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_fadump_mem_struct",
          "args": [
            "&fdm",
            "fw_dump.reserve_dump_area_start"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "init_fadump_mem_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "141-194",
          "snippet": "static unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_invalidate_release_mem",
          "args": [],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_invalidate_release_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1055-1094",
          "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;",
            "static const struct fadump_mem_struct *fdm_active;",
            "static DEFINE_MUTEX(fadump_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\nstatic DEFINE_MUTEX(fadump_mutex);\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_fadump",
          "args": [
            "fdm_active"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "process_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "686-727",
          "snippet": "static int __init process_fadump(const struct fadump_mem_struct *fdm_active)\n{\n\tstruct fadump_crash_info_header *fdh;\n\tint rc = 0;\n\n\tif (!fdm_active || !fw_dump.fadumphdr_addr)\n\t\treturn -EINVAL;\n\n\t/* Check if the dump data is valid. */\n\tif ((be16_to_cpu(fdm_active->header.dump_status_flag) == FADUMP_ERROR_FLAG) ||\n\t\t\t(fdm_active->cpu_state_data.error_flags != 0) ||\n\t\t\t(fdm_active->rmr_region.error_flags != 0)) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((fdm_active->rmr_region.bytes_dumped !=\n\t\t\tfdm_active->rmr_region.source_len) ||\n\t\t\t!fdm_active->cpu_state_data.bytes_dumped) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is incomplete\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the fadump crash info header */\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tif (fdh->magic_number != FADUMP_CRASH_INFO_MAGIC) {\n\t\tprintk(KERN_ERR \"Crash info header is not valid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = fadump_build_cpu_notes(fdm_active);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * We are done validating dump info and elfcore header is now ready\n\t * to be exported. set elfcorehdr_addr so that vmcore module will\n\t * export the elfcore header through '/proc/vmcore'.\n\t */\n\telfcorehdr_addr = fdh->elfcorehdr_addr;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static const struct fadump_mem_struct *fdm_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic const struct fadump_mem_struct *fdm_active;\n\nstatic int __init process_fadump(const struct fadump_mem_struct *fdm_active)\n{\n\tstruct fadump_crash_info_header *fdh;\n\tint rc = 0;\n\n\tif (!fdm_active || !fw_dump.fadumphdr_addr)\n\t\treturn -EINVAL;\n\n\t/* Check if the dump data is valid. */\n\tif ((be16_to_cpu(fdm_active->header.dump_status_flag) == FADUMP_ERROR_FLAG) ||\n\t\t\t(fdm_active->cpu_state_data.error_flags != 0) ||\n\t\t\t(fdm_active->rmr_region.error_flags != 0)) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((fdm_active->rmr_region.bytes_dumped !=\n\t\t\tfdm_active->rmr_region.source_len) ||\n\t\t\t!fdm_active->cpu_state_data.bytes_dumped) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is incomplete\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the fadump crash info header */\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tif (fdh->magic_number != FADUMP_CRASH_INFO_MAGIC) {\n\t\tprintk(KERN_ERR \"Crash info header is not valid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = fadump_build_cpu_notes(fdm_active);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * We are done validating dump info and elfcore header is now ready\n\t * to be exported. set elfcorehdr_addr so that vmcore module will\n\t * export the elfcore header through '/proc/vmcore'.\n\t */\n\telfcorehdr_addr = fdh->elfcorehdr_addr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_show_config",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_show_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "123-139",
          "snippet": "static void fadump_show_config(void)\n{\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"Boot memory size  : %lx\\n\", fw_dump.boot_memory_size);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_show_config(void)\n{\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"Boot memory size  : %lx\\n\", fw_dump.boot_memory_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Firmware-assisted dump is not supported on\"\n\t\t\t\" this hardware\\n\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\n\nint __init setup_fadump(void)\n{\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_ERR \"Firmware-assisted dump is not supported on\"\n\t\t\t\" this hardware\\n\");\n\t\treturn 0;\n\t}\n\n\tfadump_show_config();\n\t/*\n\t * If dump data is available then see if it is valid and prepare for\n\t * saving it to the disk.\n\t */\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * if dump process fails then invalidate the registration\n\t\t * and release memory before proceeding for re-registration.\n\t\t */\n\t\tif (process_fadump(fdm_active) < 0)\n\t\t\tfadump_invalidate_release_mem();\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\telse if (fw_dump.reserve_dump_area_size)\n\t\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n\tfadump_init_files();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fadump_init_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1251-1280",
    "snippet": "static void fadump_init_files(void)\n{\n\tstruct dentry *debugfs_file;\n\tint rc = 0;\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_enabled (%d)\\n\", rc);\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_register_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_registered (%d)\\n\", rc);\n\n\tdebugfs_file = debugfs_create_file(\"fadump_region\", 0444,\n\t\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t\t&fadump_region_fops);\n\tif (!debugfs_file)\n\t\tprintk(KERN_ERR \"fadump: unable to create debugfs file\"\n\t\t\t\t\" fadump_region\\n\");\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(kernel_kobj, &fadump_release_attr.attr);\n\t\tif (rc)\n\t\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\t\" fadump_release_mem (%d)\\n\", rc);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct kobj_attribute fadump_release_attr = __ATTR(fadump_release_mem,\n\t\t\t\t\t\t0200, NULL,\n\t\t\t\t\t\tfadump_release_memory_store);",
      "static struct kobj_attribute fadump_attr = __ATTR(fadump_enabled,\n\t\t\t\t\t\t0444, fadump_enabled_show,\n\t\t\t\t\t\tNULL);",
      "static struct kobj_attribute fadump_register_attr = __ATTR(fadump_registered,\n\t\t\t\t\t\t0644, fadump_register_show,\n\t\t\t\t\t\tfadump_register_store);",
      "static const struct file_operations fadump_region_fops = {\n\t.open    = fadump_region_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\t\" fadump_release_mem (%d)\\n\"",
            "rc"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "kernel_kobj",
            "&fadump_release_attr.attr"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fadump: unable to create debugfs file\"\n\t\t\t\t\" fadump_region\\n\""
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"fadump_region\"",
            "0444",
            "powerpc_debugfs_root",
            "NULL",
            "&fadump_region_fops"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "kernel_kobj",
            "&fadump_register_attr.attr"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "kernel_kobj",
            "&fadump_attr.attr"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct kobj_attribute fadump_release_attr = __ATTR(fadump_release_mem,\n\t\t\t\t\t\t0200, NULL,\n\t\t\t\t\t\tfadump_release_memory_store);\nstatic struct kobj_attribute fadump_attr = __ATTR(fadump_enabled,\n\t\t\t\t\t\t0444, fadump_enabled_show,\n\t\t\t\t\t\tNULL);\nstatic struct kobj_attribute fadump_register_attr = __ATTR(fadump_registered,\n\t\t\t\t\t\t0644, fadump_register_show,\n\t\t\t\t\t\tfadump_register_store);\nstatic const struct file_operations fadump_region_fops = {\n\t.open    = fadump_region_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void fadump_init_files(void)\n{\n\tstruct dentry *debugfs_file;\n\tint rc = 0;\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_enabled (%d)\\n\", rc);\n\n\trc = sysfs_create_file(kernel_kobj, &fadump_register_attr.attr);\n\tif (rc)\n\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\" fadump_registered (%d)\\n\", rc);\n\n\tdebugfs_file = debugfs_create_file(\"fadump_region\", 0444,\n\t\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t\t&fadump_region_fops);\n\tif (!debugfs_file)\n\t\tprintk(KERN_ERR \"fadump: unable to create debugfs file\"\n\t\t\t\t\" fadump_region\\n\");\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(kernel_kobj, &fadump_release_attr.attr);\n\t\tif (rc)\n\t\t\tprintk(KERN_ERR \"fadump: unable to create sysfs file\"\n\t\t\t\t\" fadump_release_mem (%d)\\n\", rc);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fadump_region_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1239-1242",
    "snippet": "static int fadump_region_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, fadump_region_show, inode->i_private);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "fadump_region_show",
            "inode->i_private"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_region_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, fadump_region_show, inode->i_private);\n}"
  },
  {
    "function_name": "fadump_region_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1168-1227",
    "snippet": "static int fadump_region_show(struct seq_file *m, void *private)\n{\n\tconst struct fadump_mem_struct *fdm_ptr;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tmutex_lock(&fadump_mutex);\n\tif (fdm_active)\n\t\tfdm_ptr = fdm_active;\n\telse {\n\t\tmutex_unlock(&fadump_mutex);\n\t\tfdm_ptr = &fdm;\n\t}\n\n\tseq_printf(m,\n\t\t\t\"CPU : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.bytes_dumped));\n\tseq_printf(m,\n\t\t\t\"HPTE: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.bytes_dumped));\n\tseq_printf(m,\n\t\t\t\"DUMP: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.bytes_dumped));\n\n\tif (!fdm_active ||\n\t\t(fw_dump.reserve_dump_area_start ==\n\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address)))\n\t\tgoto out;\n\n\t/* Dump is active. Show reserved memory region. */\n\tseq_printf(m,\n\t\t\t\"    : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\t(unsigned long long)fw_dump.reserve_dump_area_start,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start);\nout:\n\tif (fdm_active)\n\t\tmutex_unlock(&fadump_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;",
      "static DEFINE_MUTEX(fadump_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"    : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\"",
            "(unsigned long long)fw_dump.reserve_dump_area_start",
            "be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) - 1",
            "be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start",
            "be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"DUMP: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\"",
            "be64_to_cpu(fdm_ptr->rmr_region.destination_address)",
            "be64_to_cpu(fdm_ptr->rmr_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.source_len) - 1",
            "be64_to_cpu(fdm_ptr->rmr_region.source_len)",
            "be64_to_cpu(fdm_ptr->rmr_region.bytes_dumped)"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->rmr_region.bytes_dumped"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->rmr_region.source_len"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->rmr_region.source_len"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->rmr_region.destination_address"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->rmr_region.destination_address"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"HPTE: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\"",
            "be64_to_cpu(fdm_ptr->hpte_region.destination_address)",
            "be64_to_cpu(fdm_ptr->hpte_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.source_len) - 1",
            "be64_to_cpu(fdm_ptr->hpte_region.source_len)",
            "be64_to_cpu(fdm_ptr->hpte_region.bytes_dumped)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->hpte_region.bytes_dumped"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->hpte_region.source_len"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->hpte_region.source_len"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->hpte_region.destination_address"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->hpte_region.destination_address"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"CPU : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\"",
            "be64_to_cpu(fdm_ptr->cpu_state_data.destination_address)",
            "be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.source_len) - 1",
            "be64_to_cpu(fdm_ptr->cpu_state_data.source_len)",
            "be64_to_cpu(fdm_ptr->cpu_state_data.bytes_dumped)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.bytes_dumped"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.source_len"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.source_len"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_ptr->cpu_state_data.destination_address"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\nstatic DEFINE_MUTEX(fadump_mutex);\n\nstatic int fadump_region_show(struct seq_file *m, void *private)\n{\n\tconst struct fadump_mem_struct *fdm_ptr;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tmutex_lock(&fadump_mutex);\n\tif (fdm_active)\n\t\tfdm_ptr = fdm_active;\n\telse {\n\t\tmutex_unlock(&fadump_mutex);\n\t\tfdm_ptr = &fdm;\n\t}\n\n\tseq_printf(m,\n\t\t\t\"CPU : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.bytes_dumped));\n\tseq_printf(m,\n\t\t\t\"HPTE: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->hpte_region.bytes_dumped));\n\tseq_printf(m,\n\t\t\t\"DUMP: [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.destination_address),\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.destination_address) +\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.source_len) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.source_len),\n\t\t\tbe64_to_cpu(fdm_ptr->rmr_region.bytes_dumped));\n\n\tif (!fdm_active ||\n\t\t(fw_dump.reserve_dump_area_start ==\n\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address)))\n\t\tgoto out;\n\n\t/* Dump is active. Show reserved memory region. */\n\tseq_printf(m,\n\t\t\t\"    : [%#016llx-%#016llx] %#llx bytes, \"\n\t\t\t\"Dumped: %#llx\\n\",\n\t\t\t(unsigned long long)fw_dump.reserve_dump_area_start,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) - 1,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start,\n\t\t\tbe64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -\n\t\t\tfw_dump.reserve_dump_area_start);\nout:\n\tif (fdm_active)\n\t\tmutex_unlock(&fadump_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_register_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1130-1166",
    "snippet": "static ssize_t fadump_register_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret = 0;\n\n\tif (!fw_dump.fadump_enabled || fdm_active)\n\t\treturn -EPERM;\n\n\tmutex_lock(&fadump_mutex);\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tif (fw_dump.dump_registered == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\t/* Un-register Firmware-assisted dump */\n\t\tfadump_unregister_dump(&fdm);\n\t\tbreak;\n\tcase '1':\n\t\tif (fw_dump.dump_registered == 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\t/* Register Firmware-assisted dump */\n\t\tregister_fadump();\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock_out:\n\tmutex_unlock(&fadump_mutex);\n\treturn ret < 0 ? ret : count;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;",
      "static DEFINE_MUTEX(fadump_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_fadump",
          "args": [],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "register_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "940-964",
          "snippet": "static void register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn;\n\n\tfadump_setup_crash_memory_ranges();\n\n\taddr = be64_to_cpu(fdm.rmr_region.destination_address) + be64_to_cpu(fdm.rmr_region.source_len);\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tregister_fw_dump(&fdm);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic void register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn;\n\n\tfadump_setup_crash_memory_ranges();\n\n\taddr = be64_to_cpu(fdm.rmr_region.destination_address) + be64_to_cpu(fdm.rmr_region.source_len);\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tregister_fw_dump(&fdm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_unregister_dump",
          "args": [
            "&fdm"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_unregister_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "966-991",
          "snippet": "static int fadump_unregister_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_UNREGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to un-register firmware-assisted dump.\"\n\t\t\t\" unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_registered = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic int fadump_unregister_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_UNREGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to un-register firmware-assisted dump.\"\n\t\t\t\" unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_registered = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\nstatic DEFINE_MUTEX(fadump_mutex);\n\nstatic ssize_t fadump_register_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret = 0;\n\n\tif (!fw_dump.fadump_enabled || fdm_active)\n\t\treturn -EPERM;\n\n\tmutex_lock(&fadump_mutex);\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tif (fw_dump.dump_registered == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\t/* Un-register Firmware-assisted dump */\n\t\tfadump_unregister_dump(&fdm);\n\t\tbreak;\n\tcase '1':\n\t\tif (fw_dump.dump_registered == 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\t/* Register Firmware-assisted dump */\n\t\tregister_fadump();\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock_out:\n\tmutex_unlock(&fadump_mutex);\n\treturn ret < 0 ? ret : count;\n}"
  },
  {
    "function_name": "fadump_register_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1123-1128",
    "snippet": "static ssize_t fadump_register_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.dump_registered);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fw_dump.dump_registered"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t fadump_register_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.dump_registered);\n}"
  },
  {
    "function_name": "fadump_enabled_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1116-1121",
    "snippet": "static ssize_t fadump_enabled_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.fadump_enabled);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fw_dump.fadump_enabled"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t fadump_enabled_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.fadump_enabled);\n}"
  },
  {
    "function_name": "fadump_release_memory_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1096-1114",
    "snippet": "static ssize_t fadump_release_memory_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tif (!fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (buf[0] == '1') {\n\t\t/*\n\t\t * Take away the '/proc/vmcore'. We are releasing the dump\n\t\t * memory, hence it will not be valid anymore.\n\t\t */\n\t\tvmcore_cleanup();\n\t\tfadump_invalidate_release_mem();\n\n\t} else\n\t\treturn -EINVAL;\n\treturn count;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_invalidate_release_mem",
          "args": [],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_invalidate_release_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1055-1094",
          "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;",
            "static const struct fadump_mem_struct *fdm_active;",
            "static DEFINE_MUTEX(fadump_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\nstatic DEFINE_MUTEX(fadump_mutex);\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcore_cleanup",
          "args": [],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t fadump_release_memory_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tif (!fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (buf[0] == '1') {\n\t\t/*\n\t\t * Take away the '/proc/vmcore'. We are releasing the dump\n\t\t * memory, hence it will not be valid anymore.\n\t\t */\n\t\tvmcore_cleanup();\n\t\tfadump_invalidate_release_mem();\n\n\t} else\n\t\treturn -EINVAL;\n\treturn count;\n}"
  },
  {
    "function_name": "fadump_invalidate_release_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1055-1094",
    "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;",
      "static DEFINE_MUTEX(fadump_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_fadump_mem_struct",
          "args": [
            "&fdm",
            "fw_dump.reserve_dump_area_start"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "init_fadump_mem_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "141-194",
          "snippet": "static unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_cpu_notes_buf_free",
          "args": [
            "(unsigned long)__va(fw_dump.cpu_notes_buf)",
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cpu_notes_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "565-576",
          "snippet": "static void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.cpu_notes_buf"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_release_memory",
          "args": [
            "reserved_area_start",
            "reserved_area_end"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_release_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1035-1053",
          "snippet": "static void fadump_release_memory(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tunsigned long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/*\n\t\t * exclude the dump reserve area. Will reuse it for next\n\t\t * fadump registration.\n\t\t */\n\t\tif (addr <= ra_end && ((addr + PAGE_SIZE) > ra_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_release_memory(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tunsigned long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/*\n\t\t * exclude the dump reserve area. Will reuse it for next\n\t\t * fadump registration.\n\t\t */\n\t\tif (addr <= ra_end && ((addr + PAGE_SIZE) > ra_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fadump_area_size",
          "args": [],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "get_fadump_area_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "239-254",
          "snippet": "static unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_cleanup",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1021-1029",
          "snippet": "void fadump_cleanup(void)\n{\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tinit_fadump_mem_struct(&fdm,\n\t\t\tbe64_to_cpu(fdm_active->cpu_state_data.destination_address));\n\t\tfadump_invalidate_dump(&fdm);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;",
            "static const struct fadump_mem_struct *fdm_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\n\nvoid fadump_cleanup(void)\n{\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tinit_fadump_mem_struct(&fdm,\n\t\t\tbe64_to_cpu(fdm_active->cpu_state_data.destination_address));\n\t\tfadump_invalidate_dump(&fdm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_active->cpu_state_data.destination_address"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\nstatic DEFINE_MUTEX(fadump_mutex);\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tunsigned long reserved_area_start, reserved_area_end;\n\tunsigned long destination_address;\n\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tdestination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\t/*\n\t * Save the current reserved memory bounds we will require them\n\t * later for releasing the memory for general use.\n\t */\n\treserved_area_start = fw_dump.reserve_dump_area_start;\n\treserved_area_end = reserved_area_start +\n\t\t\tfw_dump.reserve_dump_area_size;\n\t/*\n\t * Setup reserve_dump_area_start and its size so that we can\n\t * reuse this reserved memory for Re-registration.\n\t */\n\tfw_dump.reserve_dump_area_start = destination_address;\n\tfw_dump.reserve_dump_area_size = get_fadump_area_size();\n\n\tfadump_release_memory(reserved_area_start, reserved_area_end);\n\tif (fw_dump.cpu_notes_buf) {\n\t\tfadump_cpu_notes_buf_free(\n\t\t\t\t(unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\tfw_dump.cpu_notes_buf_size);\n\t\tfw_dump.cpu_notes_buf = 0;\n\t\tfw_dump.cpu_notes_buf_size = 0;\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\tinit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\n}"
  },
  {
    "function_name": "fadump_release_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1035-1053",
    "snippet": "static void fadump_release_memory(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tunsigned long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/*\n\t\t * exclude the dump reserve area. Will reuse it for next\n\t\t * fadump registration.\n\t\t */\n\t\tif (addr <= ra_end && ((addr + PAGE_SIZE) > ra_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "pfn_to_page(addr >> PAGE_SHIFT)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "addr >> PAGE_SHIFT"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_release_memory(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tunsigned long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/*\n\t\t * exclude the dump reserve area. Will reuse it for next\n\t\t * fadump registration.\n\t\t */\n\t\tif (addr <= ra_end && ((addr + PAGE_SIZE) > ra_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}"
  },
  {
    "function_name": "fadump_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1021-1029",
    "snippet": "void fadump_cleanup(void)\n{\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tinit_fadump_mem_struct(&fdm,\n\t\t\tbe64_to_cpu(fdm_active->cpu_state_data.destination_address));\n\t\tfadump_invalidate_dump(&fdm);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_invalidate_dump",
          "args": [
            "&fdm"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_invalidate_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "993-1019",
          "snippet": "static int fadump_invalidate_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_INVALIDATE, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to invalidate firmware-assisted dump \"\n\t\t\t\"rgistration. unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_active = 0;\n\tfdm_active = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;",
            "static const struct fadump_mem_struct *fdm_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\n\nstatic int fadump_invalidate_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_INVALIDATE, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to invalidate firmware-assisted dump \"\n\t\t\t\"rgistration. unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_active = 0;\n\tfdm_active = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_fadump_mem_struct",
          "args": [
            "&fdm",
            "be64_to_cpu(fdm_active->cpu_state_data.destination_address)"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "init_fadump_mem_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "141-194",
          "snippet": "static unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_active->cpu_state_data.destination_address"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\n\nvoid fadump_cleanup(void)\n{\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tinit_fadump_mem_struct(&fdm,\n\t\t\tbe64_to_cpu(fdm_active->cpu_state_data.destination_address));\n\t\tfadump_invalidate_dump(&fdm);\n\t}\n}"
  },
  {
    "function_name": "fadump_invalidate_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "993-1019",
    "snippet": "static int fadump_invalidate_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_INVALIDATE, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to invalidate firmware-assisted dump \"\n\t\t\t\"rgistration. unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_active = 0;\n\tfdm_active = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to invalidate firmware-assisted dump \"\n\t\t\t\"rgistration. unexpected error(%d).\\n\"",
            "rc"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "wait_time"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay_time",
          "args": [
            "rc"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "474-489",
          "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "fw_dump.ibm_configure_kernel_dump",
            "3",
            "1",
            "NULL",
            "FADUMP_INVALIDATE",
            "fdm",
            "sizeof(struct fadump_mem_struct)"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Invalidating firmware-assisted dump registration\\n\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\nstatic const struct fadump_mem_struct *fdm_active;\n\nstatic int fadump_invalidate_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_INVALIDATE, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to invalidate firmware-assisted dump \"\n\t\t\t\"rgistration. unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_active = 0;\n\tfdm_active = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_unregister_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "966-991",
    "snippet": "static int fadump_unregister_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_UNREGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to un-register firmware-assisted dump.\"\n\t\t\t\" unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_registered = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to un-register firmware-assisted dump.\"\n\t\t\t\" unexpected error(%d).\\n\"",
            "rc"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "wait_time"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay_time",
          "args": [
            "rc"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "474-489",
          "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "fw_dump.ibm_configure_kernel_dump",
            "3",
            "1",
            "NULL",
            "FADUMP_UNREGISTER",
            "fdm",
            "sizeof(struct fadump_mem_struct)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Un-register firmware-assisted dump\\n\""
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic int fadump_unregister_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc = 0;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_UNREGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\t} while (wait_time);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to un-register firmware-assisted dump.\"\n\t\t\t\" unexpected error(%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\tfw_dump.dump_registered = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "register_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "940-964",
    "snippet": "static void register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn;\n\n\tfadump_setup_crash_memory_ranges();\n\n\taddr = be64_to_cpu(fdm.rmr_region.destination_address) + be64_to_cpu(fdm.rmr_region.source_len);\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tregister_fw_dump(&fdm);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_fw_dump",
          "args": [
            "&fdm"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "register_fw_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "360-399",
          "snippet": "static void register_fw_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_REGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\n\t} while (wait_time);\n\n\tswitch (rc) {\n\tcase -1:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Hardware Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -3:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Parameter Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -9:\n\t\tprintk(KERN_ERR \"firmware-assisted kernel dump is already \"\n\t\t\t\" registered.\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\tcase 0:\n\t\tprintk(KERN_INFO \"firmware-assisted kernel dump registration\"\n\t\t\t\" is successful\\n\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic void register_fw_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_REGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\n\t} while (wait_time);\n\n\tswitch (rc) {\n\tcase -1:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Hardware Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -3:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Parameter Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -9:\n\t\tprintk(KERN_ERR \"firmware-assisted kernel dump is already \"\n\t\t\t\" registered.\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\tcase 0:\n\t\tprintk(KERN_INFO \"firmware-assisted kernel dump registration\"\n\t\t\t\" is successful\\n\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_create_elfcore_headers",
          "args": [
            "vaddr"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_create_elfcore_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "836-918",
          "snippet": "static int fadump_create_elfcore_headers(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\tint i;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= vmcoreinfo_max_size;\n\tphdr->p_filesz\t= vmcoreinfo_max_size;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\n\tfor (i = 0; i < crash_mem_ranges; i++) {\n\t\tunsigned long long mbase, msize;\n\t\tmbase = crash_memory_ranges[i].base;\n\t\tmsize = crash_memory_ranges[i].size;\n\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == RMA_START) {\n\t\t\t/*\n\t\t\t * The entire RMA region will be moved by firmware\n\t\t\t * to the specified destination_address. Hence set\n\t\t\t * the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fadump_mem_struct fdm;",
            "struct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];",
            "int crash_mem_ranges;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fadump_mem_struct fdm;\nstruct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];\nint crash_mem_ranges;\n\nstatic int fadump_create_elfcore_headers(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\tint i;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= vmcoreinfo_max_size;\n\tphdr->p_filesz\t= vmcoreinfo_max_size;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\n\tfor (i = 0; i < crash_mem_ranges; i++) {\n\t\tunsigned long long mbase, msize;\n\t\tmbase = crash_memory_ranges[i].base;\n\t\tmsize = crash_memory_ranges[i].size;\n\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == RMA_START) {\n\t\t\t/*\n\t\t\t * The entire RMA region will be moved by firmware\n\t\t\t * to the specified destination_address. Hence set\n\t\t\t * the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Creating ELF core headers at %#016lx\\n\"",
            "addr"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_fadump_header",
          "args": [
            "addr"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "init_fadump_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "920-938",
          "snippet": "static unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfw_dump.fadumphdr_addr = addr;\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = CPU_UNKNOWN;\n\n\treturn addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfw_dump.fadumphdr_addr = addr;\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = CPU_UNKNOWN;\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm.rmr_region.source_len"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm.rmr_region.destination_address"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_setup_crash_memory_ranges",
          "args": [],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_setup_crash_memory_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "796-821",
          "snippet": "static void fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long long start, end;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mem_ranges = 0;\n\t/*\n\t * add the first memory chunk (RMA_START through boot_memory_size) as\n\t * a separate memory chunk. The reason is, at the time crash firmware\n\t * will move the content of this memory chunk to different location\n\t * specified during fadump registration. We need to create a separate\n\t * program header for this chunk with the correct offset.\n\t */\n\tfadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (unsigned long long)reg->base;\n\t\tend = start + (unsigned long long)reg->size;\n\t\tif (start == RMA_START && end >= fw_dump.boot_memory_size)\n\t\t\tstart = fw_dump.boot_memory_size;\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tfadump_exclude_reserved_area(start, end);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "int crash_mem_ranges;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nint crash_mem_ranges;\n\nstatic void fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long long start, end;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mem_ranges = 0;\n\t/*\n\t * add the first memory chunk (RMA_START through boot_memory_size) as\n\t * a separate memory chunk. The reason is, at the time crash firmware\n\t * will move the content of this memory chunk to different location\n\t * specified during fadump registration. We need to create a separate\n\t * program header for this chunk with the correct offset.\n\t */\n\tfadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (unsigned long long)reg->base;\n\t\tend = start + (unsigned long long)reg->size;\n\t\tif (start == RMA_START && end >= fw_dump.boot_memory_size)\n\t\t\tstart = fw_dump.boot_memory_size;\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tfadump_exclude_reserved_area(start, end);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic void register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn;\n\n\tfadump_setup_crash_memory_ranges();\n\n\taddr = be64_to_cpu(fdm.rmr_region.destination_address) + be64_to_cpu(fdm.rmr_region.source_len);\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tregister_fw_dump(&fdm);\n}"
  },
  {
    "function_name": "init_fadump_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "920-938",
    "snippet": "static unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfw_dump.fadumphdr_addr = addr;\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = CPU_UNKNOWN;\n\n\treturn addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdh",
            "0",
            "sizeof(struct fadump_crash_info_header)"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfw_dump.fadumphdr_addr = addr;\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = CPU_UNKNOWN;\n\n\treturn addr;\n}"
  },
  {
    "function_name": "fadump_create_elfcore_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "836-918",
    "snippet": "static int fadump_create_elfcore_headers(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\tint i;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= vmcoreinfo_max_size;\n\tphdr->p_filesz\t= vmcoreinfo_max_size;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\n\tfor (i = 0; i < crash_mem_ranges; i++) {\n\t\tunsigned long long mbase, msize;\n\t\tmbase = crash_memory_ranges[i].base;\n\t\tmsize = crash_memory_ranges[i].size;\n\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == RMA_START) {\n\t\t\t/*\n\t\t\t * The entire RMA region will be moved by firmware\n\t\t\t * to the specified destination_address. Hence set\n\t\t\t * the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fadump_mem_struct fdm;",
      "struct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];",
      "int crash_mem_ranges;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "mbase"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm.rmr_region.destination_address"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_relocate",
          "args": [
            "paddr_vmcoreinfo_note()"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "828-834",
          "snippet": "static inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tif (paddr > RMA_START && paddr < fw_dump.boot_memory_size)\n\t\treturn be64_to_cpu(fdm.rmr_region.destination_address) + paddr;\n\telse\n\t\treturn paddr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tif (paddr > RMA_START && paddr < fw_dump.boot_memory_size)\n\t\treturn be64_to_cpu(fdm.rmr_region.destination_address) + paddr;\n\telse\n\t\treturn paddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddr_vmcoreinfo_note",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_init_elfcore_header",
          "args": [
            "bufp"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_init_elfcore_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "763-790",
          "snippet": "static int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fadump_mem_struct fdm;\nstruct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];\nint crash_mem_ranges;\n\nstatic int fadump_create_elfcore_headers(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\tint i;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= vmcoreinfo_max_size;\n\tphdr->p_filesz\t= vmcoreinfo_max_size;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\n\tfor (i = 0; i < crash_mem_ranges; i++) {\n\t\tunsigned long long mbase, msize;\n\t\tmbase = crash_memory_ranges[i].base;\n\t\tmsize = crash_memory_ranges[i].size;\n\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == RMA_START) {\n\t\t\t/*\n\t\t\t * The entire RMA region will be moved by firmware\n\t\t\t * to the specified destination_address. Hence set\n\t\t\t * the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_relocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "828-834",
    "snippet": "static inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tif (paddr > RMA_START && paddr < fw_dump.boot_memory_size)\n\t\treturn be64_to_cpu(fdm.rmr_region.destination_address) + paddr;\n\telse\n\t\treturn paddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm.rmr_region.destination_address"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tif (paddr > RMA_START && paddr < fw_dump.boot_memory_size)\n\t\treturn be64_to_cpu(fdm.rmr_region.destination_address) + paddr;\n\telse\n\t\treturn paddr;\n}"
  },
  {
    "function_name": "fadump_setup_crash_memory_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "796-821",
    "snippet": "static void fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long long start, end;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mem_ranges = 0;\n\t/*\n\t * add the first memory chunk (RMA_START through boot_memory_size) as\n\t * a separate memory chunk. The reason is, at the time crash firmware\n\t * will move the content of this memory chunk to different location\n\t * specified during fadump registration. We need to create a separate\n\t * program header for this chunk with the correct offset.\n\t */\n\tfadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (unsigned long long)reg->base;\n\t\tend = start + (unsigned long long)reg->size;\n\t\tif (start == RMA_START && end >= fw_dump.boot_memory_size)\n\t\t\tstart = fw_dump.boot_memory_size;\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tfadump_exclude_reserved_area(start, end);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "int crash_mem_ranges;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_exclude_reserved_area",
          "args": [
            "start",
            "end"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_exclude_reserved_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "742-761",
          "snippet": "static void fadump_exclude_reserved_area(unsigned long long start,\n\t\t\t\t\tunsigned long long end)\n{\n\tunsigned long long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t}\n\t} else\n\t\tfadump_add_crash_memory(start, end);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_exclude_reserved_area(unsigned long long start,\n\t\t\t\t\tunsigned long long end)\n{\n\tunsigned long long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t}\n\t} else\n\t\tfadump_add_crash_memory(start, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_add_crash_memory",
          "args": [
            "RMA_START",
            "fw_dump.boot_memory_size"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_crash_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "729-740",
          "snippet": "static inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];",
            "int crash_mem_ranges;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstruct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];\nint crash_mem_ranges;\n\nstatic inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Setup crash memory ranges.\\n\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nint crash_mem_ranges;\n\nstatic void fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long long start, end;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mem_ranges = 0;\n\t/*\n\t * add the first memory chunk (RMA_START through boot_memory_size) as\n\t * a separate memory chunk. The reason is, at the time crash firmware\n\t * will move the content of this memory chunk to different location\n\t * specified during fadump registration. We need to create a separate\n\t * program header for this chunk with the correct offset.\n\t */\n\tfadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (unsigned long long)reg->base;\n\t\tend = start + (unsigned long long)reg->size;\n\t\tif (start == RMA_START && end >= fw_dump.boot_memory_size)\n\t\t\tstart = fw_dump.boot_memory_size;\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tfadump_exclude_reserved_area(start, end);\n\t}\n}"
  },
  {
    "function_name": "fadump_init_elfcore_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "763-790",
    "snippet": "static int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf->e_ident+EI_PAD",
            "0",
            "EI_NIDENT-EI_PAD"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_exclude_reserved_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "742-761",
    "snippet": "static void fadump_exclude_reserved_area(unsigned long long start,\n\t\t\t\t\tunsigned long long end)\n{\n\tunsigned long long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t}\n\t} else\n\t\tfadump_add_crash_memory(start, end);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_add_crash_memory",
          "args": [
            "start",
            "end"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_crash_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "729-740",
          "snippet": "static inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];",
            "int crash_mem_ranges;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstruct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];\nint crash_mem_ranges;\n\nstatic inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_exclude_reserved_area(unsigned long long start,\n\t\t\t\t\tunsigned long long end)\n{\n\tunsigned long long ra_start, ra_end;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tfadump_add_crash_memory(start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tfadump_add_crash_memory(ra_end, end);\n\t\t}\n\t} else\n\t\tfadump_add_crash_memory(start, end);\n}"
  },
  {
    "function_name": "fadump_add_crash_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "729-740",
    "snippet": "static inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];",
      "int crash_mem_ranges;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\"",
            "crash_mem_ranges",
            "base",
            "end - 1",
            "(end - base)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstruct fad_crash_memory_ranges crash_memory_ranges[INIT_CRASHMEM_RANGES];\nint crash_mem_ranges;\n\nstatic inline void fadump_add_crash_memory(unsigned long long base,\n\t\t\t\t\tunsigned long long end)\n{\n\tif (base == end)\n\t\treturn;\n\n\tpr_debug(\"crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\tcrash_mem_ranges, base, end - 1, (end - base));\n\tcrash_memory_ranges[crash_mem_ranges].base = base;\n\tcrash_memory_ranges[crash_mem_ranges].size = end - base;\n\tcrash_mem_ranges++;\n}"
  },
  {
    "function_name": "process_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "686-727",
    "snippet": "static int __init process_fadump(const struct fadump_mem_struct *fdm_active)\n{\n\tstruct fadump_crash_info_header *fdh;\n\tint rc = 0;\n\n\tif (!fdm_active || !fw_dump.fadumphdr_addr)\n\t\treturn -EINVAL;\n\n\t/* Check if the dump data is valid. */\n\tif ((be16_to_cpu(fdm_active->header.dump_status_flag) == FADUMP_ERROR_FLAG) ||\n\t\t\t(fdm_active->cpu_state_data.error_flags != 0) ||\n\t\t\t(fdm_active->rmr_region.error_flags != 0)) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((fdm_active->rmr_region.bytes_dumped !=\n\t\t\tfdm_active->rmr_region.source_len) ||\n\t\t\t!fdm_active->cpu_state_data.bytes_dumped) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is incomplete\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the fadump crash info header */\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tif (fdh->magic_number != FADUMP_CRASH_INFO_MAGIC) {\n\t\tprintk(KERN_ERR \"Crash info header is not valid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = fadump_build_cpu_notes(fdm_active);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * We are done validating dump info and elfcore header is now ready\n\t * to be exported. set elfcorehdr_addr so that vmcore module will\n\t * export the elfcore header through '/proc/vmcore'.\n\t */\n\telfcorehdr_addr = fdh->elfcorehdr_addr;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_build_cpu_notes",
          "args": [
            "fdm_active"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_build_cpu_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "592-680",
          "snippet": "static int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)\n{\n\tstruct fadump_reg_save_area_header *reg_header;\n\tstruct fadump_reg_entry *reg_entry;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tvoid *vaddr;\n\tunsigned long addr;\n\tu32 num_cpus, *note_buf;\n\tstruct pt_regs regs;\n\tint i, rc = 0, cpu = 0;\n\n\tif (!fdm->cpu_state_data.bytes_dumped)\n\t\treturn -EINVAL;\n\n\taddr = be64_to_cpu(fdm->cpu_state_data.destination_address);\n\tvaddr = __va(addr);\n\n\treg_header = vaddr;\n\tif (be64_to_cpu(reg_header->magic_number) != REGSAVE_AREA_MAGIC) {\n\t\tprintk(KERN_ERR \"Unable to read register save area.\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpr_debug(\"--------CPU State Data------------\\n\");\n\tpr_debug(\"Magic Number: %llx\\n\", be64_to_cpu(reg_header->magic_number));\n\tpr_debug(\"NumCpuOffset: %x\\n\", be32_to_cpu(reg_header->num_cpu_offset));\n\n\tvaddr += be32_to_cpu(reg_header->num_cpu_offset);\n\tnum_cpus = be32_to_cpu(*((__be32 *)(vaddr)));\n\tpr_debug(\"NumCpus     : %u\\n\", num_cpus);\n\tvaddr += sizeof(u32);\n\treg_entry = (struct fadump_reg_entry *)vaddr;\n\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tnote_buf = fadump_cpu_notes_buf_alloc(fw_dump.cpu_notes_buf_size);\n\tif (!note_buf) {\n\t\tprintk(KERN_ERR \"Failed to allocate 0x%lx bytes for \"\n\t\t\t\"cpu notes buffer\\n\", fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\tfw_dump.cpu_notes_buf = __pa(note_buf);\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at %p\\n\",\n\t\t\t(num_cpus * sizeof(note_buf_t)), note_buf);\n\n\tif (fw_dump.fadumphdr_addr)\n\t\tfdh = __va(fw_dump.fadumphdr_addr);\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\tif (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUSTRT\")) {\n\t\t\tprintk(KERN_ERR \"Unable to read CPU state data\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto error_out;\n\t\t}\n\t\t/* Lower 4 bytes of reg_value contains logical cpu id */\n\t\tcpu = be64_to_cpu(reg_entry->reg_value) & FADUMP_CPU_ID_MASK;\n\t\tif (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"Reading register data for cpu %d...\\n\", cpu);\n\t\tif (fdh && fdh->crashing_cpu == cpu) {\n\t\t\tregs = fdh->regs;\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t} else {\n\t\t\treg_entry++;\n\t\t\treg_entry = fadump_read_registers(reg_entry, &regs);\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t}\n\t}\n\tfadump_final_note(note_buf);\n\n\tif (fdh) {\n\t\tpr_debug(\"Updating elfcore header (%llx) with cpu notes\\n\",\n\t\t\t\t\t\t\tfdh->elfcorehdr_addr);\n\t\tfadump_update_elfcore_header((char *)__va(fdh->elfcorehdr_addr));\n\t}\n\treturn 0;\n\nerror_out:\n\tfadump_cpu_notes_buf_free((unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\t\tfw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n\treturn rc;\n\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static struct fadump_mem_struct fdm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)\n{\n\tstruct fadump_reg_save_area_header *reg_header;\n\tstruct fadump_reg_entry *reg_entry;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tvoid *vaddr;\n\tunsigned long addr;\n\tu32 num_cpus, *note_buf;\n\tstruct pt_regs regs;\n\tint i, rc = 0, cpu = 0;\n\n\tif (!fdm->cpu_state_data.bytes_dumped)\n\t\treturn -EINVAL;\n\n\taddr = be64_to_cpu(fdm->cpu_state_data.destination_address);\n\tvaddr = __va(addr);\n\n\treg_header = vaddr;\n\tif (be64_to_cpu(reg_header->magic_number) != REGSAVE_AREA_MAGIC) {\n\t\tprintk(KERN_ERR \"Unable to read register save area.\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpr_debug(\"--------CPU State Data------------\\n\");\n\tpr_debug(\"Magic Number: %llx\\n\", be64_to_cpu(reg_header->magic_number));\n\tpr_debug(\"NumCpuOffset: %x\\n\", be32_to_cpu(reg_header->num_cpu_offset));\n\n\tvaddr += be32_to_cpu(reg_header->num_cpu_offset);\n\tnum_cpus = be32_to_cpu(*((__be32 *)(vaddr)));\n\tpr_debug(\"NumCpus     : %u\\n\", num_cpus);\n\tvaddr += sizeof(u32);\n\treg_entry = (struct fadump_reg_entry *)vaddr;\n\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tnote_buf = fadump_cpu_notes_buf_alloc(fw_dump.cpu_notes_buf_size);\n\tif (!note_buf) {\n\t\tprintk(KERN_ERR \"Failed to allocate 0x%lx bytes for \"\n\t\t\t\"cpu notes buffer\\n\", fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\tfw_dump.cpu_notes_buf = __pa(note_buf);\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at %p\\n\",\n\t\t\t(num_cpus * sizeof(note_buf_t)), note_buf);\n\n\tif (fw_dump.fadumphdr_addr)\n\t\tfdh = __va(fw_dump.fadumphdr_addr);\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\tif (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUSTRT\")) {\n\t\t\tprintk(KERN_ERR \"Unable to read CPU state data\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto error_out;\n\t\t}\n\t\t/* Lower 4 bytes of reg_value contains logical cpu id */\n\t\tcpu = be64_to_cpu(reg_entry->reg_value) & FADUMP_CPU_ID_MASK;\n\t\tif (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"Reading register data for cpu %d...\\n\", cpu);\n\t\tif (fdh && fdh->crashing_cpu == cpu) {\n\t\t\tregs = fdh->regs;\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t} else {\n\t\t\treg_entry++;\n\t\t\treg_entry = fadump_read_registers(reg_entry, &regs);\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t}\n\t}\n\tfadump_final_note(note_buf);\n\n\tif (fdh) {\n\t\tpr_debug(\"Updating elfcore header (%llx) with cpu notes\\n\",\n\t\t\t\t\t\t\tfdh->elfcorehdr_addr);\n\t\tfadump_update_elfcore_header((char *)__va(fdh->elfcorehdr_addr));\n\t}\n\treturn 0;\n\nerror_out:\n\tfadump_cpu_notes_buf_free((unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\t\tfw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n\treturn rc;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Crash info header is not valid.\\n\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.fadumphdr_addr"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Dump taken by platform is incomplete\\n\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Dump taken by platform is not valid\\n\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "fdm_active->header.dump_status_flag"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic const struct fadump_mem_struct *fdm_active;\n\nstatic int __init process_fadump(const struct fadump_mem_struct *fdm_active)\n{\n\tstruct fadump_crash_info_header *fdh;\n\tint rc = 0;\n\n\tif (!fdm_active || !fw_dump.fadumphdr_addr)\n\t\treturn -EINVAL;\n\n\t/* Check if the dump data is valid. */\n\tif ((be16_to_cpu(fdm_active->header.dump_status_flag) == FADUMP_ERROR_FLAG) ||\n\t\t\t(fdm_active->cpu_state_data.error_flags != 0) ||\n\t\t\t(fdm_active->rmr_region.error_flags != 0)) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((fdm_active->rmr_region.bytes_dumped !=\n\t\t\tfdm_active->rmr_region.source_len) ||\n\t\t\t!fdm_active->cpu_state_data.bytes_dumped) {\n\t\tprintk(KERN_ERR \"Dump taken by platform is incomplete\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the fadump crash info header */\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tif (fdh->magic_number != FADUMP_CRASH_INFO_MAGIC) {\n\t\tprintk(KERN_ERR \"Crash info header is not valid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = fadump_build_cpu_notes(fdm_active);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * We are done validating dump info and elfcore header is now ready\n\t * to be exported. set elfcorehdr_addr so that vmcore module will\n\t * export the elfcore header through '/proc/vmcore'.\n\t */\n\telfcorehdr_addr = fdh->elfcorehdr_addr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_build_cpu_notes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "592-680",
    "snippet": "static int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)\n{\n\tstruct fadump_reg_save_area_header *reg_header;\n\tstruct fadump_reg_entry *reg_entry;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tvoid *vaddr;\n\tunsigned long addr;\n\tu32 num_cpus, *note_buf;\n\tstruct pt_regs regs;\n\tint i, rc = 0, cpu = 0;\n\n\tif (!fdm->cpu_state_data.bytes_dumped)\n\t\treturn -EINVAL;\n\n\taddr = be64_to_cpu(fdm->cpu_state_data.destination_address);\n\tvaddr = __va(addr);\n\n\treg_header = vaddr;\n\tif (be64_to_cpu(reg_header->magic_number) != REGSAVE_AREA_MAGIC) {\n\t\tprintk(KERN_ERR \"Unable to read register save area.\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpr_debug(\"--------CPU State Data------------\\n\");\n\tpr_debug(\"Magic Number: %llx\\n\", be64_to_cpu(reg_header->magic_number));\n\tpr_debug(\"NumCpuOffset: %x\\n\", be32_to_cpu(reg_header->num_cpu_offset));\n\n\tvaddr += be32_to_cpu(reg_header->num_cpu_offset);\n\tnum_cpus = be32_to_cpu(*((__be32 *)(vaddr)));\n\tpr_debug(\"NumCpus     : %u\\n\", num_cpus);\n\tvaddr += sizeof(u32);\n\treg_entry = (struct fadump_reg_entry *)vaddr;\n\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tnote_buf = fadump_cpu_notes_buf_alloc(fw_dump.cpu_notes_buf_size);\n\tif (!note_buf) {\n\t\tprintk(KERN_ERR \"Failed to allocate 0x%lx bytes for \"\n\t\t\t\"cpu notes buffer\\n\", fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\tfw_dump.cpu_notes_buf = __pa(note_buf);\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at %p\\n\",\n\t\t\t(num_cpus * sizeof(note_buf_t)), note_buf);\n\n\tif (fw_dump.fadumphdr_addr)\n\t\tfdh = __va(fw_dump.fadumphdr_addr);\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\tif (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUSTRT\")) {\n\t\t\tprintk(KERN_ERR \"Unable to read CPU state data\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto error_out;\n\t\t}\n\t\t/* Lower 4 bytes of reg_value contains logical cpu id */\n\t\tcpu = be64_to_cpu(reg_entry->reg_value) & FADUMP_CPU_ID_MASK;\n\t\tif (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"Reading register data for cpu %d...\\n\", cpu);\n\t\tif (fdh && fdh->crashing_cpu == cpu) {\n\t\t\tregs = fdh->regs;\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t} else {\n\t\t\treg_entry++;\n\t\t\treg_entry = fadump_read_registers(reg_entry, &regs);\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t}\n\t}\n\tfadump_final_note(note_buf);\n\n\tif (fdh) {\n\t\tpr_debug(\"Updating elfcore header (%llx) with cpu notes\\n\",\n\t\t\t\t\t\t\tfdh->elfcorehdr_addr);\n\t\tfadump_update_elfcore_header((char *)__va(fdh->elfcorehdr_addr));\n\t}\n\treturn 0;\n\nerror_out:\n\tfadump_cpu_notes_buf_free((unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\t\tfw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n\treturn rc;\n\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_cpu_notes_buf_free",
          "args": [
            "(unsigned long)__va(fw_dump.cpu_notes_buf)",
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cpu_notes_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "565-576",
          "snippet": "static void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.cpu_notes_buf"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_update_elfcore_header",
          "args": [
            "(char *)__va(fdh->elfcorehdr_addr)"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_update_elfcore_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "527-545",
          "snippet": "static void fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr = fw_dump.cpu_notes_buf;\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr = fw_dump.cpu_notes_buf;\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fdh->elfcorehdr_addr"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Updating elfcore header (%llx) with cpu notes\\n\"",
            "fdh->elfcorehdr_addr"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_final_note",
          "args": [
            "note_buf"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_final_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "502-510",
          "snippet": "static void fadump_final_note(u32 *buf)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = 0;\n\tnote.n_descsz = 0;\n\tnote.n_type   = 0;\n\tmemcpy(buf, &note, sizeof(note));\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_final_note(u32 *buf)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = 0;\n\tnote.n_descsz = 0;\n\tnote.n_type   = 0;\n\tmemcpy(buf, &note, sizeof(note));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_regs_to_elf_notes",
          "args": [
            "note_buf",
            "&regs"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_regs_to_elf_notes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "512-525",
          "snippet": "static u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t\t&prstatus, sizeof(prstatus));\n\treturn buf;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t\t&prstatus, sizeof(prstatus));\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_read_registers",
          "args": [
            "reg_entry",
            "&regs"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_read_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "470-482",
          "snippet": "static struct fadump_reg_entry*\nfadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\n\twhile (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) {\n\t\tfadump_set_regval(regs, be64_to_cpu(reg_entry->reg_id),\n\t\t\t\t\tbe64_to_cpu(reg_entry->reg_value));\n\t\treg_entry++;\n\t}\n\treg_entry++;\n\treturn reg_entry;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fadump_reg_entry*\nfadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\n\twhile (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) {\n\t\tfadump_set_regval(regs, be64_to_cpu(reg_entry->reg_id),\n\t\t\t\t\tbe64_to_cpu(reg_entry->reg_value));\n\t\treg_entry++;\n\t}\n\treg_entry++;\n\treturn reg_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SKIP_TO_NEXT_CPU",
          "args": [
            "reg_entry"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Reading register data for cpu %d...\\n\"",
            "cpu"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_TO_NEXT_CPU",
          "args": [
            "reg_entry"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&fdh->cpu_online_mask"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_entry->reg_value"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Unable to read CPU state data\\n\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"CPUSTRT\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_entry->reg_id"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.fadumphdr_addr"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Allocated buffer for cpu notes of size %ld at %p\\n\"",
            "(num_cpus * sizeof(note_buf_t))",
            "note_buf"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "note_buf"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to allocate 0x%lx bytes for \"\n\t\t\t\"cpu notes buffer\\n\"",
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_cpu_notes_buf_alloc",
          "args": [
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cpu_notes_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "547-563",
          "snippet": "static void *fadump_cpu_notes_buf_alloc(unsigned long size)\n{\n\tvoid *vaddr;\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tvaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tSetPageReserved(page + i);\n\treturn vaddr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void *fadump_cpu_notes_buf_alloc(unsigned long size)\n{\n\tvoid *vaddr;\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tvaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tSetPageReserved(page + i);\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"NumCpus     : %u\\n\"",
            "num_cpus"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*((__be32 *)(vaddr))"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "reg_header->num_cpu_offset"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"NumCpuOffset: %x\\n\"",
            "be32_to_cpu(reg_header->num_cpu_offset)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "reg_header->num_cpu_offset"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Magic Number: %llx\\n\"",
            "be64_to_cpu(reg_header->magic_number)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_header->magic_number"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"--------CPU State Data------------\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Unable to read register save area.\\n\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_header->magic_number"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm->cpu_state_data.destination_address"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)\n{\n\tstruct fadump_reg_save_area_header *reg_header;\n\tstruct fadump_reg_entry *reg_entry;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tvoid *vaddr;\n\tunsigned long addr;\n\tu32 num_cpus, *note_buf;\n\tstruct pt_regs regs;\n\tint i, rc = 0, cpu = 0;\n\n\tif (!fdm->cpu_state_data.bytes_dumped)\n\t\treturn -EINVAL;\n\n\taddr = be64_to_cpu(fdm->cpu_state_data.destination_address);\n\tvaddr = __va(addr);\n\n\treg_header = vaddr;\n\tif (be64_to_cpu(reg_header->magic_number) != REGSAVE_AREA_MAGIC) {\n\t\tprintk(KERN_ERR \"Unable to read register save area.\\n\");\n\t\treturn -ENOENT;\n\t}\n\tpr_debug(\"--------CPU State Data------------\\n\");\n\tpr_debug(\"Magic Number: %llx\\n\", be64_to_cpu(reg_header->magic_number));\n\tpr_debug(\"NumCpuOffset: %x\\n\", be32_to_cpu(reg_header->num_cpu_offset));\n\n\tvaddr += be32_to_cpu(reg_header->num_cpu_offset);\n\tnum_cpus = be32_to_cpu(*((__be32 *)(vaddr)));\n\tpr_debug(\"NumCpus     : %u\\n\", num_cpus);\n\tvaddr += sizeof(u32);\n\treg_entry = (struct fadump_reg_entry *)vaddr;\n\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tnote_buf = fadump_cpu_notes_buf_alloc(fw_dump.cpu_notes_buf_size);\n\tif (!note_buf) {\n\t\tprintk(KERN_ERR \"Failed to allocate 0x%lx bytes for \"\n\t\t\t\"cpu notes buffer\\n\", fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\tfw_dump.cpu_notes_buf = __pa(note_buf);\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at %p\\n\",\n\t\t\t(num_cpus * sizeof(note_buf_t)), note_buf);\n\n\tif (fw_dump.fadumphdr_addr)\n\t\tfdh = __va(fw_dump.fadumphdr_addr);\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\tif (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUSTRT\")) {\n\t\t\tprintk(KERN_ERR \"Unable to read CPU state data\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto error_out;\n\t\t}\n\t\t/* Lower 4 bytes of reg_value contains logical cpu id */\n\t\tcpu = be64_to_cpu(reg_entry->reg_value) & FADUMP_CPU_ID_MASK;\n\t\tif (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"Reading register data for cpu %d...\\n\", cpu);\n\t\tif (fdh && fdh->crashing_cpu == cpu) {\n\t\t\tregs = fdh->regs;\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t\tSKIP_TO_NEXT_CPU(reg_entry);\n\t\t} else {\n\t\t\treg_entry++;\n\t\t\treg_entry = fadump_read_registers(reg_entry, &regs);\n\t\t\tnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\n\t\t}\n\t}\n\tfadump_final_note(note_buf);\n\n\tif (fdh) {\n\t\tpr_debug(\"Updating elfcore header (%llx) with cpu notes\\n\",\n\t\t\t\t\t\t\tfdh->elfcorehdr_addr);\n\t\tfadump_update_elfcore_header((char *)__va(fdh->elfcorehdr_addr));\n\t}\n\treturn 0;\n\nerror_out:\n\tfadump_cpu_notes_buf_free((unsigned long)__va(fw_dump.cpu_notes_buf),\n\t\t\t\t\tfw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n\treturn rc;\n\n}"
  },
  {
    "function_name": "fadump_cpu_notes_buf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "565-576",
    "snippet": "static void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReserved",
          "args": [
            "page + i"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vaddr"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\n{\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
  },
  {
    "function_name": "fadump_cpu_notes_buf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "547-563",
    "snippet": "static void *fadump_cpu_notes_buf_alloc(unsigned long size)\n{\n\tvoid *vaddr;\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tvaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tSetPageReserved(page + i);\n\treturn vaddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageReserved",
          "args": [
            "page + i"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vaddr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL|__GFP_ZERO",
            "order"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void *fadump_cpu_notes_buf_alloc(unsigned long size)\n{\n\tvoid *vaddr;\n\tstruct page *page;\n\tunsigned long order, count, i;\n\n\torder = get_order(size);\n\tvaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = 1 << order;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tSetPageReserved(page + i);\n\treturn vaddr;\n}"
  },
  {
    "function_name": "fadump_update_elfcore_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "527-545",
    "snippet": "static void fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr = fw_dump.cpu_notes_buf;\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\tstruct elf_phdr *phdr;\n\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr = fw_dump.cpu_notes_buf;\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fadump_regs_to_elf_notes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "512-525",
    "snippet": "static u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t\t&prstatus, sizeof(prstatus));\n\treturn buf;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_append_elf_note",
          "args": [
            "buf",
            "KEXEC_CORE_NOTE_NAME",
            "NT_PRSTATUS",
            "&prstatus",
            "sizeof(prstatus)"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_append_elf_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "484-500",
          "snippet": "static u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,\n\t\t\t\t\t\tvoid *data, size_t data_len)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = strlen(name) + 1;\n\tnote.n_descsz = data_len;\n\tnote.n_type   = type;\n\tmemcpy(buf, &note, sizeof(note));\n\tbuf += (sizeof(note) + 3)/4;\n\tmemcpy(buf, name, note.n_namesz);\n\tbuf += (note.n_namesz + 3)/4;\n\tmemcpy(buf, data, note.n_descsz);\n\tbuf += (note.n_descsz + 3)/4;\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,\n\t\t\t\t\t\tvoid *data, size_t data_len)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = strlen(name) + 1;\n\tnote.n_descsz = data_len;\n\tnote.n_type   = type;\n\tmemcpy(buf, &note, sizeof(note));\n\tbuf += (sizeof(note) + 3)/4;\n\tmemcpy(buf, name, note.n_namesz);\n\tbuf += (note.n_namesz + 3)/4;\n\tmemcpy(buf, data, note.n_descsz);\n\tbuf += (note.n_descsz + 3)/4;\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_kernel_regs",
          "args": [
            "&prstatus.pr_reg",
            "regs"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&prstatus",
            "0",
            "sizeof(prstatus)"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t\t&prstatus, sizeof(prstatus));\n\treturn buf;\n}"
  },
  {
    "function_name": "fadump_final_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "502-510",
    "snippet": "static void fadump_final_note(u32 *buf)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = 0;\n\tnote.n_descsz = 0;\n\tnote.n_type   = 0;\n\tmemcpy(buf, &note, sizeof(note));\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&note",
            "sizeof(note)"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_final_note(u32 *buf)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = 0;\n\tnote.n_descsz = 0;\n\tnote.n_type   = 0;\n\tmemcpy(buf, &note, sizeof(note));\n}"
  },
  {
    "function_name": "fadump_append_elf_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "484-500",
    "snippet": "static u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,\n\t\t\t\t\t\tvoid *data, size_t data_len)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = strlen(name) + 1;\n\tnote.n_descsz = data_len;\n\tnote.n_type   = type;\n\tmemcpy(buf, &note, sizeof(note));\n\tbuf += (sizeof(note) + 3)/4;\n\tmemcpy(buf, name, note.n_namesz);\n\tbuf += (note.n_namesz + 3)/4;\n\tmemcpy(buf, data, note.n_descsz);\n\tbuf += (note.n_descsz + 3)/4;\n\n\treturn buf;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "data",
            "note.n_descsz"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,\n\t\t\t\t\t\tvoid *data, size_t data_len)\n{\n\tstruct elf_note note;\n\n\tnote.n_namesz = strlen(name) + 1;\n\tnote.n_descsz = data_len;\n\tnote.n_type   = type;\n\tmemcpy(buf, &note, sizeof(note));\n\tbuf += (sizeof(note) + 3)/4;\n\tmemcpy(buf, name, note.n_namesz);\n\tbuf += (note.n_namesz + 3)/4;\n\tmemcpy(buf, data, note.n_descsz);\n\tbuf += (note.n_descsz + 3)/4;\n\n\treturn buf;\n}"
  },
  {
    "function_name": "fadump_read_registers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "470-482",
    "snippet": "static struct fadump_reg_entry*\nfadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\n\twhile (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) {\n\t\tfadump_set_regval(regs, be64_to_cpu(reg_entry->reg_id),\n\t\t\t\t\tbe64_to_cpu(reg_entry->reg_value));\n\t\treg_entry++;\n\t}\n\treg_entry++;\n\treturn reg_entry;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_set_regval",
          "args": [
            "regs",
            "be64_to_cpu(reg_entry->reg_id)",
            "be64_to_cpu(reg_entry->reg_value)"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_set_regval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "444-468",
          "snippet": "static inline void fadump_set_regval(struct pt_regs *regs, u64 reg_id,\n\t\t\t\t\t\t\t\tu64 reg_val)\n{\n\tint i;\n\n\ti = fadump_gpr_index(reg_id);\n\tif (i >= 0)\n\t\tregs->gpr[i] = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"NIA\"))\n\t\tregs->nip = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"MSR\"))\n\t\tregs->msr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CTR\"))\n\t\tregs->ctr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"LR\"))\n\t\tregs->link = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"XER\"))\n\t\tregs->xer = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CR\"))\n\t\tregs->ccr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DAR\"))\n\t\tregs->dar = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DSISR\"))\n\t\tregs->dsisr = (unsigned long)reg_val;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic inline void fadump_set_regval(struct pt_regs *regs, u64 reg_id,\n\t\t\t\t\t\t\t\tu64 reg_val)\n{\n\tint i;\n\n\ti = fadump_gpr_index(reg_id);\n\tif (i >= 0)\n\t\tregs->gpr[i] = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"NIA\"))\n\t\tregs->nip = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"MSR\"))\n\t\tregs->msr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CTR\"))\n\t\tregs->ctr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"LR\"))\n\t\tregs->link = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"XER\"))\n\t\tregs->xer = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CR\"))\n\t\tregs->ccr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DAR\"))\n\t\tregs->dar = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DSISR\"))\n\t\tregs->dsisr = (unsigned long)reg_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_entry->reg_value"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_entry->reg_id"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"CPUEND\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "reg_entry->reg_id"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "regs",
            "0",
            "sizeof(struct pt_regs)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fadump_reg_entry*\nfadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\n\twhile (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) {\n\t\tfadump_set_regval(regs, be64_to_cpu(reg_entry->reg_id),\n\t\t\t\t\tbe64_to_cpu(reg_entry->reg_value));\n\t\treg_entry++;\n\t}\n\treg_entry++;\n\treturn reg_entry;\n}"
  },
  {
    "function_name": "fadump_set_regval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "444-468",
    "snippet": "static inline void fadump_set_regval(struct pt_regs *regs, u64 reg_id,\n\t\t\t\t\t\t\t\tu64 reg_val)\n{\n\tint i;\n\n\ti = fadump_gpr_index(reg_id);\n\tif (i >= 0)\n\t\tregs->gpr[i] = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"NIA\"))\n\t\tregs->nip = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"MSR\"))\n\t\tregs->msr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CTR\"))\n\t\tregs->ctr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"LR\"))\n\t\tregs->link = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"XER\"))\n\t\tregs->xer = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CR\"))\n\t\tregs->ccr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DAR\"))\n\t\tregs->dar = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DSISR\"))\n\t\tregs->dsisr = (unsigned long)reg_val;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"DSISR\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"DAR\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"CR\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"XER\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"LR\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"CTR\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"MSR\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"NIA\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_gpr_index",
          "args": [
            "reg_id"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_gpr_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "425-442",
          "snippet": "static inline int fadump_gpr_index(u64 id)\n{\n\tint i = -1;\n\tchar str[3];\n\n\tif ((id & GPR_MASK) == REG_ID(\"GPR\")) {\n\t\t/* get the digits at the end */\n\t\tid &= ~GPR_MASK;\n\t\tid >>= 24;\n\t\tstr[2] = '\\0';\n\t\tstr[1] = id & 0xff;\n\t\tstr[0] = (id >> 8) & 0xff;\n\t\tsscanf(str, \"%d\", &i);\n\t\tif (i > 31)\n\t\t\ti = -1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [
            "#define GPR_MASK\t0xffffff0000000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#define GPR_MASK\t0xffffff0000000000\n\nstatic inline int fadump_gpr_index(u64 id)\n{\n\tint i = -1;\n\tchar str[3];\n\n\tif ((id & GPR_MASK) == REG_ID(\"GPR\")) {\n\t\t/* get the digits at the end */\n\t\tid &= ~GPR_MASK;\n\t\tid >>= 24;\n\t\tstr[2] = '\\0';\n\t\tstr[1] = id & 0xff;\n\t\tstr[0] = (id >> 8) & 0xff;\n\t\tsscanf(str, \"%d\", &i);\n\t\tif (i > 31)\n\t\t\ti = -1;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic inline void fadump_set_regval(struct pt_regs *regs, u64 reg_id,\n\t\t\t\t\t\t\t\tu64 reg_val)\n{\n\tint i;\n\n\ti = fadump_gpr_index(reg_id);\n\tif (i >= 0)\n\t\tregs->gpr[i] = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"NIA\"))\n\t\tregs->nip = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"MSR\"))\n\t\tregs->msr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CTR\"))\n\t\tregs->ctr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"LR\"))\n\t\tregs->link = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"XER\"))\n\t\tregs->xer = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"CR\"))\n\t\tregs->ccr = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DAR\"))\n\t\tregs->dar = (unsigned long)reg_val;\n\telse if (reg_id == REG_ID(\"DSISR\"))\n\t\tregs->dsisr = (unsigned long)reg_val;\n}"
  },
  {
    "function_name": "fadump_gpr_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "425-442",
    "snippet": "static inline int fadump_gpr_index(u64 id)\n{\n\tint i = -1;\n\tchar str[3];\n\n\tif ((id & GPR_MASK) == REG_ID(\"GPR\")) {\n\t\t/* get the digits at the end */\n\t\tid &= ~GPR_MASK;\n\t\tid >>= 24;\n\t\tstr[2] = '\\0';\n\t\tstr[1] = id & 0xff;\n\t\tstr[0] = (id >> 8) & 0xff;\n\t\tsscanf(str, \"%d\", &i);\n\t\tif (i > 31)\n\t\t\ti = -1;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [
      "#define GPR_MASK\t0xffffff0000000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d\"",
            "&i"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_ID",
          "args": [
            "\"GPR\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#define GPR_MASK\t0xffffff0000000000\n\nstatic inline int fadump_gpr_index(u64 id)\n{\n\tint i = -1;\n\tchar str[3];\n\n\tif ((id & GPR_MASK) == REG_ID(\"GPR\")) {\n\t\t/* get the digits at the end */\n\t\tid &= ~GPR_MASK;\n\t\tid >>= 24;\n\t\tstr[2] = '\\0';\n\t\tstr[1] = id & 0xff;\n\t\tstr[0] = (id >> 8) & 0xff;\n\t\tsscanf(str, \"%d\", &i);\n\t\tif (i > 31)\n\t\t\ti = -1;\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "crash_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "401-422",
    "snippet": "void crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tstruct fadump_crash_info_header *fdh = NULL;\n\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn;\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tcrashing_cpu = smp_processor_id();\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->cpu_online_mask = *cpu_online_mask;\n\n\t/* Call ibm,os-term rtas call to trigger firmware assisted dump */\n\trtas_os_term((char *)str);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_os_term",
          "args": [
            "(char *)str"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_os_term",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "703-726",
          "snippet": "void rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char rtas_os_term_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic char rtas_os_term_buf[2048];\n\nvoid rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_save_regs",
          "args": [
            "&fdh->regs"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_save_vmcoreinfo",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "arch_crash_save_vmcoreinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "69-90",
          "snippet": "void arch_crash_save_vmcoreinfo(void)\n{\n\n#ifdef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(node_data);\n\tVMCOREINFO_LENGTH(node_data, MAX_NUMNODES);\n#endif\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#if defined(CONFIG_PPC64) && defined(CONFIG_SPARSEMEM_VMEMMAP)\n\tVMCOREINFO_SYMBOL(vmemmap_list);\n\tVMCOREINFO_SYMBOL(mmu_vmemmap_psize);\n\tVMCOREINFO_SYMBOL(mmu_psize_defs);\n\tVMCOREINFO_STRUCT_SIZE(vmemmap_backing);\n\tVMCOREINFO_OFFSET(vmemmap_backing, list);\n\tVMCOREINFO_OFFSET(vmemmap_backing, phys);\n\tVMCOREINFO_OFFSET(vmemmap_backing, virt_addr);\n\tVMCOREINFO_STRUCT_SIZE(mmu_psize_def);\n\tVMCOREINFO_OFFSET(mmu_psize_def, shift);\n#endif\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid arch_crash_save_vmcoreinfo(void)\n{\n\n#ifdef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(node_data);\n\tVMCOREINFO_LENGTH(node_data, MAX_NUMNODES);\n#endif\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#if defined(CONFIG_PPC64) && defined(CONFIG_SPARSEMEM_VMEMMAP)\n\tVMCOREINFO_SYMBOL(vmemmap_list);\n\tVMCOREINFO_SYMBOL(mmu_vmemmap_psize);\n\tVMCOREINFO_SYMBOL(mmu_psize_defs);\n\tVMCOREINFO_STRUCT_SIZE(vmemmap_backing);\n\tVMCOREINFO_OFFSET(vmemmap_backing, list);\n\tVMCOREINFO_OFFSET(vmemmap_backing, phys);\n\tVMCOREINFO_OFFSET(vmemmap_backing, virt_addr);\n\tVMCOREINFO_STRUCT_SIZE(mmu_psize_def);\n\tVMCOREINFO_OFFSET(mmu_psize_def, shift);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.fadumphdr_addr"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tstruct fadump_crash_info_header *fdh = NULL;\n\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn;\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tcrashing_cpu = smp_processor_id();\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->cpu_online_mask = *cpu_online_mask;\n\n\t/* Call ibm,os-term rtas call to trigger firmware assisted dump */\n\trtas_os_term((char *)str);\n}"
  },
  {
    "function_name": "register_fw_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "360-399",
    "snippet": "static void register_fw_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_REGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\n\t} while (wait_time);\n\n\tswitch (rc) {\n\tcase -1:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Hardware Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -3:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Parameter Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -9:\n\t\tprintk(KERN_ERR \"firmware-assisted kernel dump is already \"\n\t\t\t\" registered.\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\tcase 0:\n\t\tprintk(KERN_INFO \"firmware-assisted kernel dump registration\"\n\t\t\t\" is successful\\n\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"firmware-assisted kernel dump registration\"\n\t\t\t\" is successful\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"firmware-assisted kernel dump is already \"\n\t\t\t\" registered.\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Parameter Error(%d).\\n\"",
            "rc"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "wait_time"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay_time",
          "args": [
            "rc"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "474-489",
          "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "fw_dump.ibm_configure_kernel_dump",
            "3",
            "1",
            "NULL",
            "FADUMP_REGISTER",
            "fdm",
            "sizeof(struct fadump_mem_struct)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Registering for firmware-assisted kernel dump...\\n\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic void register_fw_dump(struct fadump_mem_struct *fdm)\n{\n\tint rc;\n\tunsigned int wait_time;\n\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\n\t/* TODO: Add upper time limit for the delay */\n\tdo {\n\t\trc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\n\t\t\tFADUMP_REGISTER, fdm,\n\t\t\tsizeof(struct fadump_mem_struct));\n\n\t\twait_time = rtas_busy_delay_time(rc);\n\t\tif (wait_time)\n\t\t\tmdelay(wait_time);\n\n\t} while (wait_time);\n\n\tswitch (rc) {\n\tcase -1:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Hardware Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -3:\n\t\tprintk(KERN_ERR \"Failed to register firmware-assisted kernel\"\n\t\t\t\" dump. Parameter Error(%d).\\n\", rc);\n\t\tbreak;\n\tcase -9:\n\t\tprintk(KERN_ERR \"firmware-assisted kernel dump is already \"\n\t\t\t\" registered.\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\tcase 0:\n\t\tprintk(KERN_INFO \"firmware-assisted kernel dump registration\"\n\t\t\t\" is successful\\n\");\n\t\tfw_dump.dump_registered = 1;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "early_fadump_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "352-357",
    "snippet": "static int __init early_fadump_reserve_mem(char *p)\n{\n\tif (p)\n\t\tfw_dump.reserve_bootvar = memparse(p, &p);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "prom_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "556-581",
          "snippet": "static unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/opal.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/opal.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init early_fadump_reserve_mem(char *p)\n{\n\tif (p)\n\t\tfw_dump.reserve_bootvar = memparse(p, &p);\n\treturn 0;\n}"
  },
  {
    "function_name": "early_fadump_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "337-348",
    "snippet": "static int __init early_fadump_param(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tif (strncmp(p, \"on\", 2) == 0)\n\t\tfw_dump.fadump_enabled = 1;\n\telse if (strncmp(p, \"off\", 3) == 0)\n\t\tfw_dump.fadump_enabled = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"off\"",
            "3"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"on\"",
            "2"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init early_fadump_param(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tif (strncmp(p, \"on\", 2) == 0)\n\t\tfw_dump.fadump_enabled = 1;\n\telse if (strncmp(p, \"off\", 3) == 0)\n\t\tfw_dump.fadump_enabled = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "256-334",
    "snippet": "int __init fadump_reserve_mem(void)\n{\n\tunsigned long base, size, memory_boundary;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is not supported on\"\n\t\t\t\t\" this hardware\\n\");\n\t\tfw_dump.fadump_enabled = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (fdm_active)\n\t\tfw_dump.boot_memory_size = be64_to_cpu(fdm_active->rmr_region.source_len);\n\telse\n\t\tfw_dump.boot_memory_size = fadump_calculate_reserve_size();\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmemory_boundary = memory_limit;\n\telse\n\t\tmemory_boundary = memblock_end_of_DRAM();\n\n\tif (fw_dump.dump_active) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is active.\\n\");\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot_memory_size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * will be released for general use once the dump is saved.\n\t\t */\n\t\tbase = fw_dump.boot_memory_size;\n\t\tsize = memory_boundary - base;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for saving crash dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\n\t\tfw_dump.fadumphdr_addr =\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.destination_address) +\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.source_len);\n\t\tpr_debug(\"fadumphdr_addr = %p\\n\",\n\t\t\t\t(void *) fw_dump.fadumphdr_addr);\n\t} else {\n\t\t/* Reserve the memory at the top of memory. */\n\t\tsize = get_fadump_area_size();\n\t\tbase = memory_boundary - size;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for firmware-assisted dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\t}\n\tfw_dump.reserve_dump_area_start = base;\n\tfw_dump.reserve_dump_area_size = size;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for firmware-assisted dump\\n\"",
            "(unsigned long)(size >> 20)",
            "(unsigned long)(base >> 20)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fadump_area_size",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "get_fadump_area_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "239-254",
          "snippet": "static unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"fadumphdr_addr = %p\\n\"",
            "(void *) fw_dump.fadumphdr_addr"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_active->rmr_region.source_len"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_active->rmr_region.destination_address"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for saving crash dump\\n\"",
            "(unsigned long)(size >> 20)",
            "(unsigned long)(base >> 20)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Firmware-assisted dump is active.\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\"",
            "memory_limit"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_calculate_reserve_size",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_calculate_reserve_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "211-233",
          "snippet": "static inline unsigned long fadump_calculate_reserve_size(void)\n{\n\tunsigned long size;\n\n\t/*\n\t * Check if the size is specified through fadump_reserve_mem= cmdline\n\t * option. If yes, then use that.\n\t */\n\tif (fw_dump.reserve_bootvar)\n\t\treturn fw_dump.reserve_bootvar;\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_end_of_DRAM() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\treturn (size > MIN_BOOT_MEM ? size : MIN_BOOT_MEM);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic inline unsigned long fadump_calculate_reserve_size(void)\n{\n\tunsigned long size;\n\n\t/*\n\t * Check if the size is specified through fadump_reserve_mem= cmdline\n\t * option. If yes, then use that.\n\t */\n\tif (fw_dump.reserve_bootvar)\n\t\treturn fw_dump.reserve_bootvar;\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_end_of_DRAM() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\treturn (size > MIN_BOOT_MEM ? size : MIN_BOOT_MEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fdm_active->rmr_region.source_len"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Firmware-assisted dump is not supported on\"\n\t\t\t\t\" this hardware\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic const struct fadump_mem_struct *fdm_active;\n\nint __init fadump_reserve_mem(void)\n{\n\tunsigned long base, size, memory_boundary;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is not supported on\"\n\t\t\t\t\" this hardware\\n\");\n\t\tfw_dump.fadump_enabled = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (fdm_active)\n\t\tfw_dump.boot_memory_size = be64_to_cpu(fdm_active->rmr_region.source_len);\n\telse\n\t\tfw_dump.boot_memory_size = fadump_calculate_reserve_size();\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmemory_boundary = memory_limit;\n\telse\n\t\tmemory_boundary = memblock_end_of_DRAM();\n\n\tif (fw_dump.dump_active) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is active.\\n\");\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot_memory_size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * will be released for general use once the dump is saved.\n\t\t */\n\t\tbase = fw_dump.boot_memory_size;\n\t\tsize = memory_boundary - base;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for saving crash dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\n\t\tfw_dump.fadumphdr_addr =\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.destination_address) +\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.source_len);\n\t\tpr_debug(\"fadumphdr_addr = %p\\n\",\n\t\t\t\t(void *) fw_dump.fadumphdr_addr);\n\t} else {\n\t\t/* Reserve the memory at the top of memory. */\n\t\tsize = get_fadump_area_size();\n\t\tbase = memory_boundary - size;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for firmware-assisted dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\t}\n\tfw_dump.reserve_dump_area_start = base;\n\tfw_dump.reserve_dump_area_size = size;\n\treturn 1;\n}"
  },
  {
    "function_name": "get_fadump_area_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "239-254",
    "snippet": "static unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_num_regions",
          "args": [
            "memory"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\treturn size;\n}"
  },
  {
    "function_name": "fadump_calculate_reserve_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "211-233",
    "snippet": "static inline unsigned long fadump_calculate_reserve_size(void)\n{\n\tunsigned long size;\n\n\t/*\n\t * Check if the size is specified through fadump_reserve_mem= cmdline\n\t * option. If yes, then use that.\n\t */\n\tif (fw_dump.reserve_bootvar)\n\t\treturn fw_dump.reserve_bootvar;\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_end_of_DRAM() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\treturn (size > MIN_BOOT_MEM ? size : MIN_BOOT_MEM);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic inline unsigned long fadump_calculate_reserve_size(void)\n{\n\tunsigned long size;\n\n\t/*\n\t * Check if the size is specified through fadump_reserve_mem= cmdline\n\t * option. If yes, then use that.\n\t */\n\tif (fw_dump.reserve_bootvar)\n\t\treturn fw_dump.reserve_bootvar;\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_end_of_DRAM() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\treturn (size > MIN_BOOT_MEM ? size : MIN_BOOT_MEM);\n}"
  },
  {
    "function_name": "init_fadump_mem_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "141-194",
    "snippet": "static unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static struct fadump_mem_struct fdm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "addr"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fw_dump.boot_memory_size"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "RMA_START"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "FADUMP_REAL_MODE_REGION"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "FADUMP_REQUEST_FLAG"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "addr"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fw_dump.hpte_region_size"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "FADUMP_HPTE_REGION"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "FADUMP_REQUEST_FLAG"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "addr"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fw_dump.cpu_state_data_size"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "FADUMP_CPU_STATE_DATA"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "FADUMP_REQUEST_FLAG"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(u32)offsetof(struct fadump_mem_struct, cpu_state_data)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "3"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0x00000001"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdm",
            "0",
            "sizeof(struct fadump_mem_struct)"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic struct fadump_mem_struct fdm;\n\nstatic unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\n\t\t\t\tunsigned long addr)\n{\n\tif (!fdm)\n\t\treturn 0;\n\n\tmemset(fdm, 0, sizeof(struct fadump_mem_struct));\n\taddr = addr & PAGE_MASK;\n\n\tfdm->header.dump_format_version = cpu_to_be32(0x00000001);\n\tfdm->header.dump_num_sections = cpu_to_be16(3);\n\tfdm->header.dump_status_flag = 0;\n\tfdm->header.offset_first_dump_section =\n\t\tcpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));\n\n\t/*\n\t * Fields for disk dump option.\n\t * We are not using disk dump option, hence set these fields to 0.\n\t */\n\tfdm->header.dd_block_size = 0;\n\tfdm->header.dd_block_offset = 0;\n\tfdm->header.dd_num_blocks = 0;\n\tfdm->header.dd_offset_disk_path = 0;\n\n\t/* set 0 to disable an automatic dump-reboot. */\n\tfdm->header.max_time_auto = 0;\n\n\t/* Kernel dump sections */\n\t/* cpu state data section. */\n\tfdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);\n\tfdm->cpu_state_data.source_address = 0;\n\tfdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);\n\tfdm->cpu_state_data.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.cpu_state_data_size;\n\n\t/* hpte region section */\n\tfdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);\n\tfdm->hpte_region.source_address = 0;\n\tfdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);\n\tfdm->hpte_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.hpte_region_size;\n\n\t/* RMA region section */\n\tfdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);\n\tfdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);\n\tfdm->rmr_region.source_address = cpu_to_be64(RMA_START);\n\tfdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);\n\tfdm->rmr_region.destination_address = cpu_to_be64(addr);\n\taddr += fw_dump.boot_memory_size;\n\n\treturn addr;\n}"
  },
  {
    "function_name": "fadump_show_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "123-139",
    "snippet": "static void fadump_show_config(void)\n{\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"Boot memory size  : %lx\\n\", fw_dump.boot_memory_size);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Boot memory size  : %lx\\n\"",
            "fw_dump.boot_memory_size"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    HPTE region size   : %lx\\n\"",
            "fw_dump.hpte_region_size"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    CPU state data size: %lx\\n\"",
            "fw_dump.cpu_state_data_size"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Dump section sizes:\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Dump Active       : %s\\n\"",
            "(fw_dump.dump_active ? \"yes\" : \"no\")"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Fadump enabled    : %s\\n\"",
            "(fw_dump.fadump_enabled ? \"yes\" : \"no\")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Support for firmware-assisted dump (fadump): %s\\n\"",
            "(fw_dump.fadump_supported ? \"present\" : \"no support\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_show_config(void)\n{\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"Boot memory size  : %lx\\n\", fw_dump.boot_memory_size);\n}"
  },
  {
    "function_name": "is_fadump_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "117-120",
    "snippet": "int is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}"
  },
  {
    "function_name": "early_init_dt_scan_fw_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
    "lines": "55-115",
    "snippet": "int __init early_init_dt_scan_fw_dump(unsigned long node,\n\t\t\tconst char *uname, int depth, void *data)\n{\n\tconst __be32 *sections;\n\tint i, num_sections;\n\tint size;\n\tconst __be32 *token;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\t/*\n\t * Check if Firmware Assisted dump is supported. if yes, check\n\t * if dump has been initiated on last reboot.\n\t */\n\ttoken = of_get_flat_dt_prop(node, \"ibm,configure-kernel-dump\", NULL);\n\tif (!token)\n\t\treturn 1;\n\n\tfw_dump.fadump_supported = 1;\n\tfw_dump.ibm_configure_kernel_dump = be32_to_cpu(*token);\n\n\t/*\n\t * The 'ibm,kernel-dump' rtas node is present only if there is\n\t * dump data waiting for us.\n\t */\n\tfdm_active = of_get_flat_dt_prop(node, \"ibm,kernel-dump\", NULL);\n\tif (fdm_active)\n\t\tfw_dump.dump_active = 1;\n\n\t/* Get the sizes required to store dump data for the firmware provided\n\t * dump sections.\n\t * For each dump section type supported, a 32bit cell which defines\n\t * the ID of a supported section followed by two 32 bit cells which\n\t * gives teh size of the section in bytes.\n\t */\n\tsections = of_get_flat_dt_prop(node, \"ibm,configure-kernel-dump-sizes\",\n\t\t\t\t\t&size);\n\n\tif (!sections)\n\t\treturn 1;\n\n\tnum_sections = size / (3 * sizeof(u32));\n\n\tfor (i = 0; i < num_sections; i++, sections += 3) {\n\t\tu32 type = (u32)of_read_number(sections, 1);\n\n\t\tswitch (type) {\n\t\tcase FADUMP_CPU_STATE_DATA:\n\t\t\tfw_dump.cpu_state_data_size =\n\t\t\t\t\tof_read_ulong(&sections[1], 2);\n\t\t\tbreak;\n\t\tcase FADUMP_HPTE_REGION:\n\t\t\tfw_dump.hpte_region_size =\n\t\t\t\t\tof_read_ulong(&sections[1], 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static const struct fadump_mem_struct *fdm_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_read_ulong",
          "args": [
            "&sections[1]",
            "2"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_ulong",
          "args": [
            "&sections[1]",
            "2"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "sections",
            "1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,configure-kernel-dump-sizes\"",
            "&size"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,kernel-dump\"",
            "NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*token"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,configure-kernel-dump\"",
            "NULL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"rtas\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic const struct fadump_mem_struct *fdm_active;\n\nint __init early_init_dt_scan_fw_dump(unsigned long node,\n\t\t\tconst char *uname, int depth, void *data)\n{\n\tconst __be32 *sections;\n\tint i, num_sections;\n\tint size;\n\tconst __be32 *token;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\t/*\n\t * Check if Firmware Assisted dump is supported. if yes, check\n\t * if dump has been initiated on last reboot.\n\t */\n\ttoken = of_get_flat_dt_prop(node, \"ibm,configure-kernel-dump\", NULL);\n\tif (!token)\n\t\treturn 1;\n\n\tfw_dump.fadump_supported = 1;\n\tfw_dump.ibm_configure_kernel_dump = be32_to_cpu(*token);\n\n\t/*\n\t * The 'ibm,kernel-dump' rtas node is present only if there is\n\t * dump data waiting for us.\n\t */\n\tfdm_active = of_get_flat_dt_prop(node, \"ibm,kernel-dump\", NULL);\n\tif (fdm_active)\n\t\tfw_dump.dump_active = 1;\n\n\t/* Get the sizes required to store dump data for the firmware provided\n\t * dump sections.\n\t * For each dump section type supported, a 32bit cell which defines\n\t * the ID of a supported section followed by two 32 bit cells which\n\t * gives teh size of the section in bytes.\n\t */\n\tsections = of_get_flat_dt_prop(node, \"ibm,configure-kernel-dump-sizes\",\n\t\t\t\t\t&size);\n\n\tif (!sections)\n\t\treturn 1;\n\n\tnum_sections = size / (3 * sizeof(u32));\n\n\tfor (i = 0; i < num_sections; i++, sections += 3) {\n\t\tu32 type = (u32)of_read_number(sections, 1);\n\n\t\tswitch (type) {\n\t\tcase FADUMP_CPU_STATE_DATA:\n\t\t\tfw_dump.cpu_state_data_size =\n\t\t\t\t\tof_read_ulong(&sections[1], 2);\n\t\t\tbreak;\n\t\tcase FADUMP_HPTE_REGION:\n\t\t\tfw_dump.hpte_region_size =\n\t\t\t\t\tof_read_ulong(&sections[1], 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  }
]