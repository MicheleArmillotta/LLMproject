[
  {
    "function_name": "arch_trampoline_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "553-559",
    "snippet": "int __kprobes arch_trampoline_kprobe(struct kprobe *p)\n{\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes arch_trampoline_kprobe(struct kprobe *p)\n{\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_init_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "548-551",
    "snippet": "int __init arch_init_kprobes(void)\n{\n\treturn register_kprobe(&trampoline_p);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kprobe trampoline_p = {\n\t.addr = (kprobe_opcode_t *) &kretprobe_trampoline,\n\t.pre_handler = trampoline_probe_handler\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&trampoline_p"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe trampoline_p = {\n\t.addr = (kprobe_opcode_t *) &kretprobe_trampoline,\n\t.pre_handler = trampoline_probe_handler\n};\n\nint __init arch_init_kprobes(void)\n{\n\treturn register_kprobe(&trampoline_p);\n}"
  },
  {
    "function_name": "longjmp_break_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "529-541",
    "snippet": "int __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\t/*\n\t * FIXME - we should ideally be validating that we got here 'cos\n\t * of the \"trap\" in jprobe_return() above, before restoring the\n\t * saved regs...\n\t */\n\tmemcpy(regs, &kcb->jprobe_saved_regs, sizeof(struct pt_regs));\n\tpreempt_enable_no_resched();\n\treturn 1;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "regs",
            "&kcb->jprobe_saved_regs",
            "sizeof(struct pt_regs)"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\t/*\n\t * FIXME - we should ideally be validating that we got here 'cos\n\t * of the \"trap\" in jprobe_return() above, before restoring the\n\t * saved regs...\n\t */\n\tmemcpy(regs, &kcb->jprobe_saved_regs, sizeof(struct pt_regs));\n\tpreempt_enable_no_resched();\n\treturn 1;\n}"
  },
  {
    "function_name": "jprobe_return_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "525-527",
    "snippet": "__kprobes jprobe_return_end(void)\n{\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\n__kprobes jprobe_return_end(void)\n{\n}"
  },
  {
    "function_name": "jprobe_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "520-523",
    "snippet": "__kprobes jprobe_return(void)\n{\n\tasm volatile(\"trap\" ::: \"memory\");\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\n__kprobes jprobe_return(void)\n{\n\tasm volatile(\"trap\" ::: \"memory\");\n}"
  },
  {
    "function_name": "setjmp_pre_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "500-518",
    "snippet": "int __kprobes setjmp_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct jprobe *jp = container_of(p, struct jprobe, kp);\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tmemcpy(&kcb->jprobe_saved_regs, regs, sizeof(struct pt_regs));\n\n\t/* setup return addr to the jprobe handler routine */\n\tregs->nip = arch_deref_entry_point(jp->entry);\n#ifdef CONFIG_PPC64\n#if defined(_CALL_ELF) && _CALL_ELF == 2\n\tregs->gpr[12] = (unsigned long)jp->entry;\n#else\n\tregs->gpr[2] = (unsigned long)(((func_descr_t *)jp->entry)->toc);\n#endif\n#endif\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_deref_entry_point",
          "args": [
            "jp->entry"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "arch_deref_entry_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "495-498",
          "snippet": "unsigned long arch_deref_entry_point(void *entry)\n{\n\treturn ppc_global_function_entry(entry);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nunsigned long arch_deref_entry_point(void *entry)\n{\n\treturn ppc_global_function_entry(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&kcb->jprobe_saved_regs",
            "regs",
            "sizeof(struct pt_regs)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structjprobe",
            "kp"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes setjmp_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct jprobe *jp = container_of(p, struct jprobe, kp);\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tmemcpy(&kcb->jprobe_saved_regs, regs, sizeof(struct pt_regs));\n\n\t/* setup return addr to the jprobe handler routine */\n\tregs->nip = arch_deref_entry_point(jp->entry);\n#ifdef CONFIG_PPC64\n#if defined(_CALL_ELF) && _CALL_ELF == 2\n\tregs->gpr[12] = (unsigned long)jp->entry;\n#else\n\tregs->gpr[2] = (unsigned long)(((func_descr_t *)jp->entry)->toc);\n#endif\n#endif\n\n\treturn 1;\n}"
  },
  {
    "function_name": "arch_deref_entry_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "495-498",
    "snippet": "unsigned long arch_deref_entry_point(void *entry)\n{\n\treturn ppc_global_function_entry(entry);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "entry"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nunsigned long arch_deref_entry_point(void *entry)\n{\n\treturn ppc_global_function_entry(entry);\n}"
  },
  {
    "function_name": "kprobe_exceptions_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "471-493",
    "snippet": "int __kprobes kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct die_args *args = (struct die_args *)data;\n\tint ret = NOTIFY_DONE;\n\n\tif (args->regs && user_mode(args->regs))\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase DIE_BPT:\n\t\tif (kprobe_handler(args->regs))\n\t\t\tret = NOTIFY_STOP;\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tif (post_kprobe_handler(args->regs))\n\t\t\tret = NOTIFY_STOP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_kprobe_handler",
          "args": [
            "args->regs"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "post_kprobe_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "363-402",
          "snippet": "static int __kprobes post_kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur)\n\t\treturn 0;\n\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + 4) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + 4;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int __kprobes post_kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur)\n\t\treturn 0;\n\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + 4) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + 4;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "args->regs"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct die_args *args = (struct die_args *)data;\n\tint ret = NOTIFY_DONE;\n\n\tif (args->regs && user_mode(args->regs))\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase DIE_BPT:\n\t\tif (kprobe_handler(args->regs))\n\t\t\tret = NOTIFY_STOP;\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tif (post_kprobe_handler(args->regs))\n\t\t\tret = NOTIFY_STOP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_fault_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "404-466",
    "snippet": "int __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\tconst struct exception_table_entry *entry;\n\n\tswitch(kcb->kprobe_status) {\n\tcase KPROBE_HIT_SS:\n\tcase KPROBE_REENTER:\n\t\t/*\n\t\t * We are here because the instruction being single\n\t\t * stepped caused a page fault. We reset the current\n\t\t * kprobe and the nip points back to the probe address\n\t\t * and allow the page fault handler to continue as a\n\t\t * normal page fault.\n\t\t */\n\t\tregs->nip = (unsigned long)cur->addr;\n\t\tregs->msr &= ~MSR_SINGLESTEP; /* Turn off 'trace' bits */\n\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\tif (kcb->kprobe_status == KPROBE_REENTER)\n\t\t\trestore_previous_kprobe(kcb);\n\t\telse\n\t\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\tbreak;\n\tcase KPROBE_HIT_ACTIVE:\n\tcase KPROBE_HIT_SSDONE:\n\t\t/*\n\t\t * We increment the nmissed count for accounting,\n\t\t * we can also use npre/npostfault count for accounting\n\t\t * these specific fault cases.\n\t\t */\n\t\tkprobes_inc_nmissed_count(cur);\n\n\t\t/*\n\t\t * We come here because instructions in the pre/post\n\t\t * handler caused the page_fault, this could happen\n\t\t * if handler tries to access user space by\n\t\t * copy_from_user(), get_user() etc. Let the\n\t\t * user-specified handler try to fix it first.\n\t\t */\n\t\tif (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * In case the user-specified fault handler returned\n\t\t * zero, try to fix up.\n\t\t */\n\t\tif ((entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * fixup_exception() could not handle it,\n\t\t * Let do_page_fault() fix it.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_exception_tables",
          "args": [
            "regs->nip"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->fault_handler",
          "args": [
            "cur",
            "regs",
            "trapnr"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobes_inc_nmissed_count",
          "args": [
            "cur"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "restore_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "120-125",
          "snippet": "static void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\tconst struct exception_table_entry *entry;\n\n\tswitch(kcb->kprobe_status) {\n\tcase KPROBE_HIT_SS:\n\tcase KPROBE_REENTER:\n\t\t/*\n\t\t * We are here because the instruction being single\n\t\t * stepped caused a page fault. We reset the current\n\t\t * kprobe and the nip points back to the probe address\n\t\t * and allow the page fault handler to continue as a\n\t\t * normal page fault.\n\t\t */\n\t\tregs->nip = (unsigned long)cur->addr;\n\t\tregs->msr &= ~MSR_SINGLESTEP; /* Turn off 'trace' bits */\n\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\tif (kcb->kprobe_status == KPROBE_REENTER)\n\t\t\trestore_previous_kprobe(kcb);\n\t\telse\n\t\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\tbreak;\n\tcase KPROBE_HIT_ACTIVE:\n\tcase KPROBE_HIT_SSDONE:\n\t\t/*\n\t\t * We increment the nmissed count for accounting,\n\t\t * we can also use npre/npostfault count for accounting\n\t\t * these specific fault cases.\n\t\t */\n\t\tkprobes_inc_nmissed_count(cur);\n\n\t\t/*\n\t\t * We come here because instructions in the pre/post\n\t\t * handler caused the page_fault, this could happen\n\t\t * if handler tries to access user space by\n\t\t * copy_from_user(), get_user() etc. Let the\n\t\t * user-specified handler try to fix it first.\n\t\t */\n\t\tif (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * In case the user-specified fault handler returned\n\t\t * zero, try to fix up.\n\t\t */\n\t\tif ((entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * fixup_exception() could not handle it,\n\t\t * Let do_page_fault() fix it.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "post_kprobe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "363-402",
    "snippet": "static int __kprobes post_kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur)\n\t\treturn 0;\n\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + 4) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + 4;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "restore_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "120-125",
          "snippet": "static void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->post_handler",
          "args": [
            "cur",
            "regs",
            "0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int __kprobes post_kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur)\n\t\treturn 0;\n\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + 4) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + 4;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "trampoline_probe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "291-353",
    "snippet": "static int __kprobes trampoline_probe_handler(struct kprobe *p,\n\t\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long flags, orig_ret_address = 0;\n\tunsigned long trampoline_address =(unsigned long)&kretprobe_trampoline;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\tkretprobe_hash_lock(current, &head, &flags);\n\n\t/*\n\t * It is possible to have multiple instances associated with a given\n\t * task either because an multiple functions in the call path\n\t * have a return probe installed on them, and/or more than one return\n\t * return probe was registered for a target function.\n\t *\n\t * We can handle this because:\n\t *     - instances are always inserted at the head of the list\n\t *     - when multiple return probes are registered for the same\n\t *       function, the first instance's ret_addr will point to the\n\t *       real return address, and all the rest will point to\n\t *       kretprobe_trampoline\n\t */\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task != current)\n\t\t\t/* another task is sharing our hash bucket */\n\t\t\tcontinue;\n\n\t\tif (ri->rp && ri->rp->handler)\n\t\t\tri->rp->handler(ri, regs);\n\n\t\torig_ret_address = (unsigned long)ri->ret_addr;\n\t\trecycle_rp_inst(ri, &empty_rp);\n\n\t\tif (orig_ret_address != trampoline_address)\n\t\t\t/*\n\t\t\t * This is the real return address. Any other\n\t\t\t * instances associated with this task are for\n\t\t\t * other calls deeper on the call stack\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tkretprobe_assert(ri, orig_ret_address, trampoline_address);\n\tregs->nip = orig_ret_address;\n\n\treset_current_kprobe();\n\tkretprobe_hash_unlock(current, &flags);\n\tpreempt_enable_no_resched();\n\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n\t/*\n\t * By returning a non-zero value, we are telling\n\t * kprobe_handler() that we don't want the post_handler\n\t * to run (and have re-enabled preemption)\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "&empty_rp",
            "hlist"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_hash_unlock",
          "args": [
            "current",
            "&flags"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_assert",
          "args": [
            "ri",
            "orig_ret_address",
            "trampoline_address"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recycle_rp_inst",
          "args": [
            "ri",
            "&empty_rp"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri->rp->handler",
          "args": [
            "ri",
            "regs"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "head",
            "hlist"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_hash_lock",
          "args": [
            "current",
            "&head",
            "&flags"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&empty_rp"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int __kprobes trampoline_probe_handler(struct kprobe *p,\n\t\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long flags, orig_ret_address = 0;\n\tunsigned long trampoline_address =(unsigned long)&kretprobe_trampoline;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\tkretprobe_hash_lock(current, &head, &flags);\n\n\t/*\n\t * It is possible to have multiple instances associated with a given\n\t * task either because an multiple functions in the call path\n\t * have a return probe installed on them, and/or more than one return\n\t * return probe was registered for a target function.\n\t *\n\t * We can handle this because:\n\t *     - instances are always inserted at the head of the list\n\t *     - when multiple return probes are registered for the same\n\t *       function, the first instance's ret_addr will point to the\n\t *       real return address, and all the rest will point to\n\t *       kretprobe_trampoline\n\t */\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task != current)\n\t\t\t/* another task is sharing our hash bucket */\n\t\t\tcontinue;\n\n\t\tif (ri->rp && ri->rp->handler)\n\t\t\tri->rp->handler(ri, regs);\n\n\t\torig_ret_address = (unsigned long)ri->ret_addr;\n\t\trecycle_rp_inst(ri, &empty_rp);\n\n\t\tif (orig_ret_address != trampoline_address)\n\t\t\t/*\n\t\t\t * This is the real return address. Any other\n\t\t\t * instances associated with this task are for\n\t\t\t * other calls deeper on the call stack\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tkretprobe_assert(ri, orig_ret_address, trampoline_address);\n\tregs->nip = orig_ret_address;\n\n\treset_current_kprobe();\n\tkretprobe_hash_unlock(current, &flags);\n\tpreempt_enable_no_resched();\n\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n\t/*\n\t * By returning a non-zero value, we are telling\n\t * kprobe_handler() that we don't want the post_handler\n\t * to run (and have re-enabled preemption)\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "kretprobe_trampoline_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "281-286",
    "snippet": "static void __used kretprobe_trampoline_holder(void)\n{\n\tasm volatile(\".global kretprobe_trampoline\\n\"\n\t\t\t\"kretprobe_trampoline:\\n\"\n\t\t\t\"nop\\n\");\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __used",
      "static void __used"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid __used;\nstatic void __used;\n\nstatic void __used kretprobe_trampoline_holder(void)\n{\n\tasm volatile(\".global kretprobe_trampoline\\n\"\n\t\t\t\"kretprobe_trampoline:\\n\"\n\t\t\t\"nop\\n\");\n}"
  },
  {
    "function_name": "kprobe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "143-273",
    "snippet": "static int __kprobes kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tp = get_kprobe(addr);\n\t\tif (p) {\n\t\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\t\tif (kcb->kprobe_status == KPROBE_HIT_SS &&\n\t\t\t\t\tis_trap(insn)) {\n\t\t\t\t/* Turn off 'trace' bits */\n\t\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\t\tgoto no_kprobe;\n\t\t\t}\n\t\t\t/* We have reentered the kprobe_handler(), since\n\t\t\t * another probe was hit while within the handler.\n\t\t\t * We here save the original kprobes variables and\n\t\t\t * just single step on the instruction of the new probe\n\t\t\t * without calling any user handlers.\n\t\t\t */\n\t\t\tsave_previous_kprobe(kcb);\n\t\t\tset_current_kprobe(p, regs, kcb);\n\t\t\tkcb->kprobe_saved_msr = regs->msr;\n\t\t\tkprobes_inc_nmissed_count(p);\n\t\t\tprepare_singlestep(p, regs);\n\t\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (*addr != BREAKPOINT_INSTRUCTION) {\n\t\t\t\t/* If trap variant, then it belongs not to us */\n\t\t\t\tkprobe_opcode_t cur_insn = *addr;\n\t\t\t\tif (is_trap(cur_insn))\n\t\t       \t\t\tgoto no_kprobe;\n\t\t\t\t/* The breakpoint instruction was removed by\n\t\t\t\t * another cpu right after we hit, no further\n\t\t\t\t * handling of this interrupt is appropriate\n\t\t\t\t */\n\t\t\t\tret = 1;\n\t\t\t\tgoto no_kprobe;\n\t\t\t}\n\t\t\tp = __this_cpu_read(current_kprobe);\n\t\t\tif (p->break_handler && p->break_handler(p, regs)) {\n\t\t\t\tgoto ss_probe;\n\t\t\t}\n\t\t}\n\t\tgoto no_kprobe;\n\t}\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tif (*addr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tkprobe_opcode_t cur_insn = *addr;\n\t\t\tif (is_trap(cur_insn))\n\t\t       \t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs))\n\t\t/* handler has already set things up, so skip ss setup */\n\t\treturn 1;\n\nss_probe:\n\tif (p->ainsn.boostable >= 0) {\n\t\tunsigned int insn = *p->ainsn.insn;\n\n\t\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\t\tret = emulate_step(regs, insn);\n\t\tif (ret > 0) {\n\t\t\t/*\n\t\t\t * Once this instruction has been boosted\n\t\t\t * successfully, set the boostable flag\n\t\t\t */\n\t\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\t\tp->ainsn.boostable = 1;\n\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t} else if (ret < 0) {\n\t\t\t/*\n\t\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t\t * So, we should never get here... but, its still\n\t\t\t * good to catch them, just in case...\n\t\t\t */\n\t\t\tprintk(\"Can't step on instruction %x\\n\", insn);\n\t\t\tBUG();\n\t\t} else if (ret == 0)\n\t\t\t/* This instruction can't be boosted */\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_singlestep",
          "args": [
            "p",
            "regs"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_singlestep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "100-111",
          "snippet": "static void __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic void __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Can't step on instruction %x\\n\"",
            "insn"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->post_handler",
          "args": [
            "p",
            "regs",
            "0"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ainsn.boostable == 0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_step",
          "args": [
            "regs",
            "insn"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->pre_handler",
          "args": [
            "p",
            "regs"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_kprobe",
          "args": [
            "p",
            "regs",
            "kcb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set_current_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "127-132",
          "snippet": "static void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trap",
          "args": [
            "cur_insn"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
          "lines": "38-41",
          "snippet": "bool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}",
          "includes": [
            "#include <asm/sstep.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nbool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "addr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->break_handler",
          "args": [
            "p",
            "regs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_kprobe"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobes_inc_nmissed_count",
          "args": [
            "p"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "save_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "113-118",
          "snippet": "static void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "addr"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic int __kprobes kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tp = get_kprobe(addr);\n\t\tif (p) {\n\t\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\t\tif (kcb->kprobe_status == KPROBE_HIT_SS &&\n\t\t\t\t\tis_trap(insn)) {\n\t\t\t\t/* Turn off 'trace' bits */\n\t\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\t\tgoto no_kprobe;\n\t\t\t}\n\t\t\t/* We have reentered the kprobe_handler(), since\n\t\t\t * another probe was hit while within the handler.\n\t\t\t * We here save the original kprobes variables and\n\t\t\t * just single step on the instruction of the new probe\n\t\t\t * without calling any user handlers.\n\t\t\t */\n\t\t\tsave_previous_kprobe(kcb);\n\t\t\tset_current_kprobe(p, regs, kcb);\n\t\t\tkcb->kprobe_saved_msr = regs->msr;\n\t\t\tkprobes_inc_nmissed_count(p);\n\t\t\tprepare_singlestep(p, regs);\n\t\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (*addr != BREAKPOINT_INSTRUCTION) {\n\t\t\t\t/* If trap variant, then it belongs not to us */\n\t\t\t\tkprobe_opcode_t cur_insn = *addr;\n\t\t\t\tif (is_trap(cur_insn))\n\t\t       \t\t\tgoto no_kprobe;\n\t\t\t\t/* The breakpoint instruction was removed by\n\t\t\t\t * another cpu right after we hit, no further\n\t\t\t\t * handling of this interrupt is appropriate\n\t\t\t\t */\n\t\t\t\tret = 1;\n\t\t\t\tgoto no_kprobe;\n\t\t\t}\n\t\t\tp = __this_cpu_read(current_kprobe);\n\t\t\tif (p->break_handler && p->break_handler(p, regs)) {\n\t\t\t\tgoto ss_probe;\n\t\t\t}\n\t\t}\n\t\tgoto no_kprobe;\n\t}\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tif (*addr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tkprobe_opcode_t cur_insn = *addr;\n\t\t\tif (is_trap(cur_insn))\n\t\t       \t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs))\n\t\t/* handler has already set things up, so skip ss setup */\n\t\treturn 1;\n\nss_probe:\n\tif (p->ainsn.boostable >= 0) {\n\t\tunsigned int insn = *p->ainsn.insn;\n\n\t\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\t\tret = emulate_step(regs, insn);\n\t\tif (ret > 0) {\n\t\t\t/*\n\t\t\t * Once this instruction has been boosted\n\t\t\t * successfully, set the boostable flag\n\t\t\t */\n\t\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\t\tp->ainsn.boostable = 1;\n\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t} else if (ret < 0) {\n\t\t\t/*\n\t\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t\t * So, we should never get here... but, its still\n\t\t\t * good to catch them, just in case...\n\t\t\t */\n\t\t\tprintk(\"Can't step on instruction %x\\n\", insn);\n\t\t\tBUG();\n\t\t} else if (ret == 0)\n\t\t\t/* This instruction can't be boosted */\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}"
  },
  {
    "function_name": "arch_prepare_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "134-141",
    "snippet": "void __kprobes arch_prepare_kretprobe(struct kretprobe_instance *ri,\n\t\t\t\t      struct pt_regs *regs)\n{\n\tri->ret_addr = (kprobe_opcode_t *)regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = (unsigned long)kretprobe_trampoline;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid __kprobes arch_prepare_kretprobe(struct kretprobe_instance *ri,\n\t\t\t\t      struct pt_regs *regs)\n{\n\tri->ret_addr = (kprobe_opcode_t *)regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = (unsigned long)kretprobe_trampoline;\n}"
  },
  {
    "function_name": "set_current_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "127-132",
    "snippet": "static void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "p"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}"
  },
  {
    "function_name": "restore_previous_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "120-125",
    "snippet": "static void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "kcb->prev_kprobe.kp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
  },
  {
    "function_name": "save_previous_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "113-118",
    "snippet": "static void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}"
  },
  {
    "function_name": "prepare_singlestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "100-111",
    "snippet": "static void __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_single_step",
          "args": [
            "regs"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "user_enable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "852-867",
          "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic void __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}"
  },
  {
    "function_name": "arch_remove_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "92-98",
    "snippet": "void __kprobes arch_remove_kprobe(struct kprobe *p)\n{\n\tif (p->ainsn.insn) {\n\t\tfree_insn_slot(p->ainsn.insn, 0);\n\t\tp->ainsn.insn = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_insn_slot",
          "args": [
            "p->ainsn.insn",
            "0"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid __kprobes arch_remove_kprobe(struct kprobe *p)\n{\n\tif (p->ainsn.insn) {\n\t\tfree_insn_slot(p->ainsn.insn, 0);\n\t\tp->ainsn.insn = NULL;\n\t}\n}"
  },
  {
    "function_name": "arch_disarm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "85-90",
    "snippet": "void __kprobes arch_disarm_kprobe(struct kprobe *p)\n{\n\t*p->addr = p->opcode;\n\tflush_icache_range((unsigned long) p->addr,\n\t\t\t   (unsigned long) p->addr + sizeof(kprobe_opcode_t));\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) p->addr",
            "(unsigned long) p->addr + sizeof(kprobe_opcode_t)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid __kprobes arch_disarm_kprobe(struct kprobe *p)\n{\n\t*p->addr = p->opcode;\n\tflush_icache_range((unsigned long) p->addr,\n\t\t\t   (unsigned long) p->addr + sizeof(kprobe_opcode_t));\n}"
  },
  {
    "function_name": "arch_arm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "78-83",
    "snippet": "void __kprobes arch_arm_kprobe(struct kprobe *p)\n{\n\t*p->addr = BREAKPOINT_INSTRUCTION;\n\tflush_icache_range((unsigned long) p->addr,\n\t\t\t   (unsigned long) p->addr + sizeof(kprobe_opcode_t));\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) p->addr",
            "(unsigned long) p->addr + sizeof(kprobe_opcode_t)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid __kprobes arch_arm_kprobe(struct kprobe *p)\n{\n\t*p->addr = BREAKPOINT_INSTRUCTION;\n\tflush_icache_range((unsigned long) p->addr,\n\t\t\t   (unsigned long) p->addr + sizeof(kprobe_opcode_t));\n}"
  },
  {
    "function_name": "arch_prepare_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "45-76",
    "snippet": "int __kprobes arch_prepare_kprobe(struct kprobe *p)\n{\n\tint ret = 0;\n\tkprobe_opcode_t insn = *p->addr;\n\n\tif ((unsigned long)p->addr & 0x03) {\n\t\tprintk(\"Attempt to register kprobe at an unaligned address\\n\");\n\t\tret = -EINVAL;\n\t} else if (IS_MTMSRD(insn) || IS_RFID(insn) || IS_RFI(insn)) {\n\t\tprintk(\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\t/* insn must be on a special executable page on ppc64.  This is\n\t * not explicitly required on ppc32 (right now), but it doesn't hurt */\n\tif (!ret) {\n\t\tp->ainsn.insn = get_insn_slot();\n\t\tif (!p->ainsn.insn)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tif (!ret) {\n\t\tmemcpy(p->ainsn.insn, p->addr,\n\t\t\t\tMAX_INSN_SIZE * sizeof(kprobe_opcode_t));\n\t\tp->opcode = *p->addr;\n\t\tflush_icache_range((unsigned long)p->ainsn.insn,\n\t\t\t(unsigned long)p->ainsn.insn + sizeof(kprobe_opcode_t));\n\t}\n\n\tp->ainsn.boostable = 0;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/module.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)p->ainsn.insn",
            "(unsigned long)p->ainsn.insn + sizeof(kprobe_opcode_t)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p->ainsn.insn",
            "p->addr",
            "MAX_INSN_SIZE * sizeof(kprobe_opcode_t)"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_insn_slot",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RFI",
          "args": [
            "insn"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RFID",
          "args": [
            "insn"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MTMSRD",
          "args": [
            "insn"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Attempt to register kprobe at an unaligned address\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes arch_prepare_kprobe(struct kprobe *p)\n{\n\tint ret = 0;\n\tkprobe_opcode_t insn = *p->addr;\n\n\tif ((unsigned long)p->addr & 0x03) {\n\t\tprintk(\"Attempt to register kprobe at an unaligned address\\n\");\n\t\tret = -EINVAL;\n\t} else if (IS_MTMSRD(insn) || IS_RFID(insn) || IS_RFI(insn)) {\n\t\tprintk(\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\t/* insn must be on a special executable page on ppc64.  This is\n\t * not explicitly required on ppc32 (right now), but it doesn't hurt */\n\tif (!ret) {\n\t\tp->ainsn.insn = get_insn_slot();\n\t\tif (!p->ainsn.insn)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tif (!ret) {\n\t\tmemcpy(p->ainsn.insn, p->addr,\n\t\t\t\tMAX_INSN_SIZE * sizeof(kprobe_opcode_t));\n\t\tp->opcode = *p->addr;\n\t\tflush_icache_range((unsigned long)p->ainsn.insn,\n\t\t\t(unsigned long)p->ainsn.insn + sizeof(kprobe_opcode_t));\n\t}\n\n\tp->ainsn.boostable = 0;\n\treturn ret;\n}"
  }
]