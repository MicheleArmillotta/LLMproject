[
  {
    "function_name": "setup_arch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "269-329",
    "snippet": "void __init setup_arch(char **cmdline_p)\n{\n\t*cmdline_p = boot_command_line;\n\n\t/* so udelay does something sensible, assume <= 1000 bogomips */\n\tloops_per_jiffy = 500000000 / HZ;\n\n\tunflatten_device_tree();\n\tcheck_for_initrd();\n\n\tif (ppc_md.init_early)\n\t\tppc_md.init_early();\n\n\tfind_legacy_serial_ports();\n\n\tsmp_setup_cpu_maps();\n\n\t/* Register early console */\n\tregister_early_udbg_console();\n\n\txmon_setup();\n\n\t/*\n\t * Set cache line size based on type of cpu as a default.\n\t * Systems with OF can look in the properties on the cpu node(s)\n\t * for a possibly more accurate value.\n\t */\n\tdcache_bsize = cur_cpu_spec->dcache_bsize;\n\ticache_bsize = cur_cpu_spec->icache_bsize;\n\tucache_bsize = 0;\n\tif (cpu_has_feature(CPU_FTR_UNIFIED_ID_CACHE))\n\t\tucache_bsize = icache_bsize = dcache_bsize;\n\n\tif (ppc_md.panic)\n\t\tsetup_panic();\n\n\tinit_mm.start_code = (unsigned long)_stext;\n\tinit_mm.end_code = (unsigned long) _etext;\n\tinit_mm.end_data = (unsigned long) _edata;\n\tinit_mm.brk = klimit;\n\n\texc_lvl_early_init();\n\n\tirqstack_early_init();\n\n\tinitmem_init();\n\tif ( ppc_md.progress ) ppc_md.progress(\"setup_arch: initmem\", 0x3eab);\n\n#ifdef CONFIG_DUMMY_CONSOLE\n\tconswitchp = &dummy_con;\n#endif\n\n\tif (ppc_md.setup_arch)\n\t\tppc_md.setup_arch();\n\tif ( ppc_md.progress ) ppc_md.progress(\"arch: exit\", 0x3eab);\n\n\tpaging_init();\n\n\t/* Initialize the MMU context management stuff */\n\tmmu_context_init();\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int dcache_bsize;",
      "int icache_bsize;",
      "int ucache_bsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_context_init",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paging_init",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.progress",
          "args": [
            "\"arch: exit\"",
            "0x3eab"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.setup_arch",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.progress",
          "args": [
            "\"setup_arch: initmem\"",
            "0x3eab"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initmem_init",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqstack_early_init",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "irqstack_early_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
          "lines": "226-238",
          "snippet": "static void __init irqstack_early_init(void)\n{\n\tunsigned int i;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by default */\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\thardirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t}\n}",
          "includes": [
            "#include <asm/code-patching.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/time.h>",
            "#include <asm/xmon.h>",
            "#include <asm/nvram.h>",
            "#include <asm/sections.h>",
            "#include <asm/pmac_feature.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/btext.h>",
            "#include <asm/bootx.h>",
            "#include <asm/cputable.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/setup.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/memblock.h>",
            "#include <linux/console.h>",
            "#include <linux/cpu.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tty.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void __init irqstack_early_init(void)\n{\n\tunsigned int i;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by default */\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\thardirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exc_lvl_early_init",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "exc_lvl_early_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
          "lines": "241-263",
          "snippet": "static void __init exc_lvl_early_init(void)\n{\n\tunsigned int i, hw_cpu;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by MEMBLOCK_REAL_LIMIT */\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_SMP\n\t\thw_cpu = get_hard_smp_processor_id(i);\n#else\n\t\thw_cpu = 0;\n#endif\n\n\t\tcritirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#ifdef CONFIG_BOOKE\n\t\tdbgirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\tmcheckirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#endif\n\t}\n}",
          "includes": [
            "#include <asm/code-patching.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/time.h>",
            "#include <asm/xmon.h>",
            "#include <asm/nvram.h>",
            "#include <asm/sections.h>",
            "#include <asm/pmac_feature.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/btext.h>",
            "#include <asm/bootx.h>",
            "#include <asm/cputable.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/setup.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/memblock.h>",
            "#include <linux/console.h>",
            "#include <linux/cpu.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tty.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void __init exc_lvl_early_init(void)\n{\n\tunsigned int i, hw_cpu;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by MEMBLOCK_REAL_LIMIT */\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_SMP\n\t\thw_cpu = get_hard_smp_processor_id(i);\n#else\n\t\thw_cpu = 0;\n#endif\n\n\t\tcritirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#ifdef CONFIG_BOOKE\n\t\tdbgirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\tmcheckirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_panic",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "setup_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "683-686",
          "snippet": "void __init setup_panic(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &ppc_panic_block);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct notifier_block ppc_panic_block = {\n\t.notifier_call = ppc_panic_event,\n\t.priority = INT_MIN /* may not return; must be done last */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/debugfs.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nstatic struct notifier_block ppc_panic_block = {\n\t.notifier_call = ppc_panic_event,\n\t.priority = INT_MIN /* may not return; must be done last */\n};\n\nvoid __init setup_panic(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &ppc_panic_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_UNIFIED_ID_CACHE"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmon_setup",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_early_udbg_console",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "register_early_udbg_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/udbg.c",
          "lines": "162-176",
          "snippet": "void __init register_early_udbg_console(void)\n{\n\tif (early_console)\n\t\treturn;\n\n\tif (!udbg_putc)\n\t\treturn;\n\n\tif (strstr(boot_command_line, \"udbg-immortal\")) {\n\t\tprintk(KERN_INFO \"early console immortal !\\n\");\n\t\tudbg_console.flags &= ~CON_BOOT;\n\t}\n\tearly_console = &udbg_console;\n\tregister_console(&udbg_console);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/processor.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct console udbg_console = {\n\t.name\t= \"udbg\",\n\t.write\t= udbg_console_write,\n\t.flags\t= CON_PRINTBUFFER | CON_ENABLED | CON_BOOT | CON_ANYTIME,\n\t.index\t= 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/processor.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic struct console udbg_console = {\n\t.name\t= \"udbg\",\n\t.write\t= udbg_console_write,\n\t.flags\t= CON_PRINTBUFFER | CON_ENABLED | CON_BOOT | CON_ANYTIME,\n\t.index\t= 0,\n};\n\nvoid __init register_early_udbg_console(void)\n{\n\tif (early_console)\n\t\treturn;\n\n\tif (!udbg_putc)\n\t\treturn;\n\n\tif (strstr(boot_command_line, \"udbg-immortal\")) {\n\t\tprintk(KERN_INFO \"early console immortal !\\n\");\n\t\tudbg_console.flags &= ~CON_BOOT;\n\t}\n\tearly_console = &udbg_console;\n\tregister_console(&udbg_console);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_setup_cpu_maps",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "smp_setup_cpu_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "442-552",
          "snippet": "void __init smp_setup_cpu_maps(void)\n{\n\tstruct device_node *dn = NULL;\n\tint cpu = 0;\n\tint nthreads = 1;\n\n\tDBG(\"smp_setup_cpu_maps()\\n\");\n\n\twhile ((dn = of_find_node_by_type(dn, \"cpu\")) && cpu < nr_cpu_ids) {\n\t\tconst __be32 *intserv;\n\t\t__be32 cpu_be;\n\t\tint j, len;\n\n\t\tDBG(\"  * %s...\\n\", dn->full_name);\n\n\t\tintserv = of_get_property(dn, \"ibm,ppc-interrupt-server#s\",\n\t\t\t\t&len);\n\t\tif (intserv) {\n\t\t\tDBG(\"    ibm,ppc-interrupt-server#s -> %d threads\\n\",\n\t\t\t    nthreads);\n\t\t} else {\n\t\t\tDBG(\"    no ibm,ppc-interrupt-server#s -> 1 thread\\n\");\n\t\t\tintserv = of_get_property(dn, \"reg\", &len);\n\t\t\tif (!intserv) {\n\t\t\t\tcpu_be = cpu_to_be32(cpu);\n\t\t\t\tintserv = &cpu_be;\t/* assume logical == phys */\n\t\t\t\tlen = 4;\n\t\t\t}\n\t\t}\n\n\t\tnthreads = len / sizeof(int);\n\n\t\tfor (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {\n\t\t\tbool avail;\n\n\t\t\tDBG(\"    thread %d -> cpu %d (hard id %d)\\n\",\n\t\t\t    j, cpu, be32_to_cpu(intserv[j]));\n\n\t\t\tavail = of_device_is_available(dn);\n\t\t\tif (!avail)\n\t\t\t\tavail = !of_property_match_string(dn,\n\t\t\t\t\t\t\"enable-method\", \"spin-table\");\n\n\t\t\tset_cpu_present(cpu, avail);\n\t\t\tset_hard_smp_processor_id(cpu, be32_to_cpu(intserv[j]));\n\t\t\tset_cpu_possible(cpu, true);\n\t\t\tcpu++;\n\t\t}\n\t}\n\n\t/* If no SMT supported, nthreads is forced to 1 */\n\tif (!cpu_has_feature(CPU_FTR_SMT)) {\n\t\tDBG(\"  SMT disabled ! nthreads forced to 1\\n\");\n\t\tnthreads = 1;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * On pSeries LPAR, we need to know how many cpus\n\t * could possibly be added to this partition.\n\t */\n\tif (machine_is(pseries) && firmware_has_feature(FW_FEATURE_LPAR) &&\n\t    (dn = of_find_node_by_path(\"/rtas\"))) {\n\t\tint num_addr_cell, num_size_cell, maxcpus;\n\t\tconst __be32 *ireg;\n\n\t\tnum_addr_cell = of_n_addr_cells(dn);\n\t\tnum_size_cell = of_n_size_cells(dn);\n\n\t\tireg = of_get_property(dn, \"ibm,lrdr-capacity\", NULL);\n\n\t\tif (!ireg)\n\t\t\tgoto out;\n\n\t\tmaxcpus = be32_to_cpup(ireg + num_addr_cell + num_size_cell);\n\n\t\t/* Double maxcpus for processors which have SMT capability */\n\t\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\t\tmaxcpus *= nthreads;\n\n\t\tif (maxcpus > nr_cpu_ids) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Partition configured for %d cpus, \"\n\t\t\t       \"operating system maximum is %d.\\n\",\n\t\t\t       maxcpus, nr_cpu_ids);\n\t\t\tmaxcpus = nr_cpu_ids;\n\t\t} else\n\t\t\tprintk(KERN_INFO \"Partition configured for %d cpus.\\n\",\n\t\t\t       maxcpus);\n\n\t\tfor (cpu = 0; cpu < maxcpus; cpu++)\n\t\t\tset_cpu_possible(cpu, true);\n\tout:\n\t\tof_node_put(dn);\n\t}\n\tvdso_data->processorCount = num_present_cpus();\n#endif /* CONFIG_PPC64 */\n\n        /* Initialize CPU <=> thread mapping/\n\t *\n\t * WARNING: We assume that the number of threads is the same for\n\t * every CPU in the system. If that is not the case, then some code\n\t * here will have to be reworked\n\t */\n\tcpu_init_thread_core_maps(nthreads);\n\n\t/* Now that possible cpus are set, set nr_cpu_ids for later use */\n\tsetup_nr_cpu_ids();\n\n\tfree_unused_pacas();\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/debugfs.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nvoid __init smp_setup_cpu_maps(void)\n{\n\tstruct device_node *dn = NULL;\n\tint cpu = 0;\n\tint nthreads = 1;\n\n\tDBG(\"smp_setup_cpu_maps()\\n\");\n\n\twhile ((dn = of_find_node_by_type(dn, \"cpu\")) && cpu < nr_cpu_ids) {\n\t\tconst __be32 *intserv;\n\t\t__be32 cpu_be;\n\t\tint j, len;\n\n\t\tDBG(\"  * %s...\\n\", dn->full_name);\n\n\t\tintserv = of_get_property(dn, \"ibm,ppc-interrupt-server#s\",\n\t\t\t\t&len);\n\t\tif (intserv) {\n\t\t\tDBG(\"    ibm,ppc-interrupt-server#s -> %d threads\\n\",\n\t\t\t    nthreads);\n\t\t} else {\n\t\t\tDBG(\"    no ibm,ppc-interrupt-server#s -> 1 thread\\n\");\n\t\t\tintserv = of_get_property(dn, \"reg\", &len);\n\t\t\tif (!intserv) {\n\t\t\t\tcpu_be = cpu_to_be32(cpu);\n\t\t\t\tintserv = &cpu_be;\t/* assume logical == phys */\n\t\t\t\tlen = 4;\n\t\t\t}\n\t\t}\n\n\t\tnthreads = len / sizeof(int);\n\n\t\tfor (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {\n\t\t\tbool avail;\n\n\t\t\tDBG(\"    thread %d -> cpu %d (hard id %d)\\n\",\n\t\t\t    j, cpu, be32_to_cpu(intserv[j]));\n\n\t\t\tavail = of_device_is_available(dn);\n\t\t\tif (!avail)\n\t\t\t\tavail = !of_property_match_string(dn,\n\t\t\t\t\t\t\"enable-method\", \"spin-table\");\n\n\t\t\tset_cpu_present(cpu, avail);\n\t\t\tset_hard_smp_processor_id(cpu, be32_to_cpu(intserv[j]));\n\t\t\tset_cpu_possible(cpu, true);\n\t\t\tcpu++;\n\t\t}\n\t}\n\n\t/* If no SMT supported, nthreads is forced to 1 */\n\tif (!cpu_has_feature(CPU_FTR_SMT)) {\n\t\tDBG(\"  SMT disabled ! nthreads forced to 1\\n\");\n\t\tnthreads = 1;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * On pSeries LPAR, we need to know how many cpus\n\t * could possibly be added to this partition.\n\t */\n\tif (machine_is(pseries) && firmware_has_feature(FW_FEATURE_LPAR) &&\n\t    (dn = of_find_node_by_path(\"/rtas\"))) {\n\t\tint num_addr_cell, num_size_cell, maxcpus;\n\t\tconst __be32 *ireg;\n\n\t\tnum_addr_cell = of_n_addr_cells(dn);\n\t\tnum_size_cell = of_n_size_cells(dn);\n\n\t\tireg = of_get_property(dn, \"ibm,lrdr-capacity\", NULL);\n\n\t\tif (!ireg)\n\t\t\tgoto out;\n\n\t\tmaxcpus = be32_to_cpup(ireg + num_addr_cell + num_size_cell);\n\n\t\t/* Double maxcpus for processors which have SMT capability */\n\t\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\t\tmaxcpus *= nthreads;\n\n\t\tif (maxcpus > nr_cpu_ids) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Partition configured for %d cpus, \"\n\t\t\t       \"operating system maximum is %d.\\n\",\n\t\t\t       maxcpus, nr_cpu_ids);\n\t\t\tmaxcpus = nr_cpu_ids;\n\t\t} else\n\t\t\tprintk(KERN_INFO \"Partition configured for %d cpus.\\n\",\n\t\t\t       maxcpus);\n\n\t\tfor (cpu = 0; cpu < maxcpus; cpu++)\n\t\t\tset_cpu_possible(cpu, true);\n\tout:\n\t\tof_node_put(dn);\n\t}\n\tvdso_data->processorCount = num_present_cpus();\n#endif /* CONFIG_PPC64 */\n\n        /* Initialize CPU <=> thread mapping/\n\t *\n\t * WARNING: We assume that the number of threads is the same for\n\t * every CPU in the system. If that is not the case, then some code\n\t * here will have to be reworked\n\t */\n\tcpu_init_thread_core_maps(nthreads);\n\n\t/* Now that possible cpus are set, set nr_cpu_ids for later use */\n\tsetup_nr_cpu_ids();\n\n\tfree_unused_pacas();\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_legacy_serial_ports",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "find_legacy_serial_ports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "363-446",
          "snippet": "void __init find_legacy_serial_ports(void)\n{\n\tstruct device_node *np, *stdout = NULL;\n\tconst char *path;\n\tint index;\n\n\tDBG(\" -> find_legacy_serial_port()\\n\");\n\n\t/* Now find out if one of these is out firmware console */\n\tpath = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (path != NULL) {\n\t\tstdout = of_find_node_by_path(path);\n\t\tif (stdout)\n\t\t\tDBG(\"stdout is %s\\n\", stdout->full_name);\n\t} else {\n\t\tDBG(\" no linux,stdout-path !\\n\");\n\t}\n\n\t/* Iterate over all the 16550 ports, looking for known parents */\n\tfor_each_compatible_node(np, \"serial\", \"ns16550\") {\n\t\tstruct device_node *parent = of_get_parent(np);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (of_match_node(legacy_serial_parents, parent) != NULL) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_soc_port(np, np);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(parent);\n\t}\n\n\t/* Next, fill our array with ISA ports */\n\tfor_each_node_by_type(np, \"serial\") {\n\t\tstruct device_node *isa = of_get_parent(np);\n\t\tif (isa && (!strcmp(isa->name, \"isa\") ||\n\t\t\t    !strcmp(isa->name, \"lpc\"))) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_isa_port(np, isa);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(isa);\n\t}\n\n#ifdef CONFIG_PCI\n\t/* Next, try to locate PCI ports */\n\tfor (np = NULL; (np = of_find_all_nodes(np));) {\n\t\tstruct device_node *pci, *parent = of_get_parent(np);\n\t\tif (parent && !strcmp(parent->name, \"isa\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(np->name, \"serial\") && strcmp(np->type, \"serial\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check for known pciclass, and also check whether we have\n\t\t * a device with child nodes for ports or not\n\t\t */\n\t\tif (of_device_is_compatible(np, \"pciclass,0700\") ||\n\t\t    of_device_is_compatible(np, \"pciclass,070002\"))\n\t\t\tpci = np;\n\t\telse if (of_device_is_compatible(parent, \"pciclass,0700\") ||\n\t\t\t of_device_is_compatible(parent, \"pciclass,070002\"))\n\t\t\tpci = parent;\n\t\telse {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tindex = add_legacy_pci_port(np, pci);\n\t\tif (index >= 0 && np == stdout)\n\t\t\tlegacy_serial_console = index;\n\t\tof_node_put(parent);\n\t}\n#endif\n\n\tDBG(\"legacy_serial_console = %d\\n\", legacy_serial_console);\n\tif (legacy_serial_console >= 0)\n\t\tsetup_legacy_serial_console(legacy_serial_console);\n\tDBG(\" <- find_legacy_serial_port()\\n\");\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct of_device_id legacy_serial_parents[] __initconst = {\n\t{.type = \"soc\",},\n\t{.type = \"tsi-bridge\",},\n\t{.type = \"opb\", },\n\t{.compatible = \"ibm,opb\",},\n\t{.compatible = \"simple-bus\",},\n\t{.compatible = \"wrs,epld-localbus\",},\n\t{},\n};",
            "static int legacy_serial_console = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const struct of_device_id legacy_serial_parents[] __initconst = {\n\t{.type = \"soc\",},\n\t{.type = \"tsi-bridge\",},\n\t{.type = \"opb\", },\n\t{.compatible = \"ibm,opb\",},\n\t{.compatible = \"simple-bus\",},\n\t{.compatible = \"wrs,epld-localbus\",},\n\t{},\n};\nstatic int legacy_serial_console = -1;\n\nvoid __init find_legacy_serial_ports(void)\n{\n\tstruct device_node *np, *stdout = NULL;\n\tconst char *path;\n\tint index;\n\n\tDBG(\" -> find_legacy_serial_port()\\n\");\n\n\t/* Now find out if one of these is out firmware console */\n\tpath = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (path != NULL) {\n\t\tstdout = of_find_node_by_path(path);\n\t\tif (stdout)\n\t\t\tDBG(\"stdout is %s\\n\", stdout->full_name);\n\t} else {\n\t\tDBG(\" no linux,stdout-path !\\n\");\n\t}\n\n\t/* Iterate over all the 16550 ports, looking for known parents */\n\tfor_each_compatible_node(np, \"serial\", \"ns16550\") {\n\t\tstruct device_node *parent = of_get_parent(np);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (of_match_node(legacy_serial_parents, parent) != NULL) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_soc_port(np, np);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(parent);\n\t}\n\n\t/* Next, fill our array with ISA ports */\n\tfor_each_node_by_type(np, \"serial\") {\n\t\tstruct device_node *isa = of_get_parent(np);\n\t\tif (isa && (!strcmp(isa->name, \"isa\") ||\n\t\t\t    !strcmp(isa->name, \"lpc\"))) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_isa_port(np, isa);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(isa);\n\t}\n\n#ifdef CONFIG_PCI\n\t/* Next, try to locate PCI ports */\n\tfor (np = NULL; (np = of_find_all_nodes(np));) {\n\t\tstruct device_node *pci, *parent = of_get_parent(np);\n\t\tif (parent && !strcmp(parent->name, \"isa\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(np->name, \"serial\") && strcmp(np->type, \"serial\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check for known pciclass, and also check whether we have\n\t\t * a device with child nodes for ports or not\n\t\t */\n\t\tif (of_device_is_compatible(np, \"pciclass,0700\") ||\n\t\t    of_device_is_compatible(np, \"pciclass,070002\"))\n\t\t\tpci = np;\n\t\telse if (of_device_is_compatible(parent, \"pciclass,0700\") ||\n\t\t\t of_device_is_compatible(parent, \"pciclass,070002\"))\n\t\t\tpci = parent;\n\t\telse {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tindex = add_legacy_pci_port(np, pci);\n\t\tif (index >= 0 && np == stdout)\n\t\t\tlegacy_serial_console = index;\n\t\tof_node_put(parent);\n\t}\n#endif\n\n\tDBG(\"legacy_serial_console = %d\\n\", legacy_serial_console);\n\tif (legacy_serial_console >= 0)\n\t\tsetup_legacy_serial_console(legacy_serial_console);\n\tDBG(\" <- find_legacy_serial_port()\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.init_early",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_initrd",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_initrd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "370-390",
          "snippet": "void __init check_for_initrd(void)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tDBG(\" -> check_for_initrd()  initrd_start=0x%lx  initrd_end=0x%lx\\n\",\n\t    initrd_start, initrd_end);\n\n\t/* If we were passed an initrd, set the ROOT_DEV properly if the values\n\t * look sensible. If not, clear initrd reference.\n\t */\n\tif (is_kernel_addr(initrd_start) && is_kernel_addr(initrd_end) &&\n\t    initrd_end > initrd_start)\n\t\tROOT_DEV = Root_RAM0;\n\telse\n\t\tinitrd_start = initrd_end = 0;\n\n\tif (initrd_start)\n\t\tpr_info(\"Found initrd at 0x%lx:0x%lx\\n\", initrd_start, initrd_end);\n\n\tDBG(\" <- check_for_initrd()\\n\");\n#endif /* CONFIG_BLK_DEV_INITRD */\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/debugfs.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nvoid __init check_for_initrd(void)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tDBG(\" -> check_for_initrd()  initrd_start=0x%lx  initrd_end=0x%lx\\n\",\n\t    initrd_start, initrd_end);\n\n\t/* If we were passed an initrd, set the ROOT_DEV properly if the values\n\t * look sensible. If not, clear initrd reference.\n\t */\n\tif (is_kernel_addr(initrd_start) && is_kernel_addr(initrd_end) &&\n\t    initrd_end > initrd_start)\n\t\tROOT_DEV = Root_RAM0;\n\telse\n\t\tinitrd_start = initrd_end = 0;\n\n\tif (initrd_start)\n\t\tpr_info(\"Found initrd at 0x%lx:0x%lx\\n\", initrd_start, initrd_end);\n\n\tDBG(\" <- check_for_initrd()\\n\");\n#endif /* CONFIG_BLK_DEV_INITRD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unflatten_device_tree",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint dcache_bsize;\nint icache_bsize;\nint ucache_bsize;\n\nvoid __init setup_arch(char **cmdline_p)\n{\n\t*cmdline_p = boot_command_line;\n\n\t/* so udelay does something sensible, assume <= 1000 bogomips */\n\tloops_per_jiffy = 500000000 / HZ;\n\n\tunflatten_device_tree();\n\tcheck_for_initrd();\n\n\tif (ppc_md.init_early)\n\t\tppc_md.init_early();\n\n\tfind_legacy_serial_ports();\n\n\tsmp_setup_cpu_maps();\n\n\t/* Register early console */\n\tregister_early_udbg_console();\n\n\txmon_setup();\n\n\t/*\n\t * Set cache line size based on type of cpu as a default.\n\t * Systems with OF can look in the properties on the cpu node(s)\n\t * for a possibly more accurate value.\n\t */\n\tdcache_bsize = cur_cpu_spec->dcache_bsize;\n\ticache_bsize = cur_cpu_spec->icache_bsize;\n\tucache_bsize = 0;\n\tif (cpu_has_feature(CPU_FTR_UNIFIED_ID_CACHE))\n\t\tucache_bsize = icache_bsize = dcache_bsize;\n\n\tif (ppc_md.panic)\n\t\tsetup_panic();\n\n\tinit_mm.start_code = (unsigned long)_stext;\n\tinit_mm.end_code = (unsigned long) _etext;\n\tinit_mm.end_data = (unsigned long) _edata;\n\tinit_mm.brk = klimit;\n\n\texc_lvl_early_init();\n\n\tirqstack_early_init();\n\n\tinitmem_init();\n\tif ( ppc_md.progress ) ppc_md.progress(\"setup_arch: initmem\", 0x3eab);\n\n#ifdef CONFIG_DUMMY_CONSOLE\n\tconswitchp = &dummy_con;\n#endif\n\n\tif (ppc_md.setup_arch)\n\t\tppc_md.setup_arch();\n\tif ( ppc_md.progress ) ppc_md.progress(\"arch: exit\", 0x3eab);\n\n\tpaging_init();\n\n\t/* Initialize the MMU context management stuff */\n\tmmu_context_init();\n}"
  },
  {
    "function_name": "exc_lvl_early_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "241-263",
    "snippet": "static void __init exc_lvl_early_init(void)\n{\n\tunsigned int i, hw_cpu;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by MEMBLOCK_REAL_LIMIT */\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_SMP\n\t\thw_cpu = get_hard_smp_processor_id(i);\n#else\n\t\thw_cpu = 0;\n#endif\n\n\t\tcritirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#ifdef CONFIG_BOOKE\n\t\tdbgirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\tmcheckirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#endif\n\t}\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(THREAD_SIZE, THREAD_SIZE)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "THREAD_SIZE",
            "THREAD_SIZE"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(THREAD_SIZE, THREAD_SIZE)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "THREAD_SIZE",
            "THREAD_SIZE"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(THREAD_SIZE, THREAD_SIZE)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "THREAD_SIZE",
            "THREAD_SIZE"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "i"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void __init exc_lvl_early_init(void)\n{\n\tunsigned int i, hw_cpu;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by MEMBLOCK_REAL_LIMIT */\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_SMP\n\t\thw_cpu = get_hard_smp_processor_id(i);\n#else\n\t\thw_cpu = 0;\n#endif\n\n\t\tcritirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#ifdef CONFIG_BOOKE\n\t\tdbgirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\tmcheckirq_ctx[hw_cpu] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n#endif\n\t}\n}"
  },
  {
    "function_name": "irqstack_early_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "226-238",
    "snippet": "static void __init irqstack_early_init(void)\n{\n\tunsigned int i;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by default */\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\thardirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t}\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(THREAD_SIZE, THREAD_SIZE)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "THREAD_SIZE",
            "THREAD_SIZE"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(THREAD_SIZE, THREAD_SIZE)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "THREAD_SIZE",
            "THREAD_SIZE"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void __init irqstack_early_init(void)\n{\n\tunsigned int i;\n\n\t/* interrupt stacks must be in lowmem, we get that for free on ppc32\n\t * as the memblock is limited to lowmem by default */\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t\thardirq_ctx[i] = (struct thread_info *)\n\t\t\t__va(memblock_alloc(THREAD_SIZE, THREAD_SIZE));\n\t}\n}"
  },
  {
    "function_name": "ppc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "211-222",
    "snippet": "int __init ppc_init(void)\n{\n\t/* clear the progress line */\n\tif (ppc_md.progress)\n\t\tppc_md.progress(\"             \", 0xffff);\n\n\t/* call platform init */\n\tif (ppc_md.init != NULL) {\n\t\tppc_md.init();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.init",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.progress",
          "args": [
            "\"             \"",
            "0xffff"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint __init ppc_init(void)\n{\n\t/* clear the progress line */\n\tif (ppc_md.progress)\n\t\tppc_md.progress(\"             \", 0xffff);\n\n\t/* call platform init */\n\tif (ppc_md.init != NULL) {\n\t\tppc_md.init();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "202-206",
    "snippet": "void nvram_sync(void)\n{\n\tif (ppc_md.nvram_sync)\n\t\tppc_md.nvram_sync();\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_sync",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
          "lines": "202-206",
          "snippet": "void nvram_sync(void)\n{\n\tif (ppc_md.nvram_sync)\n\t\tppc_md.nvram_sync();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nvram_sync(void)\n{\n\tif (ppc_md.nvram_sync)\n\t\tppc_md.nvram_sync();\n}"
  },
  {
    "function_name": "nvram_get_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "194-199",
    "snippet": "ssize_t nvram_get_size(void)\n{\n\tif (ppc_md.nvram_size)\n\t\treturn ppc_md.nvram_size();\n\treturn -1;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nssize_t nvram_get_size(void)\n{\n\tif (ppc_md.nvram_size)\n\t\treturn ppc_md.nvram_size();\n\treturn -1;\n}"
  },
  {
    "function_name": "nvram_write_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "187-191",
    "snippet": "void nvram_write_byte(unsigned char val, int addr)\n{\n\tif (ppc_md.nvram_write_val)\n\t\tppc_md.nvram_write_val(addr, val);\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_write_val",
          "args": [
            "addr",
            "val"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nvram_write_byte(unsigned char val, int addr)\n{\n\tif (ppc_md.nvram_write_val)\n\t\tppc_md.nvram_write_val(addr, val);\n}"
  },
  {
    "function_name": "nvram_read_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "179-184",
    "snippet": "unsigned char nvram_read_byte(int addr)\n{\n\tif (ppc_md.nvram_read_val)\n\t\treturn ppc_md.nvram_read_val(addr);\n\treturn 0xff;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_read_val",
          "args": [
            "addr"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nunsigned char nvram_read_byte(int addr)\n{\n\tif (ppc_md.nvram_read_val)\n\t\treturn ppc_md.nvram_read_val(addr);\n\treturn 0xff;\n}"
  },
  {
    "function_name": "ppc_setup_l3cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "165-173",
    "snippet": "int __init ppc_setup_l3cr(char *str)\n{\n\tif (cpu_has_feature(CPU_FTR_L3CR)) {\n\t\tunsigned long val = simple_strtoul(str, NULL, 0);\n\t\tprintk(KERN_INFO \"l3cr set to %lx\\n\", val);\n\t\t_set_L3CR(val);\t\t/* and enable it */\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set_L3CR",
          "args": [
            "val"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"l3cr set to %lx\\n\"",
            "val"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_L3CR"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint __init ppc_setup_l3cr(char *str)\n{\n\tif (cpu_has_feature(CPU_FTR_L3CR)) {\n\t\tunsigned long val = simple_strtoul(str, NULL, 0);\n\t\tprintk(KERN_INFO \"l3cr set to %lx\\n\", val);\n\t\t_set_L3CR(val);\t\t/* and enable it */\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ppc_setup_l2cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "152-161",
    "snippet": "int __init ppc_setup_l2cr(char *str)\n{\n\tif (cpu_has_feature(CPU_FTR_L2CR)) {\n\t\tunsigned long val = simple_strtoul(str, NULL, 0);\n\t\tprintk(KERN_INFO \"l2cr set to %lx\\n\", val);\n\t\t_set_L2CR(0);\t\t/* force invalidate by disable cache */\n\t\t_set_L2CR(val);\t\t/* and enable it */\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set_L2CR",
          "args": [
            "val"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_L2CR",
          "args": [
            "0"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"l2cr set to %lx\\n\"",
            "val"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_L2CR"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint __init ppc_setup_l2cr(char *str)\n{\n\tif (cpu_has_feature(CPU_FTR_L2CR)) {\n\t\tunsigned long val = simple_strtoul(str, NULL, 0);\n\t\tprintk(KERN_INFO \"l2cr set to %lx\\n\", val);\n\t\t_set_L2CR(0);\t\t/* force invalidate by disable cache */\n\t\t_set_L2CR(val);\t\t/* and enable it */\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "machine_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "115-149",
    "snippet": "__init machine_init(u64 dt_ptr)\n{\n\tlockdep_init();\n\n\t/* Enable early debugging if any specified (see udbg.h) */\n\tudbg_early_init();\n\n\tpatch_instruction((unsigned int *)&memcpy, PPC_INST_NOP);\n\tpatch_instruction(&memset_nocache_branch, PPC_INST_NOP);\n\n\t/* Do some early initialization based on the flat device tree */\n\tearly_init_devtree(__va(dt_ptr));\n\n\tepapr_paravirt_early_init();\n\n\tearly_init_mmu();\n\n\tprobe_machine();\n\n\tsetup_kdump_trampoline();\n\n#ifdef CONFIG_6xx\n\tif (cpu_has_feature(CPU_FTR_CAN_DOZE) ||\n\t    cpu_has_feature(CPU_FTR_CAN_NAP))\n\t\tppc_md.power_save = ppc6xx_idle;\n#endif\n\n#ifdef CONFIG_E500\n\tif (cpu_has_feature(CPU_FTR_CAN_DOZE) ||\n\t    cpu_has_feature(CPU_FTR_CAN_NAP))\n\t\tppc_md.power_save = e500_idle;\n#endif\n\tif (ppc_md.progress)\n\t\tppc_md.progress(\"id mach(): done\", 0x200);\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned int memset_nocache_branch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.progress",
          "args": [
            "\"id mach(): done\"",
            "0x200"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_CAN_NAP"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_CAN_DOZE"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_CAN_NAP"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_CAN_DOZE"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_kdump_trampoline",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kdump_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash_dump.c",
          "lines": "53-69",
          "snippet": "void __init setup_kdump_trampoline(void)\n{\n\tunsigned long i;\n\n\tDBG(\" -> setup_kdump_trampoline()\\n\");\n\n\tfor (i = KDUMP_TRAMPOLINE_START; i < KDUMP_TRAMPOLINE_END; i += 8) {\n\t\tcreate_trampoline(i);\n\t}\n\n#ifdef CONFIG_PPC_PSERIES\n\tcreate_trampoline(__pa(system_reset_fwnmi) - PHYSICAL_START);\n\tcreate_trampoline(__pa(machine_check_fwnmi) - PHYSICAL_START);\n#endif /* CONFIG_PPC_PSERIES */\n\n\tDBG(\" <- setup_kdump_trampoline()\\n\");\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/rtas.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/memblock.h>",
            "#include <linux/io.h>",
            "#include <linux/crash_dump.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/rtas.h>\n#include <asm/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid __init setup_kdump_trampoline(void)\n{\n\tunsigned long i;\n\n\tDBG(\" -> setup_kdump_trampoline()\\n\");\n\n\tfor (i = KDUMP_TRAMPOLINE_START; i < KDUMP_TRAMPOLINE_END; i += 8) {\n\t\tcreate_trampoline(i);\n\t}\n\n#ifdef CONFIG_PPC_PSERIES\n\tcreate_trampoline(__pa(system_reset_fwnmi) - PHYSICAL_START);\n\tcreate_trampoline(__pa(machine_check_fwnmi) - PHYSICAL_START);\n#endif /* CONFIG_PPC_PSERIES */\n\n\tDBG(\" <- setup_kdump_trampoline()\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_machine",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "probe_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "580-609",
          "snippet": "void probe_machine(void)\n{\n\textern struct machdep_calls __machine_desc_start;\n\textern struct machdep_calls __machine_desc_end;\n\n\t/*\n\t * Iterate all ppc_md structures until we find the proper\n\t * one for the current machine type\n\t */\n\tDBG(\"Probing machine type ...\\n\");\n\n\tfor (machine_id = &__machine_desc_start;\n\t     machine_id < &__machine_desc_end;\n\t     machine_id++) {\n\t\tDBG(\"  %s ...\", machine_id->name);\n\t\tmemcpy(&ppc_md, machine_id, sizeof(struct machdep_calls));\n\t\tif (ppc_md.probe()) {\n\t\t\tDBG(\" match !\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tDBG(\"\\n\");\n\t}\n\t/* What can we do if we didn't find ? */\n\tif (machine_id >= &__machine_desc_end) {\n\t\tDBG(\"No suitable machine found !\\n\");\n\t\tfor (;;);\n\t}\n\n\tprintk(KERN_INFO \"Using %s machine description\\n\", ppc_md.name);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct machdep_calls ppc_md;",
            "struct machdep_calls *machine_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/debugfs.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nstruct machdep_calls ppc_md;\nstruct machdep_calls *machine_id;\n\nvoid probe_machine(void)\n{\n\textern struct machdep_calls __machine_desc_start;\n\textern struct machdep_calls __machine_desc_end;\n\n\t/*\n\t * Iterate all ppc_md structures until we find the proper\n\t * one for the current machine type\n\t */\n\tDBG(\"Probing machine type ...\\n\");\n\n\tfor (machine_id = &__machine_desc_start;\n\t     machine_id < &__machine_desc_end;\n\t     machine_id++) {\n\t\tDBG(\"  %s ...\", machine_id->name);\n\t\tmemcpy(&ppc_md, machine_id, sizeof(struct machdep_calls));\n\t\tif (ppc_md.probe()) {\n\t\t\tDBG(\" match !\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tDBG(\"\\n\");\n\t}\n\t/* What can we do if we didn't find ? */\n\tif (machine_id >= &__machine_desc_end) {\n\t\tDBG(\"No suitable machine found !\\n\");\n\t\tfor (;;);\n\t}\n\n\tprintk(KERN_INFO \"Using %s machine description\\n\", ppc_md.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_init_mmu",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epapr_paravirt_early_init",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "epapr_paravirt_early_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/epapr_paravirt.c",
          "lines": "68-73",
          "snippet": "int __init epapr_paravirt_early_init(void)\n{\n\tof_scan_flat_dt(early_init_dt_scan_epapr, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/epapr_hcalls.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n\nint __init epapr_paravirt_early_init(void)\n{\n\tof_scan_flat_dt(early_init_dt_scan_epapr, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_init_devtree",
          "args": [
            "__va(dt_ptr)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_devtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "642-738",
          "snippet": "void __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%p)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n#endif\n\n#ifdef CONFIG_FA_DUMP\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#ifdef CONFIG_FA_DUMP\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_pacas();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static phys_addr_t first_memblock_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic phys_addr_t first_memblock_size;\n\nvoid __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%p)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n#endif\n\n#ifdef CONFIG_FA_DUMP\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#ifdef CONFIG_FA_DUMP\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_pacas();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "dt_ptr"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "&memset_nocache_branch",
            "PPC_INST_NOP"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(unsigned int *)&memcpy",
            "PPC_INST_NOP"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udbg_early_init",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_early_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/udbg.c",
          "lines": "29-81",
          "snippet": "void __init udbg_early_init(void)\n{\n#if defined(CONFIG_PPC_EARLY_DEBUG_LPAR)\n\t/* For LPAR machines that have an HVC console on vterm 0 */\n\tudbg_init_debug_lpar();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI)\n\t/* For LPAR machines that have an HVSI console on vterm 0 */\n\tudbg_init_debug_lpar_hvsi();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_G5)\n\t/* For use on Apple G5 machines */\n\tudbg_init_pmac_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_RTAS_PANEL)\n\t/* RTAS panel debug */\n\tudbg_init_rtas_panel();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_RTAS_CONSOLE)\n\t/* RTAS console debug */\n\tudbg_init_rtas_console();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_MAPLE)\n\t/* Maple real mode debug */\n\tudbg_init_maple_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_PAS_REALMODE)\n\tudbg_init_pas_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_BOOTX)\n\tudbg_init_btext();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_44x)\n\t/* PPC44x debug */\n\tudbg_init_44x_as1();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_40x)\n\t/* PPC40x debug */\n\tudbg_init_40x_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_CPM)\n\tudbg_init_cpm();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_USBGECKO)\n\tudbg_init_usbgecko();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_MEMCONS)\n\t/* In memory console */\n\tudbg_init_memcons();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_EHV_BC)\n\tudbg_init_ehv_bc();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_PS3GELIC)\n\tudbg_init_ps3gelic();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_OPAL_RAW)\n\tudbg_init_debug_opal_raw();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_OPAL_HVSI)\n\tudbg_init_debug_opal_hvsi();\n#endif\n\n#ifdef CONFIG_PPC_EARLY_DEBUG\n\tconsole_loglevel = 10;\n\n\tregister_early_udbg_console();\n#endif\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/processor.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/processor.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid __init udbg_early_init(void)\n{\n#if defined(CONFIG_PPC_EARLY_DEBUG_LPAR)\n\t/* For LPAR machines that have an HVC console on vterm 0 */\n\tudbg_init_debug_lpar();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI)\n\t/* For LPAR machines that have an HVSI console on vterm 0 */\n\tudbg_init_debug_lpar_hvsi();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_G5)\n\t/* For use on Apple G5 machines */\n\tudbg_init_pmac_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_RTAS_PANEL)\n\t/* RTAS panel debug */\n\tudbg_init_rtas_panel();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_RTAS_CONSOLE)\n\t/* RTAS console debug */\n\tudbg_init_rtas_console();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_MAPLE)\n\t/* Maple real mode debug */\n\tudbg_init_maple_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_PAS_REALMODE)\n\tudbg_init_pas_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_BOOTX)\n\tudbg_init_btext();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_44x)\n\t/* PPC44x debug */\n\tudbg_init_44x_as1();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_40x)\n\t/* PPC40x debug */\n\tudbg_init_40x_realmode();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_CPM)\n\tudbg_init_cpm();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_USBGECKO)\n\tudbg_init_usbgecko();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_MEMCONS)\n\t/* In memory console */\n\tudbg_init_memcons();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_EHV_BC)\n\tudbg_init_ehv_bc();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_PS3GELIC)\n\tudbg_init_ps3gelic();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_OPAL_RAW)\n\tudbg_init_debug_opal_raw();\n#elif defined(CONFIG_PPC_EARLY_DEBUG_OPAL_HVSI)\n\tudbg_init_debug_opal_hvsi();\n#endif\n\n#ifdef CONFIG_PPC_EARLY_DEBUG\n\tconsole_loglevel = 10;\n\n\tregister_early_udbg_console();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_init",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nextern unsigned int memset_nocache_branch;\n\n__init machine_init(u64 dt_ptr)\n{\n\tlockdep_init();\n\n\t/* Enable early debugging if any specified (see udbg.h) */\n\tudbg_early_init();\n\n\tpatch_instruction((unsigned int *)&memcpy, PPC_INST_NOP);\n\tpatch_instruction(&memset_nocache_branch, PPC_INST_NOP);\n\n\t/* Do some early initialization based on the flat device tree */\n\tearly_init_devtree(__va(dt_ptr));\n\n\tepapr_paravirt_early_init();\n\n\tearly_init_mmu();\n\n\tprobe_machine();\n\n\tsetup_kdump_trampoline();\n\n#ifdef CONFIG_6xx\n\tif (cpu_has_feature(CPU_FTR_CAN_DOZE) ||\n\t    cpu_has_feature(CPU_FTR_CAN_NAP))\n\t\tppc_md.power_save = ppc6xx_idle;\n#endif\n\n#ifdef CONFIG_E500\n\tif (cpu_has_feature(CPU_FTR_CAN_DOZE) ||\n\t    cpu_has_feature(CPU_FTR_CAN_NAP))\n\t\tppc_md.power_save = e500_idle;\n#endif\n\tif (ppc_md.progress)\n\t\tppc_md.progress(\"id mach(): done\", 0x200);\n}"
  },
  {
    "function_name": "early_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_32.c",
    "lines": "73-104",
    "snippet": "notrace unsigned long __init early_init(unsigned long dt_ptr)\n{\n\tunsigned long offset = reloc_offset();\n\tstruct cpu_spec *spec;\n\n\t/* First zero the BSS -- use memset_io, some platforms don't have\n\t * caches on yet */\n\tmemset_io((void __iomem *)PTRRELOC(&__bss_start), 0,\n\t\t\t__bss_stop - __bss_start);\n\n\t/*\n\t * Identify the CPU type and fix up code sections\n\t * that depend on which cpu we have.\n\t */\n\tspec = identify_cpu(offset, mfspr(SPRN_PVR));\n\n\tdo_feature_fixups(spec->cpu_features,\n\t\t\t  PTRRELOC(&__start___ftr_fixup),\n\t\t\t  PTRRELOC(&__stop___ftr_fixup));\n\n\tdo_feature_fixups(spec->mmu_features,\n\t\t\t  PTRRELOC(&__start___mmu_ftr_fixup),\n\t\t\t  PTRRELOC(&__stop___mmu_ftr_fixup));\n\n\tdo_lwsync_fixups(spec->cpu_features,\n\t\t\t PTRRELOC(&__start___lwsync_fixup),\n\t\t\t PTRRELOC(&__stop___lwsync_fixup));\n\n\tdo_final_fixups();\n\n\treturn KERNELBASE + offset;\n}",
    "includes": [
      "#include <asm/code-patching.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/time.h>",
      "#include <asm/xmon.h>",
      "#include <asm/nvram.h>",
      "#include <asm/sections.h>",
      "#include <asm/pmac_feature.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/machdep.h>",
      "#include <asm/btext.h>",
      "#include <asm/bootx.h>",
      "#include <asm/cputable.h>",
      "#include <asm/elf.h>",
      "#include <asm/smp.h>",
      "#include <asm/setup.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/processor.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/memblock.h>",
      "#include <linux/console.h>",
      "#include <linux/cpu.h>",
      "#include <linux/root_dev.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/tty.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notrace void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_final_fixups",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lwsync_fixups",
          "args": [
            "spec->cpu_features",
            "PTRRELOC(&__start___lwsync_fixup)",
            "PTRRELOC(&__stop___lwsync_fixup)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__stop___lwsync_fixup"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__start___lwsync_fixup"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "spec->mmu_features",
            "PTRRELOC(&__start___mmu_ftr_fixup)",
            "PTRRELOC(&__stop___mmu_ftr_fixup)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__stop___mmu_ftr_fixup"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__start___mmu_ftr_fixup"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "spec->cpu_features",
            "PTRRELOC(&__start___ftr_fixup)",
            "PTRRELOC(&__stop___ftr_fixup)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__stop___ftr_fixup"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&__start___ftr_fixup"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identify_cpu",
          "args": [
            "offset",
            "mfspr(SPRN_PVR)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "identify_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2182-2197",
          "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reloc_offset",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/code-patching.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/mmu_context.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/time.h>\n#include <asm/xmon.h>\n#include <asm/nvram.h>\n#include <asm/sections.h>\n#include <asm/pmac_feature.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/btext.h>\n#include <asm/bootx.h>\n#include <asm/cputable.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/setup.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/root_dev.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nnotrace void;\n\nnotrace unsigned long __init early_init(unsigned long dt_ptr)\n{\n\tunsigned long offset = reloc_offset();\n\tstruct cpu_spec *spec;\n\n\t/* First zero the BSS -- use memset_io, some platforms don't have\n\t * caches on yet */\n\tmemset_io((void __iomem *)PTRRELOC(&__bss_start), 0,\n\t\t\t__bss_stop - __bss_start);\n\n\t/*\n\t * Identify the CPU type and fix up code sections\n\t * that depend on which cpu we have.\n\t */\n\tspec = identify_cpu(offset, mfspr(SPRN_PVR));\n\n\tdo_feature_fixups(spec->cpu_features,\n\t\t\t  PTRRELOC(&__start___ftr_fixup),\n\t\t\t  PTRRELOC(&__stop___ftr_fixup));\n\n\tdo_feature_fixups(spec->mmu_features,\n\t\t\t  PTRRELOC(&__start___mmu_ftr_fixup),\n\t\t\t  PTRRELOC(&__stop___mmu_ftr_fixup));\n\n\tdo_lwsync_fixups(spec->cpu_features,\n\t\t\t PTRRELOC(&__start___lwsync_fixup),\n\t\t\t PTRRELOC(&__stop___lwsync_fixup));\n\n\tdo_final_fixups();\n\n\treturn KERNELBASE + offset;\n}"
  }
]