[
  {
    "function_name": "arch_uretprobe_hijack_return_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "196-207",
    "snippet": "unsigned long\narch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs)\n{\n\tunsigned long orig_ret_vaddr;\n\n\torig_ret_vaddr = regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = trampoline_vaddr;\n\n\treturn orig_ret_vaddr;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nunsigned long\narch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs)\n{\n\tunsigned long orig_ret_vaddr;\n\n\torig_ret_vaddr = regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = trampoline_vaddr;\n\n\treturn orig_ret_vaddr;\n}"
  },
  {
    "function_name": "arch_uprobe_skip_sstep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "181-194",
    "snippet": "bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tint ret;\n\n\t/*\n\t * emulate_step() returns 1 if the insn was successfully emulated.\n\t * For all other cases, we need to single-step in hardware.\n\t */\n\tret = emulate_step(regs, auprobe->insn);\n\tif (ret > 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_step",
          "args": [
            "regs",
            "auprobe->insn"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nbool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tint ret;\n\n\t/*\n\t * emulate_step() returns 1 if the insn was successfully emulated.\n\t * For all other cases, we need to single-step in hardware.\n\t */\n\tret = emulate_step(regs, auprobe->insn);\n\tif (ret > 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "arch_uprobe_abort_xol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "167-175",
    "snippet": "void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tcurrent->thread.trap_nr = utask->autask.saved_trap_nr;\n\tinstruction_pointer_set(regs, utask->vaddr);\n\n\tuser_disable_single_step(current);\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_disable_single_step",
          "args": [
            "current"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "user_disable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "886-915",
          "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "utask->vaddr"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tcurrent->thread.trap_nr = utask->autask.saved_trap_nr;\n\tinstruction_pointer_set(regs, utask->vaddr);\n\n\tuser_disable_single_step(current);\n}"
  },
  {
    "function_name": "arch_uprobe_exception_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "134-160",
    "snippet": "int arch_uprobe_exception_notify(struct notifier_block *self,\n\t\t\t\tunsigned long val, void *data)\n{\n\tstruct die_args *args = data;\n\tstruct pt_regs *regs = args->regs;\n\n\t/* regs == NULL is a kernel bug */\n\tif (WARN_ON(!regs))\n\t\treturn NOTIFY_DONE;\n\n\t/* We are only interested in userspace traps */\n\tif (!user_mode(regs))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_BPT:\n\t\tif (uprobe_pre_sstep_notifier(regs))\n\t\t\treturn NOTIFY_STOP;\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tif (uprobe_post_sstep_notifier(regs))\n\t\t\treturn NOTIFY_STOP;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_post_sstep_notifier",
          "args": [
            "regs"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_pre_sstep_notifier",
          "args": [
            "regs"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!regs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint arch_uprobe_exception_notify(struct notifier_block *self,\n\t\t\t\tunsigned long val, void *data)\n{\n\tstruct die_args *args = data;\n\tstruct pt_regs *regs = args->regs;\n\n\t/* regs == NULL is a kernel bug */\n\tif (WARN_ON(!regs))\n\t\treturn NOTIFY_DONE;\n\n\t/* We are only interested in userspace traps */\n\tif (!user_mode(regs))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_BPT:\n\t\tif (uprobe_pre_sstep_notifier(regs))\n\t\t\treturn NOTIFY_STOP;\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tif (uprobe_post_sstep_notifier(regs))\n\t\t\treturn NOTIFY_STOP;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "arch_uprobe_post_xol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "112-131",
    "snippet": "int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tWARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);\n\n\tcurrent->thread.trap_nr = utask->autask.saved_trap_nr;\n\n\t/*\n\t * On powerpc, except for loads and stores, most instructions\n\t * including ones that alter code flow (branches, calls, returns)\n\t * are emulated in the kernel. We get here only if the emulation\n\t * support doesn't exist and have to fix-up the next instruction\n\t * to be executed.\n\t */\n\tregs->nip = utask->vaddr + MAX_UINSN_BYTES;\n\n\tuser_disable_single_step(current);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_TRAP_NR\tUINT_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_disable_single_step",
          "args": [
            "current"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "user_disable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "886-915",
          "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->thread.trap_nr != UPROBE_TRAP_NR"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define UPROBE_TRAP_NR\tUINT_MAX\n\nint arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tWARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);\n\n\tcurrent->thread.trap_nr = utask->autask.saved_trap_nr;\n\n\t/*\n\t * On powerpc, except for loads and stores, most instructions\n\t * including ones that alter code flow (branches, calls, returns)\n\t * are emulated in the kernel. We get here only if the emulation\n\t * support doesn't exist and have to fix-up the next instruction\n\t * to be executed.\n\t */\n\tregs->nip = utask->vaddr + MAX_UINSN_BYTES;\n\n\tuser_disable_single_step(current);\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_uprobe_xol_was_trapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "97-103",
    "snippet": "bool arch_uprobe_xol_was_trapped(struct task_struct *t)\n{\n\tif (t->thread.trap_nr != UPROBE_TRAP_NR)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_TRAP_NR\tUINT_MAX"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define UPROBE_TRAP_NR\tUINT_MAX\n\nbool arch_uprobe_xol_was_trapped(struct task_struct *t)\n{\n\tif (t->thread.trap_nr != UPROBE_TRAP_NR)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "uprobe_get_swbp_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "82-85",
    "snippet": "unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nunsigned long uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
  },
  {
    "function_name": "arch_uprobe_pre_xol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "64-74",
    "snippet": "int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct arch_uprobe_task *autask = &current->utask->autask;\n\n\tautask->saved_trap_nr = current->thread.trap_nr;\n\tcurrent->thread.trap_nr = UPROBE_TRAP_NR;\n\tregs->nip = current->utask->xol_vaddr;\n\n\tuser_enable_single_step(current);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_TRAP_NR\tUINT_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enable_single_step",
          "args": [
            "current"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "user_enable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "852-867",
          "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define UPROBE_TRAP_NR\tUINT_MAX\n\nint arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\n{\n\tstruct arch_uprobe_task *autask = &current->utask->autask;\n\n\tautask->saved_trap_nr = current->thread.trap_nr;\n\tcurrent->thread.trap_nr = UPROBE_TRAP_NR;\n\tregs->nip = current->utask->xol_vaddr;\n\n\tuser_enable_single_step(current);\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_uprobe_analyze_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "50-57",
    "snippet": "int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe,\n\t\tstruct mm_struct *mm, unsigned long addr)\n{\n\tif (addr & 0x03)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint arch_uprobe_analyze_insn(struct arch_uprobe *auprobe,\n\t\tstruct mm_struct *mm, unsigned long addr)\n{\n\tif (addr & 0x03)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_trap_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
    "lines": "38-41",
    "snippet": "bool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}",
    "includes": [
      "#include <asm/sstep.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_trap",
          "args": [
            "*insn"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/uprobes.c",
          "lines": "38-41",
          "snippet": "bool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nbool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}"
  }
]