[
  {
    "function_name": "rtas_setup_phb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "265-279",
    "snippet": "int rtas_setup_phb(struct pci_controller *phb)\n{\n\tstruct device_node *dev = phb->dn;\n\n\tif (is_python(dev))\n\t\tpython_countermeasures(dev);\n\n\tif (phb_set_bus_ranges(dev, phb))\n\t\treturn 1;\n\n\tphb->ops = &rtas_pci_ops;\n\tphb->buid = get_phb_buid(dev);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_ops rtas_pci_ops = {\n\t.read = rtas_pci_read_config,\n\t.write = rtas_pci_write_config,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_phb_buid",
          "args": [
            "dev"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "get_phb_buid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "237-246",
          "snippet": "unsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ibm_read_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int ibm_read_pci_config;\n\nunsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb_set_bus_ranges",
          "args": [
            "dev",
            "phb"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "phb_set_bus_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "248-263",
          "snippet": "static int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "python_countermeasures",
          "args": [
            "dev"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "python_countermeasures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "192-227",
          "snippet": "static void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRG_CL_RESET_VALID 0x00010000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PRG_CL_RESET_VALID 0x00010000\n\nstatic void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_python",
          "args": [
            "dev"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "is_python",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "182-190",
          "snippet": "static int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pci_ops rtas_pci_ops = {\n\t.read = rtas_pci_read_config,\n\t.write = rtas_pci_write_config,\n};\n\nint rtas_setup_phb(struct pci_controller *phb)\n{\n\tstruct device_node *dev = phb->dn;\n\n\tif (is_python(dev))\n\t\tpython_countermeasures(dev);\n\n\tif (phb_set_bus_ranges(dev, phb))\n\t\treturn 1;\n\n\tphb->ops = &rtas_pci_ops;\n\tphb->buid = get_phb_buid(dev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "phb_set_bus_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "248-263",
    "snippet": "static int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bus_range[1]"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bus_range[0]"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dev",
            "\"bus-range\"",
            "&len"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_phb_buid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "237-246",
    "snippet": "unsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ibm_read_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_address_to_resource",
          "args": [
            "phb",
            "0",
            "&r"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int ibm_read_pci_config;\n\nunsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}"
  },
  {
    "function_name": "init_pci_config_tokens",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "229-235",
    "snippet": "void __init init_pci_config_tokens(void)\n{\n\tread_pci_config = rtas_token(\"read-pci-config\");\n\twrite_pci_config = rtas_token(\"write-pci-config\");\n\tibm_read_pci_config = rtas_token(\"ibm,read-pci-config\");\n\tibm_write_pci_config = rtas_token(\"ibm,write-pci-config\");\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_pci_config;",
      "static int write_pci_config;",
      "static int ibm_read_pci_config;",
      "static int ibm_write_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,write-pci-config\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int write_pci_config;\nstatic int ibm_read_pci_config;\nstatic int ibm_write_pci_config;\n\nvoid __init init_pci_config_tokens(void)\n{\n\tread_pci_config = rtas_token(\"read-pci-config\");\n\twrite_pci_config = rtas_token(\"write-pci-config\");\n\tibm_read_pci_config = rtas_token(\"ibm,read-pci-config\");\n\tibm_write_pci_config = rtas_token(\"ibm,write-pci-config\");\n}"
  },
  {
    "function_name": "python_countermeasures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "192-227",
    "snippet": "static void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRG_CL_RESET_VALID 0x00010000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "chip_regs"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"reg0: %x\\n\"",
            "val"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_be32",
          "args": [
            "chip_regs + 0xf6030"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_be32",
          "args": [
            "chip_regs + 0xf6030",
            "val"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Python workaround: \""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_be32",
          "args": [
            "chip_regs + 0xf6030"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "registers.start & ~(0xfffffUL)",
            "0x100000"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't get address for Python workarounds !\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_address_to_resource",
          "args": [
            "dev",
            "0",
            "&registers"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PRG_CL_RESET_VALID 0x00010000\n\nstatic void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}"
  },
  {
    "function_name": "is_python",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "182-190",
    "snippet": "static int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "model",
            "\"Python\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dev",
            "\"model\"",
            "NULL"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_pci_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "152-175",
    "snippet": "static int rtas_pci_write_config(struct pci_bus *bus,\n\t\t\t\t unsigned int devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct device_node *busdn, *dn;\n\tstruct pci_dn *pdn;\n\tbool found = false;\n\n\t/* Search only direct children of the bus */\n\tbusdn = pci_bus_to_OF_node(bus);\n\tfor (dn = busdn->child; dn; dn = dn->sibling) {\n\t\tpdn = PCI_DN(dn);\n\t\tif (pdn && pdn->devfn == devfn\n\t\t    && of_device_is_available(dn)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn rtas_write_config(pdn, where, size, val);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_write_config",
          "args": [
            "pdn",
            "where",
            "size",
            "val"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_write_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "122-150",
          "snippet": "int rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_pci_config;",
            "static int ibm_write_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int write_pci_config;\nstatic int ibm_write_pci_config;\n\nint rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "dn"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int rtas_pci_write_config(struct pci_bus *bus,\n\t\t\t\t unsigned int devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct device_node *busdn, *dn;\n\tstruct pci_dn *pdn;\n\tbool found = false;\n\n\t/* Search only direct children of the bus */\n\tbusdn = pci_bus_to_OF_node(bus);\n\tfor (dn = busdn->child; dn; dn = dn->sibling) {\n\t\tpdn = PCI_DN(dn);\n\t\tif (pdn && pdn->devfn == devfn\n\t\t    && of_device_is_available(dn)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn rtas_write_config(pdn, where, size, val);\n}"
  },
  {
    "function_name": "rtas_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "122-150",
    "snippet": "int rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_pci_config;",
      "static int ibm_write_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "write_pci_config",
            "3",
            "1",
            "NULL",
            "addr",
            "size",
            "(ulong)val"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUID_LO",
          "args": [
            "buid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUID_HI",
          "args": [
            "buid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_config_addr",
          "args": [
            "pdn->busno",
            "pdn->devfn",
            "where"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_access_valid",
          "args": [
            "pdn",
            "where"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "config_access_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "48-56",
          "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int write_pci_config;\nstatic int ibm_write_pci_config;\n\nint rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
  },
  {
    "function_name": "rtas_pci_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "90-120",
    "snippet": "static int rtas_pci_read_config(struct pci_bus *bus,\n\t\t\t\tunsigned int devfn,\n\t\t\t\tint where, int size, u32 *val)\n{\n\tstruct device_node *busdn, *dn;\n\tstruct pci_dn *pdn;\n\tbool found = false;\n\tint ret;\n\n\t/* Search only direct children of the bus */\n\t*val = 0xFFFFFFFF;\n\tbusdn = pci_bus_to_OF_node(bus);\n\tfor (dn = busdn->child; dn; dn = dn->sibling) {\n\t\tpdn = PCI_DN(dn);\n\t\tif (pdn && pdn->devfn == devfn\n\t\t    && of_device_is_available(dn)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tret = rtas_read_config(pdn, where, size, val);\n\tif (*val == EEH_IO_ERROR_VALUE(size) &&\n\t    eeh_dev_check_failure(pdn_to_eeh_dev(pdn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_check_failure",
          "args": [
            "pdn_to_eeh_dev(pdn)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "432-582",
          "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_MAX_FAILS\t2100000"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct eeh_stats eeh_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tunsigned long flags;\n\tstruct pci_dn *pdn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe, *phb_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\tpr_debug(\"EEH: Ignored check for %s\\n\",\n\t\t\teeh_pci_name(dev));\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count % EEH_MAX_FAILS == 0) {\n\t\t\tpdn = eeh_dev_to_pdn(edev);\n\t\t\tif (pdn->node)\n\t\t\t\tlocation = of_get_property(pdn->node, \"ibm,loc-code\", NULL);\n\t\t\tprintk(KERN_ERR \"EEH: %d reads ignored for recovering device at \"\n\t\t\t\t\"location=%s driver=%s pci addr=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev), eeh_pci_name(dev));\n\t\t\tprintk(KERN_ERR \"EEH: Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) ||\n\t    ((ret & active_flags) == active_flags)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 &&\n\t\t    (ret & active_flags) != active_flags)\n\t\t\tpe = parent_pe;\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t       pe->phb->global_number, pe->addr);\n\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\tdump_stack();\n\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EEH_IO_ERROR_VALUE",
          "args": [
            "size"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_read_config",
          "args": [
            "pdn",
            "where",
            "size",
            "val"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_read_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "58-88",
          "snippet": "int rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_pci_config;",
            "static int ibm_read_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int ibm_read_pci_config;\n\nint rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "dn"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int rtas_pci_read_config(struct pci_bus *bus,\n\t\t\t\tunsigned int devfn,\n\t\t\t\tint where, int size, u32 *val)\n{\n\tstruct device_node *busdn, *dn;\n\tstruct pci_dn *pdn;\n\tbool found = false;\n\tint ret;\n\n\t/* Search only direct children of the bus */\n\t*val = 0xFFFFFFFF;\n\tbusdn = pci_bus_to_OF_node(bus);\n\tfor (dn = busdn->child; dn; dn = dn->sibling) {\n\t\tpdn = PCI_DN(dn);\n\t\tif (pdn && pdn->devfn == devfn\n\t\t    && of_device_is_available(dn)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tret = rtas_read_config(pdn, where, size, val);\n\tif (*val == EEH_IO_ERROR_VALUE(size) &&\n\t    eeh_dev_check_failure(pdn_to_eeh_dev(pdn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "58-88",
    "snippet": "int rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_pci_config;",
      "static int ibm_read_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "read_pci_config",
            "2",
            "2",
            "&returnval",
            "addr",
            "size"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUID_LO",
          "args": [
            "buid"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUID_HI",
          "args": [
            "buid"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_config_addr",
          "args": [
            "pdn->busno",
            "pdn->devfn",
            "where"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_access_valid",
          "args": [
            "pdn",
            "where"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "config_access_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "48-56",
          "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int ibm_read_pci_config;\n\nint rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
  },
  {
    "function_name": "config_access_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "48-56",
    "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]