[
  {
    "function_name": "setup_noirqdistrib",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "684-688",
    "snippet": "static int __init setup_noirqdistrib(char *str)\n{\n\tdistribute_irqs = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic int __init setup_noirqdistrib(char *str)\n{\n\tdistribute_irqs = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "arch_early_irq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "678-681",
    "snippet": "int arch_early_irq_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint arch_early_irq_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_choose_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "672-675",
    "snippet": "int irq_choose_cpu(const struct cpumask *mask)\n{\n\treturn hard_smp_processor_id();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hard_smp_processor_id",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint irq_choose_cpu(const struct cpumask *mask)\n{\n\treturn hard_smp_processor_id();\n}"
  },
  {
    "function_name": "irq_choose_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "643-670",
    "snippet": "int irq_choose_cpu(const struct cpumask *mask)\n{\n\tint cpuid;\n\n\tif (cpumask_equal(mask, cpu_online_mask)) {\n\t\tstatic int irq_rover;\n\t\tstatic DEFINE_RAW_SPINLOCK(irq_rover_lock);\n\t\tunsigned long flags;\n\n\t\t/* Round-robin distribution... */\ndo_round_robin:\n\t\traw_spin_lock_irqsave(&irq_rover_lock, flags);\n\n\t\tirq_rover = cpumask_next(irq_rover, cpu_online_mask);\n\t\tif (irq_rover >= nr_cpu_ids)\n\t\t\tirq_rover = cpumask_first(cpu_online_mask);\n\n\t\tcpuid = irq_rover;\n\n\t\traw_spin_unlock_irqrestore(&irq_rover_lock, flags);\n\t} else {\n\t\tcpuid = cpumask_first_and(mask, cpu_online_mask);\n\t\tif (cpuid >= nr_cpu_ids)\n\t\t\tgoto do_round_robin;\n\t}\n\n\treturn get_hard_smp_processor_id(cpuid);\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "cpuid"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&irq_rover_lock",
            "flags"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "irq_rover",
            "cpu_online_mask"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&irq_rover_lock",
            "flags"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint irq_choose_cpu(const struct cpumask *mask)\n{\n\tint cpuid;\n\n\tif (cpumask_equal(mask, cpu_online_mask)) {\n\t\tstatic int irq_rover;\n\t\tstatic DEFINE_RAW_SPINLOCK(irq_rover_lock);\n\t\tunsigned long flags;\n\n\t\t/* Round-robin distribution... */\ndo_round_robin:\n\t\traw_spin_lock_irqsave(&irq_rover_lock, flags);\n\n\t\tirq_rover = cpumask_next(irq_rover, cpu_online_mask);\n\t\tif (irq_rover >= nr_cpu_ids)\n\t\t\tirq_rover = cpumask_first(cpu_online_mask);\n\n\t\tcpuid = irq_rover;\n\n\t\traw_spin_unlock_irqrestore(&irq_rover_lock, flags);\n\t} else {\n\t\tcpuid = cpumask_first_and(mask, cpu_online_mask);\n\t\tif (cpuid >= nr_cpu_ids)\n\t\t\tgoto do_round_robin;\n\t}\n\n\treturn get_hard_smp_processor_id(cpuid);\n}"
  },
  {
    "function_name": "virq_to_hw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "635-639",
    "snippet": "irq_hw_number_t virq_to_hw(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\treturn WARN_ON(!irq_data) ? 0 : irq_data->hwirq;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irq_data"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nirq_hw_number_t virq_to_hw(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\treturn WARN_ON(!irq_data) ? 0 : irq_data->hwirq;\n}"
  },
  {
    "function_name": "do_softirq_own_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "617-633",
    "snippet": "void do_softirq_own_stack(void)\n{\n\tstruct thread_info *curtp, *irqtp;\n\n\tcurtp = current_thread_info();\n\tirqtp = softirq_ctx[smp_processor_id()];\n\tirqtp->task = curtp->task;\n\tirqtp->flags = 0;\n\tcall_do_softirq(irqtp);\n\tirqtp->task = NULL;\n\n\t/* Set any flag that may have been set on the\n\t * alternate stack\n\t */\n\tif (irqtp->flags)\n\t\tset_bits(irqtp->flags, &curtp->flags);\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct thread_info *softirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bits",
          "args": [
            "irqtp->flags",
            "&curtp->flags"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_do_softirq",
          "args": [
            "irqtp"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstruct thread_info *softirq_ctx[NR_CPUS];\n\nvoid do_softirq_own_stack(void)\n{\n\tstruct thread_info *curtp, *irqtp;\n\n\tcurtp = current_thread_info();\n\tirqtp = softirq_ctx[smp_processor_id()];\n\tirqtp->task = curtp->task;\n\tirqtp->flags = 0;\n\tcall_do_softirq(irqtp);\n\tirqtp->task = NULL;\n\n\t/* Set any flag that may have been set on the\n\t * alternate stack\n\t */\n\tif (irqtp->flags)\n\t\tset_bits(irqtp->flags, &curtp->flags);\n}"
  },
  {
    "function_name": "irq_ctx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "601-615",
    "snippet": "void irq_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tmemset((void *)softirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = softirq_ctx[i];\n\t\ttp->cpu = i;\n\n\t\tmemset((void *)hardirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = hardirq_ctx[i];\n\t\ttp->cpu = i;\n\t}\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct thread_info *softirq_ctx[NR_CPUS]",
      "struct thread_info *hardirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)hardirq_ctx[i]",
            "0",
            "THREAD_SIZE"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstruct thread_info *softirq_ctx[NR_CPUS];\nstruct thread_info *hardirq_ctx[NR_CPUS];\n\nvoid irq_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tmemset((void *)softirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = softirq_ctx[i];\n\t\ttp->cpu = i;\n\n\t\tmemset((void *)hardirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = hardirq_ctx[i];\n\t\ttp->cpu = i;\n\t}\n}"
  },
  {
    "function_name": "exc_lvl_ctx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "562-595",
    "snippet": "void exc_lvl_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i, cpu_nr;\n\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_PPC64\n\t\tcpu_nr = i;\n#else\n#ifdef CONFIG_SMP\n\t\tcpu_nr = get_hard_smp_processor_id(i);\n#else\n\t\tcpu_nr = 0;\n#endif\n#endif\n\n\t\tmemset((void *)critirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = critirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n#ifdef CONFIG_BOOKE\n\t\tmemset((void *)dbgirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = dbgirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n\t\tmemset((void *)mcheckirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = mcheckirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = HARDIRQ_OFFSET;\n#endif\n\t}\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)mcheckirq_ctx[cpu_nr]",
            "0",
            "THREAD_SIZE"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "i"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid exc_lvl_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i, cpu_nr;\n\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_PPC64\n\t\tcpu_nr = i;\n#else\n#ifdef CONFIG_SMP\n\t\tcpu_nr = get_hard_smp_processor_id(i);\n#else\n\t\tcpu_nr = 0;\n#endif\n#endif\n\n\t\tmemset((void *)critirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = critirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n#ifdef CONFIG_BOOKE\n\t\tmemset((void *)dbgirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = dbgirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n\t\tmemset((void *)mcheckirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = mcheckirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = HARDIRQ_OFFSET;\n#endif\n\t}\n}"
  },
  {
    "function_name": "init_IRQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "547-555",
    "snippet": "void __init init_IRQ(void)\n{\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n\n\texc_lvl_ctx_init();\n\n\tirq_ctx_init();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_ctx_init",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "irq_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "601-615",
          "snippet": "void irq_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tmemset((void *)softirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = softirq_ctx[i];\n\t\ttp->cpu = i;\n\n\t\tmemset((void *)hardirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = hardirq_ctx[i];\n\t\ttp->cpu = i;\n\t}\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct thread_info *softirq_ctx[NR_CPUS]",
            "struct thread_info *hardirq_ctx[NR_CPUS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstruct thread_info *softirq_ctx[NR_CPUS];\nstruct thread_info *hardirq_ctx[NR_CPUS];\n\nvoid irq_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tmemset((void *)softirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = softirq_ctx[i];\n\t\ttp->cpu = i;\n\n\t\tmemset((void *)hardirq_ctx[i], 0, THREAD_SIZE);\n\t\ttp = hardirq_ctx[i];\n\t\ttp->cpu = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exc_lvl_ctx_init",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "exc_lvl_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "562-595",
          "snippet": "void exc_lvl_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i, cpu_nr;\n\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_PPC64\n\t\tcpu_nr = i;\n#else\n#ifdef CONFIG_SMP\n\t\tcpu_nr = get_hard_smp_processor_id(i);\n#else\n\t\tcpu_nr = 0;\n#endif\n#endif\n\n\t\tmemset((void *)critirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = critirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n#ifdef CONFIG_BOOKE\n\t\tmemset((void *)dbgirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = dbgirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n\t\tmemset((void *)mcheckirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = mcheckirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = HARDIRQ_OFFSET;\n#endif\n\t}\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid exc_lvl_ctx_init(void)\n{\n\tstruct thread_info *tp;\n\tint i, cpu_nr;\n\n\tfor_each_possible_cpu(i) {\n#ifdef CONFIG_PPC64\n\t\tcpu_nr = i;\n#else\n#ifdef CONFIG_SMP\n\t\tcpu_nr = get_hard_smp_processor_id(i);\n#else\n\t\tcpu_nr = 0;\n#endif\n#endif\n\n\t\tmemset((void *)critirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = critirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n#ifdef CONFIG_BOOKE\n\t\tmemset((void *)dbgirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = dbgirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = 0;\n\n\t\tmemset((void *)mcheckirq_ctx[cpu_nr], 0, THREAD_SIZE);\n\t\ttp = mcheckirq_ctx[cpu_nr];\n\t\ttp->cpu = cpu_nr;\n\t\ttp->preempt_count = HARDIRQ_OFFSET;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.init_IRQ",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "init_IRQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "547-555",
          "snippet": "void __init init_IRQ(void)\n{\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n\n\texc_lvl_ctx_init();\n\n\tirq_ctx_init();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __init init_IRQ(void)\n{\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n\n\texc_lvl_ctx_init();\n\n\tirq_ctx_init();\n}"
  },
  {
    "function_name": "do_IRQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "510-545",
    "snippet": "void do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tstruct thread_info *curtp, *irqtp, *sirqtp;\n\n\t/* Switch to the irq stack to handle this */\n\tcurtp = current_thread_info();\n\tirqtp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqtp = softirq_ctx[raw_smp_processor_id()];\n\n\t/* Already there ? */\n\tif (unlikely(curtp == irqtp || curtp == sirqtp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\n\t/* Prepare the thread_info in the irq stack */\n\tirqtp->task = curtp->task;\n\tirqtp->flags = 0;\n\n\t/* Copy the preempt_count so that the [soft]irq checks work. */\n\tirqtp->preempt_count = curtp->preempt_count;\n\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqtp);\n\n\t/* Restore stack limit */\n\tirqtp->task = NULL;\n\n\t/* Copy back updates to the thread_info */\n\tif (irqtp->flags)\n\t\tset_bits(irqtp->flags, &curtp->flags);\n\n\tset_irq_regs(old_regs);\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct thread_info *softirq_ctx[NR_CPUS]",
      "struct thread_info *hardirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bits",
          "args": [
            "irqtp->flags",
            "&curtp->flags"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_do_irq",
          "args": [
            "regs",
            "irqtp"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_irq",
          "args": [
            "regs"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__do_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "479-508",
          "snippet": "void __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\tcheck_stack_overflow();\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(irq == NO_IRQ))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\tcheck_stack_overflow();\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(irq == NO_IRQ))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curtp == irqtp || curtp == sirqtp"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "regs"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstruct thread_info *softirq_ctx[NR_CPUS];\nstruct thread_info *hardirq_ctx[NR_CPUS];\n\nvoid do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tstruct thread_info *curtp, *irqtp, *sirqtp;\n\n\t/* Switch to the irq stack to handle this */\n\tcurtp = current_thread_info();\n\tirqtp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqtp = softirq_ctx[raw_smp_processor_id()];\n\n\t/* Already there ? */\n\tif (unlikely(curtp == irqtp || curtp == sirqtp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\n\t/* Prepare the thread_info in the irq stack */\n\tirqtp->task = curtp->task;\n\tirqtp->flags = 0;\n\n\t/* Copy the preempt_count so that the [soft]irq checks work. */\n\tirqtp->preempt_count = curtp->preempt_count;\n\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqtp);\n\n\t/* Restore stack limit */\n\tirqtp->task = NULL;\n\n\t/* Copy back updates to the thread_info */\n\tif (irqtp->flags)\n\t\tset_bits(irqtp->flags, &curtp->flags);\n\n\tset_irq_regs(old_regs);\n}"
  },
  {
    "function_name": "__do_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "479-508",
    "snippet": "void __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\tcheck_stack_overflow();\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(irq == NO_IRQ))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_exit",
          "args": [
            "regs"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_handle_irq",
          "args": [
            "irq"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.spurious_irqs"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irq == NO_IRQ"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_hard_irq_enable",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.get_irq",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_overflow",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "463-477",
          "snippet": "static inline void check_stack_overflow(void)\n{\n#ifdef CONFIG_DEBUG_STACKOVERFLOW\n\tlong sp;\n\n\tsp = current_stack_pointer() & (THREAD_SIZE-1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < (sizeof(struct thread_info) + 2048))) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\",\n\t\t\tsp - sizeof(struct thread_info));\n\t\tdump_stack();\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline void check_stack_overflow(void)\n{\n#ifdef CONFIG_DEBUG_STACKOVERFLOW\n\tlong sp;\n\n\tsp = current_stack_pointer() & (THREAD_SIZE-1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < (sizeof(struct thread_info) + 2048))) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\",\n\t\t\tsp - sizeof(struct thread_info));\n\t\tdump_stack();\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_entry",
          "args": [
            "regs"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\tcheck_stack_overflow();\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(irq == NO_IRQ))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}"
  },
  {
    "function_name": "check_stack_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "463-477",
    "snippet": "static inline void check_stack_overflow(void)\n{\n#ifdef CONFIG_DEBUG_STACKOVERFLOW\n\tlong sp;\n\n\tsp = current_stack_pointer() & (THREAD_SIZE-1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < (sizeof(struct thread_info) + 2048))) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\",\n\t\t\tsp - sizeof(struct thread_info));\n\t\tdump_stack();\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"do_IRQ: stack overflow: %ld\\n\"",
            "sp - sizeof(struct thread_info)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sp < (sizeof(struct thread_info) + 2048)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_stack_pointer",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline void check_stack_overflow(void)\n{\n#ifdef CONFIG_DEBUG_STACKOVERFLOW\n\tlong sp;\n\n\tsp = current_stack_pointer() & (THREAD_SIZE-1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < (sizeof(struct thread_info) + 2048))) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\",\n\t\t\tsp - sizeof(struct thread_info));\n\t\tdump_stack();\n\t}\n#endif\n}"
  },
  {
    "function_name": "migrate_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "424-460",
    "snippet": "void migrate_irqs(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned int irq;\n\tstatic int warned;\n\tcpumask_var_t mask;\n\tconst struct cpumask *map = cpu_online_mask;\n\n\talloc_cpumask_var(&mask, GFP_KERNEL);\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tstruct irq_data *data;\n\t\tstruct irq_chip *chip;\n\n\t\tdata = irq_desc_get_irq_data(desc);\n\t\tif (irqd_is_per_cpu(data))\n\t\t\tcontinue;\n\n\t\tchip = irq_data_get_irq_chip(data);\n\n\t\tcpumask_and(mask, irq_data_get_affinity_mask(data), map);\n\t\tif (cpumask_any(mask) >= nr_cpu_ids) {\n\t\t\tpr_warn(\"Breaking affinity for irq %i\\n\", irq);\n\t\t\tcpumask_copy(mask, map);\n\t\t}\n\t\tif (chip->irq_set_affinity)\n\t\t\tchip->irq_set_affinity(data, mask, true);\n\t\telse if (desc->action && !(warned++))\n\t\t\tpr_err(\"Cannot set affinity for irq %i\\n\", irq);\n\t}\n\n\tfree_cpumask_var(mask);\n\n\tlocal_irq_enable();\n\tmdelay(1);\n\tlocal_irq_disable();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot set affinity for irq %i\\n\"",
            "irq"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_set_affinity",
          "args": [
            "data",
            "mask",
            "true"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "mask",
            "map"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Breaking affinity for irq %i\\n\"",
            "irq"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "mask"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "mask",
            "irq_data_get_affinity_mask(data)",
            "map"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "data"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_per_cpu",
          "args": [
            "data"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid migrate_irqs(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned int irq;\n\tstatic int warned;\n\tcpumask_var_t mask;\n\tconst struct cpumask *map = cpu_online_mask;\n\n\talloc_cpumask_var(&mask, GFP_KERNEL);\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tstruct irq_data *data;\n\t\tstruct irq_chip *chip;\n\n\t\tdata = irq_desc_get_irq_data(desc);\n\t\tif (irqd_is_per_cpu(data))\n\t\t\tcontinue;\n\n\t\tchip = irq_data_get_irq_chip(data);\n\n\t\tcpumask_and(mask, irq_data_get_affinity_mask(data), map);\n\t\tif (cpumask_any(mask) >= nr_cpu_ids) {\n\t\t\tpr_warn(\"Breaking affinity for irq %i\\n\", irq);\n\t\t\tcpumask_copy(mask, map);\n\t\t}\n\t\tif (chip->irq_set_affinity)\n\t\t\tchip->irq_set_affinity(data, mask, true);\n\t\telse if (desc->action && !(warned++))\n\t\t\tpr_err(\"Cannot set affinity for irq %i\\n\", irq);\n\t}\n\n\tfree_cpumask_var(mask);\n\n\tlocal_irq_enable();\n\tmdelay(1);\n\tlocal_irq_disable();\n}"
  },
  {
    "function_name": "arch_irq_stat_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "407-421",
    "snippet": "u64 arch_irq_stat_cpu(unsigned int cpu)\n{\n\tu64 sum = per_cpu(irq_stat, cpu).timer_irqs_event;\n\n\tsum += per_cpu(irq_stat, cpu).pmu_irqs;\n\tsum += per_cpu(irq_stat, cpu).mce_exceptions;\n\tsum += per_cpu(irq_stat, cpu).spurious_irqs;\n\tsum += per_cpu(irq_stat, cpu).timer_irqs_others;\n\tsum += per_cpu(irq_stat, cpu).hmi_exceptions;\n#ifdef CONFIG_PPC_DOORBELL\n\tsum += per_cpu(irq_stat, cpu).doorbell_irqs;\n#endif\n\n\treturn sum;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nu64 arch_irq_stat_cpu(unsigned int cpu)\n{\n\tu64 sum = per_cpu(irq_stat, cpu).timer_irqs_event;\n\n\tsum += per_cpu(irq_stat, cpu).pmu_irqs;\n\tsum += per_cpu(irq_stat, cpu).mce_exceptions;\n\tsum += per_cpu(irq_stat, cpu).spurious_irqs;\n\tsum += per_cpu(irq_stat, cpu).timer_irqs_others;\n\tsum += per_cpu(irq_stat, cpu).hmi_exceptions;\n#ifdef CONFIG_PPC_DOORBELL\n\tsum += per_cpu(irq_stat, cpu).doorbell_irqs;\n#endif\n\n\treturn sum;\n}"
  },
  {
    "function_name": "arch_show_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "346-402",
    "snippet": "int arch_show_interrupts(struct seq_file *p, int prec)\n{\n\tint j;\n\n#if defined(CONFIG_PPC32) && defined(CONFIG_TAU_INT)\n\tif (tau_initialized) {\n\t\tseq_printf(p, \"%*s: \", prec, \"TAU\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", tau_interrupts(j));\n\t\tseq_puts(p, \"  PowerPC             Thermal Assist (cpu temp)\\n\");\n\t}\n#endif /* CONFIG_PPC32 && CONFIG_TAU_INT */\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_event);\n        seq_printf(p, \"  Local timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_others);\n        seq_printf(p, \"  Local timer interrupts for others\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"SPU\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).spurious_irqs);\n\tseq_printf(p, \"  Spurious interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"PMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).pmu_irqs);\n\tseq_printf(p, \"  Performance monitoring interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"MCE\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).mce_exceptions);\n\tseq_printf(p, \"  Machine check exceptions\\n\");\n\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HMI\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \",\n\t\t\t\t\tper_cpu(irq_stat, j).hmi_exceptions);\n\t\tseq_printf(p, \"  Hypervisor Maintenance Interrupts\\n\");\n\t}\n\n#ifdef CONFIG_PPC_DOORBELL\n\tif (cpu_has_feature(CPU_FTR_DBELL)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"DBL\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).doorbell_irqs);\n\t\tseq_printf(p, \"  Doorbell interrupts\\n\");\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Doorbell interrupts\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"DBL\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DBELL"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Hypervisor Maintenance Interrupts\\n\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"HMI\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Machine check exceptions\\n\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"MCE\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Performance monitoring interrupts\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"PMI\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Spurious interrupts\\n\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"SPU\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Local timer interrupts for others\\n\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"LOC\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Local timer interrupts for timer event device\\n\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"LOC\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "p",
            "\"  PowerPC             Thermal Assist (cpu temp)\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"TAU\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint arch_show_interrupts(struct seq_file *p, int prec)\n{\n\tint j;\n\n#if defined(CONFIG_PPC32) && defined(CONFIG_TAU_INT)\n\tif (tau_initialized) {\n\t\tseq_printf(p, \"%*s: \", prec, \"TAU\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", tau_interrupts(j));\n\t\tseq_puts(p, \"  PowerPC             Thermal Assist (cpu temp)\\n\");\n\t}\n#endif /* CONFIG_PPC32 && CONFIG_TAU_INT */\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_event);\n        seq_printf(p, \"  Local timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_others);\n        seq_printf(p, \"  Local timer interrupts for others\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"SPU\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).spurious_irqs);\n\tseq_printf(p, \"  Spurious interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"PMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).pmu_irqs);\n\tseq_printf(p, \"  Performance monitoring interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"MCE\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).mce_exceptions);\n\tseq_printf(p, \"  Machine check exceptions\\n\");\n\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HMI\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \",\n\t\t\t\t\tper_cpu(irq_stat, j).hmi_exceptions);\n\t\tseq_printf(p, \"  Hypervisor Maintenance Interrupts\\n\");\n\t}\n\n#ifdef CONFIG_PPC_DOORBELL\n\tif (cpu_has_feature(CPU_FTR_DBELL)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"DBL\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).doorbell_irqs);\n\t\tseq_printf(p, \"  Doorbell interrupts\\n\");\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prep_irq_for_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "313-342",
    "snippet": "bool prep_irq_for_idle(void)\n{\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\t/*\n\t * Mark interrupts as soft-enabled and clear the\n\t * PACA_IRQ_HARD_DIS from the pending mask since we\n\t * are about to hard enable as well as a side effect\n\t * of entering the low power state.\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\tlocal_paca->soft_enabled = 1;\n\n\t/* Tell the caller to enter the low power state */\n\treturn true;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_irq_pending",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nbool prep_irq_for_idle(void)\n{\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\t/*\n\t * Mark interrupts as soft-enabled and clear the\n\t * PACA_IRQ_HARD_DIS from the pending mask since we\n\t * are about to hard enable as well as a side effect\n\t * of entering the low power state.\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\tlocal_paca->soft_enabled = 1;\n\n\t/* Tell the caller to enter the low power state */\n\treturn true;\n}"
  },
  {
    "function_name": "restore_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "289-296",
    "snippet": "void notrace restore_interrupts(void)\n{\n\tif (irqs_disabled()) {\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\t\tlocal_irq_enable();\n\t} else\n\t\t__hard_irq_enable();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hard_irq_enable",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid notrace restore_interrupts(void)\n{\n\tif (irqs_disabled()) {\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\t\tlocal_irq_enable();\n\t} else\n\t\t__hard_irq_enable();\n}"
  },
  {
    "function_name": "arch_local_irq_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "202-277",
    "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hard_irq_enable",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__replay_interrupt",
          "args": [
            "replay"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_soft_enabled",
          "args": [
            "1"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "set_soft_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "107-111",
          "snippet": "static inline notrace void set_soft_enabled(unsigned long enable)\n{\n\t__asm__ __volatile__(\"stb %0,%1(13)\"\n\t: : \"r\" (enable), \"i\" (offsetof(struct paca_struct, soft_enabled)));\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace void set_soft_enabled(unsigned long enable)\n{\n\t__asm__ __volatile__(\"stb %0,%1(13)\"\n\t: : \"r\" (enable), \"i\" (offsetof(struct paca_struct, soft_enabled)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__check_irq_replay",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__check_irq_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "135-200",
          "snippet": "notrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/* Clear bit 0 which we wouldn't clear otherwise */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * We may have missed a decrementer interrupt. We check the\n\t * decrementer itself rather than the paca irq_happened field\n\t * in case we also had a rollover while hard disabled\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\tif ((happened & PACA_IRQ_DEC) || decrementer_check_overflow())\n\t\treturn 0x900;\n\n\t/* Finally check if an external interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\tif (happened & PACA_IRQ_EE)\n\t\treturn 0x500;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Finally check if an EPR external interrupt happened\n\t * this bit is typically set if we need to handle another\n\t * \"edge\" interrupt from within the MPIC \"EPR\" handler\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE_EDGE;\n\tif (happened & PACA_IRQ_EE_EDGE)\n\t\treturn 0x500;\n\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL)\n\t\treturn 0x280;\n#else\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\t\treturn 0xe80;\n\t\treturn 0xa00;\n\t}\n#endif /* CONFIG_PPC_BOOK3E */\n\n\t/* Check if an hypervisor Maintenance interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\tif (happened & PACA_IRQ_HMI)\n\t\treturn 0xe60;\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/* Clear bit 0 which we wouldn't clear otherwise */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * We may have missed a decrementer interrupt. We check the\n\t * decrementer itself rather than the paca irq_happened field\n\t * in case we also had a rollover while hard disabled\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\tif ((happened & PACA_IRQ_DEC) || decrementer_check_overflow())\n\t\treturn 0x900;\n\n\t/* Finally check if an external interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\tif (happened & PACA_IRQ_EE)\n\t\treturn 0x500;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Finally check if an EPR external interrupt happened\n\t * this bit is typically set if we need to handle another\n\t * \"edge\" interrupt from within the MPIC \"EPR\" handler\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE_EDGE;\n\tif (happened & PACA_IRQ_EE_EDGE)\n\t\treturn 0x500;\n\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL)\n\t\treturn 0x280;\n#else\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\t\treturn 0xe80;\n\t\treturn 0xa00;\n\t}\n#endif /* CONFIG_PPC_BOOK3E */\n\n\t/* Check if an hypervisor Maintenance interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\tif (happened & PACA_IRQ_HMI)\n\t\treturn 0xe60;\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mfmsr() & MSR_EE"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irq_happened != PACA_IRQ_HARD_DIS"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_irq_happened",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "get_irq_happened",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "97-105",
          "snippet": "static inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
  },
  {
    "function_name": "__check_irq_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "135-200",
    "snippet": "notrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/* Clear bit 0 which we wouldn't clear otherwise */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * We may have missed a decrementer interrupt. We check the\n\t * decrementer itself rather than the paca irq_happened field\n\t * in case we also had a rollover while hard disabled\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\tif ((happened & PACA_IRQ_DEC) || decrementer_check_overflow())\n\t\treturn 0x900;\n\n\t/* Finally check if an external interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\tif (happened & PACA_IRQ_EE)\n\t\treturn 0x500;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Finally check if an EPR external interrupt happened\n\t * this bit is typically set if we need to handle another\n\t * \"edge\" interrupt from within the MPIC \"EPR\" handler\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE_EDGE;\n\tif (happened & PACA_IRQ_EE_EDGE)\n\t\treturn 0x500;\n\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL)\n\t\treturn 0x280;\n#else\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\t\treturn 0xe80;\n\t\treturn 0xa00;\n\t}\n#endif /* CONFIG_PPC_BOOK3E */\n\n\t/* Check if an hypervisor Maintenance interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\tif (happened & PACA_IRQ_HMI)\n\t\treturn 0xe60;\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "local_paca->irq_happened != 0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decrementer_check_overflow",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "decrementer_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "113-119",
          "snippet": "static inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lv1_get_version_info",
          "args": [
            "&tmp",
            "&tmp2"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_PS3_LV1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/* Clear bit 0 which we wouldn't clear otherwise */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * We may have missed a decrementer interrupt. We check the\n\t * decrementer itself rather than the paca irq_happened field\n\t * in case we also had a rollover while hard disabled\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\tif ((happened & PACA_IRQ_DEC) || decrementer_check_overflow())\n\t\treturn 0x900;\n\n\t/* Finally check if an external interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\tif (happened & PACA_IRQ_EE)\n\t\treturn 0x500;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Finally check if an EPR external interrupt happened\n\t * this bit is typically set if we need to handle another\n\t * \"edge\" interrupt from within the MPIC \"EPR\" handler\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_EE_EDGE;\n\tif (happened & PACA_IRQ_EE_EDGE)\n\t\treturn 0x500;\n\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL)\n\t\treturn 0x280;\n#else\n\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\t\treturn 0xe80;\n\t\treturn 0xa00;\n\t}\n#endif /* CONFIG_PPC_BOOK3E */\n\n\t/* Check if an hypervisor Maintenance interrupt happened */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\tif (happened & PACA_IRQ_HMI)\n\t\treturn 0xe60;\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decrementer_check_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "113-119",
    "snippet": "static inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&decrementers_next_tb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb_or_rtc",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}"
  },
  {
    "function_name": "set_soft_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "107-111",
    "snippet": "static inline notrace void set_soft_enabled(unsigned long enable)\n{\n\t__asm__ __volatile__(\"stb %0,%1(13)\"\n\t: : \"r\" (enable), \"i\" (offsetof(struct paca_struct, soft_enabled)));\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace void set_soft_enabled(unsigned long enable)\n{\n\t__asm__ __volatile__(\"stb %0,%1(13)\"\n\t: : \"r\" (enable), \"i\" (offsetof(struct paca_struct, soft_enabled)));\n}"
  },
  {
    "function_name": "get_irq_happened",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
    "lines": "97-105",
    "snippet": "static inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}",
    "includes": [
      "#include <asm/trace.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/debug.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}"
  }
]