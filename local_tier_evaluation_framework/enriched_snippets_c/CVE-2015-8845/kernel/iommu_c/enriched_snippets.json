[
  {
    "function_name": "tce_iommu_bus_notifier_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1152-1156",
    "snippet": "int __init tce_iommu_bus_notifier_init(void)\n{\n        bus_register_notifier(&pci_bus_type, &tce_iommu_bus_nb);\n        return 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&tce_iommu_bus_nb"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint __init tce_iommu_bus_notifier_init(void)\n{\n        bus_register_notifier(&pci_bus_type, &tce_iommu_bus_nb);\n        return 0;\n}"
  },
  {
    "function_name": "tce_iommu_bus_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1131-1146",
    "snippet": "static int tce_iommu_bus_notifier(struct notifier_block *nb,\n                unsigned long action, void *data)\n{\n        struct device *dev = data;\n\n        switch (action) {\n        case BUS_NOTIFY_ADD_DEVICE:\n                return iommu_add_device(dev);\n        case BUS_NOTIFY_DEL_DEVICE:\n                if (dev->iommu_group)\n                        iommu_del_device(dev);\n                return 0;\n        default:\n                return 0;\n        }\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_del_device",
          "args": [
            "dev"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_del_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "1114-1128",
          "snippet": "void iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!dev->iommu_group) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!dev->iommu_group) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_add_device",
          "args": [
            "dev"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "1065-1111",
          "snippet": "int iommu_add_device(struct device *dev)\n{\n\tstruct iommu_table *tbl;\n\tstruct iommu_table_group_link *tgl;\n\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (dev->iommu_group) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\ttbl = get_iommu_table_base(dev);\n\tif (!tbl) {\n\t\tpr_debug(\"%s: Skipping device %s with no tbl\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\n\ttgl = list_first_entry_or_null(&tbl->it_group_list,\n\t\t\tstruct iommu_table_group_link, next);\n\tif (!tgl) {\n\t\tpr_debug(\"%s: Skipping device %s with no group\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),\n\t\t iommu_group_id(tgl->table_group->group));\n\n\tif (PAGE_SIZE < IOMMU_PAGE_SIZE(tbl)) {\n\t\tpr_err(\"%s: Invalid IOMMU page size %lx (%lx) on %s\\n\",\n\t\t       __func__, IOMMU_PAGE_SIZE(tbl),\n\t\t       PAGE_SIZE, dev_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\treturn iommu_group_add_device(tgl->table_group->group, dev);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_add_device(struct device *dev)\n{\n\tstruct iommu_table *tbl;\n\tstruct iommu_table_group_link *tgl;\n\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (dev->iommu_group) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\ttbl = get_iommu_table_base(dev);\n\tif (!tbl) {\n\t\tpr_debug(\"%s: Skipping device %s with no tbl\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\n\ttgl = list_first_entry_or_null(&tbl->it_group_list,\n\t\t\tstruct iommu_table_group_link, next);\n\tif (!tgl) {\n\t\tpr_debug(\"%s: Skipping device %s with no group\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),\n\t\t iommu_group_id(tgl->table_group->group));\n\n\tif (PAGE_SIZE < IOMMU_PAGE_SIZE(tbl)) {\n\t\tpr_err(\"%s: Invalid IOMMU page size %lx (%lx) on %s\\n\",\n\t\t       __func__, IOMMU_PAGE_SIZE(tbl),\n\t\t       PAGE_SIZE, dev_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\treturn iommu_group_add_device(tgl->table_group->group, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int tce_iommu_bus_notifier(struct notifier_block *nb,\n                unsigned long action, void *data)\n{\n        struct device *dev = data;\n\n        switch (action) {\n        case BUS_NOTIFY_ADD_DEVICE:\n                return iommu_add_device(dev);\n        case BUS_NOTIFY_DEL_DEVICE:\n                if (dev->iommu_group)\n                        iommu_del_device(dev);\n                return 0;\n        default:\n                return 0;\n        }\n}"
  },
  {
    "function_name": "iommu_del_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1114-1128",
    "snippet": "void iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!dev->iommu_group) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_group_remove_device",
          "args": [
            "dev"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"iommu_tce: skipping device %s with no tbl\\n\"",
            "dev_name(dev)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!dev->iommu_group) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}"
  },
  {
    "function_name": "iommu_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1065-1111",
    "snippet": "int iommu_add_device(struct device *dev)\n{\n\tstruct iommu_table *tbl;\n\tstruct iommu_table_group_link *tgl;\n\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (dev->iommu_group) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\ttbl = get_iommu_table_base(dev);\n\tif (!tbl) {\n\t\tpr_debug(\"%s: Skipping device %s with no tbl\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\n\ttgl = list_first_entry_or_null(&tbl->it_group_list,\n\t\t\tstruct iommu_table_group_link, next);\n\tif (!tgl) {\n\t\tpr_debug(\"%s: Skipping device %s with no group\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),\n\t\t iommu_group_id(tgl->table_group->group));\n\n\tif (PAGE_SIZE < IOMMU_PAGE_SIZE(tbl)) {\n\t\tpr_err(\"%s: Invalid IOMMU page size %lx (%lx) on %s\\n\",\n\t\t       __func__, IOMMU_PAGE_SIZE(tbl),\n\t\t       PAGE_SIZE, dev_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\treturn iommu_group_add_device(tgl->table_group->group, dev);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_group_add_device",
          "args": [
            "tgl->table_group->group",
            "dev"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Invalid IOMMU page size %lx (%lx) on %s\\n\"",
            "__func__",
            "IOMMU_PAGE_SIZE(tbl)",
            "PAGE_SIZE",
            "dev_name(dev)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Adding %s to iommu group %d\\n\"",
            "__func__",
            "dev_name(dev)",
            "iommu_group_id(tgl->table_group->group)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_id",
          "args": [
            "tgl->table_group->group"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Skipping device %s with no group\\n\"",
            "__func__",
            "dev_name(dev)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&tbl->it_group_list",
            "structiommu_table_group_link",
            "next"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Skipping device %s with no tbl\\n\"",
            "__func__",
            "dev_name(dev)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Skipping device %s with iommu group %d\\n\"",
            "__func__",
            "dev_name(dev)",
            "iommu_group_id(dev->iommu_group)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_id",
          "args": [
            "dev->iommu_group"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_is_registered",
          "args": [
            "dev"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_add_device(struct device *dev)\n{\n\tstruct iommu_table *tbl;\n\tstruct iommu_table_group_link *tgl;\n\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (dev->iommu_group) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\ttbl = get_iommu_table_base(dev);\n\tif (!tbl) {\n\t\tpr_debug(\"%s: Skipping device %s with no tbl\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\n\ttgl = list_first_entry_or_null(&tbl->it_group_list,\n\t\t\tstruct iommu_table_group_link, next);\n\tif (!tgl) {\n\t\tpr_debug(\"%s: Skipping device %s with no group\\n\",\n\t\t\t __func__, dev_name(dev));\n\t\treturn 0;\n\t}\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),\n\t\t iommu_group_id(tgl->table_group->group));\n\n\tif (PAGE_SIZE < IOMMU_PAGE_SIZE(tbl)) {\n\t\tpr_err(\"%s: Invalid IOMMU page size %lx (%lx) on %s\\n\",\n\t\t       __func__, IOMMU_PAGE_SIZE(tbl),\n\t\t       PAGE_SIZE, dev_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\treturn iommu_group_add_device(tgl->table_group->group, dev);\n}"
  },
  {
    "function_name": "iommu_release_ownership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1045-1062",
    "snippet": "void iommu_release_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tmemset(tbl->it_map, 0, sz);\n\n\t/* Restore bit#0 set by iommu_init_table() */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0",
            "sz"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_release_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tmemset(tbl->it_map, 0, sz);\n\n\t/* Restore bit#0 set by iommu_init_table() */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n}"
  },
  {
    "function_name": "iommu_take_ownership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1005-1042",
    "snippet": "int iommu_take_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\tint ret = 0;\n\n\t/*\n\t * VFIO does not control TCE entries allocation and the guest\n\t * can write new TCEs on top of existing ones so iommu_tce_build()\n\t * must be able to release old pages. This functionality\n\t * requires exchange() callback defined so if it is not\n\t * implemented, we disallow taking ownership over the table.\n\t */\n\tif (!tbl->it_ops->exchange)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size)) {\n\t\tpr_err(\"iommu_tce: it_map is not empty\");\n\t\tret = -EBUSY;\n\t\t/* Restore bit#0 set by iommu_init_table() */\n\t\tif (tbl->it_offset == 0)\n\t\t\tset_bit(0, tbl->it_map);\n\t} else {\n\t\tmemset(tbl->it_map, 0xff, sz);\n\t}\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0xff",
            "sz"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"iommu_tce: it_map is not empty\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "tbl->it_map",
            "tbl->it_size"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_take_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\tint ret = 0;\n\n\t/*\n\t * VFIO does not control TCE entries allocation and the guest\n\t * can write new TCEs on top of existing ones so iommu_tce_build()\n\t * must be able to release old pages. This functionality\n\t * requires exchange() callback defined so if it is not\n\t * implemented, we disallow taking ownership over the table.\n\t */\n\tif (!tbl->it_ops->exchange)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size)) {\n\t\tpr_err(\"iommu_tce: it_map is not empty\");\n\t\tret = -EBUSY;\n\t\t/* Restore bit#0 set by iommu_init_table() */\n\t\tif (tbl->it_offset == 0)\n\t\t\tset_bit(0, tbl->it_map);\n\t} else {\n\t\tmemset(tbl->it_map, 0xff, sz);\n\t}\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_tce_xchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "985-1002",
    "snippet": "long iommu_tce_xchg(struct iommu_table *tbl, unsigned long entry,\n\t\tunsigned long *hpa, enum dma_data_direction *direction)\n{\n\tlong ret;\n\n\tret = tbl->it_ops->exchange(tbl, entry, hpa, direction);\n\n\tif (!ret && ((*direction == DMA_FROM_DEVICE) ||\n\t\t\t(*direction == DMA_BIDIRECTIONAL)))\n\t\tSetPageDirty(pfn_to_page(*hpa >> PAGE_SHIFT));\n\n\t/* if (unlikely(ret))\n\t\tpr_err(\"iommu_tce: %s failed on hwaddr=%lx ioba=%lx kva=%lx ret=%d\\n\",\n\t\t\t__func__, hwaddr, entry << tbl->it_page_shift,\n\t\t\t\thwaddr, ret); */\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "pfn_to_page(*hpa >> PAGE_SHIFT)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "*hpa >> PAGE_SHIFT"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->exchange",
          "args": [
            "tbl",
            "entry",
            "hpa",
            "direction"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nlong iommu_tce_xchg(struct iommu_table *tbl, unsigned long entry,\n\t\tunsigned long *hpa, enum dma_data_direction *direction)\n{\n\tlong ret;\n\n\tret = tbl->it_ops->exchange(tbl, entry, hpa, direction);\n\n\tif (!ret && ((*direction == DMA_FROM_DEVICE) ||\n\t\t\t(*direction == DMA_BIDIRECTIONAL)))\n\t\tSetPageDirty(pfn_to_page(*hpa >> PAGE_SHIFT));\n\n\t/* if (unlikely(ret))\n\t\tpr_err(\"iommu_tce: %s failed on hwaddr=%lx ioba=%lx kva=%lx ret=%d\\n\",\n\t\t\t__func__, hwaddr, entry << tbl->it_page_shift,\n\t\t\t\thwaddr, ret); */\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_tce_put_param_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "965-982",
    "snippet": "int iommu_tce_put_param_check(struct iommu_table *tbl,\n\t\tunsigned long ioba, unsigned long tce)\n{\n\tif (tce & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tif (ioba & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tioba >>= tbl->it_page_shift;\n\tif (ioba < tbl->it_offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + 1) > (tbl->it_offset + tbl->it_size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_tce_put_param_check(struct iommu_table *tbl,\n\t\tunsigned long ioba, unsigned long tce)\n{\n\tif (tce & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tif (ioba & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tioba >>= tbl->it_page_shift;\n\tif (ioba < tbl->it_offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + 1) > (tbl->it_offset + tbl->it_size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_tce_clear_param_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "943-962",
    "snippet": "int iommu_tce_clear_param_check(struct iommu_table *tbl,\n\t\tunsigned long ioba, unsigned long tce_value,\n\t\tunsigned long npages)\n{\n\t/* tbl->it_ops->clear() does not support any value but 0 */\n\tif (tce_value)\n\t\treturn -EINVAL;\n\n\tif (ioba & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tioba >>= tbl->it_page_shift;\n\tif (ioba < tbl->it_offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + npages) > (tbl->it_offset + tbl->it_size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_tce_clear_param_check(struct iommu_table *tbl,\n\t\tunsigned long ioba, unsigned long tce_value,\n\t\tunsigned long npages)\n{\n\t/* tbl->it_ops->clear() does not support any value but 0 */\n\tif (tce_value)\n\t\treturn -EINVAL;\n\n\tif (ioba & ~IOMMU_PAGE_MASK(tbl))\n\t\treturn -EINVAL;\n\n\tioba >>= tbl->it_page_shift;\n\tif (ioba < tbl->it_offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + npages) > (tbl->it_offset + tbl->it_size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_flush_tce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "932-940",
    "snippet": "void iommu_flush_tce(struct iommu_table *tbl)\n{\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_flush_tce(struct iommu_table *tbl)\n{\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n}"
  },
  {
    "function_name": "iommu_tce_direction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "919-929",
    "snippet": "enum dma_data_direction iommu_tce_direction(unsigned long tce)\n{\n\tif ((tce & TCE_PCI_READ) && (tce & TCE_PCI_WRITE))\n\t\treturn DMA_BIDIRECTIONAL;\n\telse if (tce & TCE_PCI_READ)\n\t\treturn DMA_TO_DEVICE;\n\telse if (tce & TCE_PCI_WRITE)\n\t\treturn DMA_FROM_DEVICE;\n\telse\n\t\treturn DMA_NONE;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nenum dma_data_direction iommu_tce_direction(unsigned long tce)\n{\n\tif ((tce & TCE_PCI_READ) && (tce & TCE_PCI_WRITE))\n\t\treturn DMA_BIDIRECTIONAL;\n\telse if (tce & TCE_PCI_READ)\n\t\treturn DMA_TO_DEVICE;\n\telse if (tce & TCE_PCI_WRITE)\n\t\treturn DMA_FROM_DEVICE;\n\telse\n\t\treturn DMA_NONE;\n}"
  },
  {
    "function_name": "iommu_register_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "897-917",
    "snippet": "void iommu_register_group(struct iommu_table_group *table_group,\n\t\tint pci_domain_number, unsigned long pe_num)\n{\n\tstruct iommu_group *grp;\n\tchar *name;\n\n\tgrp = iommu_group_alloc();\n\tif (IS_ERR(grp)) {\n\t\tpr_warn(\"powerpc iommu api: cannot create new group, err=%ld\\n\",\n\t\t\t\tPTR_ERR(grp));\n\t\treturn;\n\t}\n\ttable_group->group = grp;\n\tiommu_group_set_iommudata(grp, table_group, group_release);\n\tname = kasprintf(GFP_KERNEL, \"domain%d-pe%lx\",\n\t\t\tpci_domain_number, pe_num);\n\tif (!name)\n\t\treturn;\n\tiommu_group_set_name(grp, name);\n\tkfree(name);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_set_name",
          "args": [
            "grp",
            "name"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"domain%d-pe%lx\"",
            "pci_domain_number",
            "pe_num"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_set_iommudata",
          "args": [
            "grp",
            "table_group",
            "group_release"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"powerpc iommu api: cannot create new group, err=%ld\\n\"",
            "PTR_ERR(grp)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "grp"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "grp"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_alloc",
          "args": [],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_register_group(struct iommu_table_group *table_group,\n\t\tint pci_domain_number, unsigned long pe_num)\n{\n\tstruct iommu_group *grp;\n\tchar *name;\n\n\tgrp = iommu_group_alloc();\n\tif (IS_ERR(grp)) {\n\t\tpr_warn(\"powerpc iommu api: cannot create new group, err=%ld\\n\",\n\t\t\t\tPTR_ERR(grp));\n\t\treturn;\n\t}\n\ttable_group->group = grp;\n\tiommu_group_set_iommudata(grp, table_group, group_release);\n\tname = kasprintf(GFP_KERNEL, \"domain%d-pe%lx\",\n\t\t\tpci_domain_number, pe_num);\n\tif (!name)\n\t\treturn;\n\tiommu_group_set_name(grp, name);\n\tkfree(name);\n}"
  },
  {
    "function_name": "group_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "890-895",
    "snippet": "static void group_release(void *iommu_data)\n{\n\tstruct iommu_table_group *table_group = iommu_data;\n\n\ttable_group->group = NULL;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void group_release(void *iommu_data)\n{\n\tstruct iommu_table_group *table_group = iommu_data;\n\n\ttable_group->group = NULL;\n}"
  },
  {
    "function_name": "iommu_direction_to_tce_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "871-883",
    "snippet": "unsigned long iommu_direction_to_tce_perm(enum dma_data_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn TCE_PCI_READ | TCE_PCI_WRITE;\n\tcase DMA_FROM_DEVICE:\n\t\treturn TCE_PCI_WRITE;\n\tcase DMA_TO_DEVICE:\n\t\treturn TCE_PCI_READ;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nunsigned long iommu_direction_to_tce_perm(enum dma_data_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn TCE_PCI_READ | TCE_PCI_WRITE;\n\tcase DMA_FROM_DEVICE:\n\t\treturn TCE_PCI_WRITE;\n\tcase DMA_TO_DEVICE:\n\t\treturn TCE_PCI_READ;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "iommu_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "857-869",
    "snippet": "void iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vaddr",
            "get_order(size)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "nio_pages"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "418-429",
          "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}"
  },
  {
    "function_name": "iommu_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "810-855",
    "snippet": "void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)ret",
            "order"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_alloc",
          "args": [
            "dev",
            "tbl",
            "ret",
            "nio_pages",
            "DMA_BIDIRECTIONAL",
            "mask >> tbl->it_page_shift",
            "io_order",
            "NULL"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "306-347",
          "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_order",
          "args": [
            "size",
            "tbl"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "flag",
            "order"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc_consistent size too large: 0x%lx\\n\"",
            "size"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "791-804",
    "snippet": "void iommu_unmap_page(struct iommu_table *tbl, dma_addr_t dma_handle,\n\t\t      size_t size, enum dma_data_direction direction,\n\t\t      struct dma_attrs *attrs)\n{\n\tunsigned int npages;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(dma_handle, size,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\tiommu_free(tbl, dma_handle, npages);\n\t}\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "npages"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "418-429",
          "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "dma_handle",
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_unmap_page(struct iommu_table *tbl, dma_addr_t dma_handle,\n\t\t      size_t size, enum dma_data_direction direction,\n\t\t      struct dma_attrs *attrs)\n{\n\tunsigned int npages;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(dma_handle, size,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\tiommu_free(tbl, dma_handle, npages);\n\t}\n}"
  },
  {
    "function_name": "iommu_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "753-789",
    "snippet": "dma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_handle = DMA_ERROR_CODE;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\n\tif (tbl) {\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_ERROR_CODE) {\n\t\t\tif (printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\"",
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_alloc",
          "args": [
            "dev",
            "tbl",
            "vaddr",
            "npages",
            "direction",
            "mask >> tbl->it_page_shift",
            "align",
            "attrs"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "306-347",
          "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "uaddr",
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\ndma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_handle = DMA_ERROR_CODE;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\n\tif (tbl) {\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_ERROR_CODE) {\n\t\t\tif (printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}"
  },
  {
    "function_name": "iommu_free_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "713-746",
    "snippet": "void iommu_free_table(struct iommu_table *tbl, const char *node_name)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\n\tif (!tbl)\n\t\treturn;\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs for %s\\n\", __func__, node_name);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long) tbl->it_map",
            "order"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "bitmap_sz"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "tbl->it_size"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unexpected TCEs for %s\\n\"",
            "__func__",
            "node_name"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "tbl->it_map",
            "tbl->it_size"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_free_table(struct iommu_table *tbl, const char *node_name)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\n\tif (!tbl)\n\t\treturn;\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs for %s\\n\", __func__, node_name);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}"
  },
  {
    "function_name": "iommu_init_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "652-711",
    "snippet": "struct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\"",
            "novmerge ? \"disabled\" : \"enabled\""
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_table_clear",
          "args": [
            "tbl"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "607-646",
          "snippet": "static void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&(p->lock)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&(p->lock)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0",
            "sz"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"iommu_init_table: Can't allocate %ld bytes\\n\"",
            "sz"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "nid",
            "GFP_KERNEL",
            "get_order(sz)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "sz"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "tbl->it_size"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tbl->it_ops"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\n\nstruct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}"
  },
  {
    "function_name": "iommu_table_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "607-646",
    "snippet": "static void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "index",
            "tbl->it_map"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%d entries for the kdump boot\\n\"",
            "KDUMP_MIN_TCE_ENTRIES"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"TCE table is full; freeing \""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "index",
            "tbl->it_map"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->get",
          "args": [
            "tbl",
            "index + tbl->it_offset"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->clear",
          "args": [
            "tbl",
            "tbl->it_offset",
            "tbl->it_size"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fadump_active",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "is_fadump_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "117-120",
          "snippet": "int is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kdump_kernel",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "ppc_iommu_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "575-605",
    "snippet": "void ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "sg"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "npages"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "396-416",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "dma_handle",
            "sg->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
  },
  {
    "function_name": "ppc_iommu_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "431-572",
    "snippet": "int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_ERROR_CODE)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_ERROR_CODE;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_ERROR_CODE;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;",
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "396-416",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "s->dma_address",
            "s->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "outs"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"mapped %d elements:\\n\"",
            "outcount"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - dma next is: %lx\\n\"",
            "dma_next"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - filling new segment.\\n\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"    merged, new len: %ux\\n\"",
            "outs->dma_length"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"    can't merge, new segment.\\n\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "outs"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - trying merge...\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "build_fail"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->set",
          "args": [
            "tbl",
            "entry",
            "npages",
            "vaddr & IOMMU_PAGE_MASK(tbl)",
            "direction",
            "attrs"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\"",
            "npages",
            "entry",
            "dma_addr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\"",
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry == DMA_ERROR_CODE"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - vaddr: %lx, size: %lx\\n\"",
            "vaddr",
            "slen"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_range_alloc",
          "args": [
            "dev",
            "tbl",
            "npages",
            "&handle",
            "mask >> tbl->it_page_shift",
            "align"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "176-304",
          "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "vaddr",
            "slen",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_virt",
          "args": [
            "s"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "dev"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"sg mapping %d elements:\\n\"",
            "nelems"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nint ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_ERROR_CODE)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_ERROR_CODE;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_ERROR_CODE;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "418-429",
    "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "dma_addr",
            "npages"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "396-416",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
  },
  {
    "function_name": "__iommu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "396-416",
    "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "tbl->it_map",
            "free_entry",
            "npages"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->clear",
          "args": [
            "tbl",
            "entry",
            "npages"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_free_check",
          "args": [
            "tbl",
            "dma_addr",
            "npages"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "349-375",
          "snippet": "static bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pool",
          "args": [
            "tbl",
            "free_entry"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "get_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "377-394",
          "snippet": "static struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
  },
  {
    "function_name": "get_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "377-394",
    "snippet": "static struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pool_nr > tbl->nr_pools"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "iommu_free_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "349-375",
    "snippet": "static bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"\\tindex     = 0x%llx\\n\"",
            "(u64)tbl->it_index"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"iommu_free: invalid entry\\n\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "iommu_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "306-347",
    "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "ret",
            "npages"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "396-416",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "build_fail"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->set",
          "args": [
            "tbl",
            "entry",
            "npages",
            "(unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl)",
            "direction",
            "attrs"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry == DMA_ERROR_CODE"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_range_alloc",
          "args": [
            "dev",
            "tbl",
            "npages",
            "NULL",
            "mask",
            "align_order"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "176-304",
          "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      struct dma_attrs *attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_ERROR_CODE))\n\t\treturn DMA_ERROR_CODE;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_ERROR_CODE. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_range_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "176-304",
    "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pass == 0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_area_alloc",
          "args": [
            "tbl->it_map",
            "limit",
            "start",
            "npages",
            "tbl->it_offset",
            "boundary_size >> tbl->it_page_shift",
            "align_mask"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "1UL << 32",
            "1 << tbl->it_page_shift"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "dma_get_seg_boundary(dev) + 1",
            "1 << tbl->it_page_shift"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "dev"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "iommu_pool_hash"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_iommu",
          "args": [
            "dev"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_iommu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "170-173",
          "snippet": "static inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "npages == 0"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = 0xffffffffffffffffl >> (64 - align_order);\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_ERROR_CODE;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_ERROR_CODE;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = __this_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_ERROR_CODE;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
  },
  {
    "function_name": "should_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "170-173",
    "snippet": "static inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "fail_iommu_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "153-163",
    "snippet": "static int __init fail_iommu_setup(void)\n{\n#ifdef CONFIG_PCI\n\tbus_register_notifier(&pci_bus_type, &fail_iommu_bus_notifier);\n#endif\n#ifdef CONFIG_IBMVIO\n\tbus_register_notifier(&vio_bus_type, &fail_iommu_bus_notifier);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&vio_bus_type",
            "&fail_iommu_bus_notifier"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&fail_iommu_bus_notifier"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init fail_iommu_setup(void)\n{\n#ifdef CONFIG_PCI\n\tbus_register_notifier(&pci_bus_type, &fail_iommu_bus_notifier);\n#endif\n#ifdef CONFIG_IBMVIO\n\tbus_register_notifier(&vio_bus_type, &fail_iommu_bus_notifier);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fail_iommu_bus_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "133-147",
    "snippet": "static int fail_iommu_bus_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tif (action == BUS_NOTIFY_ADD_DEVICE) {\n\t\tif (device_create_file(dev, &dev_attr_fail_iommu))\n\t\t\tpr_warn(\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\");\n\t} else if (action == BUS_NOTIFY_DEL_DEVICE) {\n\t\tdevice_remove_file(dev, &dev_attr_fail_iommu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "dev",
            "&dev_attr_fail_iommu"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_fail_iommu"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int fail_iommu_bus_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tif (action == BUS_NOTIFY_ADD_DEVICE) {\n\t\tif (device_create_file(dev, &dev_attr_fail_iommu))\n\t\t\tpr_warn(\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\");\n\t} else if (action == BUS_NOTIFY_DEL_DEVICE) {\n\t\tdevice_remove_file(dev, &dev_attr_fail_iommu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fail_iommu_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "118-128",
    "snippet": "static ssize_t fail_iommu_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint i;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &i) > 0)\n\t\tdev->archdata.fail_iommu = (i == 0) ? 0 : 1;\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&i"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic ssize_t fail_iommu_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint i;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &i) > 0)\n\t\tdev->archdata.fail_iommu = (i == 0) ? 0 : 1;\n\n\treturn count;\n}"
  },
  {
    "function_name": "fail_iommu_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "112-116",
    "snippet": "static ssize_t fail_iommu_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->archdata.fail_iommu);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "dev->archdata.fail_iommu"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic ssize_t fail_iommu_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->archdata.fail_iommu);\n}"
  },
  {
    "function_name": "fail_iommu_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "103-109",
    "snippet": "static int __init fail_iommu_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_iommu\",\n\t\t\t\t\t\t       NULL, &fail_iommu);\n\n\treturn PTR_ERR_OR_ZERO(dir);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "dir"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_iommu\"",
            "NULL",
            "&fail_iommu"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init fail_iommu_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_iommu\",\n\t\t\t\t\t\t       NULL, &fail_iommu);\n\n\treturn PTR_ERR_OR_ZERO(dir);\n}"
  },
  {
    "function_name": "should_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "98-101",
    "snippet": "static bool should_fail_iommu(struct device *dev)\n{\n\treturn dev->archdata.fail_iommu && should_fail(&fail_iommu, 1);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fail_iommu",
            "1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic bool should_fail_iommu(struct device *dev)\n{\n\treturn dev->archdata.fail_iommu && should_fail(&fail_iommu, 1);\n}"
  },
  {
    "function_name": "setup_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "92-95",
    "snippet": "static int __init setup_fail_iommu(char *str)\n{\n\treturn setup_fault_attr(&fail_iommu, str);\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_fault_attr",
          "args": [
            "&fail_iommu",
            "str"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init setup_fail_iommu(char *str)\n{\n\treturn setup_fault_attr(&fail_iommu, str);\n}"
  },
  {
    "function_name": "setup_iommu_pool_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "77-85",
    "snippet": "static int __init setup_iommu_pool_hash(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tper_cpu(iommu_pool_hash, i) = hash_32(i, IOMMU_POOL_HASHBITS);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "i",
            "IOMMU_POOL_HASHBITS"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic int __init setup_iommu_pool_hash(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tper_cpu(iommu_pool_hash, i) = hash_32(i, IOMMU_POOL_HASHBITS);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
    "lines": "57-64",
    "snippet": "static int __init setup_iommu(char *str)\n{\n\tif (!strcmp(str, \"novmerge\"))\n\t\tnovmerge = 1;\n\telse if (!strcmp(str, \"vmerge\"))\n\t\tnovmerge = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"vmerge\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"novmerge\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\n\nstatic int __init setup_iommu(char *str)\n{\n\tif (!strcmp(str, \"novmerge\"))\n\t\tnovmerge = 1;\n\telse if (!strcmp(str, \"vmerge\"))\n\t\tnovmerge = 0;\n\treturn 1;\n}"
  }
]