[
  {
    "function_name": "smp_generic_give_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "112-170",
    "snippet": "void smp_generic_give_timebase(void)\n{\n\tint i, score, score2, old, min=0, max=5000, offset=1000;\n\n\tpr_debug(\"Software timebase sync\\n\");\n\n\t/* if this fails then this kernel won't work anyway... */\n\ttbsync = kzalloc( sizeof(*tbsync), GFP_KERNEL );\n\tmb();\n\trunning = 1;\n\n\twhile (!tbsync->ack)\n\t\tbarrier();\n\n\tpr_debug(\"Got ack\\n\");\n\n\t/* binary search */\n\tfor (old = -1; old != offset ; offset = (min+max) / 2) {\n\t\tscore = start_contest(kSetAndTest, offset, NUM_ITER);\n\n\t\tpr_debug(\"score %d, offset %d\\n\", score, offset );\n\n\t\tif( score > 0 )\n\t\t\tmax = offset;\n\t\telse\n\t\t\tmin = offset;\n\t\told = offset;\n\t}\n\tscore = start_contest(kSetAndTest, min, NUM_ITER);\n\tscore2 = start_contest(kSetAndTest, max, NUM_ITER);\n\n\tpr_debug(\"Min %d (score %d), Max %d (score %d)\\n\",\n\t\t min, score, max, score2);\n\tscore = abs(score);\n\tscore2 = abs(score2);\n\toffset = (score < score2) ? min : max;\n\n\t/* guard against inaccurate mttb */\n\tfor (i = 0; i < 10; i++) {\n\t\tstart_contest(kSetAndTest, offset, NUM_ITER/10);\n\n\t\tif ((score2 = start_contest(kTest, offset, NUM_ITER)) < 0)\n\t\t\tscore2 = -score2;\n\t\tif (score2 <= score || score2 < 20)\n\t\t\tbreak;\n\t}\n\tpr_debug(\"Final offset: %d (%d/%d)\\n\", offset, score2, NUM_ITER );\n\n\t/* exiting */\n\ttbsync->cmd = kExit;\n\twmb();\n\ttbsync->handshake = 1;\n\twhile (tbsync->ack)\n\t\tbarrier();\n\ttbsync->handshake = 0;\n\tkfree(tbsync);\n\ttbsync = NULL;\n\trunning = 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NUM_ITER\t\t300"
    ],
    "globals_used": [
      "static volatile int\t\trunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbsync"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Final offset: %d (%d/%d)\\n\"",
            "offset",
            "score2",
            "NUM_ITER"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_contest",
          "args": [
            "kTest",
            "offset",
            "NUM_ITER"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "start_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "77-110",
          "snippet": "static int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "score2"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "score"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Min %d (score %d), Max %d (score %d)\\n\"",
            "min",
            "score",
            "max",
            "score2"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"score %d, offset %d\\n\"",
            "score",
            "offset"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Got ack\\n\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tbsync)",
            "GFP_KERNEL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Software timebase sync\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define NUM_ITER\t\t300\n\nstatic volatile int\t\trunning;\n\nvoid smp_generic_give_timebase(void)\n{\n\tint i, score, score2, old, min=0, max=5000, offset=1000;\n\n\tpr_debug(\"Software timebase sync\\n\");\n\n\t/* if this fails then this kernel won't work anyway... */\n\ttbsync = kzalloc( sizeof(*tbsync), GFP_KERNEL );\n\tmb();\n\trunning = 1;\n\n\twhile (!tbsync->ack)\n\t\tbarrier();\n\n\tpr_debug(\"Got ack\\n\");\n\n\t/* binary search */\n\tfor (old = -1; old != offset ; offset = (min+max) / 2) {\n\t\tscore = start_contest(kSetAndTest, offset, NUM_ITER);\n\n\t\tpr_debug(\"score %d, offset %d\\n\", score, offset );\n\n\t\tif( score > 0 )\n\t\t\tmax = offset;\n\t\telse\n\t\t\tmin = offset;\n\t\told = offset;\n\t}\n\tscore = start_contest(kSetAndTest, min, NUM_ITER);\n\tscore2 = start_contest(kSetAndTest, max, NUM_ITER);\n\n\tpr_debug(\"Min %d (score %d), Max %d (score %d)\\n\",\n\t\t min, score, max, score2);\n\tscore = abs(score);\n\tscore2 = abs(score2);\n\toffset = (score < score2) ? min : max;\n\n\t/* guard against inaccurate mttb */\n\tfor (i = 0; i < 10; i++) {\n\t\tstart_contest(kSetAndTest, offset, NUM_ITER/10);\n\n\t\tif ((score2 = start_contest(kTest, offset, NUM_ITER)) < 0)\n\t\t\tscore2 = -score2;\n\t\tif (score2 <= score || score2 < 20)\n\t\t\tbreak;\n\t}\n\tpr_debug(\"Final offset: %d (%d/%d)\\n\", offset, score2, NUM_ITER );\n\n\t/* exiting */\n\ttbsync->cmd = kExit;\n\twmb();\n\ttbsync->handshake = 1;\n\twhile (tbsync->ack)\n\t\tbarrier();\n\ttbsync->handshake = 0;\n\tkfree(tbsync);\n\ttbsync = NULL;\n\trunning = 0;\n}"
  },
  {
    "function_name": "start_contest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "77-110",
    "snippet": "static int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_contest",
          "args": [
            "mark",
            "1"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "enter_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "38-42",
          "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}"
  },
  {
    "function_name": "smp_generic_take_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "44-75",
    "snippet": "void smp_generic_take_timebase(void)\n{\n\tint cmd;\n\tu64 tb;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twhile (!running)\n\t\tbarrier();\n\trmb();\n\n\tfor (;;) {\n\t\ttbsync->ack = 1;\n\t\twhile (!tbsync->handshake)\n\t\t\tbarrier();\n\t\trmb();\n\n\t\tcmd = tbsync->cmd;\n\t\ttb = tbsync->tb;\n\t\tmb();\n\t\ttbsync->ack = 0;\n\t\tif (cmd == kExit)\n\t\t\tbreak;\n\n\t\twhile (tbsync->handshake)\n\t\t\tbarrier();\n\t\tif (cmd == kSetAndTest)\n\t\t\tset_tb(tb >> 32, tb & 0xfffffffful);\n\t\tenter_contest(tbsync->mark, -1);\n\t}\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int\t\trunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_contest",
          "args": [
            "tbsync->mark",
            "-1"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "enter_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "38-42",
          "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tb",
          "args": [
            "tb >> 32",
            "tb & 0xfffffffful"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic volatile int\t\trunning;\n\nvoid smp_generic_take_timebase(void)\n{\n\tint cmd;\n\tu64 tb;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twhile (!running)\n\t\tbarrier();\n\trmb();\n\n\tfor (;;) {\n\t\ttbsync->ack = 1;\n\t\twhile (!tbsync->handshake)\n\t\t\tbarrier();\n\t\trmb();\n\n\t\tcmd = tbsync->cmd;\n\t\ttb = tbsync->tb;\n\t\tmb();\n\t\ttbsync->ack = 0;\n\t\tif (cmd == kExit)\n\t\t\tbreak;\n\n\t\twhile (tbsync->handshake)\n\t\t\tbarrier();\n\t\tif (cmd == kSetAndTest)\n\t\t\tset_tb(tb >> 32, tb & 0xfffffffful);\n\t\tenter_contest(tbsync->mark, -1);\n\t}\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "enter_contest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "38-42",
    "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
  }
]