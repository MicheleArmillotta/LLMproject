[
  {
    "function_name": "of_rescan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "401-404",
    "snippet": "void of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__of_scan_bus",
          "args": [
            "node",
            "bus",
            "1"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "350-380",
          "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}"
  },
  {
    "function_name": "of_scan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "387-390",
    "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__of_scan_bus",
          "args": [
            "node",
            "bus",
            "0"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "350-380",
          "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
  },
  {
    "function_name": "__of_scan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "350-380",
    "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_scan_pci_bridge",
          "args": [
            "dev"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_pci_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "205-300",
          "snippet": "void of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%s)\\n\", node->full_name);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %s\\n\",\n\t\t\t       node->full_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%s)\\n\", node->full_name);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %s\\n\",\n\t\t\t       node->full_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_is_bridge",
          "args": [
            "dev"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_bus_devices",
          "args": [
            "bus"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1011-1027",
          "snippet": "void pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_setup_bus_self",
          "args": [
            "bus"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "951-969",
          "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    dev header type: %x\\n\"",
            "dev->hdr_type"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_pci_dev",
          "args": [
            "bus",
            "child"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_pci_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "303-342",
          "snippet": "static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %s\\n\", dn->full_name);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %s\\n\", dn->full_name);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_child_of_node",
          "args": [
            "node",
            "child"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"of_scan_bus(%s) bus no %d...\\n\"",
            "node->full_name",
            "bus->number"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%s) bus no %d...\\n\",\n\t\t node->full_name, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\tpcibios_setup_bus_devices(bus);\n\n\t/* Now scan child busses */\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (pci_is_bridge(dev)) {\n\t\t\tof_scan_pci_bridge(dev);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "of_scan_pci_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "303-342",
    "snippet": "static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %s\\n\", dn->full_name);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  dev header type: %x\\n\"",
            "dev->hdr_type"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_create_pci_dev",
          "args": [
            "dn",
            "bus",
            "devfn"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "of_create_pci_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "124-194",
          "snippet": "struct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tconst char *type;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\ttype = of_get_property(node, \"device_type\", NULL);\n\tif (type == NULL)\n\t\ttype = \"\";\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn, type);\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (!strcmp(type, \"pci\") || !strcmp(type, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (!strcmp(type, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = NO_IRQ;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\t/* Setup MSI caps & disable MSI/MSI-X interrupts */\n\tpci_msi_setup_pci_dev(dev);\n\n\treturn dev;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstruct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tconst char *type;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\ttype = of_get_property(node, \"device_type\", NULL);\n\tif (type == NULL)\n\t\ttype = \"\";\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn, type);\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (!strcmp(type, \"pci\") || !strcmp(type, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (!strcmp(type, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = NO_IRQ;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\t/* Setup MSI caps & disable MSI/MSI-X interrupts */\n\tpci_msi_setup_pci_dev(dev);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_slot",
          "args": [
            "bus",
            "devfn"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "reg",
            "1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"reg\"",
            "&reglen"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "dn"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  * %s\\n\"",
            "dn->full_name"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "PCI_DN(dn)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %s\\n\", dn->full_name);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}"
  },
  {
    "function_name": "of_scan_pci_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "205-300",
    "snippet": "void of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%s)\\n\", node->full_name);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %s\\n\",\n\t\t\t       node->full_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_scan_child_bus",
          "args": [
            "bus"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_bus",
          "args": [
            "node",
            "bus"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "387-390",
          "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    probe mode: %d\\n\"",
            "mode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    bus name: %s\\n\"",
            "bus->name"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "bus->name",
            "\"PCI Bus %04x:%02x\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_bus_to_resource",
          "args": [
            "dev->bus",
            "res",
            "&region"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&ranges[1]",
            "2"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %s\\n\"",
            "node->full_name"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&ranges[6]",
            "2"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_parse_of_flags",
          "args": [
            "of_read_number(ranges, 1)",
            "1"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "pci_parse_of_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "41-64",
          "snippet": "static unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "ranges",
            "1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_insert_busn_res",
          "args": [
            "bus",
            "of_read_number(busrange, 1)",
            "of_read_number(busrange+1, 1)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange+1",
            "1"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_new_bus",
          "args": [
            "dev->bus",
            "dev",
            "of_read_number(busrange, 1)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_bus",
          "args": [
            "pci_domain_nr(dev->bus)",
            "of_read_number(busrange, 1)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"ranges\"",
            "&len"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"bus-range\"",
            "&len"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"of_scan_pci_bridge(%s)\\n\"",
            "node->full_name"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%s)\\n\", node->full_name);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %s\\n\",\n\t\t       node->full_name);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %s\\n\",\n\t\t\t       node->full_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %s\\n\", node->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}"
  },
  {
    "function_name": "of_create_pci_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "124-194",
    "snippet": "struct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tconst char *type;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\ttype = of_get_property(node, \"device_type\", NULL);\n\tif (type == NULL)\n\t\ttype = \"\";\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn, type);\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (!strcmp(type, \"pci\") || !strcmp(type, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (!strcmp(type, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = NO_IRQ;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\t/* Setup MSI caps & disable MSI/MSI-X interrupts */\n\tpci_msi_setup_pci_dev(dev);\n\n\treturn dev;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_msi_setup_pci_dev",
          "args": [
            "dev"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_add",
          "args": [
            "dev",
            "bus"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    adding to system ...\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_pci_parse_addrs",
          "args": [
            "node",
            "dev"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "of_pci_parse_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "74-116",
          "snippet": "static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs)\n\t\treturn;\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs)\n\t\treturn;\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"cardbus\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pcie_hotplug_bridge",
          "args": [
            "dev"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"pciex\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"pci\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_fixup_device",
          "args": [
            "pci_fixup_early",
            "dev"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    revision: 0x%x\\n\"",
            "dev->revision"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    class: 0x%x\\n\"",
            "dev->class"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "node",
            "\"revision-id\"",
            "0"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "25-34",
          "snippet": "static u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&dev->dev",
            "\"%04x:%02x:%02x.%d\"",
            "pci_domain_nr(bus)",
            "dev->bus->number",
            "PCI_SLOT(devfn)",
            "PCI_FUNC(devfn)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "devfn"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "devfn"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_cfg_space_size",
          "args": [
            "dev"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_assign_slot",
          "args": [
            "dev"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pcie_port_type",
          "args": [
            "dev"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "node"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    create device, devfn: %x, type: %s\\n\"",
            "devfn",
            "type"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"device_type\"",
            "NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_alloc_dev",
          "args": [
            "bus"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstruct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tconst char *type;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\ttype = of_get_property(node, \"device_type\", NULL);\n\tif (type == NULL)\n\t\ttype = \"\";\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn, type);\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (!strcmp(type, \"pci\") || !strcmp(type, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (!strcmp(type, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = NO_IRQ;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\t/* Setup MSI caps & disable MSI/MSI-X interrupts */\n\tpci_msi_setup_pci_dev(dev);\n\n\treturn dev;\n}"
  },
  {
    "function_name": "of_pci_parse_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "74-116",
    "snippet": "static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs)\n\t\treturn;\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_bus_to_resource",
          "args": [
            "dev->bus",
            "res",
            "&region"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\"",
            "i"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  base: %llx, size: %llx, i: %x\\n\"",
            "(unsigned long long)base",
            "(unsigned long long)size",
            "i"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "addrs",
            "1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&addrs[3]",
            "2"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&addrs[1]",
            "2"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_parse_of_flags",
          "args": [
            "of_read_number(addrs, 1)",
            "0"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "pci_parse_of_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "41-64",
          "snippet": "static unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "addrs",
            "1"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    parse addresses (%d bytes) @ %p\\n\"",
            "proplen",
            "addrs"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"assigned-addresses\"",
            "&proplen"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs)\n\t\treturn;\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}"
  },
  {
    "function_name": "pci_parse_of_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "41-64",
    "snippet": "static unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0;\n\n\tif (addr0 & 0x02000000) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\t\tflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\t\tif (addr0 & 0x40000000)\n\t\t\tflags |= IORESOURCE_PREFETCH\n\t\t\t\t | PCI_BASE_ADDRESS_MEM_PREFETCH;\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & 0xff) == 0x30)\n\t\t\tflags |= IORESOURCE_READONLY;\n\t} else if (addr0 & 0x01000000)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\treturn flags;\n}"
  },
  {
    "function_name": "get_int_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "25-34",
    "snippet": "static u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop",
            "1"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "name",
            "&len"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}"
  }
]