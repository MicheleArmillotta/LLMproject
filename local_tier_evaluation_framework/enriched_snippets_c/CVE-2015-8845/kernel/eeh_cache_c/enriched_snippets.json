[
  {
    "function_name": "eeh_addr_cache_build",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "280-308",
    "snippet": "void eeh_addr_cache_build(void)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *dev = NULL;\n\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n\n\tfor_each_pci_dev(dev) {\n\t\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\t\tif (!pdn)\n\t\t\tcontinue;\n\n\t\tedev = pdn_to_eeh_dev(pdn);\n\t\tif (!edev)\n\t\t\tcontinue;\n\n\t\tdev->dev.archdata.edev = edev;\n\t\tedev->pdev = dev;\n\n\t\teeh_addr_cache_insert_dev(dev);\n\t\teeh_sysfs_add_device(dev);\n\t}\n\n#ifdef DEBUG\n\t/* Verify tree built up above, echo back the list of addrs. */\n\teeh_addr_cache_print(&pci_io_addr_cache_root);\n#endif\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_addr_cache_print",
          "args": [
            "&pci_io_addr_cache_root"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "108-123",
          "snippet": "static void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_debug(\"PCI: %s addr range %d [%lx-%lx]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       piar->addr_lo, piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_debug(\"PCI: %s addr range %d [%lx-%lx]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       piar->addr_lo, piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_sysfs_add_device",
          "args": [
            "dev"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "94-114",
          "snippet": "void eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_insert_dev",
          "args": [
            "dev"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_insert_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "221-232",
          "snippet": "void eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_pdn_by_devfn",
          "args": [
            "dev->bus",
            "dev->devfn"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pci_io_addr_cache_root.piar_lock"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_build(void)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *dev = NULL;\n\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n\n\tfor_each_pci_dev(dev) {\n\t\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\t\tif (!pdn)\n\t\t\tcontinue;\n\n\t\tedev = pdn_to_eeh_dev(pdn);\n\t\tif (!edev)\n\t\t\tcontinue;\n\n\t\tdev->dev.archdata.edev = edev;\n\t\tedev->pdev = dev;\n\n\t\teeh_addr_cache_insert_dev(dev);\n\t\teeh_sysfs_add_device(dev);\n\t}\n\n#ifdef DEBUG\n\t/* Verify tree built up above, echo back the list of addrs. */\n\teeh_addr_cache_print(&pci_io_addr_cache_root);\n#endif\n}"
  },
  {
    "function_name": "eeh_addr_cache_rmv_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "262-269",
    "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_rmv_dev",
          "args": [
            "dev"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "234-251",
          "snippet": "static inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
  },
  {
    "function_name": "__eeh_addr_cache_rmv_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "234-251",
    "snippet": "static inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "piar"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_insert_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "221-232",
    "snippet": "void eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_insert_dev",
          "args": [
            "dev"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_insert_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "172-211",
          "snippet": "static void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tif (!pdn) {\n\t\tpr_warn(\"PCI: no pci dn found for dev=%s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/* Walk resources on this device, poke them into the tree */\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tif (!pdn) {\n\t\tpr_warn(\"PCI: no pci dn found for dev=%s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/* Walk resources on this device, poke them into the tree */\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\t/* Ignore PCI bridges */\n\tif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\n\t\treturn;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
  },
  {
    "function_name": "__eeh_addr_cache_insert_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "172-211",
    "snippet": "static void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tif (!pdn) {\n\t\tpr_warn(\"PCI: no pci dn found for dev=%s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/* Walk resources on this device, poke them into the tree */\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_addr_cache_insert",
          "args": [
            "dev",
            "start",
            "end",
            "flags"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "127-170",
          "snippet": "static struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n#ifdef DEBUG\n\tpr_debug(\"PIAR: insert range=[%lx:%lx] dev=%s\\n\",\n\t                  alo, ahi, pci_name(dev));\n#endif\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n#ifdef DEBUG\n\tpr_debug(\"PIAR: insert range=[%lx:%lx] dev=%s\\n\",\n\t                  alo, ahi, pci_name(dev));\n#endif\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_resource_flags",
          "args": [
            "dev",
            "i"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_resource_end",
          "args": [
            "dev",
            "i"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_resource_start",
          "args": [
            "dev",
            "i"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "&dev->dev",
            "\"EEH: Skip building address cache\\n\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PCI: no EEH dev found for %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PCI: no pci dn found for dev=%s\\n\"",
            "pci_name(dev)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_pdn_by_devfn",
          "args": [
            "dev->bus",
            "dev->devfn"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct pci_dn *pdn;\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tpdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\n\tif (!pdn) {\n\t\tpr_warn(\"PCI: no pci dn found for dev=%s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\tedev = pdn_to_eeh_dev(pdn);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/* Walk resources on this device, poke them into the tree */\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "127-170",
    "snippet": "static struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n#ifdef DEBUG\n\tpr_debug(\"PIAR: insert range=[%lx:%lx] dev=%s\\n\",\n\t                  alo, ahi, pci_name(dev));\n#endif\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&piar->rb_node",
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&piar->rb_node",
            "parent",
            "p"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PIAR: insert range=[%lx:%lx] dev=%s\\n\"",
            "alo",
            "ahi",
            "pci_name(dev)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pci_io_addr_range)",
            "GFP_ATOMIC"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PIAR: overlapping address range\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n#ifdef DEBUG\n\tpr_debug(\"PIAR: insert range=[%lx:%lx] dev=%s\\n\",\n\t                  alo, ahi, pci_name(dev));\n#endif\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}"
  },
  {
    "function_name": "eeh_addr_cache_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "108-123",
    "snippet": "static void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_debug(\"PCI: %s addr range %d [%lx-%lx]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       piar->addr_lo, piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: %s addr range %d [%lx-%lx]: %s\\n\"",
            "(piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\"",
            "cnt",
            "piar->addr_lo",
            "piar->addr_hi",
            "pci_name(piar->pcidev)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "piar->pcidev"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cache->rb_root"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_debug(\"PCI: %s addr range %d [%lx-%lx]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       piar->addr_lo, piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_get_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "92-101",
    "snippet": "struct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_get_device",
          "args": [
            "addr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_get_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "63-80",
          "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstruct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}"
  },
  {
    "function_name": "__eeh_addr_cache_get_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "63-80",
    "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
  }
]