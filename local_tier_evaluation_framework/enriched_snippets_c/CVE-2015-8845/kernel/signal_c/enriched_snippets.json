[
  {
    "function_name": "get_tm_stackpointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
    "lines": "165-197",
    "snippet": "unsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_TRANSACTIONAL",
          "args": [
            "regs->msr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_SIGNAL"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "565-569",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}"
  },
  {
    "function_name": "do_notify_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
    "lines": "147-163",
    "snippet": "void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n\n\tuser_enter();\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_notify_resume",
          "args": [
            "regs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_NOTIFY_RESUME"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_signal",
          "args": [
            "regs"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "do_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "102-145",
          "snippet": "static void do_signal(struct pt_regs *regs)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig;\n\tint ret;\n\tint is32 = is_32bit_task();\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tregs->trap = 0;\n\t\treturn;               /* no signals delivered */\n\t}\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (current->thread.hw_brk.address &&\n\t\tcurrent->thread.hw_brk.type)\n\t\t__set_breakpoint(&current->thread.hw_brk);\n#endif\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(current, regs);\n\n\tif (is32) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, regs);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, regs);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, regs);\n\t}\n\n\tregs->trap = 0;\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void do_signal(struct pt_regs *regs)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig;\n\tint ret;\n\tint is32 = is_32bit_task();\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tregs->trap = 0;\n\t\treturn;               /* no signals delivered */\n\t}\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (current->thread.hw_brk.address &&\n\t\tcurrent->thread.hw_brk.type)\n\t\t__set_breakpoint(&current->thread.hw_brk);\n#endif\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(current, regs);\n\n\tif (is32) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, regs);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, regs);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, regs);\n\t}\n\n\tregs->trap = 0;\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_notify_resume",
          "args": [
            "regs"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n\n\tuser_enter();\n}"
  },
  {
    "function_name": "do_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
    "lines": "102-145",
    "snippet": "static void do_signal(struct pt_regs *regs)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig;\n\tint ret;\n\tint is32 = is_32bit_task();\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tregs->trap = 0;\n\t\treturn;               /* no signals delivered */\n\t}\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (current->thread.hw_brk.address &&\n\t\tcurrent->thread.hw_brk.type)\n\t\t__set_breakpoint(&current->thread.hw_brk);\n#endif\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(current, regs);\n\n\tif (is32) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, regs);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, regs);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, regs);\n\t}\n\n\tregs->trap = 0;\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_setup_done",
          "args": [
            "ret",
            "&ksig",
            "test_thread_flag(TIF_SINGLESTEP)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_rt_signal64",
          "args": [
            "&ksig",
            "oldset",
            "regs"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rt_signal64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.h",
          "lines": "50-54",
          "snippet": "static inline int handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\t\t\t     struct pt_regs *regs)\n{\n\treturn -EFAULT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\t\t\t     struct pt_regs *regs)\n{\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_signal32",
          "args": [
            "&ksig",
            "oldset",
            "regs"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "handle_signal32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "1417-1494",
          "snippet": "int handle_signal32(struct ksignal *ksig, sigset_t *oldset, struct pt_regs *regs)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
            "#define mcontext\tmcontext32",
            "#define sigcontext\tsigcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nint handle_signal32(struct ksignal *ksig, sigset_t *oldset, struct pt_regs *regs)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_rt_signal32",
          "args": [
            "&ksig",
            "oldset",
            "regs"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rt_signal32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "991-1079",
          "snippet": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define copy_siginfo_to_user\tcopy_siginfo_to_user32",
            "#define tramp\tmc_pad",
            "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
            "#define __save_altstack __compat_save_altstack",
            "#define ucontext\tucontext32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define copy_siginfo_to_user\tcopy_siginfo_to_user32\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define __save_altstack __compat_save_altstack\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nint handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_change_pc",
          "args": [
            "current",
            "regs"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "thread_change_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "192-203",
          "snippet": "void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\n\tif (likely(!tsk->thread.last_hit_ubp))\n\t\treturn;\n\n\tinfo = counter_arch_bp(tsk->thread.last_hit_ubp);\n\tregs->msr &= ~MSR_SE;\n\t__set_breakpoint(info);\n\ttsk->thread.last_hit_ubp = NULL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\n\tif (likely(!tsk->thread.last_hit_ubp))\n\t\treturn;\n\n\tinfo = counter_arch_bp(tsk->thread.last_hit_ubp);\n\tregs->msr &= ~MSR_SE;\n\t__set_breakpoint(info);\n\ttsk->thread.last_hit_ubp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "&current->thread.hw_brk"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_saved_sigmask",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_syscall_restart",
          "args": [
            "regs",
            "&ksig.ka",
            "ksig.sig > 0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "check_syscall_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "51-100",
          "snippet": "static void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (TRAP(regs) != 0x0C00)\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (!(regs->ccr & 0x10000000))\n\t\treturn;\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tregs->result = -EINTR;\n\t\tregs->gpr[3] = EINTR;\n\t\tregs->ccr |= 0x10000000;\n\t}\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (TRAP(regs) != 0x0C00)\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (!(regs->ccr & 0x10000000))\n\t\treturn;\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tregs->result = -EINTR;\n\t\tregs->gpr[3] = EINTR;\n\t\tregs->ccr |= 0x10000000;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_signal",
          "args": [
            "&ksig"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask_to_save",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void do_signal(struct pt_regs *regs)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig;\n\tint ret;\n\tint is32 = is_32bit_task();\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tregs->trap = 0;\n\t\treturn;               /* no signals delivered */\n\t}\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (current->thread.hw_brk.address &&\n\t\tcurrent->thread.hw_brk.type)\n\t\t__set_breakpoint(&current->thread.hw_brk);\n#endif\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(current, regs);\n\n\tif (is32) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, regs);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, regs);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, regs);\n\t}\n\n\tregs->trap = 0;\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}"
  },
  {
    "function_name": "check_syscall_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
    "lines": "51-100",
    "snippet": "static void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (TRAP(regs) != 0x0C00)\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (!(regs->ccr & 0x10000000))\n\t\treturn;\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tregs->result = -EINTR;\n\t\tregs->gpr[3] = EINTR;\n\t\tregs->ccr |= 0x10000000;\n\t}\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (TRAP(regs) != 0x0C00)\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (!(regs->ccr & 0x10000000))\n\t\treturn;\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tregs->result = -EINTR;\n\t\tregs->gpr[3] = EINTR;\n\t\tregs->ccr |= 0x10000000;\n\t}\n}"
  },
  {
    "function_name": "get_sigframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
    "lines": "34-49",
    "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "(void __user *)newsp",
            "oldsp - newsp"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigsp",
          "args": [
            "oldsp",
            "ksig"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clean_sp",
          "args": [
            "sp",
            "is_32"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
  }
]