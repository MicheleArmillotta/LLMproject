[
  {
    "function_name": "tau_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "267-270",
    "snippet": "int tau_interrupts(unsigned long cpu)\n{\n\treturn (tau[cpu].interrupts);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nint tau_interrupts(unsigned long cpu)\n{\n\treturn (tau[cpu].interrupts);\n}"
  },
  {
    "function_name": "cpu_temp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "262-265",
    "snippet": "int cpu_temp(unsigned long cpu)\n{\n\treturn ((tau[cpu].high + tau[cpu].low) / 2);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nint cpu_temp(unsigned long cpu)\n{\n\treturn ((tau[cpu].high + tau[cpu].low) / 2);\n}"
  },
  {
    "function_name": "cpu_temp_both",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "257-260",
    "snippet": "u32 cpu_temp_both(unsigned long cpu)\n{\n\treturn ((tau[cpu].high << 16) | tau[cpu].low);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nu32 cpu_temp_both(unsigned long cpu)\n{\n\treturn ((tau[cpu].high << 16) | tau[cpu].low);\n}"
  },
  {
    "function_name": "TAU_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "219-249",
    "snippet": "int __init TAU_init(void)\n{\n\t/* We assume in SMP that if one CPU has TAU support, they\n\t * all have it --BenH\n\t */\n\tif (!cpu_has_feature(CPU_FTR_TAU)) {\n\t\tprintk(\"Thermal assist unit not available\\n\");\n\t\ttau_initialized = 0;\n\t\treturn 1;\n\t}\n\n\n\t/* first, set up the window shrinking timer */\n\tinit_timer(&tau_timer);\n\ttau_timer.function = tau_timeout_smp;\n\ttau_timer.expires = jiffies + shrink_timer;\n\tadd_timer(&tau_timer);\n\n\ton_each_cpu(TAU_init_smp, NULL, 0);\n\n\tprintk(\"Thermal assist unit \");\n#ifdef CONFIG_TAU_INT\n\tprintk(\"using interrupts, \");\n#else\n\tprintk(\"using timers, \");\n#endif\n\tprintk(\"shrink_timer: %d jiffies\\n\", shrink_timer);\n\ttau_initialized = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define shrink_timer\t2*HZ\t/* period between shrinking the window */"
    ],
    "globals_used": [
      "struct timer_list tau_timer;",
      "int tau_initialized = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"shrink_timer: %d jiffies\\n\"",
            "shrink_timer"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"using timers, \""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"using interrupts, \""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Thermal assist unit \""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "TAU_init_smp",
            "NULL",
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "&tau_timer"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_timer",
          "args": [
            "&tau_timer"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Thermal assist unit not available\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TAU"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define shrink_timer\t2*HZ\t/* period between shrinking the window */\n\nstruct timer_list tau_timer;\nint tau_initialized = 0;\n\nint __init TAU_init(void)\n{\n\t/* We assume in SMP that if one CPU has TAU support, they\n\t * all have it --BenH\n\t */\n\tif (!cpu_has_feature(CPU_FTR_TAU)) {\n\t\tprintk(\"Thermal assist unit not available\\n\");\n\t\ttau_initialized = 0;\n\t\treturn 1;\n\t}\n\n\n\t/* first, set up the window shrinking timer */\n\tinit_timer(&tau_timer);\n\ttau_timer.function = tau_timeout_smp;\n\ttau_timer.expires = jiffies + shrink_timer;\n\tadd_timer(&tau_timer);\n\n\ton_each_cpu(TAU_init_smp, NULL, 0);\n\n\tprintk(\"Thermal assist unit \");\n#ifdef CONFIG_TAU_INT\n\tprintk(\"using interrupts, \");\n#else\n\tprintk(\"using timers, \");\n#endif\n\tprintk(\"shrink_timer: %d jiffies\\n\", shrink_timer);\n\ttau_initialized = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "TAU_init_smp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "207-217",
    "snippet": "void __init TAU_init_smp(void * info)\n{\n\tunsigned long cpu = smp_processor_id();\n\n\t/* set these to a reasonable value and let the timer shrink the\n\t * window */\n\ttau[cpu].low = 5;\n\ttau[cpu].high = 120;\n\n\tset_thresholds(cpu);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thresholds",
          "args": [
            "cpu"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "set_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "52-70",
          "snippet": "void set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid __init TAU_init_smp(void * info)\n{\n\tunsigned long cpu = smp_processor_id();\n\n\t/* set these to a reasonable value and let the timer shrink the\n\t * window */\n\ttau[cpu].low = 5;\n\ttau[cpu].high = 120;\n\n\tset_thresholds(cpu);\n}"
  },
  {
    "function_name": "tau_timeout_smp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "190-196",
    "snippet": "static void tau_timeout_smp(unsigned long unused)\n{\n\n\t/* schedule ourselves to be run again */\n\tmod_timer(&tau_timer, jiffies + shrink_timer) ;\n\ton_each_cpu(tau_timeout, NULL, 0);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define shrink_timer\t2*HZ\t/* period between shrinking the window */"
    ],
    "globals_used": [
      "struct timer_list tau_timer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "tau_timeout",
            "NULL",
            "0"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&tau_timer",
            "jiffies + shrink_timer"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define shrink_timer\t2*HZ\t/* period between shrinking the window */\n\nstruct timer_list tau_timer;\n\nstatic void tau_timeout_smp(unsigned long unused)\n{\n\n\t/* schedule ourselves to be run again */\n\tmod_timer(&tau_timer, jiffies + shrink_timer) ;\n\ton_each_cpu(tau_timeout, NULL, 0);\n}"
  },
  {
    "function_name": "tau_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "136-188",
    "snippet": "static void tau_timeout(void * info)\n{\n\tint cpu;\n\tunsigned long flags;\n\tint size;\n\tint shrink;\n\n\t/* disabling interrupts *should* be okay */\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\n#ifndef CONFIG_TAU_INT\n\tTAUupdate(cpu);\n#endif\n\n\tsize = tau[cpu].high - tau[cpu].low;\n\tif (size > min_window && ! tau[cpu].grew) {\n\t\t/* do an exponential shrink of half the amount currently over size */\n\t\tshrink = (2 + size - min_window) / 4;\n\t\tif (shrink) {\n\t\t\ttau[cpu].low += shrink;\n\t\t\ttau[cpu].high -= shrink;\n\t\t} else { /* size must have been min_window + 1 */\n\t\t\ttau[cpu].low += 1;\n#if 1 /* debug */\n\t\t\tif ((tau[cpu].high - tau[cpu].low) != min_window){\n\t\t\t\tprintk(KERN_ERR \"temp.c: line %d, logic error\\n\", __LINE__);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\ttau[cpu].grew = 0;\n\n\tset_thresholds(cpu);\n\n\t/*\n\t * Do the enable every time, since otherwise a bunch of (relatively)\n\t * complex sleep code needs to be added. One mtspr every time\n\t * tau_timeout is called is probably not a big deal.\n\t *\n\t * Enable thermal sensor and set up sample interval timer\n\t * need 20 us to do the compare.. until a nice 'cpu_speed' function\n\t * call is implemented, just assume a 500 mhz clock. It doesn't really\n\t * matter if we take too long for a compare since it's all interrupt\n\t * driven anyway.\n\t *\n\t * use a extra long time.. (60 us @ 500 mhz)\n\t */\n\tmtspr(SPRN_THRM3, THRM3_SITV(500*60) | THRM3_E);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define min_window\t2\t/* minimum window size, degrees C */"
    ],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM3",
            "THRM3_SITV(500*60) | THRM3_E"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM3_SITV",
          "args": [
            "500*60"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thresholds",
          "args": [
            "cpu"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "set_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "52-70",
          "snippet": "void set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"temp.c: line %d, logic error\\n\"",
            "__LINE__"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAUupdate",
          "args": [
            "cpu"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "TAUupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "72-115",
          "snippet": "void TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define window_expand\t\t1\t/* expand the window by this much */",
            "#define step_size\t\t2\t/* step size when temp goes out of range */"
          ],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define min_window\t2\t/* minimum window size, degrees C */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nstatic void tau_timeout(void * info)\n{\n\tint cpu;\n\tunsigned long flags;\n\tint size;\n\tint shrink;\n\n\t/* disabling interrupts *should* be okay */\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\n#ifndef CONFIG_TAU_INT\n\tTAUupdate(cpu);\n#endif\n\n\tsize = tau[cpu].high - tau[cpu].low;\n\tif (size > min_window && ! tau[cpu].grew) {\n\t\t/* do an exponential shrink of half the amount currently over size */\n\t\tshrink = (2 + size - min_window) / 4;\n\t\tif (shrink) {\n\t\t\ttau[cpu].low += shrink;\n\t\t\ttau[cpu].high -= shrink;\n\t\t} else { /* size must have been min_window + 1 */\n\t\t\ttau[cpu].low += 1;\n#if 1 /* debug */\n\t\t\tif ((tau[cpu].high - tau[cpu].low) != min_window){\n\t\t\t\tprintk(KERN_ERR \"temp.c: line %d, logic error\\n\", __LINE__);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\ttau[cpu].grew = 0;\n\n\tset_thresholds(cpu);\n\n\t/*\n\t * Do the enable every time, since otherwise a bunch of (relatively)\n\t * complex sleep code needs to be added. One mtspr every time\n\t * tau_timeout is called is probably not a big deal.\n\t *\n\t * Enable thermal sensor and set up sample interval timer\n\t * need 20 us to do the compare.. until a nice 'cpu_speed' function\n\t * call is implemented, just assume a 500 mhz clock. It doesn't really\n\t * matter if we take too long for a compare since it's all interrupt\n\t * driven anyway.\n\t *\n\t * use a extra long time.. (60 us @ 500 mhz)\n\t */\n\tmtspr(SPRN_THRM3, THRM3_SITV(500*60) | THRM3_E);\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "TAUException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "123-133",
    "snippet": "void TAUException(struct pt_regs * regs)\n{\n\tint cpu = smp_processor_id();\n\n\tirq_enter();\n\ttau[cpu].interrupts++;\n\n\tTAUupdate(cpu);\n\n\tirq_exit();\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAUupdate",
          "args": [
            "cpu"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "TAUupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "72-115",
          "snippet": "void TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define window_expand\t\t1\t/* expand the window by this much */",
            "#define step_size\t\t2\t/* step size when temp goes out of range */"
          ],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid TAUException(struct pt_regs * regs)\n{\n\tint cpu = smp_processor_id();\n\n\tirq_enter();\n\ttau[cpu].interrupts++;\n\n\tTAUupdate(cpu);\n\n\tirq_exit();\n}"
  },
  {
    "function_name": "TAUupdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "72-115",
    "snippet": "void TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define window_expand\t\t1\t/* expand the window by this much */",
      "#define step_size\t\t2\t/* step size when temp goes out of range */"
    ],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thresholds",
          "args": [
            "cpu"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "set_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "52-70",
          "snippet": "void set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"grew = %d\\n\"",
            "tau[cpu].grew"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"high threshold crossed \""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_THRM2"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"low threshold crossed \""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_THRM1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"TAUupdate \""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid TAUupdate(int cpu)\n{\n\tunsigned thrm;\n\n#ifdef DEBUG\n\tprintk(\"TAUupdate \");\n#endif\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed low threshold */\n\t\t\tif (tau[cpu].low >= step_size){\n\t\t\t\ttau[cpu].low -= step_size;\n\t\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"low threshold crossed \");\n#endif\n\t\t}\n\t}\n\tif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){ /* is valid? */\n\t\tif(thrm & THRM1_TIN){ /* crossed high threshold */\n\t\t\tif (tau[cpu].high <= 127-step_size){\n\t\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\t\ttau[cpu].high += step_size;\n\t\t\t}\n\t\t\ttau[cpu].grew = 1;\n#ifdef DEBUG\n\t\t\tprintk(\"high threshold crossed \");\n#endif\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tprintk(\"grew = %d\\n\", tau[cpu].grew);\n#endif\n\n#ifndef CONFIG_TAU_INT /* tau_timeout will do this if not using interrupts */\n\tset_thresholds(cpu);\n#endif\n\n}"
  },
  {
    "function_name": "set_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "52-70",
    "snippet": "void set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM2",
            "THRM1_THRES(tau[cpu].high) | THRM1_V"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].high"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM1",
            "THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].low"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM2",
            "THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].high"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM1",
            "THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].low"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid set_thresholds(unsigned long cpu)\n{\n#ifdef CONFIG_TAU_INT\n\t/*\n\t * setup THRM1,\n\t * threshold, valid bit, enable interrupts, interrupt when below threshold\n\t */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\n\n\t/* setup THRM2,\n\t * threshold, valid bit, enable interrupts, interrupt when above threshold\n\t */\n\tmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\n#else\n\t/* same thing but don't enable interrupts */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\n#endif\n}"
  }
]