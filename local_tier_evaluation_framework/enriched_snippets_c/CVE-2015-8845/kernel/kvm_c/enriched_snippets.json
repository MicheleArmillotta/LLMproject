[
  {
    "function_name": "kvm_guest_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "719-739",
    "snippet": "static int __init kvm_guest_init(void)\n{\n\tif (!kvm_para_available())\n\t\tgoto free_tmp;\n\n\tif (!epapr_paravirt_enabled)\n\t\tgoto free_tmp;\n\n\tif (kvm_para_has_feature(KVM_FEATURE_MAGIC_PAGE))\n\t\tkvm_use_magic_page();\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Enable napping */\n\tpowersave_nap = 1;\n#endif\n\nfree_tmp:\n\tkvm_free_tmp();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_free_tmp",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "713-717",
          "snippet": "static __init void kvm_free_tmp(void)\n{\n\tfree_reserved_area(&kvm_tmp[kvm_tmp_index],\n\t\t\t   &kvm_tmp[ARRAY_SIZE(kvm_tmp)], -1, NULL);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic __init void kvm_free_tmp(void)\n{\n\tfree_reserved_area(&kvm_tmp[kvm_tmp_index],\n\t\t\t   &kvm_tmp[ARRAY_SIZE(kvm_tmp)], -1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_use_magic_page",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_use_magic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "671-711",
          "snippet": "static void kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 tmp;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (__get_user(tmp, (u32*)KVM_MAGIC_PAGE)) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAGIC_PAGE\t\t(-4096L)"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_template_start[];",
            "extern u32 kvm_template_end[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_template_start[];\nextern u32 kvm_template_end[];\n\nstatic void kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 tmp;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (__get_user(tmp, (u32*)KVM_MAGIC_PAGE)) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_para_has_feature",
          "args": [
            "KVM_FEATURE_MAGIC_PAGE"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_para_available",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic int __init kvm_guest_init(void)\n{\n\tif (!kvm_para_available())\n\t\tgoto free_tmp;\n\n\tif (!epapr_paravirt_enabled)\n\t\tgoto free_tmp;\n\n\tif (kvm_para_has_feature(KVM_FEATURE_MAGIC_PAGE))\n\t\tkvm_use_magic_page();\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Enable napping */\n\tpowersave_nap = 1;\n#endif\n\nfree_tmp:\n\tkvm_free_tmp();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_free_tmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "713-717",
    "snippet": "static __init void kvm_free_tmp(void)\n{\n\tfree_reserved_area(&kvm_tmp[kvm_tmp_index],\n\t\t\t   &kvm_tmp[ARRAY_SIZE(kvm_tmp)], -1, NULL);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char kvm_tmp[1024 * 1024];",
      "static int kvm_tmp_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_area",
          "args": [
            "&kvm_tmp[kvm_tmp_index]",
            "&kvm_tmp[ARRAY_SIZE(kvm_tmp)]",
            "-1",
            "NULL"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kvm_tmp"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic __init void kvm_free_tmp(void)\n{\n\tfree_reserved_area(&kvm_tmp[kvm_tmp_index],\n\t\t\t   &kvm_tmp[ARRAY_SIZE(kvm_tmp)], -1, NULL);\n}"
  },
  {
    "function_name": "kvm_use_magic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "671-711",
    "snippet": "static void kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 tmp;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (__get_user(tmp, (u32*)KVM_MAGIC_PAGE)) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAGIC_PAGE\t\t(-4096L)"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_template_start[];",
      "extern u32 kvm_template_end[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"KVM: Live patching for a fast VM %s\\n\"",
            "kvm_patching_worked ? \"worked\" : \"failed\""
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_ins",
          "args": [
            "p",
            "features"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_ins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "427-666",
          "snippet": "static void kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_MTSRIN\t\t0x7c0001e4",
            "#define KVM_INST_WRTEEI_1\t0x7c008146",
            "#define KVM_INST_WRTEEI_0\t0x7c000146",
            "#define KVM_INST_WRTEE\t\t0x7c000106",
            "#define KVM_INST_MTMSR\t\t0x7c000124",
            "#define KVM_INST_MTMSRD_L1\t0x7c010164",
            "#define KVM_INST_MTMSRD_L0\t0x7c000164",
            "#define KVM_INST_TLBSYNC\t0x7c00046c",
            "#define KVM_INST_MFMSR\t\t0x7c0000a6",
            "#define KVM_MASK_RB\t\t0x0000f800",
            "#define KVM_MASK_RT\t\t0x03e00000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_MTSRIN\t\t0x7c0001e4\n#define KVM_INST_WRTEEI_1\t0x7c008146\n#define KVM_INST_WRTEEI_0\t0x7c000146\n#define KVM_INST_WRTEE\t\t0x7c000106\n#define KVM_INST_MTMSR\t\t0x7c000124\n#define KVM_INST_MTMSRD_L1\t0x7c010164\n#define KVM_INST_MTMSRD_L0\t0x7c000164\n#define KVM_INST_TLBSYNC\t0x7c00046c\n#define KVM_INST_MFMSR\t\t0x7c0000a6\n#define KVM_MASK_RB\t\t0x0000f800\n#define KVM_MASK_RT\t\t0x03e00000\n\nstatic void kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u32*)KVM_MAGIC_PAGE"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "kvm_map_magic_page",
            "&features",
            "1"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_template_start[];\nextern u32 kvm_template_end[];\n\nstatic void kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 tmp;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (__get_user(tmp, (u32*)KVM_MAGIC_PAGE)) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}"
  },
  {
    "function_name": "kvm_check_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "427-666",
    "snippet": "static void kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_MTSRIN\t\t0x7c0001e4",
      "#define KVM_INST_WRTEEI_1\t0x7c008146",
      "#define KVM_INST_WRTEEI_0\t0x7c000146",
      "#define KVM_INST_WRTEE\t\t0x7c000106",
      "#define KVM_INST_MTMSR\t\t0x7c000124",
      "#define KVM_INST_MTMSRD_L1\t0x7c010164",
      "#define KVM_INST_MTMSRD_L0\t0x7c000164",
      "#define KVM_INST_TLBSYNC\t0x7c00046c",
      "#define KVM_INST_MFMSR\t\t0x7c0000a6",
      "#define KVM_MASK_RB\t\t0x0000f800",
      "#define KVM_MASK_RT\t\t0x03e00000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_wrtee",
          "args": [
            "inst",
            "0",
            "1"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_wrtee",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "278-329",
          "snippet": "static void kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_LI\t\t0x38000000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_LI\t\t0x38000000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_wrteei_0",
          "args": [
            "inst"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_wrteei_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "335-363",
          "snippet": "static void kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtsrin",
          "args": [
            "inst",
            "inst_rt",
            "inst_rb"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtsrin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "376-408",
          "snippet": "static void kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtmsr",
          "args": [
            "inst",
            "inst_rt"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtmsrd",
          "args": [
            "inst",
            "inst_rt"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsrd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "164-208",
          "snippet": "static void kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsrd_branch_offs;",
            "extern u32 kvm_emulate_mtmsrd_reg_offs;",
            "extern u32 kvm_emulate_mtmsrd_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsrd_len;",
            "extern u32 kvm_emulate_mtmsrd[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsrd_branch_offs;\nextern u32 kvm_emulate_mtmsrd_reg_offs;\nextern u32 kvm_emulate_mtmsrd_orig_ins_offs;\nextern u32 kvm_emulate_mtmsrd_len;\nextern u32 kvm_emulate_mtmsrd[];\n\nstatic void kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_nop",
          "args": [
            "inst"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_nop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "123-126",
          "snippet": "static void kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_NOP\t\t0x60000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_NOP\t\t0x60000000\n\nstatic void kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_stw",
          "args": [
            "inst",
            "magic_var(esr)",
            "inst_rt"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_stw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "118-121",
          "snippet": "static void kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_STW\t\t0x90000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "esr"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_ESR"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_std",
          "args": [
            "inst",
            "magic_var(sprg7)",
            "inst_rt"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "109-116",
          "snippet": "static void kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_STD\t\t0xf8000000",
            "#define KVM_INST_STW\t\t0x90000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STD\t\t0xf8000000\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg7"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG7"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg6"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG6"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg5"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG5"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg4"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG4"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS7"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas6"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS6"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas4"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS4"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS3"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas2"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS2"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas1"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS1"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas0"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS0"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dsisr"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DSISR"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dar"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DAR"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DEAR"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr1"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SRR1"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SRR0"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg3"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG3"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg2"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG2"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG1"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg0"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_lwz",
          "args": [
            "inst",
            "magic_var(pir)",
            "inst_rt"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_lwz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "104-107",
          "snippet": "static void kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "pir"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_PIR"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "esr"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_ESR"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ld",
          "args": [
            "inst",
            "magic_var(sprg7)",
            "inst_rt"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ld",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "95-102",
          "snippet": "static void kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg7"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG7R"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG7"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg6"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG6R"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG6"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg5"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG5R"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG5"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg4"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG4R"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG4"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS7"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas6"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS6"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas4"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS4"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS3"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas2"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS2"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas1"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS0"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dsisr"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DSISR"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dar"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DAR"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DEAR"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SRR1"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr0"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SRR0"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg3"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG3"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg2"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG2"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg1"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG1"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "msr"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_MTSRIN\t\t0x7c0001e4\n#define KVM_INST_WRTEEI_1\t0x7c008146\n#define KVM_INST_WRTEEI_0\t0x7c000146\n#define KVM_INST_WRTEE\t\t0x7c000106\n#define KVM_INST_MTMSR\t\t0x7c000124\n#define KVM_INST_MTMSRD_L1\t0x7c010164\n#define KVM_INST_MTMSRD_L0\t0x7c000164\n#define KVM_INST_TLBSYNC\t0x7c00046c\n#define KVM_INST_MFMSR\t\t0x7c0000a6\n#define KVM_MASK_RB\t\t0x0000f800\n#define KVM_MASK_RT\t\t0x03e00000\n\nstatic void kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}"
  },
  {
    "function_name": "kvm_map_magic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "412-425",
    "snippet": "static void kvm_map_magic_page(void *data)\n{\n\tu32 *features = data;\n\n\tulong in[8] = {0};\n\tulong out[8];\n\n\tin[0] = KVM_MAGIC_PAGE;\n\tin[1] = KVM_MAGIC_PAGE | MAGIC_PAGE_FLAG_NOT_MAPPED_NX;\n\n\tepapr_hypercall(in, out, KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE));\n\n\t*features = out[0];\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAGIC_PAGE\t\t(-4096L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "epapr_hypercall",
          "args": [
            "in",
            "out",
            "KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_HCALL_TOKEN",
          "args": [
            "KVM_HC_PPC_MAP_MAGIC_PAGE"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic void kvm_map_magic_page(void *data)\n{\n\tu32 *features = data;\n\n\tulong in[8] = {0};\n\tulong out[8];\n\n\tin[0] = KVM_MAGIC_PAGE;\n\tin[1] = KVM_MAGIC_PAGE | MAGIC_PAGE_FLAG_NOT_MAPPED_NX;\n\n\tepapr_hypercall(in, out, KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE));\n\n\t*features = out[0];\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtsrin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "376-408",
    "snippet": "static void kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "128-139",
          "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtsrin_len * 4"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtsrin",
            "kvm_emulate_mtsrin_len * 4"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtsrin_len * 4"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "141-156",
          "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_wrteei_0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "335-363",
    "snippet": "static void kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "128-139",
          "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_wrteei_0",
            "kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "141-156",
          "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_wrtee",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "278-329",
    "snippet": "static void kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_LI\t\t0x38000000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "128-139",
          "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_wrtee_len * 4"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_wrtee_reg_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "86-93",
          "snippet": "static void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "47-84",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R30"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_wrtee",
            "kvm_emulate_wrtee_len * 4"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_wrtee_len * 4"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "141-156",
          "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_LI\t\t0x38000000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtmsr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "217-268",
    "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_emulate_mtmsr_branch_offs;",
      "extern u32 kvm_emulate_mtmsr_reg1_offs;",
      "extern u32 kvm_emulate_mtmsr_reg2_offs;",
      "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
      "extern u32 kvm_emulate_mtmsr_len;",
      "extern u32 kvm_emulate_mtmsr[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "128-139",
          "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtmsr_len * 4"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_mtmsr_reg2_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "86-93",
          "snippet": "static void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "47-84",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtmsr",
            "kvm_emulate_mtmsr_len * 4"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtmsr_len * 4"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "141-156",
          "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtmsrd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "164-208",
    "snippet": "static void kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_emulate_mtmsrd_branch_offs;",
      "extern u32 kvm_emulate_mtmsrd_reg_offs;",
      "extern u32 kvm_emulate_mtmsrd_orig_ins_offs;",
      "extern u32 kvm_emulate_mtmsrd_len;",
      "extern u32 kvm_emulate_mtmsrd[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "128-139",
          "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_mtmsrd_reg_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "86-93",
          "snippet": "static void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "47-84",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtmsrd",
            "kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "141-156",
          "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "char kvm_tmp[1024 * 1024];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsrd_branch_offs;\nextern u32 kvm_emulate_mtmsrd_reg_offs;\nextern u32 kvm_emulate_mtmsrd_orig_ins_offs;\nextern u32 kvm_emulate_mtmsrd_len;\nextern u32 kvm_emulate_mtmsrd[];\n\nstatic void kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "141-156",
    "snippet": "static u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "char kvm_tmp[1024 * 1024];",
      "static int kvm_tmp_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"KVM: No more space (%d + %d)\\n\"",
            "kvm_tmp_index",
            "len"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kvm_tmp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nchar kvm_tmp[1024 * 1024];\nstatic int kvm_tmp_index;\n\nstatic u32 *kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > ARRAY_SIZE(kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
  },
  {
    "function_name": "kvm_patch_ins_b",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "128-139",
    "snippet": "static void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MASK\t\t0x03ffffff",
      "#define KVM_INST_B\t\t0x48000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_B | (addr & KVM_INST_B_MASK)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
  },
  {
    "function_name": "kvm_patch_ins_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "123-126",
    "snippet": "static void kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_NOP\t\t0x60000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_NOP"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_NOP\t\t0x60000000\n\nstatic void kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}"
  },
  {
    "function_name": "kvm_patch_ins_stw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "118-121",
    "snippet": "static void kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_STW\t\t0x90000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_STW | rt | (addr & 0x0000fffc)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}"
  },
  {
    "function_name": "kvm_patch_ins_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "109-116",
    "snippet": "static void kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_STD\t\t0xf8000000",
      "#define KVM_INST_STW\t\t0x90000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc)"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STD\t\t0xf8000000\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins_lwz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "104-107",
    "snippet": "static void kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | (addr & 0x0000ffff)"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}"
  },
  {
    "function_name": "kvm_patch_ins_ld",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "95-102",
    "snippet": "static void kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LD\t\t0xe8000000",
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins_ll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "86-93",
    "snippet": "static void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LD\t\t0xe8000000",
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | (addr & 0x0000fffc)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
          "lines": "217-268",
          "snippet": "static void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kvm.c",
    "lines": "80-84",
    "snippet": "static inline void kvm_patch_ins(u32 *inst, u32 new_inst)\n{\n\t*inst = new_inst;\n\tflush_icache_range((ulong)inst, (ulong)inst + 4);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)inst",
            "(ulong)inst + 4"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_patch_ins(u32 *inst, u32 new_inst)\n{\n\t*inst = new_inst;\n\tflush_icache_range((ulong)inst, (ulong)inst + 4);\n}"
  }
]