[
  {
    "function_name": "vio_disable_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1694-1700",
    "snippet": "int vio_disable_interrupts(struct vio_dev *dev)\n{\n\tint rc = h_vio_signal(dev->unit_address, VIO_IRQ_DISABLE);\n\tif (rc != H_SUCCESS)\n\t\tprintk(KERN_ERR \"vio: Error 0x%x disabling interrupts\\n\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vio: Error 0x%x disabling interrupts\\n\"",
            "rc"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "h_vio_signal",
          "args": [
            "dev->unit_address",
            "VIO_IRQ_DISABLE"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nint vio_disable_interrupts(struct vio_dev *dev)\n{\n\tint rc = h_vio_signal(dev->unit_address, VIO_IRQ_DISABLE);\n\tif (rc != H_SUCCESS)\n\t\tprintk(KERN_ERR \"vio: Error 0x%x disabling interrupts\\n\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "vio_enable_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1685-1691",
    "snippet": "int vio_enable_interrupts(struct vio_dev *dev)\n{\n\tint rc = h_vio_signal(dev->unit_address, VIO_IRQ_ENABLE);\n\tif (rc != H_SUCCESS)\n\t\tprintk(KERN_ERR \"vio: Error 0x%x enabling interrupts\\n\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vio: Error 0x%x enabling interrupts\\n\"",
            "rc"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "h_vio_signal",
          "args": [
            "dev->unit_address",
            "VIO_IRQ_ENABLE"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nint vio_enable_interrupts(struct vio_dev *dev)\n{\n\tint rc = h_vio_signal(dev->unit_address, VIO_IRQ_ENABLE);\n\tif (rc != H_SUCCESS)\n\t\tprintk(KERN_ERR \"vio: Error 0x%x enabling interrupts\\n\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "vio_find_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1652-1682",
    "snippet": "struct vio_dev *vio_find_node(struct device_node *vnode)\n{\n\tchar kobj_name[20];\n\tstruct device_node *vnode_parent;\n\tconst char *dev_type;\n\n\tvnode_parent = of_get_parent(vnode);\n\tif (!vnode_parent)\n\t\treturn NULL;\n\n\tdev_type = of_get_property(vnode_parent, \"device_type\", NULL);\n\tof_node_put(vnode_parent);\n\tif (!dev_type)\n\t\treturn NULL;\n\n\t/* construct the kobject name from the device node */\n\tif (!strcmp(dev_type, \"vdevice\")) {\n\t\tconst __be32 *prop;\n\t\t\n\t\tprop = of_get_property(vnode, \"reg\", NULL);\n\t\tif (!prop)\n\t\t\treturn NULL;\n\t\tsnprintf(kobj_name, sizeof(kobj_name), \"%x\",\n\t\t\t (uint32_t)of_read_number(prop, 1));\n\t} else if (!strcmp(dev_type, \"ibm,platform-facilities\"))\n\t\tsnprintf(kobj_name, sizeof(kobj_name), \"%s\", vnode->name);\n\telse\n\t\treturn NULL;\n\n\treturn vio_find_name(kobj_name);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_find_name",
          "args": [
            "kobj_name"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "vio_find_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1637-1646",
          "snippet": "static struct vio_dev *vio_find_name(const char *name)\n{\n\tstruct device *found;\n\n\tfound = bus_find_device_by_name(&vio_bus_type, NULL, name);\n\tif (!found)\n\t\treturn NULL;\n\n\treturn to_vio_dev(found);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstatic struct vio_dev *vio_find_name(const char *name)\n{\n\tstruct device *found;\n\n\tfound = bus_find_device_by_name(&vio_bus_type, NULL, name);\n\tif (!found)\n\t\treturn NULL;\n\n\treturn to_vio_dev(found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kobj_name",
            "sizeof(kobj_name)",
            "\"%s\"",
            "vnode->name"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dev_type",
            "\"ibm,platform-facilities\""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kobj_name",
            "sizeof(kobj_name)",
            "\"%x\"",
            "(uint32_t)of_read_number(prop, 1)"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop",
            "1"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "vnode",
            "\"reg\"",
            "NULL"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dev_type",
            "\"vdevice\""
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "vnode_parent"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "vnode_parent",
            "\"device_type\"",
            "NULL"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "vnode"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstruct vio_dev *vio_find_node(struct device_node *vnode)\n{\n\tchar kobj_name[20];\n\tstruct device_node *vnode_parent;\n\tconst char *dev_type;\n\n\tvnode_parent = of_get_parent(vnode);\n\tif (!vnode_parent)\n\t\treturn NULL;\n\n\tdev_type = of_get_property(vnode_parent, \"device_type\", NULL);\n\tof_node_put(vnode_parent);\n\tif (!dev_type)\n\t\treturn NULL;\n\n\t/* construct the kobject name from the device node */\n\tif (!strcmp(dev_type, \"vdevice\")) {\n\t\tconst __be32 *prop;\n\t\t\n\t\tprop = of_get_property(vnode, \"reg\", NULL);\n\t\tif (!prop)\n\t\t\treturn NULL;\n\t\tsnprintf(kobj_name, sizeof(kobj_name), \"%x\",\n\t\t\t (uint32_t)of_read_number(prop, 1));\n\t} else if (!strcmp(dev_type, \"ibm,platform-facilities\"))\n\t\tsnprintf(kobj_name, sizeof(kobj_name), \"%s\", vnode->name);\n\telse\n\t\treturn NULL;\n\n\treturn vio_find_name(kobj_name);\n}"
  },
  {
    "function_name": "vio_find_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1637-1646",
    "snippet": "static struct vio_dev *vio_find_name(const char *name)\n{\n\tstruct device *found;\n\n\tfound = bus_find_device_by_name(&vio_bus_type, NULL, name);\n\tif (!found)\n\t\treturn NULL;\n\n\treturn to_vio_dev(found);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "found"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_find_device_by_name",
          "args": [
            "&vio_bus_type",
            "NULL",
            "name"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstatic struct vio_dev *vio_find_name(const char *name)\n{\n\tstruct device *found;\n\n\tfound = bus_find_device_by_name(&vio_bus_type, NULL, name);\n\tif (!found)\n\t\treturn NULL;\n\n\treturn to_vio_dev(found);\n}"
  },
  {
    "function_name": "vio_get_attribute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1627-1630",
    "snippet": "const void *vio_get_attribute(struct vio_dev *vdev, char *which, int *length)\n{\n\treturn of_get_property(vdev->dev.of_node, which, length);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "vdev->dev.of_node",
            "which",
            "length"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nconst void *vio_get_attribute(struct vio_dev *vdev, char *which, int *length)\n{\n\treturn of_get_property(vdev->dev.of_node, which, length);\n}"
  },
  {
    "function_name": "vio_hotplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1592-1607",
    "snippet": "static int vio_hotplug(struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct device_node *dn;\n\tconst char *cp;\n\n\tdn = dev->of_node;\n\tif (!dn)\n\t\treturn -ENODEV;\n\tcp = of_get_property(dn, \"compatible\", NULL);\n\tif (!cp)\n\t\treturn -ENODEV;\n\n\tadd_uevent_var(env, \"MODALIAS=vio:T%sS%s\", vio_dev->type, cp);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_uevent_var",
          "args": [
            "env",
            "\"MODALIAS=vio:T%sS%s\"",
            "vio_dev->type",
            "cp"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"compatible\"",
            "NULL"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_hotplug(struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct device_node *dn;\n\tconst char *cp;\n\n\tdn = dev->of_node;\n\tif (!dn)\n\t\treturn -ENODEV;\n\tcp = of_get_property(dn, \"compatible\", NULL);\n\tif (!cp)\n\t\treturn -ENODEV;\n\n\tadd_uevent_var(env, \"MODALIAS=vio:T%sS%s\", vio_dev->type, cp);\n\treturn 0;\n}"
  },
  {
    "function_name": "vio_bus_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1583-1590",
    "snippet": "static int vio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct vio_driver *vio_drv = to_vio_driver(drv);\n\tconst struct vio_device_id *ids = vio_drv->id_table;\n\n\treturn (ids != NULL) && (vio_match_device(ids, vio_dev) != NULL);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_match_device",
          "args": [
            "ids",
            "vio_dev"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "vio_match_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1217-1228",
          "snippet": "static const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vio_driver",
          "args": [
            "drv"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct vio_driver *vio_drv = to_vio_driver(drv);\n\tconst struct vio_device_id *ids = vio_drv->id_table;\n\n\treturn (ids != NULL) && (vio_match_device(ids, vio_dev) != NULL);\n}"
  },
  {
    "function_name": "vio_unregister_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1577-1580",
    "snippet": "void vio_unregister_device(struct vio_dev *viodev)\n{\n\tdevice_unregister(&viodev->dev);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "&viodev->dev"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nvoid vio_unregister_device(struct vio_dev *viodev)\n{\n\tdevice_unregister(&viodev->dev);\n}"
  },
  {
    "function_name": "modalias_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1549-1568",
    "snippet": "static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct device_node *dn;\n\tconst char *cp;\n\n\tdn = dev->of_node;\n\tif (!dn) {\n\t\tstrcpy(buf, \"\\n\");\n\t\treturn strlen(buf);\n\t}\n\tcp = of_get_property(dn, \"compatible\", NULL);\n\tif (!cp) {\n\t\tstrcpy(buf, \"\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\treturn sprintf(buf, \"vio:T%sS%s\\n\", vio_dev->type, cp);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"vio:T%sS%s\\n\"",
            "vio_dev->type",
            "cp"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"compatible\"",
            "NULL"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tconst struct vio_dev *vio_dev = to_vio_dev(dev);\n\tstruct device_node *dn;\n\tconst char *cp;\n\n\tdn = dev->of_node;\n\tif (!dn) {\n\t\tstrcpy(buf, \"\\n\");\n\t\treturn strlen(buf);\n\t}\n\tcp = of_get_property(dn, \"compatible\", NULL);\n\tif (!cp) {\n\t\tstrcpy(buf, \"\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\treturn sprintf(buf, \"vio:T%sS%s\\n\", vio_dev->type, cp);\n}"
  },
  {
    "function_name": "devspec_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1541-1547",
    "snippet": "static ssize_t devspec_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct device_node *of_node = dev->of_node;\n\n\treturn sprintf(buf, \"%s\\n\", of_node_full_name(of_node));\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "of_node_full_name(of_node)"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "of_node"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t devspec_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct device_node *of_node = dev->of_node;\n\n\treturn sprintf(buf, \"%s\\n\", of_node_full_name(of_node));\n}"
  },
  {
    "function_name": "name_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1535-1539",
    "snippet": "static ssize_t name_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_vio_dev(dev)->name);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "to_vio_dev(dev)->name"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t name_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", to_vio_dev(dev)->name);\n}"
  },
  {
    "function_name": "vio_device_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1526-1532",
    "snippet": "static int __init vio_device_init(void)\n{\n\tvio_bus_scan_register_devices(\"vdevice\");\n\tvio_bus_scan_register_devices(\"ibm,platform-facilities\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_bus_scan_register_devices",
          "args": [
            "\"ibm,platform-facilities\""
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "vio_bus_scan_register_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1469-1490",
          "snippet": "static void vio_bus_scan_register_devices(char *root_name)\n{\n\tstruct device_node *node_root, *node_child;\n\n\tif (!root_name)\n\t\treturn;\n\n\tnode_root = of_find_node_by_name(NULL, root_name);\n\tif (node_root) {\n\n\t\t/*\n\t\t * Create struct vio_devices for each virtual device in\n\t\t * the device tree. Drivers will associate with them later.\n\t\t */\n\t\tnode_child = of_get_next_child(node_root, NULL);\n\t\twhile (node_child) {\n\t\t\tvio_register_device_node(node_child);\n\t\t\tnode_child = of_get_next_child(node_root, node_child);\n\t\t}\n\t\tof_node_put(node_root);\n\t}\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_bus_scan_register_devices(char *root_name)\n{\n\tstruct device_node *node_root, *node_child;\n\n\tif (!root_name)\n\t\treturn;\n\n\tnode_root = of_find_node_by_name(NULL, root_name);\n\tif (node_root) {\n\n\t\t/*\n\t\t * Create struct vio_devices for each virtual device in\n\t\t * the device tree. Drivers will associate with them later.\n\t\t */\n\t\tnode_child = of_get_next_child(node_root, NULL);\n\t\twhile (node_child) {\n\t\t\tvio_register_device_node(node_child);\n\t\t\tnode_child = of_get_next_child(node_root, node_child);\n\t\t}\n\t\tof_node_put(node_root);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int __init vio_device_init(void)\n{\n\tvio_bus_scan_register_devices(\"vdevice\");\n\tvio_bus_scan_register_devices(\"ibm,platform-facilities\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vio_bus_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1495-1523",
    "snippet": "static int __init vio_bus_init(void)\n{\n\tint err;\n\n\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_sysfs_init();\n\n\terr = bus_register(&vio_bus_type);\n\tif (err) {\n\t\tprintk(KERN_ERR \"failed to register VIO bus\\n\");\n\t\treturn err;\n\t}\n\n\t/*\n\t * The fake parent of all vio devices, just to give us\n\t * a nice directory\n\t */\n\terr = device_register(&vio_bus_device.dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: device_register returned %i\\n\",\n\t\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_bus_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};",
      "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_bus_init",
          "args": [],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_bus_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1078-1078",
          "snippet": "static void vio_cmo_bus_init(void) {}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: device_register returned %i\\n\"",
            "__func__",
            "err"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&vio_bus_device.dev"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"failed to register VIO bus\\n\""
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_register",
          "args": [
            "&vio_bus_type"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "ibmebus_register_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ibmebus.c",
          "lines": "208-215",
          "snippet": "int ibmebus_register_driver(struct platform_driver *drv)\n{\n\t/* If the driver uses devices that ibmebus doesn't know, add them */\n\tibmebus_create_devices(drv->driver.of_match_table);\n\n\tdrv->driver.bus = &ibmebus_bus_type;\n\treturn driver_register(&drv->driver);\n}",
          "includes": [
            "#include <asm/ibmebus.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/kobject.h>",
            "#include <linux/console.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct bus_type ibmebus_bus_type;",
            "struct bus_type ibmebus_bus_type = {\n\t.name      = \"ibmebus\",\n\t.uevent    = of_device_uevent_modalias,\n\t.bus_groups = ibmbus_bus_groups,\n\t.match     = ibmebus_bus_bus_match,\n\t.probe     = ibmebus_bus_device_probe,\n\t.remove    = ibmebus_bus_device_remove,\n\t.shutdown  = ibmebus_bus_device_shutdown,\n\t.dev_attrs = ibmebus_bus_device_attrs,\n\t.pm        = IBMEBUS_BUS_PM_OPS_PTR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ibmebus.h>\n#include <linux/of_platform.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/kobject.h>\n#include <linux/console.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct bus_type ibmebus_bus_type;\nstruct bus_type ibmebus_bus_type = {\n\t.name      = \"ibmebus\",\n\t.uevent    = of_device_uevent_modalias,\n\t.bus_groups = ibmbus_bus_groups,\n\t.match     = ibmebus_bus_bus_match,\n\t.probe     = ibmebus_bus_device_probe,\n\t.remove    = ibmebus_bus_device_remove,\n\t.shutdown  = ibmebus_bus_device_shutdown,\n\t.dev_attrs = ibmebus_bus_device_attrs,\n\t.pm        = IBMEBUS_BUS_PM_OPS_PTR,\n};\n\nint ibmebus_register_driver(struct platform_driver *drv)\n{\n\t/* If the driver uses devices that ibmebus doesn't know, add them */\n\tibmebus_create_devices(drv->driver.of_match_table);\n\n\tdrv->driver.bus = &ibmebus_bus_type;\n\treturn driver_register(&drv->driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vio_cmo_sysfs_init",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1079-1079",
          "snippet": "static void vio_cmo_sysfs_init(void) { }",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_sysfs_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstatic int __init vio_bus_init(void)\n{\n\tint err;\n\n\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_sysfs_init();\n\n\terr = bus_register(&vio_bus_type);\n\tif (err) {\n\t\tprintk(KERN_ERR \"failed to register VIO bus\\n\");\n\t\treturn err;\n\t}\n\n\t/*\n\t * The fake parent of all vio devices, just to give us\n\t * a nice directory\n\t */\n\terr = device_register(&vio_bus_device.dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: device_register returned %i\\n\",\n\t\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_bus_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vio_bus_scan_register_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1469-1490",
    "snippet": "static void vio_bus_scan_register_devices(char *root_name)\n{\n\tstruct device_node *node_root, *node_child;\n\n\tif (!root_name)\n\t\treturn;\n\n\tnode_root = of_find_node_by_name(NULL, root_name);\n\tif (node_root) {\n\n\t\t/*\n\t\t * Create struct vio_devices for each virtual device in\n\t\t * the device tree. Drivers will associate with them later.\n\t\t */\n\t\tnode_child = of_get_next_child(node_root, NULL);\n\t\twhile (node_child) {\n\t\t\tvio_register_device_node(node_child);\n\t\t\tnode_child = of_get_next_child(node_root, node_child);\n\t\t}\n\t\tof_node_put(node_root);\n\t}\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "node_root"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_next_child",
          "args": [
            "node_root",
            "node_child"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_register_device_node",
          "args": [
            "node_child"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "vio_register_device_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1335-1458",
          "snippet": "struct vio_dev *vio_register_device_node(struct device_node *of_node)\n{\n\tstruct vio_dev *viodev;\n\tstruct device_node *parent_node;\n\tconst __be32 *prop;\n\tenum vio_dev_family family;\n\tconst char *of_node_name = of_node->name ? of_node->name : \"<unknown>\";\n\n\t/*\n\t * Determine if this node is a under the /vdevice node or under the\n\t * /ibm,platform-facilities node.  This decides the device's family.\n\t */\n\tparent_node = of_get_parent(of_node);\n\tif (parent_node) {\n\t\tif (!strcmp(parent_node->full_name, \"/ibm,platform-facilities\"))\n\t\t\tfamily = PFO;\n\t\telse if (!strcmp(parent_node->full_name, \"/vdevice\"))\n\t\t\tfamily = VDEVICE;\n\t\telse {\n\t\t\tpr_warn(\"%s: parent(%s) of %s not recognized.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tparent_node->full_name,\n\t\t\t\t\tof_node_name);\n\t\t\tof_node_put(parent_node);\n\t\t\treturn NULL;\n\t\t}\n\t\tof_node_put(parent_node);\n\t} else {\n\t\tpr_warn(\"%s: could not determine the parent of node %s.\\n\",\n\t\t\t\t__func__, of_node_name);\n\t\treturn NULL;\n\t}\n\n\tif (family == PFO) {\n\t\tif (of_get_property(of_node, \"interrupt-controller\", NULL)) {\n\t\t\tpr_debug(\"%s: Skipping the interrupt controller %s.\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* allocate a vio_dev for this node */\n\tviodev = kzalloc(sizeof(struct vio_dev), GFP_KERNEL);\n\tif (viodev == NULL) {\n\t\tpr_warn(\"%s: allocation failure for VIO device.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* we need the 'device_type' property, in order to match with drivers */\n\tviodev->family = family;\n\tif (viodev->family == VDEVICE) {\n\t\tunsigned int unit_address;\n\n\t\tif (of_node->type != NULL)\n\t\t\tviodev->type = of_node->type;\n\t\telse {\n\t\t\tpr_warn(\"%s: node %s is missing the 'device_type' \"\n\t\t\t\t\t\"property.\\n\", __func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprop = of_get_property(of_node, \"reg\", NULL);\n\t\tif (prop == NULL) {\n\t\t\tpr_warn(\"%s: node %s missing 'reg'\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\t\tunit_address = of_read_number(prop, 1);\n\t\tdev_set_name(&viodev->dev, \"%x\", unit_address);\n\t\tviodev->irq = irq_of_parse_and_map(of_node, 0);\n\t\tviodev->unit_address = unit_address;\n\t} else {\n\t\t/* PFO devices need their resource_id for submitting COP_OPs\n\t\t * This is an optional field for devices, but is required when\n\t\t * performing synchronous ops */\n\t\tprop = of_get_property(of_node, \"ibm,resource-id\", NULL);\n\t\tif (prop != NULL)\n\t\t\tviodev->resource_id = of_read_number(prop, 1);\n\n\t\tdev_set_name(&viodev->dev, \"%s\", of_node_name);\n\t\tviodev->type = of_node_name;\n\t\tviodev->irq = 0;\n\t}\n\n\tviodev->name = of_node->name;\n\tviodev->dev.of_node = of_node_get(of_node);\n\n\tset_dev_node(&viodev->dev, of_node_to_nid(of_node));\n\n\t/* init generic 'struct device' fields: */\n\tviodev->dev.parent = &vio_bus_device.dev;\n\tviodev->dev.bus = &vio_bus_type;\n\tviodev->dev.release = vio_dev_release;\n\n\tif (of_get_property(viodev->dev.of_node, \"ibm,my-dma-window\", NULL)) {\n\t\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_set_dma_ops(viodev);\n\t\telse\n\t\t\tset_dma_ops(&viodev->dev, &dma_iommu_ops);\n\n\t\tset_iommu_table_base(&viodev->dev,\n\t\t\t\t     vio_build_iommu_table(viodev));\n\n\t\t/* needed to ensure proper operation of coherent allocations\n\t\t * later, in case driver doesn't set it explicitly */\n\t\tviodev->dev.coherent_dma_mask = DMA_BIT_MASK(64);\n\t\tviodev->dev.dma_mask = &viodev->dev.coherent_dma_mask;\n\t}\n\n\t/* register with generic device framework */\n\tif (device_register(&viodev->dev)) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %s\\n\",\n\t\t\t\t__func__, dev_name(&viodev->dev));\n\t\tput_device(&viodev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn viodev;\n\nout:\t/* Use this exit point for any return prior to device_register */\n\tkfree(viodev);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};",
            "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstruct vio_dev *vio_register_device_node(struct device_node *of_node)\n{\n\tstruct vio_dev *viodev;\n\tstruct device_node *parent_node;\n\tconst __be32 *prop;\n\tenum vio_dev_family family;\n\tconst char *of_node_name = of_node->name ? of_node->name : \"<unknown>\";\n\n\t/*\n\t * Determine if this node is a under the /vdevice node or under the\n\t * /ibm,platform-facilities node.  This decides the device's family.\n\t */\n\tparent_node = of_get_parent(of_node);\n\tif (parent_node) {\n\t\tif (!strcmp(parent_node->full_name, \"/ibm,platform-facilities\"))\n\t\t\tfamily = PFO;\n\t\telse if (!strcmp(parent_node->full_name, \"/vdevice\"))\n\t\t\tfamily = VDEVICE;\n\t\telse {\n\t\t\tpr_warn(\"%s: parent(%s) of %s not recognized.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tparent_node->full_name,\n\t\t\t\t\tof_node_name);\n\t\t\tof_node_put(parent_node);\n\t\t\treturn NULL;\n\t\t}\n\t\tof_node_put(parent_node);\n\t} else {\n\t\tpr_warn(\"%s: could not determine the parent of node %s.\\n\",\n\t\t\t\t__func__, of_node_name);\n\t\treturn NULL;\n\t}\n\n\tif (family == PFO) {\n\t\tif (of_get_property(of_node, \"interrupt-controller\", NULL)) {\n\t\t\tpr_debug(\"%s: Skipping the interrupt controller %s.\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* allocate a vio_dev for this node */\n\tviodev = kzalloc(sizeof(struct vio_dev), GFP_KERNEL);\n\tif (viodev == NULL) {\n\t\tpr_warn(\"%s: allocation failure for VIO device.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* we need the 'device_type' property, in order to match with drivers */\n\tviodev->family = family;\n\tif (viodev->family == VDEVICE) {\n\t\tunsigned int unit_address;\n\n\t\tif (of_node->type != NULL)\n\t\t\tviodev->type = of_node->type;\n\t\telse {\n\t\t\tpr_warn(\"%s: node %s is missing the 'device_type' \"\n\t\t\t\t\t\"property.\\n\", __func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprop = of_get_property(of_node, \"reg\", NULL);\n\t\tif (prop == NULL) {\n\t\t\tpr_warn(\"%s: node %s missing 'reg'\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\t\tunit_address = of_read_number(prop, 1);\n\t\tdev_set_name(&viodev->dev, \"%x\", unit_address);\n\t\tviodev->irq = irq_of_parse_and_map(of_node, 0);\n\t\tviodev->unit_address = unit_address;\n\t} else {\n\t\t/* PFO devices need their resource_id for submitting COP_OPs\n\t\t * This is an optional field for devices, but is required when\n\t\t * performing synchronous ops */\n\t\tprop = of_get_property(of_node, \"ibm,resource-id\", NULL);\n\t\tif (prop != NULL)\n\t\t\tviodev->resource_id = of_read_number(prop, 1);\n\n\t\tdev_set_name(&viodev->dev, \"%s\", of_node_name);\n\t\tviodev->type = of_node_name;\n\t\tviodev->irq = 0;\n\t}\n\n\tviodev->name = of_node->name;\n\tviodev->dev.of_node = of_node_get(of_node);\n\n\tset_dev_node(&viodev->dev, of_node_to_nid(of_node));\n\n\t/* init generic 'struct device' fields: */\n\tviodev->dev.parent = &vio_bus_device.dev;\n\tviodev->dev.bus = &vio_bus_type;\n\tviodev->dev.release = vio_dev_release;\n\n\tif (of_get_property(viodev->dev.of_node, \"ibm,my-dma-window\", NULL)) {\n\t\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_set_dma_ops(viodev);\n\t\telse\n\t\t\tset_dma_ops(&viodev->dev, &dma_iommu_ops);\n\n\t\tset_iommu_table_base(&viodev->dev,\n\t\t\t\t     vio_build_iommu_table(viodev));\n\n\t\t/* needed to ensure proper operation of coherent allocations\n\t\t * later, in case driver doesn't set it explicitly */\n\t\tviodev->dev.coherent_dma_mask = DMA_BIT_MASK(64);\n\t\tviodev->dev.dma_mask = &viodev->dev.coherent_dma_mask;\n\t}\n\n\t/* register with generic device framework */\n\tif (device_register(&viodev->dev)) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %s\\n\",\n\t\t\t\t__func__, dev_name(&viodev->dev));\n\t\tput_device(&viodev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn viodev;\n\nout:\t/* Use this exit point for any return prior to device_register */\n\tkfree(viodev);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_next_child",
          "args": [
            "node_root",
            "NULL"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "root_name"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_bus_scan_register_devices(char *root_name)\n{\n\tstruct device_node *node_root, *node_child;\n\n\tif (!root_name)\n\t\treturn;\n\n\tnode_root = of_find_node_by_name(NULL, root_name);\n\tif (node_root) {\n\n\t\t/*\n\t\t * Create struct vio_devices for each virtual device in\n\t\t * the device tree. Drivers will associate with them later.\n\t\t */\n\t\tnode_child = of_get_next_child(node_root, NULL);\n\t\twhile (node_child) {\n\t\t\tvio_register_device_node(node_child);\n\t\t\tnode_child = of_get_next_child(node_root, node_child);\n\t\t}\n\t\tof_node_put(node_root);\n\t}\n}"
  },
  {
    "function_name": "vio_register_device_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1335-1458",
    "snippet": "struct vio_dev *vio_register_device_node(struct device_node *of_node)\n{\n\tstruct vio_dev *viodev;\n\tstruct device_node *parent_node;\n\tconst __be32 *prop;\n\tenum vio_dev_family family;\n\tconst char *of_node_name = of_node->name ? of_node->name : \"<unknown>\";\n\n\t/*\n\t * Determine if this node is a under the /vdevice node or under the\n\t * /ibm,platform-facilities node.  This decides the device's family.\n\t */\n\tparent_node = of_get_parent(of_node);\n\tif (parent_node) {\n\t\tif (!strcmp(parent_node->full_name, \"/ibm,platform-facilities\"))\n\t\t\tfamily = PFO;\n\t\telse if (!strcmp(parent_node->full_name, \"/vdevice\"))\n\t\t\tfamily = VDEVICE;\n\t\telse {\n\t\t\tpr_warn(\"%s: parent(%s) of %s not recognized.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tparent_node->full_name,\n\t\t\t\t\tof_node_name);\n\t\t\tof_node_put(parent_node);\n\t\t\treturn NULL;\n\t\t}\n\t\tof_node_put(parent_node);\n\t} else {\n\t\tpr_warn(\"%s: could not determine the parent of node %s.\\n\",\n\t\t\t\t__func__, of_node_name);\n\t\treturn NULL;\n\t}\n\n\tif (family == PFO) {\n\t\tif (of_get_property(of_node, \"interrupt-controller\", NULL)) {\n\t\t\tpr_debug(\"%s: Skipping the interrupt controller %s.\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* allocate a vio_dev for this node */\n\tviodev = kzalloc(sizeof(struct vio_dev), GFP_KERNEL);\n\tif (viodev == NULL) {\n\t\tpr_warn(\"%s: allocation failure for VIO device.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* we need the 'device_type' property, in order to match with drivers */\n\tviodev->family = family;\n\tif (viodev->family == VDEVICE) {\n\t\tunsigned int unit_address;\n\n\t\tif (of_node->type != NULL)\n\t\t\tviodev->type = of_node->type;\n\t\telse {\n\t\t\tpr_warn(\"%s: node %s is missing the 'device_type' \"\n\t\t\t\t\t\"property.\\n\", __func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprop = of_get_property(of_node, \"reg\", NULL);\n\t\tif (prop == NULL) {\n\t\t\tpr_warn(\"%s: node %s missing 'reg'\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\t\tunit_address = of_read_number(prop, 1);\n\t\tdev_set_name(&viodev->dev, \"%x\", unit_address);\n\t\tviodev->irq = irq_of_parse_and_map(of_node, 0);\n\t\tviodev->unit_address = unit_address;\n\t} else {\n\t\t/* PFO devices need their resource_id for submitting COP_OPs\n\t\t * This is an optional field for devices, but is required when\n\t\t * performing synchronous ops */\n\t\tprop = of_get_property(of_node, \"ibm,resource-id\", NULL);\n\t\tif (prop != NULL)\n\t\t\tviodev->resource_id = of_read_number(prop, 1);\n\n\t\tdev_set_name(&viodev->dev, \"%s\", of_node_name);\n\t\tviodev->type = of_node_name;\n\t\tviodev->irq = 0;\n\t}\n\n\tviodev->name = of_node->name;\n\tviodev->dev.of_node = of_node_get(of_node);\n\n\tset_dev_node(&viodev->dev, of_node_to_nid(of_node));\n\n\t/* init generic 'struct device' fields: */\n\tviodev->dev.parent = &vio_bus_device.dev;\n\tviodev->dev.bus = &vio_bus_type;\n\tviodev->dev.release = vio_dev_release;\n\n\tif (of_get_property(viodev->dev.of_node, \"ibm,my-dma-window\", NULL)) {\n\t\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_set_dma_ops(viodev);\n\t\telse\n\t\t\tset_dma_ops(&viodev->dev, &dma_iommu_ops);\n\n\t\tset_iommu_table_base(&viodev->dev,\n\t\t\t\t     vio_build_iommu_table(viodev));\n\n\t\t/* needed to ensure proper operation of coherent allocations\n\t\t * later, in case driver doesn't set it explicitly */\n\t\tviodev->dev.coherent_dma_mask = DMA_BIT_MASK(64);\n\t\tviodev->dev.dma_mask = &viodev->dev.coherent_dma_mask;\n\t}\n\n\t/* register with generic device framework */\n\tif (device_register(&viodev->dev)) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %s\\n\",\n\t\t\t\t__func__, dev_name(&viodev->dev));\n\t\tput_device(&viodev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn viodev;\n\nout:\t/* Use this exit point for any return prior to device_register */\n\tkfree(viodev);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};",
      "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "viodev"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "&viodev->dev"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: failed to register device %s\\n\"",
            "__func__",
            "dev_name(&viodev->dev)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&viodev->dev"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&viodev->dev"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "64"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_iommu_table_base",
          "args": [
            "&viodev->dev",
            "vio_build_iommu_table(viodev)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_build_iommu_table",
          "args": [
            "viodev"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "vio_build_iommu_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1172-1205",
          "snippet": "static struct iommu_table *vio_build_iommu_table(struct vio_dev *dev)\n{\n\tconst __be32 *dma_window;\n\tstruct iommu_table *tbl;\n\tunsigned long offset, size;\n\n\tdma_window = of_get_property(dev->dev.of_node,\n\t\t\t\t  \"ibm,my-dma-window\", NULL);\n\tif (!dma_window)\n\t\treturn NULL;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (tbl == NULL)\n\t\treturn NULL;\n\n\tof_parse_dma_window(dev->dev.of_node, dma_window,\n\t\t\t    &tbl->it_index, &offset, &size);\n\n\t/* TCE table size - measured in tce entries */\n\ttbl->it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\ttbl->it_size = size >> tbl->it_page_shift;\n\t/* offset for VIO should always be 0 */\n\ttbl->it_offset = offset >> tbl->it_page_shift;\n\ttbl->it_busno = 0;\n\ttbl->it_type = TCE_VB;\n\ttbl->it_blocksize = 16;\n\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\ttbl->it_ops = &iommu_table_lpar_multi_ops;\n\telse\n\t\ttbl->it_ops = &iommu_table_pseries_ops;\n\n\treturn iommu_init_table(tbl, -1);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic struct iommu_table *vio_build_iommu_table(struct vio_dev *dev)\n{\n\tconst __be32 *dma_window;\n\tstruct iommu_table *tbl;\n\tunsigned long offset, size;\n\n\tdma_window = of_get_property(dev->dev.of_node,\n\t\t\t\t  \"ibm,my-dma-window\", NULL);\n\tif (!dma_window)\n\t\treturn NULL;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (tbl == NULL)\n\t\treturn NULL;\n\n\tof_parse_dma_window(dev->dev.of_node, dma_window,\n\t\t\t    &tbl->it_index, &offset, &size);\n\n\t/* TCE table size - measured in tce entries */\n\ttbl->it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\ttbl->it_size = size >> tbl->it_page_shift;\n\t/* offset for VIO should always be 0 */\n\ttbl->it_offset = offset >> tbl->it_page_shift;\n\ttbl->it_busno = 0;\n\ttbl->it_type = TCE_VB;\n\ttbl->it_blocksize = 16;\n\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\ttbl->it_ops = &iommu_table_lpar_multi_ops;\n\telse\n\t\ttbl->it_ops = &iommu_table_pseries_ops;\n\n\treturn iommu_init_table(tbl, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dma_ops",
          "args": [
            "&viodev->dev",
            "&dma_iommu_ops"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_set_dma_ops",
          "args": [
            "viodev"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_set_dma_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1077-1077",
          "snippet": "static void vio_cmo_set_dma_ops(struct vio_dev *viodev) {}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_set_dma_ops(struct vio_dev *viodev) {}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "viodev->dev.of_node",
            "\"ibm,my-dma-window\"",
            "NULL"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dev_node",
          "args": [
            "&viodev->dev",
            "of_node_to_nid(of_node)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "of_node"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&viodev->dev",
            "\"%s\"",
            "of_node_name"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop",
            "1"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_node",
            "\"ibm,resource-id\"",
            "NULL"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_of_parse_and_map",
          "args": [
            "of_node",
            "0"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&viodev->dev",
            "\"%x\"",
            "unit_address"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop",
            "1"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: node %s missing 'reg'\\n\"",
            "__func__",
            "of_node_name"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_node",
            "\"reg\"",
            "NULL"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: node %s is missing the 'device_type' \"\n\t\t\t\t\t\"property.\\n\"",
            "__func__",
            "of_node_name"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: allocation failure for VIO device.\\n\"",
            "__func__"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct vio_dev)",
            "GFP_KERNEL"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Skipping the interrupt controller %s.\\n\"",
            "__func__",
            "of_node_name"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_node",
            "\"interrupt-controller\"",
            "NULL"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: could not determine the parent of node %s.\\n\"",
            "__func__",
            "of_node_name"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent_node"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent_node"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: parent(%s) of %s not recognized.\\n\"",
            "__func__",
            "parent_node->full_name",
            "of_node_name"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent_node->full_name",
            "\"/vdevice\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent_node->full_name",
            "\"/ibm,platform-facilities\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "of_node"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic struct vio_dev vio_bus_device  = { /* fake \"parent\" device */\n\t.name = \"vio\",\n\t.type = \"\",\n\t.dev.init_name = \"vio\",\n\t.dev.bus = &vio_bus_type,\n};\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstruct vio_dev *vio_register_device_node(struct device_node *of_node)\n{\n\tstruct vio_dev *viodev;\n\tstruct device_node *parent_node;\n\tconst __be32 *prop;\n\tenum vio_dev_family family;\n\tconst char *of_node_name = of_node->name ? of_node->name : \"<unknown>\";\n\n\t/*\n\t * Determine if this node is a under the /vdevice node or under the\n\t * /ibm,platform-facilities node.  This decides the device's family.\n\t */\n\tparent_node = of_get_parent(of_node);\n\tif (parent_node) {\n\t\tif (!strcmp(parent_node->full_name, \"/ibm,platform-facilities\"))\n\t\t\tfamily = PFO;\n\t\telse if (!strcmp(parent_node->full_name, \"/vdevice\"))\n\t\t\tfamily = VDEVICE;\n\t\telse {\n\t\t\tpr_warn(\"%s: parent(%s) of %s not recognized.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tparent_node->full_name,\n\t\t\t\t\tof_node_name);\n\t\t\tof_node_put(parent_node);\n\t\t\treturn NULL;\n\t\t}\n\t\tof_node_put(parent_node);\n\t} else {\n\t\tpr_warn(\"%s: could not determine the parent of node %s.\\n\",\n\t\t\t\t__func__, of_node_name);\n\t\treturn NULL;\n\t}\n\n\tif (family == PFO) {\n\t\tif (of_get_property(of_node, \"interrupt-controller\", NULL)) {\n\t\t\tpr_debug(\"%s: Skipping the interrupt controller %s.\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* allocate a vio_dev for this node */\n\tviodev = kzalloc(sizeof(struct vio_dev), GFP_KERNEL);\n\tif (viodev == NULL) {\n\t\tpr_warn(\"%s: allocation failure for VIO device.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* we need the 'device_type' property, in order to match with drivers */\n\tviodev->family = family;\n\tif (viodev->family == VDEVICE) {\n\t\tunsigned int unit_address;\n\n\t\tif (of_node->type != NULL)\n\t\t\tviodev->type = of_node->type;\n\t\telse {\n\t\t\tpr_warn(\"%s: node %s is missing the 'device_type' \"\n\t\t\t\t\t\"property.\\n\", __func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprop = of_get_property(of_node, \"reg\", NULL);\n\t\tif (prop == NULL) {\n\t\t\tpr_warn(\"%s: node %s missing 'reg'\\n\",\n\t\t\t\t\t__func__, of_node_name);\n\t\t\tgoto out;\n\t\t}\n\t\tunit_address = of_read_number(prop, 1);\n\t\tdev_set_name(&viodev->dev, \"%x\", unit_address);\n\t\tviodev->irq = irq_of_parse_and_map(of_node, 0);\n\t\tviodev->unit_address = unit_address;\n\t} else {\n\t\t/* PFO devices need their resource_id for submitting COP_OPs\n\t\t * This is an optional field for devices, but is required when\n\t\t * performing synchronous ops */\n\t\tprop = of_get_property(of_node, \"ibm,resource-id\", NULL);\n\t\tif (prop != NULL)\n\t\t\tviodev->resource_id = of_read_number(prop, 1);\n\n\t\tdev_set_name(&viodev->dev, \"%s\", of_node_name);\n\t\tviodev->type = of_node_name;\n\t\tviodev->irq = 0;\n\t}\n\n\tviodev->name = of_node->name;\n\tviodev->dev.of_node = of_node_get(of_node);\n\n\tset_dev_node(&viodev->dev, of_node_to_nid(of_node));\n\n\t/* init generic 'struct device' fields: */\n\tviodev->dev.parent = &vio_bus_device.dev;\n\tviodev->dev.bus = &vio_bus_type;\n\tviodev->dev.release = vio_dev_release;\n\n\tif (of_get_property(viodev->dev.of_node, \"ibm,my-dma-window\", NULL)) {\n\t\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_set_dma_ops(viodev);\n\t\telse\n\t\t\tset_dma_ops(&viodev->dev, &dma_iommu_ops);\n\n\t\tset_iommu_table_base(&viodev->dev,\n\t\t\t\t     vio_build_iommu_table(viodev));\n\n\t\t/* needed to ensure proper operation of coherent allocations\n\t\t * later, in case driver doesn't set it explicitly */\n\t\tviodev->dev.coherent_dma_mask = DMA_BIT_MASK(64);\n\t\tviodev->dev.dma_mask = &viodev->dev.coherent_dma_mask;\n\t}\n\n\t/* register with generic device framework */\n\tif (device_register(&viodev->dev)) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %s\\n\",\n\t\t\t\t__func__, dev_name(&viodev->dev));\n\t\tput_device(&viodev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn viodev;\n\nout:\t/* Use this exit point for any return prior to device_register */\n\tkfree(viodev);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "vio_dev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1316-1324",
    "snippet": "static void vio_dev_release(struct device *dev)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\n\tif (tbl)\n\t\tiommu_free_table(tbl, of_node_full_name(dev->of_node));\n\tof_node_put(dev->of_node);\n\tkfree(to_vio_dev(dev));\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "to_vio_dev(dev)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "dev->of_node"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_free_table",
          "args": [
            "tbl",
            "of_node_full_name(dev->of_node)"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "713-746",
          "snippet": "void iommu_free_table(struct iommu_table *tbl, const char *node_name)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\n\tif (!tbl)\n\t\treturn;\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs for %s\\n\", __func__, node_name);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_free_table(struct iommu_table *tbl, const char *node_name)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\n\tif (!tbl)\n\t\treturn;\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs for %s\\n\", __func__, node_name);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "dev->of_node"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_dev_release(struct device *dev)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\n\tif (tbl)\n\t\tiommu_free_table(tbl, of_node_full_name(dev->of_node));\n\tof_node_put(dev->of_node);\n\tkfree(to_vio_dev(dev));\n}"
  },
  {
    "function_name": "vio_unregister_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1309-1312",
    "snippet": "void vio_unregister_driver(struct vio_driver *viodrv)\n{\n\tdriver_unregister(&viodrv->driver);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver_unregister",
          "args": [
            "&viodrv->driver"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nvoid vio_unregister_driver(struct vio_driver *viodrv)\n{\n\tdriver_unregister(&viodrv->driver);\n}"
  },
  {
    "function_name": "__vio_register_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1289-1302",
    "snippet": "int __vio_register_driver(struct vio_driver *viodrv, struct module *owner,\n\t\t\t  const char *mod_name)\n{\n\tpr_debug(\"%s: driver %s registering\\n\", __func__, viodrv->name);\n\n\t/* fill in 'struct driver' fields */\n\tviodrv->driver.name = viodrv->name;\n\tviodrv->driver.pm = viodrv->pm;\n\tviodrv->driver.bus = &vio_bus_type;\n\tviodrv->driver.owner = owner;\n\tviodrv->driver.mod_name = mod_name;\n\n\treturn driver_register(&viodrv->driver);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver_register",
          "args": [
            "&viodrv->driver"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: driver %s registering\\n\"",
            "__func__",
            "viodrv->name"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nint __vio_register_driver(struct vio_driver *viodrv, struct module *owner,\n\t\t\t  const char *mod_name)\n{\n\tpr_debug(\"%s: driver %s registering\\n\", __func__, viodrv->name);\n\n\t/* fill in 'struct driver' fields */\n\tviodrv->driver.name = viodrv->name;\n\tviodrv->driver.pm = viodrv->pm;\n\tviodrv->driver.bus = &vio_bus_type;\n\tviodrv->driver.owner = owner;\n\tviodrv->driver.mod_name = mod_name;\n\n\treturn driver_register(&viodrv->driver);\n}"
  },
  {
    "function_name": "vio_bus_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1262-1283",
    "snippet": "static int vio_bus_remove(struct device *dev)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tstruct device *devptr;\n\tint ret = 1;\n\n\t/*\n\t * Hold a reference to the device after the remove function is called\n\t * to allow for CMO accounting cleanup for the device.\n\t */\n\tdevptr = get_device(dev);\n\n\tif (viodrv->remove)\n\t\tret = viodrv->remove(viodev);\n\n\tif (!ret && firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_bus_remove(viodev);\n\n\tput_device(devptr);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "devptr"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_bus_remove",
          "args": [
            "viodev"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_bus_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1076-1076",
          "snippet": "static void vio_cmo_bus_remove(struct vio_dev *viodev) {}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_remove(struct vio_dev *viodev) {}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "viodrv->remove",
          "args": [
            "viodev"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "dev"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_get_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "63-80",
          "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vio_driver",
          "args": [
            "dev->driver"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_bus_remove(struct device *dev)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tstruct device *devptr;\n\tint ret = 1;\n\n\t/*\n\t * Hold a reference to the device after the remove function is called\n\t * to allow for CMO accounting cleanup for the device.\n\t */\n\tdevptr = get_device(dev);\n\n\tif (viodrv->remove)\n\t\tret = viodrv->remove(viodev);\n\n\tif (!ret && firmware_has_feature(FW_FEATURE_CMO))\n\t\tvio_cmo_bus_remove(viodev);\n\n\tput_device(devptr);\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_bus_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1235-1259",
    "snippet": "static int vio_bus_probe(struct device *dev)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tconst struct vio_device_id *id;\n\tint error = -ENODEV;\n\n\tif (!viodrv->probe)\n\t\treturn error;\n\n\tid = vio_match_device(viodrv->id_table, viodev);\n\tif (id) {\n\t\tmemset(&viodev->cmo, 0, sizeof(viodev->cmo));\n\t\tif (firmware_has_feature(FW_FEATURE_CMO)) {\n\t\t\terror = vio_cmo_bus_probe(viodev);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = viodrv->probe(viodev, id);\n\t\tif (error && firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_bus_remove(viodev);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_bus_remove",
          "args": [
            "viodev"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_bus_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1076-1076",
          "snippet": "static void vio_cmo_bus_remove(struct vio_dev *viodev) {}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_remove(struct vio_dev *viodev) {}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "viodrv->probe",
          "args": [
            "viodev",
            "id"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_bus_probe",
          "args": [
            "viodev"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_bus_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1075-1075",
          "snippet": "static int vio_cmo_bus_probe(struct vio_dev *viodev) { return 0; }",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_bus_probe(struct vio_dev *viodev) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&viodev->cmo",
            "0",
            "sizeof(viodev->cmo)"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "vio_match_device",
          "args": [
            "viodrv->id_table",
            "viodev"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "vio_match_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1217-1228",
          "snippet": "static const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vio_driver",
          "args": [
            "dev->driver"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_bus_probe(struct device *dev)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tconst struct vio_device_id *id;\n\tint error = -ENODEV;\n\n\tif (!viodrv->probe)\n\t\treturn error;\n\n\tid = vio_match_device(viodrv->id_table, viodev);\n\tif (id) {\n\t\tmemset(&viodev->cmo, 0, sizeof(viodev->cmo));\n\t\tif (firmware_has_feature(FW_FEATURE_CMO)) {\n\t\t\terror = vio_cmo_bus_probe(viodev);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = viodrv->probe(viodev, id);\n\t\tif (error && firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tvio_cmo_bus_remove(viodev);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "vio_match_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1217-1228",
    "snippet": "static const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "dev->dev.of_node",
            "ids->compat"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "dev->type",
            "ids->type",
            "strlen(ids->type)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ids->type"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic const struct vio_device_id *vio_match_device(\n\t\tconst struct vio_device_id *ids, const struct vio_dev *dev)\n{\n\twhile (ids->type[0] != '\\0') {\n\t\tif ((strncmp(dev->type, ids->type, strlen(ids->type)) == 0) &&\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t ids->compat))\n\t\t\treturn ids;\n\t\tids++;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "vio_build_iommu_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1172-1205",
    "snippet": "static struct iommu_table *vio_build_iommu_table(struct vio_dev *dev)\n{\n\tconst __be32 *dma_window;\n\tstruct iommu_table *tbl;\n\tunsigned long offset, size;\n\n\tdma_window = of_get_property(dev->dev.of_node,\n\t\t\t\t  \"ibm,my-dma-window\", NULL);\n\tif (!dma_window)\n\t\treturn NULL;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (tbl == NULL)\n\t\treturn NULL;\n\n\tof_parse_dma_window(dev->dev.of_node, dma_window,\n\t\t\t    &tbl->it_index, &offset, &size);\n\n\t/* TCE table size - measured in tce entries */\n\ttbl->it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\ttbl->it_size = size >> tbl->it_page_shift;\n\t/* offset for VIO should always be 0 */\n\ttbl->it_offset = offset >> tbl->it_page_shift;\n\ttbl->it_busno = 0;\n\ttbl->it_type = TCE_VB;\n\ttbl->it_blocksize = 16;\n\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\ttbl->it_ops = &iommu_table_lpar_multi_ops;\n\telse\n\t\ttbl->it_ops = &iommu_table_pseries_ops;\n\n\treturn iommu_init_table(tbl, -1);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_init_table",
          "args": [
            "tbl",
            "-1"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_init_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "652-711",
          "snippet": "struct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int novmerge;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\n\nstruct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_LPAR"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_parse_dma_window",
          "args": [
            "dev->dev.of_node",
            "dma_window",
            "&tbl->it_index",
            "&offset",
            "&size"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "of_parse_dma_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom_parse.c",
          "lines": "10-33",
          "snippet": "void of_parse_dma_window(struct device_node *dn, const __be32 *dma_window,\n\t\t\t unsigned long *busno, unsigned long *phys,\n\t\t\t unsigned long *size)\n{\n\tu32 cells;\n\tconst __be32 *prop;\n\n\t/* busno is always one cell */\n\t*busno = of_read_number(dma_window, 1);\n\tdma_window++;\n\n\tprop = of_get_property(dn, \"ibm,#dma-address-cells\", NULL);\n\tif (!prop)\n\t\tprop = of_get_property(dn, \"#address-cells\", NULL);\n\n\tcells = prop ? of_read_number(prop, 1) : of_n_addr_cells(dn);\n\t*phys = of_read_number(dma_window, cells);\n\n\tdma_window += cells;\n\n\tprop = of_get_property(dn, \"ibm,#dma-size-cells\", NULL);\n\tcells = prop ? of_read_number(prop, 1) : of_n_size_cells(dn);\n\t*size = of_read_number(dma_window, cells);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <linux/of_address.h>",
            "#include <linux/etherdevice.h>",
            "#include <linux/ioport.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <linux/of_address.h>\n#include <linux/etherdevice.h>\n#include <linux/ioport.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid of_parse_dma_window(struct device_node *dn, const __be32 *dma_window,\n\t\t\t unsigned long *busno, unsigned long *phys,\n\t\t\t unsigned long *size)\n{\n\tu32 cells;\n\tconst __be32 *prop;\n\n\t/* busno is always one cell */\n\t*busno = of_read_number(dma_window, 1);\n\tdma_window++;\n\n\tprop = of_get_property(dn, \"ibm,#dma-address-cells\", NULL);\n\tif (!prop)\n\t\tprop = of_get_property(dn, \"#address-cells\", NULL);\n\n\tcells = prop ? of_read_number(prop, 1) : of_n_addr_cells(dn);\n\t*phys = of_read_number(dma_window, cells);\n\n\tdma_window += cells;\n\n\tprop = of_get_property(dn, \"ibm,#dma-size-cells\", NULL);\n\tcells = prop ? of_read_number(prop, 1) : of_n_size_cells(dn);\n\t*size = of_read_number(dma_window, cells);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tbl)",
            "GFP_KERNEL"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dev->dev.of_node",
            "\"ibm,my-dma-window\"",
            "NULL"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic struct iommu_table *vio_build_iommu_table(struct vio_dev *dev)\n{\n\tconst __be32 *dma_window;\n\tstruct iommu_table *tbl;\n\tunsigned long offset, size;\n\n\tdma_window = of_get_property(dev->dev.of_node,\n\t\t\t\t  \"ibm,my-dma-window\", NULL);\n\tif (!dma_window)\n\t\treturn NULL;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (tbl == NULL)\n\t\treturn NULL;\n\n\tof_parse_dma_window(dev->dev.of_node, dma_window,\n\t\t\t    &tbl->it_index, &offset, &size);\n\n\t/* TCE table size - measured in tce entries */\n\ttbl->it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\ttbl->it_size = size >> tbl->it_page_shift;\n\t/* offset for VIO should always be 0 */\n\ttbl->it_offset = offset >> tbl->it_page_shift;\n\ttbl->it_busno = 0;\n\ttbl->it_type = TCE_VB;\n\ttbl->it_blocksize = 16;\n\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\ttbl->it_ops = &iommu_table_lpar_multi_ops;\n\telse\n\t\ttbl->it_ops = &iommu_table_pseries_ops;\n\n\treturn iommu_init_table(tbl, -1);\n}"
  },
  {
    "function_name": "vio_h_cop_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1114-1169",
    "snippet": "int vio_h_cop_sync(struct vio_dev *vdev, struct vio_pfo_op *op)\n{\n\tstruct device *dev = &vdev->dev;\n\tunsigned long deadline = 0;\n\tlong hret = 0;\n\tint ret = 0;\n\n\tif (op->timeout)\n\t\tdeadline = jiffies + msecs_to_jiffies(op->timeout);\n\n\twhile (true) {\n\t\thret = plpar_hcall_norets(H_COP, op->flags,\n\t\t\t\tvdev->resource_id,\n\t\t\t\top->in, op->inlen, op->out,\n\t\t\t\top->outlen, op->csbcpb);\n\n\t\tif (hret == H_SUCCESS ||\n\t\t    (hret != H_NOT_ENOUGH_RESOURCES &&\n\t\t     hret != H_BUSY && hret != H_RESOURCE) ||\n\t\t    (op->timeout && time_after(deadline, jiffies)))\n\t\t\tbreak;\n\n\t\tdev_dbg(dev, \"%s: hcall ret(%ld), retrying.\\n\", __func__, hret);\n\t}\n\n\tswitch (hret) {\n\tcase H_SUCCESS:\n\t\tret = 0;\n\t\tbreak;\n\tcase H_OP_MODE:\n\tcase H_TOO_BIG:\n\t\tret = -E2BIG;\n\t\tbreak;\n\tcase H_RESCINDED:\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase H_HARDWARE:\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase H_NOT_ENOUGH_RESOURCES:\n\tcase H_RESOURCE:\n\tcase H_BUSY:\n\t\tret = -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_dbg(dev, \"%s: Sync h_cop_op failure (ret:%d) (hret:%ld)\\n\",\n\t\t\t\t__func__, ret, hret);\n\n\top->hcall_err = hret;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "dev",
            "\"%s: Sync h_cop_op failure (ret:%d) (hret:%ld)\\n\"",
            "__func__",
            "ret",
            "hret"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "dev",
            "\"%s: hcall ret(%ld), retrying.\\n\"",
            "__func__",
            "hret"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "deadline",
            "jiffies"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plpar_hcall_norets",
          "args": [
            "H_COP",
            "op->flags",
            "vdev->resource_id",
            "op->in",
            "op->inlen",
            "op->out",
            "op->outlen",
            "op->csbcpb"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "op->timeout"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nint vio_h_cop_sync(struct vio_dev *vdev, struct vio_pfo_op *op)\n{\n\tstruct device *dev = &vdev->dev;\n\tunsigned long deadline = 0;\n\tlong hret = 0;\n\tint ret = 0;\n\n\tif (op->timeout)\n\t\tdeadline = jiffies + msecs_to_jiffies(op->timeout);\n\n\twhile (true) {\n\t\thret = plpar_hcall_norets(H_COP, op->flags,\n\t\t\t\tvdev->resource_id,\n\t\t\t\top->in, op->inlen, op->out,\n\t\t\t\top->outlen, op->csbcpb);\n\n\t\tif (hret == H_SUCCESS ||\n\t\t    (hret != H_NOT_ENOUGH_RESOURCES &&\n\t\t     hret != H_BUSY && hret != H_RESOURCE) ||\n\t\t    (op->timeout && time_after(deadline, jiffies)))\n\t\t\tbreak;\n\n\t\tdev_dbg(dev, \"%s: hcall ret(%ld), retrying.\\n\", __func__, hret);\n\t}\n\n\tswitch (hret) {\n\tcase H_SUCCESS:\n\t\tret = 0;\n\t\tbreak;\n\tcase H_OP_MODE:\n\tcase H_TOO_BIG:\n\t\tret = -E2BIG;\n\t\tbreak;\n\tcase H_RESCINDED:\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase H_HARDWARE:\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase H_NOT_ENOUGH_RESOURCES:\n\tcase H_RESOURCE:\n\tcase H_BUSY:\n\t\tret = -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_dbg(dev, \"%s: Sync h_cop_op failure (ret:%d) (hret:%ld)\\n\",\n\t\t\t\t__func__, ret, hret);\n\n\top->hcall_err = hret;\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_cmo_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1079-1079",
    "snippet": "static void vio_cmo_sysfs_init(void) { }",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_sysfs_init(void) { }"
  },
  {
    "function_name": "vio_cmo_bus_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1078-1078",
    "snippet": "static void vio_cmo_bus_init(void) {}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_init(void) {}"
  },
  {
    "function_name": "vio_cmo_set_dma_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1077-1077",
    "snippet": "static void vio_cmo_set_dma_ops(struct vio_dev *viodev) {}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_set_dma_ops(struct vio_dev *viodev) {}"
  },
  {
    "function_name": "vio_cmo_bus_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1076-1076",
    "snippet": "static void vio_cmo_bus_remove(struct vio_dev *viodev) {}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_remove(struct vio_dev *viodev) {}"
  },
  {
    "function_name": "vio_cmo_bus_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1075-1075",
    "snippet": "static int vio_cmo_bus_probe(struct vio_dev *viodev) { return 0; }",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_bus_probe(struct vio_dev *viodev) { return 0; }"
  },
  {
    "function_name": "vio_cmo_set_dev_desired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1074-1074",
    "snippet": "void vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired) {}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nvoid vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired) {}"
  },
  {
    "function_name": "vio_cmo_entitlement_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1073-1073",
    "snippet": "int vio_cmo_entitlement_update(size_t new_entitlement) { return 0; }",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nint vio_cmo_entitlement_update(size_t new_entitlement) { return 0; }"
  },
  {
    "function_name": "vio_cmo_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1067-1071",
    "snippet": "static void vio_cmo_sysfs_init(void)\n{\n\tvio_bus_type.dev_attrs = vio_cmo_dev_attrs;\n\tvio_bus_type.bus_groups = vio_bus_groups;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstruct bus_type vio_bus_type = {\n\t.name = \"vio\",\n\t.dev_attrs = vio_dev_attrs,\n\t.uevent = vio_hotplug,\n\t.match = vio_bus_match,\n\t.probe = vio_bus_probe,\n\t.remove = vio_bus_remove,\n};\n\nstatic void vio_cmo_sysfs_init(void)\n{\n\tvio_bus_type.dev_attrs = vio_cmo_dev_attrs;\n\tvio_bus_type.bus_groups = vio_bus_groups;\n}"
  },
  {
    "function_name": "cmo_high_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1040-1050",
    "snippet": "static ssize_t cmo_high_store(struct bus_type *bt, const char *buf,\n\t\t\t      size_t count)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.high = vio_cmo.curr;\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t cmo_high_store(struct bus_type *bt, const char *buf,\n\t\t\t      size_t count)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.high = vio_cmo.curr;\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "cmo_high_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "1035-1038",
    "snippet": "static ssize_t cmo_high_show(struct bus_type *bt, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", vio_cmo.high);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "vio_cmo.high"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t cmo_high_show(struct bus_type *bt, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", vio_cmo.high);\n}"
  },
  {
    "function_name": "viodev_cmo_desired_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "973-986",
    "snippet": "static ssize_t viodev_cmo_desired_set(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tsize_t new_desired;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &new_desired);\n\tif (ret)\n\t\treturn ret;\n\n\tvio_cmo_set_dev_desired(viodev, new_desired);\n\treturn count;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_set_dev_desired",
          "args": [
            "viodev",
            "new_desired"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_set_dev_desired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "1074-1074",
          "snippet": "void vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired) {}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nvoid vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired) {}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&new_desired"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t viodev_cmo_desired_set(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tsize_t new_desired;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &new_desired);\n\tif (ret)\n\t\treturn ret;\n\n\tvio_cmo_set_dev_desired(viodev, new_desired);\n\treturn count;\n}"
  },
  {
    "function_name": "viodev_cmo_allocs_failed_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "965-971",
    "snippet": "static ssize_t viodev_cmo_allocs_failed_reset(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tatomic_set(&viodev->cmo.allocs_failed, 0);\n\treturn count;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&viodev->cmo.allocs_failed",
            "0"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t viodev_cmo_allocs_failed_reset(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tatomic_set(&viodev->cmo.allocs_failed, 0);\n\treturn count;\n}"
  },
  {
    "function_name": "viodev_cmo_allocs_failed_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "958-963",
    "snippet": "static ssize_t viodev_cmo_allocs_failed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&viodev->cmo.allocs_failed));\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "atomic_read(&viodev->cmo.allocs_failed)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic ssize_t viodev_cmo_allocs_failed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&viodev->cmo.allocs_failed));\n}"
  },
  {
    "function_name": "vio_cmo_bus_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "905-946",
    "snippet": "static void vio_cmo_bus_init(void)\n{\n\tstruct hvcall_mpp_data mpp_data;\n\tint err;\n\n\tmemset(&vio_cmo, 0, sizeof(struct vio_cmo));\n\tspin_lock_init(&vio_cmo.lock);\n\tINIT_LIST_HEAD(&vio_cmo.device_list);\n\tINIT_DELAYED_WORK(&vio_cmo.balance_q, vio_cmo_balance);\n\n\t/* Get current system entitlement */\n\terr = h_get_mpp(&mpp_data);\n\n\t/*\n\t * On failure, continue with entitlement set to 0, will panic()\n\t * later when spare is reserved.\n\t */\n\tif (err != H_SUCCESS) {\n\t\tprintk(KERN_ERR \"%s: unable to determine system IO \"\\\n\t\t       \"entitlement. (%d)\\n\", __func__, err);\n\t\tvio_cmo.entitled = 0;\n\t} else {\n\t\tvio_cmo.entitled = mpp_data.entitled_mem;\n\t}\n\n\t/* Set reservation and check against entitlement */\n\tvio_cmo.spare = VIO_CMO_MIN_ENT;\n\tvio_cmo.reserve.size = vio_cmo.spare;\n\tvio_cmo.reserve.size += (vio_cmo_num_OF_devs() *\n\t                         VIO_CMO_MIN_ENT);\n\tif (vio_cmo.reserve.size > vio_cmo.entitled) {\n\t\tprintk(KERN_ERR \"%s: insufficient system entitlement\\n\",\n\t\t       __func__);\n\t\tpanic(\"%s: Insufficient system entitlement\", __func__);\n\t}\n\n\t/* Set the remaining accounting variables */\n\tvio_cmo.excess.size = vio_cmo.entitled - vio_cmo.reserve.size;\n\tvio_cmo.excess.free = vio_cmo.excess.size;\n\tvio_cmo.min = vio_cmo.reserve.size;\n\tvio_cmo.desired = vio_cmo.reserve.size;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Insufficient system entitlement\"",
            "__func__"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: insufficient system entitlement\\n\"",
            "__func__"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vio_cmo_num_OF_devs",
          "args": [],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_num_OF_devs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "107-130",
          "snippet": "static int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: unable to determine system IO \"\\\n\t\t       \"entitlement. (%d)\\n\"",
            "__func__",
            "err"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h_get_mpp",
          "args": [
            "&mpp_data"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&vio_cmo.balance_q",
            "vio_cmo_balance"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vio_cmo.device_list"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vio_cmo.lock"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vio_cmo",
            "0",
            "sizeof(struct vio_cmo)"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_init(void)\n{\n\tstruct hvcall_mpp_data mpp_data;\n\tint err;\n\n\tmemset(&vio_cmo, 0, sizeof(struct vio_cmo));\n\tspin_lock_init(&vio_cmo.lock);\n\tINIT_LIST_HEAD(&vio_cmo.device_list);\n\tINIT_DELAYED_WORK(&vio_cmo.balance_q, vio_cmo_balance);\n\n\t/* Get current system entitlement */\n\terr = h_get_mpp(&mpp_data);\n\n\t/*\n\t * On failure, continue with entitlement set to 0, will panic()\n\t * later when spare is reserved.\n\t */\n\tif (err != H_SUCCESS) {\n\t\tprintk(KERN_ERR \"%s: unable to determine system IO \"\\\n\t\t       \"entitlement. (%d)\\n\", __func__, err);\n\t\tvio_cmo.entitled = 0;\n\t} else {\n\t\tvio_cmo.entitled = mpp_data.entitled_mem;\n\t}\n\n\t/* Set reservation and check against entitlement */\n\tvio_cmo.spare = VIO_CMO_MIN_ENT;\n\tvio_cmo.reserve.size = vio_cmo.spare;\n\tvio_cmo.reserve.size += (vio_cmo_num_OF_devs() *\n\t                         VIO_CMO_MIN_ENT);\n\tif (vio_cmo.reserve.size > vio_cmo.entitled) {\n\t\tprintk(KERN_ERR \"%s: insufficient system entitlement\\n\",\n\t\t       __func__);\n\t\tpanic(\"%s: Insufficient system entitlement\", __func__);\n\t}\n\n\t/* Set the remaining accounting variables */\n\tvio_cmo.excess.size = vio_cmo.entitled - vio_cmo.reserve.size;\n\tvio_cmo.excess.free = vio_cmo.excess.size;\n\tvio_cmo.min = vio_cmo.reserve.size;\n\tvio_cmo.desired = vio_cmo.reserve.size;\n}"
  },
  {
    "function_name": "vio_cmo_set_dma_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "893-896",
    "snippet": "static void vio_cmo_set_dma_ops(struct vio_dev *viodev)\n{\n\tset_dma_ops(&viodev->dev, &vio_dma_mapping_ops);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dma_ops",
          "args": [
            "&viodev->dev",
            "&vio_dma_mapping_ops"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_set_dma_ops(struct vio_dev *viodev)\n{\n\tset_dma_ops(&viodev->dev, &vio_dma_mapping_ops);\n}"
  },
  {
    "function_name": "vio_cmo_bus_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "822-891",
    "snippet": "static void vio_cmo_bus_remove(struct vio_dev *viodev)\n{\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t tmp;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tif (viodev->cmo.allocated) {\n\t\tdev_err(&viodev->dev, \"%s: device had %lu bytes of IO \"\n\t\t        \"allocated after remove operation.\\n\",\n\t\t        __func__, viodev->cmo.allocated);\n\t\tBUG();\n\t}\n\n\t/*\n\t * Remove the device from the device list being maintained for\n\t * CMO enabled devices.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list)\n\t\tif (viodev == dev_ent->viodev) {\n\t\t\tlist_del(&dev_ent->list);\n\t\t\tkfree(dev_ent);\n\t\t\tbreak;\n\t\t}\n\n\t/*\n\t * Devices may not require any entitlement and they do not need\n\t * to be processed.  Otherwise, return the device's entitlement\n\t * back to the pools.\n\t */\n\tif (viodev->cmo.entitled) {\n\t\t/*\n\t\t * This device has not yet left the OF tree, it's\n\t\t * minimum entitlement remains in vio_cmo.min and\n\t\t * vio_cmo.desired\n\t\t */\n\t\tvio_cmo.desired -= (viodev->cmo.desired - VIO_CMO_MIN_ENT);\n\n\t\t/*\n\t\t * Save min allocation for device in reserve as long\n\t\t * as it exists in OF tree as determined by later\n\t\t * balance operation\n\t\t */\n\t\tviodev->cmo.entitled -= VIO_CMO_MIN_ENT;\n\n\t\t/* Replenish spare from freed reserve pool */\n\t\tif (viodev->cmo.entitled && (vio_cmo.spare < VIO_CMO_MIN_ENT)) {\n\t\t\ttmp = min(viodev->cmo.entitled, (VIO_CMO_MIN_ENT -\n\t\t\t                                 vio_cmo.spare));\n\t\t\tvio_cmo.spare += tmp;\n\t\t\tviodev->cmo.entitled -= tmp;\n\t\t}\n\n\t\t/* Remaining reserve goes to excess pool */\n\t\tvio_cmo.excess.size += viodev->cmo.entitled;\n\t\tvio_cmo.excess.free += viodev->cmo.entitled;\n\t\tvio_cmo.reserve.size -= viodev->cmo.entitled;\n\n\t\t/*\n\t\t * Until the device is removed it will keep a\n\t\t * minimum entitlement; this will guarantee that\n\t\t * a module unload/load will result in a success.\n\t\t */\n\t\tviodev->cmo.entitled = VIO_CMO_MIN_ENT;\n\t\tviodev->cmo.desired = VIO_CMO_MIN_ENT;\n\t\tatomic_set(&viodev->cmo.allocs_failed, 0);\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&viodev->cmo.allocs_failed",
            "0"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "viodev->cmo.entitled",
            "(VIO_CMO_MIN_ENT -\n\t\t\t                                 vio_cmo.spare)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev_ent"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dev_ent->list"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "&viodev->dev",
            "\"%s: device had %lu bytes of IO \"\n\t\t        \"allocated after remove operation.\\n\"",
            "__func__",
            "viodev->cmo.allocated"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_cmo_bus_remove(struct vio_dev *viodev)\n{\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t tmp;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tif (viodev->cmo.allocated) {\n\t\tdev_err(&viodev->dev, \"%s: device had %lu bytes of IO \"\n\t\t        \"allocated after remove operation.\\n\",\n\t\t        __func__, viodev->cmo.allocated);\n\t\tBUG();\n\t}\n\n\t/*\n\t * Remove the device from the device list being maintained for\n\t * CMO enabled devices.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list)\n\t\tif (viodev == dev_ent->viodev) {\n\t\t\tlist_del(&dev_ent->list);\n\t\t\tkfree(dev_ent);\n\t\t\tbreak;\n\t\t}\n\n\t/*\n\t * Devices may not require any entitlement and they do not need\n\t * to be processed.  Otherwise, return the device's entitlement\n\t * back to the pools.\n\t */\n\tif (viodev->cmo.entitled) {\n\t\t/*\n\t\t * This device has not yet left the OF tree, it's\n\t\t * minimum entitlement remains in vio_cmo.min and\n\t\t * vio_cmo.desired\n\t\t */\n\t\tvio_cmo.desired -= (viodev->cmo.desired - VIO_CMO_MIN_ENT);\n\n\t\t/*\n\t\t * Save min allocation for device in reserve as long\n\t\t * as it exists in OF tree as determined by later\n\t\t * balance operation\n\t\t */\n\t\tviodev->cmo.entitled -= VIO_CMO_MIN_ENT;\n\n\t\t/* Replenish spare from freed reserve pool */\n\t\tif (viodev->cmo.entitled && (vio_cmo.spare < VIO_CMO_MIN_ENT)) {\n\t\t\ttmp = min(viodev->cmo.entitled, (VIO_CMO_MIN_ENT -\n\t\t\t                                 vio_cmo.spare));\n\t\t\tvio_cmo.spare += tmp;\n\t\t\tviodev->cmo.entitled -= tmp;\n\t\t}\n\n\t\t/* Remaining reserve goes to excess pool */\n\t\tvio_cmo.excess.size += viodev->cmo.entitled;\n\t\tvio_cmo.excess.free += viodev->cmo.entitled;\n\t\tvio_cmo.reserve.size -= viodev->cmo.entitled;\n\n\t\t/*\n\t\t * Until the device is removed it will keep a\n\t\t * minimum entitlement; this will guarantee that\n\t\t * a module unload/load will result in a success.\n\t\t */\n\t\tviodev->cmo.entitled = VIO_CMO_MIN_ENT;\n\t\tviodev->cmo.desired = VIO_CMO_MIN_ENT;\n\t\tatomic_set(&viodev->cmo.allocs_failed, 0);\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
  },
  {
    "function_name": "vio_cmo_bus_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "713-810",
    "snippet": "static int vio_cmo_bus_probe(struct vio_dev *viodev)\n{\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tstruct device *dev = &viodev->dev;\n\tstruct iommu_table *tbl;\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tunsigned long flags;\n\tsize_t size;\n\tbool dma_capable = false;\n\n\ttbl = get_iommu_table_base(dev);\n\n\t/* A device requires entitlement if it has a DMA window property */\n\tswitch (viodev->family) {\n\tcase VDEVICE:\n\t\tif (of_get_property(viodev->dev.of_node,\n\t\t\t\t\t\"ibm,my-dma-window\", NULL))\n\t\t\tdma_capable = true;\n\t\tbreak;\n\tcase PFO:\n\t\tdma_capable = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unknown device family: %d\\n\", viodev->family);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\t/* Configure entitlement for the device. */\n\tif (dma_capable) {\n\t\t/* Check that the driver is CMO enabled and get desired DMA */\n\t\tif (!viodrv->get_desired_dma) {\n\t\t\tdev_err(dev, \"%s: device driver does not support CMO\\n\",\n\t\t\t        __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tviodev->cmo.desired =\n\t\t\tIOMMU_PAGE_ALIGN(viodrv->get_desired_dma(viodev), tbl);\n\t\tif (viodev->cmo.desired < VIO_CMO_MIN_ENT)\n\t\t\tviodev->cmo.desired = VIO_CMO_MIN_ENT;\n\t\tsize = VIO_CMO_MIN_ENT;\n\n\t\tdev_ent = kmalloc(sizeof(struct vio_cmo_dev_entry),\n\t\t                  GFP_KERNEL);\n\t\tif (!dev_ent)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_ent->viodev = viodev;\n\t\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\t\tlist_add(&dev_ent->list, &vio_cmo.device_list);\n\t} else {\n\t\tviodev->cmo.desired = 0;\n\t\tsize = 0;\n\t\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\t}\n\n\t/*\n\t * If the needs for vio_cmo.min have not changed since they\n\t * were last set, the number of devices in the OF tree has\n\t * been constant and the IO memory for this is already in\n\t * the reserve pool.\n\t */\n\tif (vio_cmo.min == ((vio_cmo_num_OF_devs() + 1) *\n\t                    VIO_CMO_MIN_ENT)) {\n\t\t/* Updated desired entitlement if device requires it */\n\t\tif (size)\n\t\t\tvio_cmo.desired += (viodev->cmo.desired -\n\t\t                        VIO_CMO_MIN_ENT);\n\t} else {\n\t\tsize_t tmp;\n\n\t\ttmp = vio_cmo.spare + vio_cmo.excess.free;\n\t\tif (tmp < size) {\n\t\t\tdev_err(dev, \"%s: insufficient free \"\n\t\t\t        \"entitlement to add device. \"\n\t\t\t        \"Need %lu, have %lu\\n\", __func__,\n\t\t\t\tsize, (vio_cmo.spare + tmp));\n\t\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Use excess pool first to fulfill request */\n\t\ttmp = min(size, vio_cmo.excess.free);\n\t\tvio_cmo.excess.free -= tmp;\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\n\t\t/* Use spare if excess pool was insufficient */\n\t\tvio_cmo.spare -= size - tmp;\n\n\t\t/* Update bus accounting */\n\t\tvio_cmo.min += size;\n\t\tvio_cmo.desired += viodev->cmo.desired;\n\t}\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "vio_cmo.excess.free"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"%s: insufficient free \"\n\t\t\t        \"entitlement to add device. \"\n\t\t\t        \"Need %lu, have %lu\\n\"",
            "__func__",
            "size",
            "(vio_cmo.spare + tmp)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_num_OF_devs",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_num_OF_devs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "107-130",
          "snippet": "static int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dev_ent->list",
            "&vio_cmo.device_list"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct vio_cmo_dev_entry)",
            "GFP_KERNEL"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_ALIGN",
          "args": [
            "viodrv->get_desired_dma(viodev)",
            "tbl"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "viodrv->get_desired_dma",
          "args": [
            "viodev"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"%s: device driver does not support CMO\\n\"",
            "__func__"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "dev",
            "\"unknown device family: %d\\n\"",
            "viodev->family"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "viodev->dev.of_node",
            "\"ibm,my-dma-window\"",
            "NULL"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_driver",
          "args": [
            "dev->driver"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_bus_probe(struct vio_dev *viodev)\n{\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tstruct device *dev = &viodev->dev;\n\tstruct iommu_table *tbl;\n\tstruct vio_driver *viodrv = to_vio_driver(dev->driver);\n\tunsigned long flags;\n\tsize_t size;\n\tbool dma_capable = false;\n\n\ttbl = get_iommu_table_base(dev);\n\n\t/* A device requires entitlement if it has a DMA window property */\n\tswitch (viodev->family) {\n\tcase VDEVICE:\n\t\tif (of_get_property(viodev->dev.of_node,\n\t\t\t\t\t\"ibm,my-dma-window\", NULL))\n\t\t\tdma_capable = true;\n\t\tbreak;\n\tcase PFO:\n\t\tdma_capable = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unknown device family: %d\\n\", viodev->family);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\t/* Configure entitlement for the device. */\n\tif (dma_capable) {\n\t\t/* Check that the driver is CMO enabled and get desired DMA */\n\t\tif (!viodrv->get_desired_dma) {\n\t\t\tdev_err(dev, \"%s: device driver does not support CMO\\n\",\n\t\t\t        __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tviodev->cmo.desired =\n\t\t\tIOMMU_PAGE_ALIGN(viodrv->get_desired_dma(viodev), tbl);\n\t\tif (viodev->cmo.desired < VIO_CMO_MIN_ENT)\n\t\t\tviodev->cmo.desired = VIO_CMO_MIN_ENT;\n\t\tsize = VIO_CMO_MIN_ENT;\n\n\t\tdev_ent = kmalloc(sizeof(struct vio_cmo_dev_entry),\n\t\t                  GFP_KERNEL);\n\t\tif (!dev_ent)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_ent->viodev = viodev;\n\t\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\t\tlist_add(&dev_ent->list, &vio_cmo.device_list);\n\t} else {\n\t\tviodev->cmo.desired = 0;\n\t\tsize = 0;\n\t\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\t}\n\n\t/*\n\t * If the needs for vio_cmo.min have not changed since they\n\t * were last set, the number of devices in the OF tree has\n\t * been constant and the IO memory for this is already in\n\t * the reserve pool.\n\t */\n\tif (vio_cmo.min == ((vio_cmo_num_OF_devs() + 1) *\n\t                    VIO_CMO_MIN_ENT)) {\n\t\t/* Updated desired entitlement if device requires it */\n\t\tif (size)\n\t\t\tvio_cmo.desired += (viodev->cmo.desired -\n\t\t                        VIO_CMO_MIN_ENT);\n\t} else {\n\t\tsize_t tmp;\n\n\t\ttmp = vio_cmo.spare + vio_cmo.excess.free;\n\t\tif (tmp < size) {\n\t\t\tdev_err(dev, \"%s: insufficient free \"\n\t\t\t        \"entitlement to add device. \"\n\t\t\t        \"Need %lu, have %lu\\n\", __func__,\n\t\t\t\tsize, (vio_cmo.spare + tmp));\n\t\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Use excess pool first to fulfill request */\n\t\ttmp = min(size, vio_cmo.excess.free);\n\t\tvio_cmo.excess.free -= tmp;\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\n\t\t/* Use spare if excess pool was insufficient */\n\t\tvio_cmo.spare -= size - tmp;\n\n\t\t/* Update bus accounting */\n\t\tvio_cmo.min += size;\n\t\tvio_cmo.desired += viodev->cmo.desired;\n\t}\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "vio_cmo_set_dev_desired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "640-697",
    "snippet": "void vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired)\n{\n\tunsigned long flags;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tint found = 0;\n\n\tif (!firmware_has_feature(FW_FEATURE_CMO))\n\t\treturn;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tif (desired < VIO_CMO_MIN_ENT)\n\t\tdesired = VIO_CMO_MIN_ENT;\n\n\t/*\n\t * Changes will not be made for devices not in the device list.\n\t * If it is not in the device list, then no driver is loaded\n\t * for the device and it can not receive entitlement.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list)\n\t\tif (viodev == dev_ent->viodev) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\tif (!found) {\n\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\treturn;\n\t}\n\n\t/* Increase/decrease in desired device entitlement */\n\tif (desired >= viodev->cmo.desired) {\n\t\t/* Just bump the bus and device values prior to a balance*/\n\t\tvio_cmo.desired += desired - viodev->cmo.desired;\n\t\tviodev->cmo.desired = desired;\n\t} else {\n\t\t/* Decrease bus and device values for desired entitlement */\n\t\tvio_cmo.desired -= viodev->cmo.desired - desired;\n\t\tviodev->cmo.desired = desired;\n\t\t/*\n\t\t * If less entitlement is desired than current entitlement, move\n\t\t * any reserve memory in the change region to the excess pool.\n\t\t */\n\t\tif (viodev->cmo.entitled > desired) {\n\t\t\tvio_cmo.reserve.size -= viodev->cmo.entitled - desired;\n\t\t\tvio_cmo.excess.size += viodev->cmo.entitled - desired;\n\t\t\t/*\n\t\t\t * If entitlement moving from the reserve pool to the\n\t\t\t * excess pool is currently unused, add to the excess\n\t\t\t * free counter.\n\t\t\t */\n\t\t\tif (viodev->cmo.allocated < viodev->cmo.entitled)\n\t\t\t\tvio_cmo.excess.free += viodev->cmo.entitled -\n\t\t\t\t                       max(viodev->cmo.allocated, desired);\n\t\t\tviodev->cmo.entitled = desired;\n\t\t}\n\t}\n\tschedule_delayed_work(&vio_cmo.balance_q, 0);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&vio_cmo.balance_q",
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "viodev->cmo.allocated",
            "desired"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_CMO"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nvoid vio_cmo_set_dev_desired(struct vio_dev *viodev, size_t desired)\n{\n\tunsigned long flags;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tint found = 0;\n\n\tif (!firmware_has_feature(FW_FEATURE_CMO))\n\t\treturn;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tif (desired < VIO_CMO_MIN_ENT)\n\t\tdesired = VIO_CMO_MIN_ENT;\n\n\t/*\n\t * Changes will not be made for devices not in the device list.\n\t * If it is not in the device list, then no driver is loaded\n\t * for the device and it can not receive entitlement.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list)\n\t\tif (viodev == dev_ent->viodev) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\tif (!found) {\n\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\treturn;\n\t}\n\n\t/* Increase/decrease in desired device entitlement */\n\tif (desired >= viodev->cmo.desired) {\n\t\t/* Just bump the bus and device values prior to a balance*/\n\t\tvio_cmo.desired += desired - viodev->cmo.desired;\n\t\tviodev->cmo.desired = desired;\n\t} else {\n\t\t/* Decrease bus and device values for desired entitlement */\n\t\tvio_cmo.desired -= viodev->cmo.desired - desired;\n\t\tviodev->cmo.desired = desired;\n\t\t/*\n\t\t * If less entitlement is desired than current entitlement, move\n\t\t * any reserve memory in the change region to the excess pool.\n\t\t */\n\t\tif (viodev->cmo.entitled > desired) {\n\t\t\tvio_cmo.reserve.size -= viodev->cmo.entitled - desired;\n\t\t\tvio_cmo.excess.size += viodev->cmo.entitled - desired;\n\t\t\t/*\n\t\t\t * If entitlement moving from the reserve pool to the\n\t\t\t * excess pool is currently unused, add to the excess\n\t\t\t * free counter.\n\t\t\t */\n\t\t\tif (viodev->cmo.allocated < viodev->cmo.entitled)\n\t\t\t\tvio_cmo.excess.free += viodev->cmo.entitled -\n\t\t\t\t                       max(viodev->cmo.allocated, desired);\n\t\t\tviodev->cmo.entitled = desired;\n\t\t}\n\t}\n\tschedule_delayed_work(&vio_cmo.balance_q, 0);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
  },
  {
    "function_name": "vio_dma_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "613-616",
    "snippet": "static u64 vio_dma_get_required_mask(struct device *dev)\n{\n        return dma_iommu_ops.get_required_mask(dev);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_iommu_ops.get_required_mask",
          "args": [
            "dev"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic u64 vio_dma_get_required_mask(struct device *dev)\n{\n        return dma_iommu_ops.get_required_mask(dev);\n}"
  },
  {
    "function_name": "vio_dma_iommu_dma_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "608-611",
    "snippet": "static int vio_dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n        return dma_iommu_ops.dma_supported(dev, mask);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_iommu_ops.dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n        return dma_iommu_ops.dma_supported(dev, mask);\n}"
  },
  {
    "function_name": "vio_dma_iommu_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "588-606",
    "snippet": "static void vio_dma_iommu_unmap_sg(struct device *dev,\n\t\tstruct scatterlist *sglist, int nelems,\n\t\tenum dma_data_direction direction,\n\t\tstruct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tstruct scatterlist *sgl;\n\tsize_t alloc_size = 0;\n\tint count;\n\n\ttbl = get_iommu_table_base(dev);\n\tfor_each_sg(sglist, sgl, nelems, count)\n\t\talloc_size += roundup(sgl->dma_length, IOMMU_PAGE_SIZE(tbl));\n\n\tdma_iommu_ops.unmap_sg(dev, sglist, nelems, direction, attrs);\n\n\tvio_cmo_dealloc(viodev, alloc_size);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "alloc_size"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.unmap_sg",
          "args": [
            "dev",
            "sglist",
            "nelems",
            "direction",
            "attrs"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "sgl->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "sgl",
            "nelems",
            "count"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_dma_iommu_unmap_sg(struct device *dev,\n\t\tstruct scatterlist *sglist, int nelems,\n\t\tenum dma_data_direction direction,\n\t\tstruct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tstruct scatterlist *sgl;\n\tsize_t alloc_size = 0;\n\tint count;\n\n\ttbl = get_iommu_table_base(dev);\n\tfor_each_sg(sglist, sgl, nelems, count)\n\t\talloc_size += roundup(sgl->dma_length, IOMMU_PAGE_SIZE(tbl));\n\n\tdma_iommu_ops.unmap_sg(dev, sglist, nelems, direction, attrs);\n\n\tvio_cmo_dealloc(viodev, alloc_size);\n}"
  },
  {
    "function_name": "vio_dma_iommu_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "553-586",
    "snippet": "static int vio_dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,\n                                int nelems, enum dma_data_direction direction,\n                                struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tstruct scatterlist *sgl;\n\tint ret, count;\n\tsize_t alloc_size = 0;\n\n\ttbl = get_iommu_table_base(dev);\n\tfor_each_sg(sglist, sgl, nelems, count)\n\t\talloc_size += roundup(sgl->length, IOMMU_PAGE_SIZE(tbl));\n\n\tif (vio_cmo_alloc(viodev, alloc_size)) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn 0;\n\t}\n\n\tret = dma_iommu_ops.map_sg(dev, sglist, nelems, direction, attrs);\n\n\tif (unlikely(!ret)) {\n\t\tvio_cmo_dealloc(viodev, alloc_size);\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn ret;\n\t}\n\n\tfor_each_sg(sglist, sgl, ret, count)\n\t\talloc_size -= roundup(sgl->dma_length, IOMMU_PAGE_SIZE(tbl));\n\tif (alloc_size)\n\t\tvio_cmo_dealloc(viodev, alloc_size);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "alloc_size"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "sgl->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "sgl",
            "ret",
            "count"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ret"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.map_sg",
          "args": [
            "dev",
            "sglist",
            "nelems",
            "direction",
            "attrs"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_alloc",
          "args": [
            "viodev",
            "alloc_size"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "146-176",
          "snippet": "static inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "sgl->length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "sgl",
            "nelems",
            "count"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,\n                                int nelems, enum dma_data_direction direction,\n                                struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tstruct scatterlist *sgl;\n\tint ret, count;\n\tsize_t alloc_size = 0;\n\n\ttbl = get_iommu_table_base(dev);\n\tfor_each_sg(sglist, sgl, nelems, count)\n\t\talloc_size += roundup(sgl->length, IOMMU_PAGE_SIZE(tbl));\n\n\tif (vio_cmo_alloc(viodev, alloc_size)) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn 0;\n\t}\n\n\tret = dma_iommu_ops.map_sg(dev, sglist, nelems, direction, attrs);\n\n\tif (unlikely(!ret)) {\n\t\tvio_cmo_dealloc(viodev, alloc_size);\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn ret;\n\t}\n\n\tfor_each_sg(sglist, sgl, ret, count)\n\t\talloc_size -= roundup(sgl->dma_length, IOMMU_PAGE_SIZE(tbl));\n\tif (alloc_size)\n\t\tvio_cmo_dealloc(viodev, alloc_size);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_dma_iommu_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "539-551",
    "snippet": "static void vio_dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t     size_t size,\n\t\t\t\t     enum dma_data_direction direction,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\n\ttbl = get_iommu_table_base(dev);\n\tdma_iommu_ops.unmap_page(dev, dma_handle, size, direction, attrs);\n\n\tvio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)));\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "roundup(size, IOMMU_PAGE_SIZE(tbl))"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.unmap_page",
          "args": [
            "dev",
            "dma_handle",
            "size",
            "direction",
            "attrs"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t     size_t size,\n\t\t\t\t     enum dma_data_direction direction,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\n\ttbl = get_iommu_table_base(dev);\n\tdma_iommu_ops.unmap_page(dev, dma_handle, size, direction, attrs);\n\n\tvio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)));\n}"
  },
  {
    "function_name": "vio_dma_iommu_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "515-537",
    "snippet": "static dma_addr_t vio_dma_iommu_map_page(struct device *dev, struct page *page,\n                                         unsigned long offset, size_t size,\n                                         enum dma_data_direction direction,\n                                         struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\n\ttbl = get_iommu_table_base(dev);\n\tif (vio_cmo_alloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)))) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn ret;\n\t}\n\n\tret = dma_iommu_ops.map_page(dev, page, offset, size, direction, attrs);\n\tif (unlikely(dma_mapping_error(dev, ret))) {\n\t\tvio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)));\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "roundup(size, IOMMU_PAGE_SIZE(tbl))"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_mapping_error(dev, ret)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "dev",
            "ret"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.map_page",
          "args": [
            "dev",
            "page",
            "offset",
            "size",
            "direction",
            "attrs"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_alloc",
          "args": [
            "viodev",
            "roundup(size, IOMMU_PAGE_SIZE(tbl))"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "146-176",
          "snippet": "static inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic dma_addr_t vio_dma_iommu_map_page(struct device *dev, struct page *page,\n                                         unsigned long offset, size_t size,\n                                         enum dma_data_direction direction,\n                                         struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tstruct iommu_table *tbl;\n\tdma_addr_t ret = DMA_ERROR_CODE;\n\n\ttbl = get_iommu_table_base(dev);\n\tif (vio_cmo_alloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)))) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn ret;\n\t}\n\n\tret = dma_iommu_ops.map_page(dev, page, offset, size, direction, attrs);\n\tif (unlikely(dma_mapping_error(dev, ret))) {\n\t\tvio_cmo_dealloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)));\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_dma_iommu_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "504-513",
    "snippet": "static void vio_dma_iommu_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\n\tdma_iommu_ops.free(dev, size, vaddr, dma_handle, attrs);\n\n\tvio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "roundup(size, PAGE_SIZE)"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.free",
          "args": [
            "dev",
            "size",
            "vaddr",
            "dma_handle",
            "attrs"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void vio_dma_iommu_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\tvoid *vaddr, dma_addr_t dma_handle,\n\t\t\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\n\tdma_iommu_ops.free(dev, size, vaddr, dma_handle, attrs);\n\n\tvio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));\n}"
  },
  {
    "function_name": "vio_dma_iommu_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "483-502",
    "snippet": "static void *vio_dma_iommu_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t\t  struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tvoid *ret;\n\n\tif (vio_cmo_alloc(viodev, roundup(size, PAGE_SIZE))) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn NULL;\n\t}\n\n\tret = dma_iommu_ops.alloc(dev, size, dma_handle, flag, attrs);\n\tif (unlikely(ret == NULL)) {\n\t\tvio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_dealloc",
          "args": [
            "viodev",
            "roundup(size, PAGE_SIZE)"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "190-266",
          "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define VIO_CMO_BALANCE_DELAY 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == NULL"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_iommu_ops.alloc",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "flag",
            "attrs"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&viodev->cmo.allocs_failed"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_alloc",
          "args": [
            "viodev",
            "roundup(size, PAGE_SIZE)"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "146-176",
          "snippet": "static inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vio_dev",
          "args": [
            "dev"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic void *vio_dma_iommu_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t\t  dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t\t  struct dma_attrs *attrs)\n{\n\tstruct vio_dev *viodev = to_vio_dev(dev);\n\tvoid *ret;\n\n\tif (vio_cmo_alloc(viodev, roundup(size, PAGE_SIZE))) {\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t\treturn NULL;\n\t}\n\n\tret = dma_iommu_ops.alloc(dev, size, dma_handle, flag, attrs);\n\tif (unlikely(ret == NULL)) {\n\t\tvio_cmo_dealloc(viodev, roundup(size, PAGE_SIZE));\n\t\tatomic_inc(&viodev->cmo.allocs_failed);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_cmo_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "387-481",
    "snippet": "static void vio_cmo_balance(struct work_struct *work)\n{\n\tstruct vio_cmo *cmo;\n\tstruct vio_dev *viodev;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t avail = 0, level, chunk, need;\n\tint devcount = 0, fulfilled;\n\n\tcmo = container_of(work, struct vio_cmo, balance_q.work);\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Calculate minimum entitlement and fulfill spare */\n\tcmo->min = vio_cmo_num_OF_devs() * VIO_CMO_MIN_ENT;\n\tBUG_ON(cmo->min > cmo->entitled);\n\tcmo->spare = min_t(size_t, VIO_CMO_MIN_ENT, (cmo->entitled - cmo->min));\n\tcmo->min += cmo->spare;\n\tcmo->desired = cmo->min;\n\n\t/*\n\t * Determine how much entitlement is available and reset device\n\t * entitlements\n\t */\n\tavail = cmo->entitled - cmo->spare;\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tviodev = dev_ent->viodev;\n\t\tdevcount++;\n\t\tviodev->cmo.entitled = VIO_CMO_MIN_ENT;\n\t\tcmo->desired += (viodev->cmo.desired - VIO_CMO_MIN_ENT);\n\t\tavail -= max_t(size_t, viodev->cmo.allocated, VIO_CMO_MIN_ENT);\n\t}\n\n\t/*\n\t * Having provided each device with the minimum entitlement, loop\n\t * over the devices portioning out the remaining entitlement\n\t * until there is nothing left.\n\t */\n\tlevel = VIO_CMO_MIN_ENT;\n\twhile (avail) {\n\t\tfulfilled = 0;\n\t\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\t\tviodev = dev_ent->viodev;\n\n\t\t\tif (viodev->cmo.desired <= level) {\n\t\t\t\tfulfilled++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Give the device up to VIO_CMO_BALANCE_CHUNK\n\t\t\t * bytes of entitlement, but do not exceed the\n\t\t\t * desired level of entitlement for the device.\n\t\t\t */\n\t\t\tchunk = min_t(size_t, avail, VIO_CMO_BALANCE_CHUNK);\n\t\t\tchunk = min(chunk, (viodev->cmo.desired -\n\t\t\t                    viodev->cmo.entitled));\n\t\t\tviodev->cmo.entitled += chunk;\n\n\t\t\t/*\n\t\t\t * If the memory for this entitlement increase was\n\t\t\t * already allocated to the device it does not come\n\t\t\t * from the available pool being portioned out.\n\t\t\t */\n\t\t\tneed = max(viodev->cmo.allocated, viodev->cmo.entitled)-\n\t\t\t       max(viodev->cmo.allocated, level);\n\t\t\tavail -= need;\n\n\t\t}\n\t\tif (fulfilled == devcount)\n\t\t\tbreak;\n\t\tlevel += VIO_CMO_BALANCE_CHUNK;\n\t}\n\n\t/* Calculate new reserve and excess pool sizes */\n\tcmo->reserve.size = cmo->min;\n\tcmo->excess.free = 0;\n\tcmo->excess.size = 0;\n\tneed = 0;\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tviodev = dev_ent->viodev;\n\t\t/* Calculated reserve size above the minimum entitlement */\n\t\tif (viodev->cmo.entitled)\n\t\t\tcmo->reserve.size += (viodev->cmo.entitled -\n\t\t\t                      VIO_CMO_MIN_ENT);\n\t\t/* Calculated used excess entitlement */\n\t\tif (viodev->cmo.allocated > viodev->cmo.entitled)\n\t\t\tneed += viodev->cmo.allocated - viodev->cmo.entitled;\n\t}\n\tcmo->excess.size = cmo->entitled - cmo->reserve.size;\n\tcmo->excess.free = cmo->excess.size - need;\n\n\tcancel_delayed_work(to_delayed_work(work));\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define VIO_CMO_BALANCE_CHUNK 131072"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "to_delayed_work(work)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "viodev->cmo.allocated",
            "level"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "viodev->cmo.allocated",
            "viodev->cmo.entitled"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "chunk",
            "(viodev->cmo.desired -\n\t\t\t                    viodev->cmo.entitled)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "avail",
            "VIO_CMO_BALANCE_CHUNK"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "viodev->cmo.allocated",
            "VIO_CMO_MIN_ENT"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "VIO_CMO_MIN_ENT",
            "(cmo->entitled - cmo->min)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cmo->min > cmo->entitled"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vio_cmo_num_OF_devs",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "vio_cmo_num_OF_devs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
          "lines": "107-130",
          "snippet": "static int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/page.h>",
            "#include <asm/tce.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/vio.h>",
            "#include <asm/dma.h>",
            "#include <asm/iommu.h>",
            "#include <linux/kobject.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/console.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structvio_cmo",
            "balance_q.work"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_CHUNK 131072\n\nstatic void vio_cmo_balance(struct work_struct *work)\n{\n\tstruct vio_cmo *cmo;\n\tstruct vio_dev *viodev;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t avail = 0, level, chunk, need;\n\tint devcount = 0, fulfilled;\n\n\tcmo = container_of(work, struct vio_cmo, balance_q.work);\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Calculate minimum entitlement and fulfill spare */\n\tcmo->min = vio_cmo_num_OF_devs() * VIO_CMO_MIN_ENT;\n\tBUG_ON(cmo->min > cmo->entitled);\n\tcmo->spare = min_t(size_t, VIO_CMO_MIN_ENT, (cmo->entitled - cmo->min));\n\tcmo->min += cmo->spare;\n\tcmo->desired = cmo->min;\n\n\t/*\n\t * Determine how much entitlement is available and reset device\n\t * entitlements\n\t */\n\tavail = cmo->entitled - cmo->spare;\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tviodev = dev_ent->viodev;\n\t\tdevcount++;\n\t\tviodev->cmo.entitled = VIO_CMO_MIN_ENT;\n\t\tcmo->desired += (viodev->cmo.desired - VIO_CMO_MIN_ENT);\n\t\tavail -= max_t(size_t, viodev->cmo.allocated, VIO_CMO_MIN_ENT);\n\t}\n\n\t/*\n\t * Having provided each device with the minimum entitlement, loop\n\t * over the devices portioning out the remaining entitlement\n\t * until there is nothing left.\n\t */\n\tlevel = VIO_CMO_MIN_ENT;\n\twhile (avail) {\n\t\tfulfilled = 0;\n\t\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\t\tviodev = dev_ent->viodev;\n\n\t\t\tif (viodev->cmo.desired <= level) {\n\t\t\t\tfulfilled++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Give the device up to VIO_CMO_BALANCE_CHUNK\n\t\t\t * bytes of entitlement, but do not exceed the\n\t\t\t * desired level of entitlement for the device.\n\t\t\t */\n\t\t\tchunk = min_t(size_t, avail, VIO_CMO_BALANCE_CHUNK);\n\t\t\tchunk = min(chunk, (viodev->cmo.desired -\n\t\t\t                    viodev->cmo.entitled));\n\t\t\tviodev->cmo.entitled += chunk;\n\n\t\t\t/*\n\t\t\t * If the memory for this entitlement increase was\n\t\t\t * already allocated to the device it does not come\n\t\t\t * from the available pool being portioned out.\n\t\t\t */\n\t\t\tneed = max(viodev->cmo.allocated, viodev->cmo.entitled)-\n\t\t\t       max(viodev->cmo.allocated, level);\n\t\t\tavail -= need;\n\n\t\t}\n\t\tif (fulfilled == devcount)\n\t\t\tbreak;\n\t\tlevel += VIO_CMO_BALANCE_CHUNK;\n\t}\n\n\t/* Calculate new reserve and excess pool sizes */\n\tcmo->reserve.size = cmo->min;\n\tcmo->excess.free = 0;\n\tcmo->excess.size = 0;\n\tneed = 0;\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tviodev = dev_ent->viodev;\n\t\t/* Calculated reserve size above the minimum entitlement */\n\t\tif (viodev->cmo.entitled)\n\t\t\tcmo->reserve.size += (viodev->cmo.entitled -\n\t\t\t                      VIO_CMO_MIN_ENT);\n\t\t/* Calculated used excess entitlement */\n\t\tif (viodev->cmo.allocated > viodev->cmo.entitled)\n\t\t\tneed += viodev->cmo.allocated - viodev->cmo.entitled;\n\t}\n\tcmo->excess.size = cmo->entitled - cmo->reserve.size;\n\tcmo->excess.free = cmo->excess.size - need;\n\n\tcancel_delayed_work(to_delayed_work(work));\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
  },
  {
    "function_name": "vio_cmo_entitlement_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "279-364",
    "snippet": "int vio_cmo_entitlement_update(size_t new_entitlement)\n{\n\tstruct vio_dev *viodev;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t avail, delta, tmp;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Entitlement increases */\n\tif (new_entitlement > vio_cmo.entitled) {\n\t\tdelta = new_entitlement - vio_cmo.entitled;\n\n\t\t/* Fulfill spare allocation */\n\t\tif (vio_cmo.spare < VIO_CMO_MIN_ENT) {\n\t\t\ttmp = min(delta, (VIO_CMO_MIN_ENT - vio_cmo.spare));\n\t\t\tvio_cmo.spare += tmp;\n\t\t\tvio_cmo.reserve.size += tmp;\n\t\t\tdelta -= tmp;\n\t\t}\n\n\t\t/* Remaining new allocation goes to the excess pool */\n\t\tvio_cmo.entitled += delta;\n\t\tvio_cmo.excess.size += delta;\n\t\tvio_cmo.excess.free += delta;\n\n\t\tgoto out;\n\t}\n\n\t/* Entitlement decreases */\n\tdelta = vio_cmo.entitled - new_entitlement;\n\tavail = vio_cmo.excess.free;\n\n\t/*\n\t * Need to check how much unused entitlement each device can\n\t * sacrifice to fulfill entitlement change.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tif (avail >= delta)\n\t\t\tbreak;\n\n\t\tviodev = dev_ent->viodev;\n\t\tif ((viodev->cmo.entitled > viodev->cmo.allocated) &&\n\t\t    (viodev->cmo.entitled > VIO_CMO_MIN_ENT))\n\t\t\t\tavail += viodev->cmo.entitled -\n\t\t\t\t         max_t(size_t, viodev->cmo.allocated,\n\t\t\t\t               VIO_CMO_MIN_ENT);\n\t}\n\n\tif (delta <= avail) {\n\t\tvio_cmo.entitled -= delta;\n\n\t\t/* Take entitlement from the excess pool first */\n\t\ttmp = min(vio_cmo.excess.free, delta);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.excess.free -= tmp;\n\t\tdelta -= tmp;\n\n\t\t/*\n\t\t * Remove all but VIO_CMO_MIN_ENT bytes from devices\n\t\t * until entitlement change is served\n\t\t */\n\t\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\t\tif (!delta)\n\t\t\t\tbreak;\n\n\t\t\tviodev = dev_ent->viodev;\n\t\t\ttmp = 0;\n\t\t\tif ((viodev->cmo.entitled > viodev->cmo.allocated) &&\n\t\t\t    (viodev->cmo.entitled > VIO_CMO_MIN_ENT))\n\t\t\t\ttmp = viodev->cmo.entitled -\n\t\t\t\t      max_t(size_t, viodev->cmo.allocated,\n\t\t\t\t            VIO_CMO_MIN_ENT);\n\t\t\tviodev->cmo.entitled -= min(tmp, delta);\n\t\t\tdelta -= min(tmp, delta);\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\nout:\n\tschedule_delayed_work(&vio_cmo.balance_q, 0);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&vio_cmo.balance_q",
            "0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "tmp",
            "delta"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "tmp",
            "delta"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "viodev->cmo.allocated",
            "VIO_CMO_MIN_ENT"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vio_cmo.excess.free",
            "delta"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "viodev->cmo.allocated",
            "VIO_CMO_MIN_ENT"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev_ent",
            "&vio_cmo.device_list",
            "list"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "(VIO_CMO_MIN_ENT - vio_cmo.spare)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nint vio_cmo_entitlement_update(size_t new_entitlement)\n{\n\tstruct vio_dev *viodev;\n\tstruct vio_cmo_dev_entry *dev_ent;\n\tunsigned long flags;\n\tsize_t avail, delta, tmp;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Entitlement increases */\n\tif (new_entitlement > vio_cmo.entitled) {\n\t\tdelta = new_entitlement - vio_cmo.entitled;\n\n\t\t/* Fulfill spare allocation */\n\t\tif (vio_cmo.spare < VIO_CMO_MIN_ENT) {\n\t\t\ttmp = min(delta, (VIO_CMO_MIN_ENT - vio_cmo.spare));\n\t\t\tvio_cmo.spare += tmp;\n\t\t\tvio_cmo.reserve.size += tmp;\n\t\t\tdelta -= tmp;\n\t\t}\n\n\t\t/* Remaining new allocation goes to the excess pool */\n\t\tvio_cmo.entitled += delta;\n\t\tvio_cmo.excess.size += delta;\n\t\tvio_cmo.excess.free += delta;\n\n\t\tgoto out;\n\t}\n\n\t/* Entitlement decreases */\n\tdelta = vio_cmo.entitled - new_entitlement;\n\tavail = vio_cmo.excess.free;\n\n\t/*\n\t * Need to check how much unused entitlement each device can\n\t * sacrifice to fulfill entitlement change.\n\t */\n\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\tif (avail >= delta)\n\t\t\tbreak;\n\n\t\tviodev = dev_ent->viodev;\n\t\tif ((viodev->cmo.entitled > viodev->cmo.allocated) &&\n\t\t    (viodev->cmo.entitled > VIO_CMO_MIN_ENT))\n\t\t\t\tavail += viodev->cmo.entitled -\n\t\t\t\t         max_t(size_t, viodev->cmo.allocated,\n\t\t\t\t               VIO_CMO_MIN_ENT);\n\t}\n\n\tif (delta <= avail) {\n\t\tvio_cmo.entitled -= delta;\n\n\t\t/* Take entitlement from the excess pool first */\n\t\ttmp = min(vio_cmo.excess.free, delta);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.excess.free -= tmp;\n\t\tdelta -= tmp;\n\n\t\t/*\n\t\t * Remove all but VIO_CMO_MIN_ENT bytes from devices\n\t\t * until entitlement change is served\n\t\t */\n\t\tlist_for_each_entry(dev_ent, &vio_cmo.device_list, list) {\n\t\t\tif (!delta)\n\t\t\t\tbreak;\n\n\t\t\tviodev = dev_ent->viodev;\n\t\t\ttmp = 0;\n\t\t\tif ((viodev->cmo.entitled > viodev->cmo.allocated) &&\n\t\t\t    (viodev->cmo.entitled > VIO_CMO_MIN_ENT))\n\t\t\t\ttmp = viodev->cmo.entitled -\n\t\t\t\t      max_t(size_t, viodev->cmo.allocated,\n\t\t\t\t            VIO_CMO_MIN_ENT);\n\t\t\tviodev->cmo.entitled -= min(tmp, delta);\n\t\t\tdelta -= min(tmp, delta);\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\nout:\n\tschedule_delayed_work(&vio_cmo.balance_q, 0);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "vio_cmo_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "190-266",
    "snippet": "static inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define VIO_CMO_BALANCE_DELAY 100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&vio_cmo.balance_q",
            "VIO_CMO_BALANCE_DELAY"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "excess_freed",
            "(vio_cmo.desired - vio_cmo.reserve.size)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "spare_needed",
            "reserve_freed",
            "(viodev->cmo.entitled - VIO_CMO_MIN_ENT)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "excess_freed",
            "spare_needed"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "reserve_freed",
            "(viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\n#define VIO_CMO_BALANCE_DELAY 100\n\nstatic inline void vio_cmo_dealloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t spare_needed = 0;\n\tsize_t excess_freed = 0;\n\tsize_t reserve_freed = size;\n\tsize_t tmp;\n\tint balance = 0;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\tvio_cmo.curr -= size;\n\n\t/* Amount of memory freed from the excess pool */\n\tif (viodev->cmo.allocated > viodev->cmo.entitled) {\n\t\texcess_freed = min(reserve_freed, (viodev->cmo.allocated -\n\t\t                                   viodev->cmo.entitled));\n\t\treserve_freed -= excess_freed;\n\t}\n\n\t/* Remove allocation from device */\n\tviodev->cmo.allocated -= (reserve_freed + excess_freed);\n\n\t/* Spare is a subset of the reserve pool, replenish it first. */\n\tspare_needed = VIO_CMO_MIN_ENT - vio_cmo.spare;\n\n\t/*\n\t * Replenish the spare in the reserve pool from the excess pool.\n\t * This moves entitlement into the reserve pool.\n\t */\n\tif (spare_needed && excess_freed) {\n\t\ttmp = min(excess_freed, spare_needed);\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\tvio_cmo.spare += tmp;\n\t\texcess_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Replenish the spare in the reserve pool from the reserve pool.\n\t * This removes entitlement from the device down to VIO_CMO_MIN_ENT,\n\t * if needed, and gives it to the spare pool. The amount of used\n\t * memory in this pool does not change.\n\t */\n\tif (spare_needed && reserve_freed) {\n\t\ttmp = min3(spare_needed, reserve_freed, (viodev->cmo.entitled - VIO_CMO_MIN_ENT));\n\n\t\tvio_cmo.spare += tmp;\n\t\tviodev->cmo.entitled -= tmp;\n\t\treserve_freed -= tmp;\n\t\tspare_needed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/*\n\t * Increase the reserve pool until the desired allocation is met.\n\t * Move an allocation freed from the excess pool into the reserve\n\t * pool and schedule a balance operation.\n\t */\n\tif (excess_freed && (vio_cmo.desired > vio_cmo.reserve.size)) {\n\t\ttmp = min(excess_freed, (vio_cmo.desired - vio_cmo.reserve.size));\n\n\t\tvio_cmo.excess.size -= tmp;\n\t\tvio_cmo.reserve.size += tmp;\n\t\texcess_freed -= tmp;\n\t\tbalance = 1;\n\t}\n\n\t/* Return memory from the excess pool to that pool */\n\tif (excess_freed)\n\t\tvio_cmo.excess.free += excess_freed;\n\n\tif (balance)\n\t\tschedule_delayed_work(&vio_cmo.balance_q, VIO_CMO_BALANCE_DELAY);\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n}"
  },
  {
    "function_name": "vio_cmo_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "146-176",
    "snippet": "static inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "reserve_free",
            "size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&vio_cmo.lock",
            "flags"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic inline int vio_cmo_alloc(struct vio_dev *viodev, size_t size)\n{\n\tunsigned long flags;\n\tsize_t reserve_free = 0;\n\tsize_t excess_free = 0;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&vio_cmo.lock, flags);\n\n\t/* Determine the amount of free entitlement available in reserve */\n\tif (viodev->cmo.entitled > viodev->cmo.allocated)\n\t\treserve_free = viodev->cmo.entitled - viodev->cmo.allocated;\n\n\t/* If spare is not fulfilled, the excess pool can not be used. */\n\tif (vio_cmo.spare >= VIO_CMO_MIN_ENT)\n\t\texcess_free = vio_cmo.excess.free;\n\n\t/* The request can be satisfied */\n\tif ((reserve_free + excess_free) >= size) {\n\t\tvio_cmo.curr += size;\n\t\tif (vio_cmo.curr > vio_cmo.high)\n\t\t\tvio_cmo.high = vio_cmo.curr;\n\t\tviodev->cmo.allocated += size;\n\t\tsize -= min(reserve_free, size);\n\t\tvio_cmo.excess.free -= size;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vio_cmo.lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "vio_cmo_num_OF_devs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/vio.c",
    "lines": "107-130",
    "snippet": "static int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/page.h>",
      "#include <asm/tce.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/vio.h>",
      "#include <asm/dma.h>",
      "#include <asm/iommu.h>",
      "#include <linux/kobject.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/console.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/device.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "node_vroot"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "of_node",
            "\"ibm,my-dma-window\"",
            "NULL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_child_of_node",
          "args": [
            "node_vroot",
            "of_node"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "\"vdevice\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/page.h>\n#include <asm/tce.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/vio.h>\n#include <asm/dma.h>\n#include <asm/iommu.h>\n#include <linux/kobject.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/cpu.h>\n\nstatic int vio_cmo_num_OF_devs(void)\n{\n\tstruct device_node *node_vroot;\n\tint count = 0;\n\n\t/*\n\t * Count the number of vdevice entries with an\n\t * ibm,my-dma-window OF property\n\t */\n\tnode_vroot = of_find_node_by_name(NULL, \"vdevice\");\n\tif (node_vroot) {\n\t\tstruct device_node *of_node;\n\t\tstruct property *prop;\n\n\t\tfor_each_child_of_node(node_vroot, of_node) {\n\t\t\tprop = of_find_property(of_node, \"ibm,my-dma-window\",\n\t\t\t                       NULL);\n\t\t\tif (prop)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tof_node_put(node_vroot);\n\treturn count;\n}"
  }
]