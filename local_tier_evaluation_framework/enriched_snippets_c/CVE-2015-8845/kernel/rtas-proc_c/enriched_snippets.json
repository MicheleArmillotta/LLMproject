[
  {
    "function_name": "ppc_rtas_rmo_buf_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "784-788",
    "snippet": "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%016lx %x\\n\", rtas_rmo_buf, RTAS_RMOBUF_MAX);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%016lx %x\\n\"",
            "rtas_rmo_buf",
            "RTAS_RMOBUF_MAX"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%016lx %x\\n\", rtas_rmo_buf, RTAS_RMOBUF_MAX);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_volume_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "775-779",
    "snippet": "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_volume);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rtas_tone_volume = 0;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "rtas_tone_volume"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long rtas_tone_volume = 0;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_volume);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_volume_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "755-773",
    "snippet": "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long volume;\n\tint error = parse_number(buf, count, &volume);\n\tif (error)\n\t\treturn error;\n\n\tif (volume > 100)\n\t\tvolume = 100;\n\t\n        rtas_tone_volume = volume; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_VOLUME, 0, volume);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone volume returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define TONE_VOLUME\t\t0x0002 /* 0 - 100 (%) */"
    ],
    "globals_used": [
      "static unsigned long rtas_tone_volume = 0;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting tone volume returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-indicator\")",
            "3",
            "1",
            "NULL",
            "TONE_VOLUME",
            "0",
            "volume"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&volume"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "282-300",
          "snippet": "static int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define TONE_VOLUME\t\t0x0002 /* 0 - 100 (%) */\n\nstatic unsigned long rtas_tone_volume = 0;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long volume;\n\tint error = parse_number(buf, count, &volume);\n\tif (error)\n\t\treturn error;\n\n\tif (volume > 100)\n\t\tvolume = 100;\n\t\n        rtas_tone_volume = volume; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_VOLUME, 0, volume);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone volume returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_freq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "747-751",
    "snippet": "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_frequency);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rtas_tone_frequency = 1000;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "rtas_tone_frequency"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long rtas_tone_frequency = 1000;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_frequency);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_freq_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "730-745",
    "snippet": "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long freq;\n\tint error = parse_number(buf, count, &freq);\n\tif (error)\n\t\treturn error;\n\n\trtas_tone_frequency = freq; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_FREQUENCY, 0, freq);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone frequency returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define TONE_FREQUENCY\t\t0x0001 /* 0 - 1000 (HZ)*/"
    ],
    "globals_used": [
      "static unsigned long rtas_tone_frequency = 1000;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting tone frequency returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-indicator\")",
            "3",
            "1",
            "NULL",
            "TONE_FREQUENCY",
            "0",
            "freq"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&freq"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "282-300",
          "snippet": "static int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define TONE_FREQUENCY\t\t0x0001 /* 0 - 1000 (HZ)*/\n\nstatic unsigned long rtas_tone_frequency = 1000;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long freq;\n\tint error = parse_number(buf, count, &freq);\n\tif (error)\n\t\treturn error;\n\n\trtas_tone_frequency = freq; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_FREQUENCY, 0, freq);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone frequency returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "get_location_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "717-726",
    "snippet": "static void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "' '"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_location_string",
          "args": [
            "m",
            "loc"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "check_location_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "703-712",
          "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_location_string(struct seq_file *m, const char *c);",
            "static void check_location(struct seq_file *m, const char *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"---\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}"
  },
  {
    "function_name": "check_location_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "703-712",
    "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_location_string(struct seq_file *m, const char *c);",
      "static void check_location(struct seq_file *m, const char *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" at \""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_location",
          "args": [
            "m",
            "c"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "check_location_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "703-712",
          "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "*c"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}"
  },
  {
    "function_name": "check_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "666-694",
    "snippet": "static void check_location(struct seq_file *m, const char *c)\n{\n\tswitch (c[0]) {\n\t\tcase LOC_PLANAR:\n\t\t\tseq_printf(m, \"Planar #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_CPU:\n\t\t\tseq_printf(m, \"CPU #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_FAN:\n\t\t\tseq_printf(m, \"Fan #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_RACKMOUNTED:\n\t\t\tseq_printf(m, \"Rack #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_LCD:\n\t\t\tseq_printf(m, \"LCD #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tseq_printf(m, \"- %c\", c[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"Unknown location\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define LOC_VOLTAGE\t\t'V'",
      "#define LOC_RACKMOUNTED\t\t'U' /* for _u_nit is rack mounted */",
      "#define LOC_PLANAR\t\t'P'",
      "#define LOC_LCD\t\t\t'L'",
      "#define LOC_FAN\t\t\t'F'",
      "#define LOC_CPU\t\t\t'C'"
    ],
    "globals_used": [
      "static void check_location_string(struct seq_file *m, const char *c);",
      "static void check_location(struct seq_file *m, const char *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Unknown location\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"- %c\"",
            "c[1]"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"LCD #%c\"",
            "c[1]"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Voltage #%c\"",
            "c[1]"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Rack #%c\"",
            "c[1]"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Fan #%c\"",
            "c[1]"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"CPU #%c\"",
            "c[1]"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Planar #%c\"",
            "c[1]"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LOC_VOLTAGE\t\t'V'\n#define LOC_RACKMOUNTED\t\t'U' /* for _u_nit is rack mounted */\n#define LOC_PLANAR\t\t'P'\n#define LOC_LCD\t\t\t'L'\n#define LOC_FAN\t\t\t'F'\n#define LOC_CPU\t\t\t'C'\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location(struct seq_file *m, const char *c)\n{\n\tswitch (c[0]) {\n\t\tcase LOC_PLANAR:\n\t\t\tseq_printf(m, \"Planar #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_CPU:\n\t\t\tseq_printf(m, \"CPU #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_FAN:\n\t\t\tseq_printf(m, \"Fan #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_RACKMOUNTED:\n\t\t\tseq_printf(m, \"Rack #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_LCD:\n\t\t\tseq_printf(m, \"LCD #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tseq_printf(m, \"- %c\", c[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"Unknown location\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_process_sensor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "513-662",
    "snippet": "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharching\", \n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */",
      "#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */",
      "#define IBM_VOLTAGE\t\t0x232a /* 9002 */",
      "#define IBM_FANRPM\t\t0x2329 /* 9001 */",
      "#define IBM_SURVEILLANCE\t0x2328 /* 9000 */",
      "#define BATTERY_CHARGING\t0x000b",
      "#define BATTERY_CYCLESTATE\t0x000a",
      "#define EPOW_SENSOR\t\t0x0009",
      "#define BATTERY_PERCENTAGE\t0x0008",
      "#define BATTERY_REMAINING\t0x0007",
      "#define BATTERY_VOLTAGE\t\t0x0006",
      "#define POWER_SOURCE\t\t0x0005",
      "#define LID_STATUS\t\t0x0004",
      "#define THERMAL_SENSOR\t\t0x0003",
      "#define ENCLOSURE_SWITCH\t0x0002",
      "#define KEY_SWITCH\t\t0x0001"
    ],
    "globals_used": [
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static char *ppc_rtas_process_error(int error);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_location_code",
          "args": [
            "m",
            "s",
            "loc"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "get_location_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "717-726",
          "snippet": "static void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
            "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%10d\\t\"",
            "state"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%4d /%4d\\t\"",
            "state",
            "cel_to_fahr(state)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cel_to_fahr",
          "args": [
            "state"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Unknown sensor (type %d), ignoring it\\n\"",
            "s->token"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Powersupply:\\t\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "ibm_drconnector[state]"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"DR connector:\\t\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Voltage (mv):\\t\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Fan (rpm):\\t\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Surveillance:\\t\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_charging[state]"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery Charging:\\t\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_cyclestate[state]"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery cyclestate:\\t\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "epow_sensor[state]"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EPOW Sensor:\\t\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery percentage:\\t\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_remaining[state]"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery remaining:\\t\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery voltage:\\t\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "power_source[state]"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Power source:\\t\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "lid_status[state]"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Lid status:\\t\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Temp. (C/F):\\t\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "enclosure_switch[state]"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Enclosure switch:\\t\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "key_switch[state]"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Key switch:\\t\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */\n#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */\n#define IBM_VOLTAGE\t\t0x232a /* 9002 */\n#define IBM_FANRPM\t\t0x2329 /* 9001 */\n#define IBM_SURVEILLANCE\t0x2328 /* 9000 */\n#define BATTERY_CHARGING\t0x000b\n#define BATTERY_CYCLESTATE\t0x000a\n#define EPOW_SENSOR\t\t0x0009\n#define BATTERY_PERCENTAGE\t0x0008\n#define BATTERY_REMAINING\t0x0007\n#define BATTERY_VOLTAGE\t\t0x0006\n#define POWER_SOURCE\t\t0x0005\n#define LID_STATUS\t\t0x0004\n#define THERMAL_SENSOR\t\t0x0003\n#define ENCLOSURE_SWITCH\t0x0002\n#define KEY_SWITCH\t\t0x0001\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharching\", \n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_process_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "480-506",
    "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define SENSOR_DR_ENTITY\t-9000",
      "#define SENSOR_NOT_EXIST\t-3",
      "#define SENSOR_BUSY\t\t-2",
      "#define SENSOR_HW_ERROR\t\t-1",
      "#define SENSOR_SUCCESS\t\t 0",
      "#define SENSOR_CRITICAL_LOW\t 9",
      "#define SENSOR_WARNING_LOW\t10",
      "#define SENSOR_NORMAL\t\t11",
      "#define SENSOR_WARNING_HIGH\t12",
      "#define SENSOR_CRITICAL_HIGH\t13"
    ],
    "globals_used": [
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_find_all_sensors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "456-474",
    "snippet": "static int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static int ppc_rtas_find_all_sensors(void);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"error: could not get rtas-sensors\\n\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas_node",
            "\"rtas-sensors\"",
            "&len"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_find_all_sensors(void);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_sensors_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "412-452",
    "snippet": "static int ppc_rtas_sensors_show(struct seq_file *m, void *v)\n{\n\tint i,j;\n\tint state, error;\n\tint get_sensor_state = rtas_token(\"get-sensor-state\");\n\n\tseq_printf(m, \"RTAS (RunTime Abstraction Services) Sensor Information\\n\");\n\tseq_printf(m, \"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\");\n\tseq_printf(m, \"********************************************************\\n\");\n\n\tif (ppc_rtas_find_all_sensors() != 0) {\n\t\tseq_printf(m, \"\\nNo sensors are available\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tstruct individual_sensor *p = &sensors.sensor[i];\n\t\tchar rstr[64];\n\t\tconst char *loc;\n\t\tint llen, offs;\n\n\t\tsprintf (rstr, SENSOR_PREFIX\"%04d\", p->token);\n\t\tloc = of_get_property(rtas_node, rstr, &llen);\n\n\t\t/* A sensor may have multiple instances */\n\t\tfor (j = 0, offs = 0; j <= p->quant; j++) {\n\t\t\terror =\trtas_call(get_sensor_state, 2, 2, &state, \n\t\t\t\t  \t  p->token, j);\n\n\t\t\tppc_rtas_process_sensor(m, p, state, error, loc);\n\t\t\tseq_putc(m, '\\n');\n\t\t\tif (loc) {\n\t\t\t\toffs += strlen(loc) + 1;\n\t\t\t\tloc += strlen(loc) + 1;\n\t\t\t\tif (offs >= llen)\n\t\t\t\t\tloc = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define SENSOR_PREFIX\t\t\"ibm,sensor-\""
    ],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_find_all_sensors(void);",
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static char *ppc_rtas_process_error(int error);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "loc"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "loc"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_sensor",
          "args": [
            "m",
            "p",
            "state",
            "error",
            "loc"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_sensor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "513-662",
          "snippet": "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharching\", \n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */",
            "#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */",
            "#define IBM_VOLTAGE\t\t0x232a /* 9002 */",
            "#define IBM_FANRPM\t\t0x2329 /* 9001 */",
            "#define IBM_SURVEILLANCE\t0x2328 /* 9000 */",
            "#define BATTERY_CHARGING\t0x000b",
            "#define BATTERY_CYCLESTATE\t0x000a",
            "#define EPOW_SENSOR\t\t0x0009",
            "#define BATTERY_PERCENTAGE\t0x0008",
            "#define BATTERY_REMAINING\t0x0007",
            "#define BATTERY_VOLTAGE\t\t0x0006",
            "#define POWER_SOURCE\t\t0x0005",
            "#define LID_STATUS\t\t0x0004",
            "#define THERMAL_SENSOR\t\t0x0003",
            "#define ENCLOSURE_SWITCH\t0x0002",
            "#define KEY_SWITCH\t\t0x0001"
          ],
          "globals_used": [
            "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
            "static char *ppc_rtas_process_error(int error);",
            "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */\n#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */\n#define IBM_VOLTAGE\t\t0x232a /* 9002 */\n#define IBM_FANRPM\t\t0x2329 /* 9001 */\n#define IBM_SURVEILLANCE\t0x2328 /* 9000 */\n#define BATTERY_CHARGING\t0x000b\n#define BATTERY_CYCLESTATE\t0x000a\n#define EPOW_SENSOR\t\t0x0009\n#define BATTERY_PERCENTAGE\t0x0008\n#define BATTERY_REMAINING\t0x0007\n#define BATTERY_VOLTAGE\t\t0x0006\n#define POWER_SOURCE\t\t0x0005\n#define LID_STATUS\t\t0x0004\n#define THERMAL_SENSOR\t\t0x0003\n#define ENCLOSURE_SWITCH\t0x0002\n#define KEY_SWITCH\t\t0x0001\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharching\", \n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "get_sensor_state",
            "2",
            "2",
            "&state",
            "p->token",
            "j"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas_node",
            "rstr",
            "&llen"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "rstr",
            "SENSOR_PREFIX\"%04d\"",
            "p->token"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nNo sensors are available\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_find_all_sensors",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_find_all_sensors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "456-474",
          "snippet": "static int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtas_sensors sensors;",
            "static struct device_node *rtas_node = NULL;",
            "static int ppc_rtas_find_all_sensors(void);",
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_find_all_sensors(void);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"********************************************************\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"RTAS (RunTime Abstraction Services) Sensor Information\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_PREFIX\t\t\"ibm,sensor-\"\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_find_all_sensors(void);\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v)\n{\n\tint i,j;\n\tint state, error;\n\tint get_sensor_state = rtas_token(\"get-sensor-state\");\n\n\tseq_printf(m, \"RTAS (RunTime Abstraction Services) Sensor Information\\n\");\n\tseq_printf(m, \"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\");\n\tseq_printf(m, \"********************************************************\\n\");\n\n\tif (ppc_rtas_find_all_sensors() != 0) {\n\t\tseq_printf(m, \"\\nNo sensors are available\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tstruct individual_sensor *p = &sensors.sensor[i];\n\t\tchar rstr[64];\n\t\tconst char *loc;\n\t\tint llen, offs;\n\n\t\tsprintf (rstr, SENSOR_PREFIX\"%04d\", p->token);\n\t\tloc = of_get_property(rtas_node, rstr, &llen);\n\n\t\t/* A sensor may have multiple instances */\n\t\tfor (j = 0, offs = 0; j <= p->quant; j++) {\n\t\t\terror =\trtas_call(get_sensor_state, 2, 2, &state, \n\t\t\t\t  \t  p->token, j);\n\n\t\t\tppc_rtas_process_sensor(m, p, state, error, loc);\n\t\t\tseq_putc(m, '\\n');\n\t\t\tif (loc) {\n\t\t\t\toffs += strlen(loc) + 1;\n\t\t\t\tloc += strlen(loc) + 1;\n\t\t\t\tif (offs >= llen)\n\t\t\t\t\tloc = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_clock_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "390-407",
    "snippet": "static int ppc_rtas_clock_show(struct seq_file *m, void *v)\n{\n\tint ret[8];\n\tint error = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\tif (error) {\n\t\tprintk(KERN_WARNING \"error: reading the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\t\tseq_printf(m, \"0\");\n\t} else { \n\t\tunsigned int year, mon, day, hour, min, sec;\n\t\tyear = ret[0]; mon  = ret[1]; day  = ret[2];\n\t\thour = ret[3]; min  = ret[4]; sec  = ret[5];\n\t\tseq_printf(m, \"%lu\\n\",\n\t\t\t\tmktime(year, mon, day, hour, min, sec));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "mktime(year, mon, day, hour, min, sec)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mktime",
          "args": [
            "year",
            "mon",
            "day",
            "hour",
            "min",
            "sec"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: reading the clock returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"get-time-of-day\")",
            "0",
            "8",
            "ret"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-time-of-day\""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v)\n{\n\tint ret[8];\n\tint error = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\tif (error) {\n\t\tprintk(KERN_WARNING \"error: reading the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\t\tseq_printf(m, \"0\");\n\t} else { \n\t\tunsigned int year, mon, day, hour, min, sec;\n\t\tyear = ret[0]; mon  = ret[1]; day  = ret[2];\n\t\thour = ret[3]; min  = ret[4]; sec  = ret[5];\n\t\tseq_printf(m, \"%lu\\n\",\n\t\t\t\tmktime(year, mon, day, hour, min, sec));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_clock_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "371-388",
    "snippet": "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\tunsigned long nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tto_tm(nowtime, &tm);\n\terror = rtas_call(rtas_token(\"set-time-of-day\"), 7, 1, NULL, \n\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday, \n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting the clock returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-time-of-day\")",
            "7",
            "1",
            "NULL",
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday",
            "tm.tm_hour",
            "tm.tm_min",
            "tm.tm_sec",
            "0"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-time-of-day\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_tm",
          "args": [
            "nowtime",
            "&tm"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "to_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/time.c",
          "lines": "1037-1070",
          "snippet": "void to_tm(int tim, struct rtc_time * tm)\n{\n\tregister int    i;\n\tregister long   hms, day;\n\n\tday = tim / SECDAY;\n\thms = tim % SECDAY;\n\n\t/* Hours, minutes, seconds are easy */\n\ttm->tm_hour = hms / 3600;\n\ttm->tm_min = (hms % 3600) / 60;\n\ttm->tm_sec = (hms % 3600) % 60;\n\n\t/* Number of years in days */\n\tfor (i = STARTOFTIME; day >= days_in_year(i); i++)\n\t\tday -= days_in_year(i);\n\ttm->tm_year = i;\n\n\t/* Number of months in days left */\n\tif (leapyear(tm->tm_year))\n\t\tdays_in_month(FEBRUARY) = 29;\n\tfor (i = 1; day >= days_in_month(i); i++)\n\t\tday -= days_in_month(i);\n\tdays_in_month(FEBRUARY) = 28;\n\ttm->tm_mon = i;\n\n\t/* Days are what is left over (+1) from all that. */\n\ttm->tm_mday = day + 1;\n\n\t/*\n\t * Determine the day of week\n\t */\n\tGregorianDay(tm);\n}",
          "includes": [
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/cputime.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/clk-provider.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SECDAY\t\t86400L",
            "#define\tSTARTOFTIME\t1970",
            "#define FEBRUARY\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/cputime.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/clk-provider.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/clockchips.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\n#define SECDAY\t\t86400L\n#define\tSTARTOFTIME\t1970\n#define FEBRUARY\t2\n\nvoid to_tm(int tim, struct rtc_time * tm)\n{\n\tregister int    i;\n\tregister long   hms, day;\n\n\tday = tim / SECDAY;\n\thms = tim % SECDAY;\n\n\t/* Hours, minutes, seconds are easy */\n\ttm->tm_hour = hms / 3600;\n\ttm->tm_min = (hms % 3600) / 60;\n\ttm->tm_sec = (hms % 3600) % 60;\n\n\t/* Number of years in days */\n\tfor (i = STARTOFTIME; day >= days_in_year(i); i++)\n\t\tday -= days_in_year(i);\n\ttm->tm_year = i;\n\n\t/* Number of months in days left */\n\tif (leapyear(tm->tm_year))\n\t\tdays_in_month(FEBRUARY) = 29;\n\tfor (i = 1; day >= days_in_month(i); i++)\n\t\tday -= days_in_month(i);\n\tdays_in_month(FEBRUARY) = 28;\n\ttm->tm_mon = i;\n\n\t/* Days are what is left over (+1) from all that. */\n\ttm->tm_mday = day + 1;\n\n\t/*\n\t * Determine the day of week\n\t */\n\tGregorianDay(tm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&nowtime"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "282-300",
          "snippet": "static int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\tunsigned long nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tto_tm(nowtime, &tm);\n\terror = rtas_call(rtas_token(\"set-time-of-day\"), 7, 1, NULL, \n\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday, \n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "ppc_rtas_progress_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "361-366",
    "snippet": "static int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char progress_led[MAX_LINELENGTH];",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "progress_led"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_progress_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "339-359",
    "snippet": "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long hex;\n\n\tif (count >= MAX_LINELENGTH)\n\t\tcount = MAX_LINELENGTH -1;\n\tif (copy_from_user(progress_led, buf, count)) { /* save the string */\n\t\treturn -EFAULT;\n\t}\n\tprogress_led[count] = 0;\n\n\t/* Lets see if the user passed hexdigits */\n\thex = simple_strtoul(progress_led, NULL, 10);\n\n\trtas_progress ((char *)progress_led, hex);\n\treturn count;\n\n\t/* clear the line */\n\t/* rtas_progress(\"                   \", 0xffff);*/\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define MAX_LINELENGTH          256"
    ],
    "globals_used": [
      "static char progress_led[MAX_LINELENGTH];",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_progress",
          "args": [
            "(char *)progress_led",
            "hex"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_progress_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "361-366",
          "snippet": "static int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char progress_led[MAX_LINELENGTH];",
            "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "progress_led",
            "NULL",
            "10"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "progress_led",
            "buf",
            "count"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_LINELENGTH          256\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\n\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long hex;\n\n\tif (count >= MAX_LINELENGTH)\n\t\tcount = MAX_LINELENGTH -1;\n\tif (copy_from_user(progress_led, buf, count)) { /* save the string */\n\t\treturn -EFAULT;\n\t}\n\tprogress_led[count] = 0;\n\n\t/* Lets see if the user passed hexdigits */\n\thex = simple_strtoul(progress_led, NULL, 10);\n\n\trtas_progress ((char *)progress_led, hex);\n\treturn count;\n\n\t/* clear the line */\n\t/* rtas_progress(\"                   \", 0xffff);*/\n}"
  },
  {
    "function_name": "ppc_rtas_poweron_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "327-334",
    "snippet": "static int ppc_rtas_poweron_show(struct seq_file *m, void *v)\n{\n\tif (power_on_time == 0)\n\t\tseq_printf(m, \"Power on time not set\\n\");\n\telse\n\t\tseq_printf(m, \"%lu\\n\",power_on_time);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long power_on_time = 0;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "power_on_time"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Power on time not set\\n\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long power_on_time = 0;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v)\n{\n\tif (power_on_time == 0)\n\t\tseq_printf(m, \"Power on time not set\\n\");\n\telse\n\t\tseq_printf(m, \"%lu\\n\",power_on_time);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_poweron_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "305-325",
    "snippet": "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\tunsigned long nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tpower_on_time = nowtime; /* save the time */\n\n\tto_tm(nowtime, &tm);\n\n\terror = rtas_call(rtas_token(\"set-time-for-power-on\"), 7, 1, NULL, \n\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday, \n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting poweron time returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long power_on_time = 0;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting poweron time returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "480-506",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-time-for-power-on\")",
            "7",
            "1",
            "NULL",
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday",
            "tm.tm_hour",
            "tm.tm_min",
            "tm.tm_sec",
            "0/* nano */"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-time-for-power-on\""
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_tm",
          "args": [
            "nowtime",
            "&tm"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "to_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/time.c",
          "lines": "1037-1070",
          "snippet": "void to_tm(int tim, struct rtc_time * tm)\n{\n\tregister int    i;\n\tregister long   hms, day;\n\n\tday = tim / SECDAY;\n\thms = tim % SECDAY;\n\n\t/* Hours, minutes, seconds are easy */\n\ttm->tm_hour = hms / 3600;\n\ttm->tm_min = (hms % 3600) / 60;\n\ttm->tm_sec = (hms % 3600) % 60;\n\n\t/* Number of years in days */\n\tfor (i = STARTOFTIME; day >= days_in_year(i); i++)\n\t\tday -= days_in_year(i);\n\ttm->tm_year = i;\n\n\t/* Number of months in days left */\n\tif (leapyear(tm->tm_year))\n\t\tdays_in_month(FEBRUARY) = 29;\n\tfor (i = 1; day >= days_in_month(i); i++)\n\t\tday -= days_in_month(i);\n\tdays_in_month(FEBRUARY) = 28;\n\ttm->tm_mon = i;\n\n\t/* Days are what is left over (+1) from all that. */\n\ttm->tm_mday = day + 1;\n\n\t/*\n\t * Determine the day of week\n\t */\n\tGregorianDay(tm);\n}",
          "includes": [
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/cputime.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/clk-provider.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SECDAY\t\t86400L",
            "#define\tSTARTOFTIME\t1970",
            "#define FEBRUARY\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/cputime.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/clk-provider.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/clockchips.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\n#define SECDAY\t\t86400L\n#define\tSTARTOFTIME\t1970\n#define FEBRUARY\t2\n\nvoid to_tm(int tim, struct rtc_time * tm)\n{\n\tregister int    i;\n\tregister long   hms, day;\n\n\tday = tim / SECDAY;\n\thms = tim % SECDAY;\n\n\t/* Hours, minutes, seconds are easy */\n\ttm->tm_hour = hms / 3600;\n\ttm->tm_min = (hms % 3600) / 60;\n\ttm->tm_sec = (hms % 3600) % 60;\n\n\t/* Number of years in days */\n\tfor (i = STARTOFTIME; day >= days_in_year(i); i++)\n\t\tday -= days_in_year(i);\n\ttm->tm_year = i;\n\n\t/* Number of months in days left */\n\tif (leapyear(tm->tm_year))\n\t\tdays_in_month(FEBRUARY) = 29;\n\tfor (i = 1; day >= days_in_month(i); i++)\n\t\tday -= days_in_month(i);\n\tdays_in_month(FEBRUARY) = 28;\n\ttm->tm_mon = i;\n\n\t/* Days are what is left over (+1) from all that. */\n\ttm->tm_mday = day + 1;\n\n\t/*\n\t * Determine the day of week\n\t */\n\tGregorianDay(tm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&nowtime"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "282-300",
          "snippet": "static int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long power_on_time = 0;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\tunsigned long nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tpower_on_time = nowtime; /* save the time */\n\n\tto_tm(nowtime, &tm);\n\n\terror = rtas_call(rtas_token(\"set-time-for-power-on\"), 7, 1, NULL, \n\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday, \n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting poweron time returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "parse_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "282-300",
    "snippet": "static int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "&end",
            "10"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "p",
            "count"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoul(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_rtas_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "254-278",
    "snippet": "static int __init proc_rtas_init(void)\n{\n\tif (!machine_is(pseries))\n\t\treturn -ENODEV;\n\n\trtas_node = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas_node == NULL)\n\t\treturn -ENODEV;\n\n\tproc_create(\"powerpc/rtas/progress\", S_IRUGO|S_IWUSR, NULL,\n\t\t    &ppc_rtas_progress_operations);\n\tproc_create(\"powerpc/rtas/clock\", S_IRUGO|S_IWUSR, NULL,\n\t\t    &ppc_rtas_clock_operations);\n\tproc_create(\"powerpc/rtas/poweron\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_poweron_operations);\n\tproc_create(\"powerpc/rtas/sensors\", S_IRUGO, NULL,\n\t\t    &ppc_rtas_sensors_operations);\n\tproc_create(\"powerpc/rtas/frequency\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_tone_freq_operations);\n\tproc_create(\"powerpc/rtas/volume\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_tone_volume_operations);\n\tproc_create(\"powerpc/rtas/rmo_buffer\", S_IRUSR, NULL,\n\t\t    &ppc_rtas_rmo_buf_ops);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static const struct file_operations ppc_rtas_sensors_operations = {\n\t.open\t\t= sensors_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_poweron_operations = {\n\t.open\t\t= poweron_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_poweron_write,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_progress_operations = {\n\t.open\t\t= progress_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_progress_write,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_clock_operations = {\n\t.open\t\t= clock_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_clock_write,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_tone_freq_operations = {\n\t.open\t\t= tone_freq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_tone_freq_write,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_tone_volume_operations = {\n\t.open\t\t= tone_volume_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_tone_volume_write,\n\t.release\t= single_release,\n};",
      "static const struct file_operations ppc_rtas_rmo_buf_ops = {\n\t.open\t\t= rmo_buf_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/rmo_buffer\"",
            "S_IRUSR",
            "NULL",
            "&ppc_rtas_rmo_buf_ops"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/volume\"",
            "S_IWUSR|S_IRUGO",
            "NULL",
            "&ppc_rtas_tone_volume_operations"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/frequency\"",
            "S_IWUSR|S_IRUGO",
            "NULL",
            "&ppc_rtas_tone_freq_operations"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/sensors\"",
            "S_IRUGO",
            "NULL",
            "&ppc_rtas_sensors_operations"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/poweron\"",
            "S_IWUSR|S_IRUGO",
            "NULL",
            "&ppc_rtas_poweron_operations"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/clock\"",
            "S_IRUGO|S_IWUSR",
            "NULL",
            "&ppc_rtas_clock_operations"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/progress\"",
            "S_IRUGO|S_IWUSR",
            "NULL",
            "&ppc_rtas_progress_operations"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "\"rtas\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic const struct file_operations ppc_rtas_sensors_operations = {\n\t.open\t\t= sensors_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_poweron_operations = {\n\t.open\t\t= poweron_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_poweron_write,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_progress_operations = {\n\t.open\t\t= progress_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_progress_write,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_clock_operations = {\n\t.open\t\t= clock_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_clock_write,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_tone_freq_operations = {\n\t.open\t\t= tone_freq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_tone_freq_write,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_tone_volume_operations = {\n\t.open\t\t= tone_volume_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= ppc_rtas_tone_volume_write,\n\t.release\t= single_release,\n};\nstatic const struct file_operations ppc_rtas_rmo_buf_ops = {\n\t.open\t\t= rmo_buf_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init proc_rtas_init(void)\n{\n\tif (!machine_is(pseries))\n\t\treturn -ENODEV;\n\n\trtas_node = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas_node == NULL)\n\t\treturn -ENODEV;\n\n\tproc_create(\"powerpc/rtas/progress\", S_IRUGO|S_IWUSR, NULL,\n\t\t    &ppc_rtas_progress_operations);\n\tproc_create(\"powerpc/rtas/clock\", S_IRUGO|S_IWUSR, NULL,\n\t\t    &ppc_rtas_clock_operations);\n\tproc_create(\"powerpc/rtas/poweron\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_poweron_operations);\n\tproc_create(\"powerpc/rtas/sensors\", S_IRUGO, NULL,\n\t\t    &ppc_rtas_sensors_operations);\n\tproc_create(\"powerpc/rtas/frequency\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_tone_freq_operations);\n\tproc_create(\"powerpc/rtas/volume\", S_IWUSR|S_IRUGO, NULL,\n\t\t    &ppc_rtas_tone_volume_operations);\n\tproc_create(\"powerpc/rtas/rmo_buffer\", S_IRUSR, NULL,\n\t\t    &ppc_rtas_rmo_buf_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "rmo_buf_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "233-236",
    "snippet": "static int rmo_buf_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_rmo_buf_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_rmo_buf_show",
            "NULL"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int rmo_buf_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_rmo_buf_show, NULL);\n}"
  },
  {
    "function_name": "tone_volume_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "220-223",
    "snippet": "static int tone_volume_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_volume_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_tone_volume_show",
            "NULL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int tone_volume_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_volume_show, NULL);\n}"
  },
  {
    "function_name": "tone_freq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "207-210",
    "snippet": "static int tone_freq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_freq_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_tone_freq_show",
            "NULL"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int tone_freq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_freq_show, NULL);\n}"
  },
  {
    "function_name": "clock_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "194-197",
    "snippet": "static int clock_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_clock_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_clock_show",
            "NULL"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int clock_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_clock_show, NULL);\n}"
  },
  {
    "function_name": "progress_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "181-184",
    "snippet": "static int progress_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_progress_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_progress_show",
            "NULL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int progress_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_progress_show, NULL);\n}"
  },
  {
    "function_name": "poweron_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "168-171",
    "snippet": "static int poweron_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_poweron_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_poweron_show",
            "NULL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int poweron_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_poweron_show, NULL);\n}"
  },
  {
    "function_name": "sensors_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "156-159",
    "snippet": "static int sensors_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_sensors_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_sensors_show",
            "NULL"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int sensors_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_sensors_show, NULL);\n}"
  }
]