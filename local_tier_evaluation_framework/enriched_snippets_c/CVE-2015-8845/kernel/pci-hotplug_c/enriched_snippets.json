[
  {
    "function_name": "pcibios_add_pci_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "77-116",
    "snippet": "void pcibios_add_pci_devices(struct pci_bus * bus)\n{\n\tint slotno, mode, pass, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\teeh_add_device_tree_early(PCI_DN(dn));\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tpcibios_setup_bus_devices(bus);\n\t\tmax = bus->busn_res.start;\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t\t\tif (pci_is_bridge(dev))\n\t\t\t\t\tmax = pci_scan_bridge(bus, dev,\n\t\t\t\t\t\t\t      max, pass);\n\t\t\t}\n\t\t}\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_finish_adding_to_bus",
          "args": [
            "bus"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_finish_adding_to_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1431-1450",
          "snippet": "void pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY))\n\t\tpci_assign_unassigned_bus_resources(bus);\n\n\t/* Fixup EEH */\n\teeh_add_device_tree_late(bus);\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY))\n\t\tpci_assign_unassigned_bus_resources(bus);\n\n\t/* Fixup EEH */\n\teeh_add_device_tree_late(bus);\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_scan_bridge",
          "args": [
            "bus",
            "dev",
            "max",
            "pass"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_is_bridge",
          "args": [
            "dev"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_bus_devices",
          "args": [
            "bus"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1011-1027",
          "snippet": "void pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_scan_slot",
          "args": [
            "bus",
            "PCI_DEVFN(slotno, 0)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DEVFN",
          "args": [
            "slotno",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "PCI_DN(dn->child)->devfn"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn->child"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_rescan_bus",
          "args": [
            "dn",
            "bus"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "of_rescan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "401-404",
          "snippet": "void of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_device_tree_early",
          "args": [
            "PCI_DN(dn)"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1098-1108",
          "snippet": "void eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_add_pci_devices(struct pci_bus * bus)\n{\n\tint slotno, mode, pass, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\teeh_add_device_tree_early(PCI_DN(dn));\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tpcibios_setup_bus_devices(bus);\n\t\tmax = bus->busn_res.start;\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t\t\tif (pci_is_bridge(dev))\n\t\t\t\t\tmax = pci_scan_bridge(bus, dev,\n\t\t\t\t\t\t\t      max, pass);\n\t\t\t}\n\t\t}\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}"
  },
  {
    "function_name": "pcibios_remove_pci_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "47-62",
    "snippet": "void pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_stop_and_remove_bus_device",
          "args": [
            "dev"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"   Removing %s...\\n\"",
            "pci_name(dev)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dev",
            "tmp",
            "&bus->devices",
            "bus_list"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Removing devices on bus %04x:%02x\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_remove_pci_devices",
          "args": [
            "child_bus"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_remove_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "47-62",
          "snippet": "void pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_bus",
            "&bus->children",
            "node"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
  },
  {
    "function_name": "pcibios_release_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "30-38",
    "snippet": "void pcibios_release_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\teeh_remove_device(dev);\n\n\tif (phb->controller_ops.release_device)\n\t\tphb->controller_ops.release_device(dev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.release_device",
          "args": [
            "dev"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_remove_device",
          "args": [
            "dev"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1223-1263",
          "snippet": "void eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tpr_debug(\"EEH: Removing device %s\\n\", pci_name(dev));\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tpr_debug(\"EEH: Not referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_rmv_from_parent_pe(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\teeh_sysfs_remove_device(dev);\n\tedev->mode &= ~EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tpr_debug(\"EEH: Removing device %s\\n\", pci_name(dev));\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tpr_debug(\"EEH: Not referenced !\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_rmv_from_parent_pe(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\teeh_sysfs_remove_device(dev);\n\tedev->mode &= ~EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_release_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\teeh_remove_device(dev);\n\n\tif (phb->controller_ops.release_device)\n\t\tphb->controller_ops.release_device(dev);\n}"
  }
]