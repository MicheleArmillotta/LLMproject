[
  {
    "function_name": "fixup_vga",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1681-1689",
    "snippet": "static void fixup_vga(struct pci_dev *pdev)\n{\n\tu16 cmd;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif ((cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) || !vga_default_device())\n\t\tvga_set_default_device(pdev);\n\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vga_set_default_device",
          "args": [
            "pdev"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vga_default_device",
          "args": [],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "pdev",
            "PCI_COMMAND",
            "&cmd"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_vga(struct pci_dev *pdev)\n{\n\tu16 cmd;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif ((cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) || !vga_default_device())\n\t\tvga_set_default_device(pdev);\n\n}"
  },
  {
    "function_name": "fixup_hide_host_resource_fsl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1660-1677",
    "snippet": "static void fixup_hide_host_resource_fsl(struct pci_dev *dev)\n{\n\tint i, class = dev->class >> 8;\n\t/* When configured as agent, programing interface = 1 */\n\tint prog_if = dev->class & 0xf;\n\n\tif ((class == PCI_CLASS_PROCESSOR_POWERPC ||\n\t     class == PCI_CLASS_BRIDGE_OTHER) &&\n\t\t(dev->hdr_type == PCI_HEADER_TYPE_NORMAL) &&\n\t\t(prog_if == 0) &&\n\t\t(dev->bus->parent == NULL)) {\n\t\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\t\tdev->resource[i].start = 0;\n\t\t\tdev->resource[i].end = 0;\n\t\t\tdev->resource[i].flags = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_hide_host_resource_fsl(struct pci_dev *dev)\n{\n\tint i, class = dev->class >> 8;\n\t/* When configured as agent, programing interface = 1 */\n\tint prog_if = dev->class & 0xf;\n\n\tif ((class == PCI_CLASS_PROCESSOR_POWERPC ||\n\t     class == PCI_CLASS_BRIDGE_OTHER) &&\n\t\t(dev->hdr_type == PCI_HEADER_TYPE_NORMAL) &&\n\t\t(prog_if == 0) &&\n\t\t(dev->bus->parent == NULL)) {\n\t\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\t\tdev->resource[i].start = 0;\n\t\t\tdev->resource[i].end = 0;\n\t\t\tdev->resource[i].flags = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcibios_scan_phb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1600-1657",
    "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcie_bus_configure_settings",
          "args": [
            "child"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&bus->children",
            "node"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_phb",
          "args": [
            "hose"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_update_busn_res_end",
          "args": [
            "bus",
            "hose->last_busno"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_scan_child_bus",
          "args": [
            "bus"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_update_busn_res_end",
          "args": [
            "bus",
            "255"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_bus",
          "args": [
            "node",
            "bus"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "387-390",
          "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    probe mode: %d\\n\"",
            "mode"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hose->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_free_resource_list",
          "args": [
            "&resources"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to create bus for PCI domain %04x\\n\"",
            "hose->global_number"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_create_root_bus",
          "args": [
            "hose->parent",
            "hose->first_busno",
            "hose->ops",
            "hose",
            "&resources"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_resource",
          "args": [
            "&resources",
            "&hose->busn"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_phb_resources",
          "args": [
            "hose",
            "&resources"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_phb_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1477-1517",
          "snippet": "static void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_info(\"PCI: I/O resource not set for host\"\n\t\t       \" bridge %s (domain %d)\\n\",\n\t\t       hose->dn->full_name, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags) {\n\t\t\tif (i == 0)\n\t\t\t\tprintk(KERN_ERR \"PCI: Memory resource 0 not set for \"\n\t\t\t\t       \"host bridge %s (domain %d)\\n\",\n\t\t\t\t       hose->dn->full_name, hose->global_number);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = hose->mem_offset[i];\n\n\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_info(\"PCI: I/O resource not set for host\"\n\t\t       \" bridge %s (domain %d)\\n\",\n\t\t       hose->dn->full_name, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags) {\n\t\t\tif (i == 0)\n\t\t\t\tprintk(KERN_ERR \"PCI: Memory resource 0 not set for \"\n\t\t\t\t       \"host bridge %s (domain %d)\\n\",\n\t\t\t\t       hose->dn->full_name, hose->global_number);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = hose->mem_offset[i];\n\n\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_setup_phb_io_space",
          "args": [
            "hose"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_phb_io_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "214-223",
          "snippet": "void pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Scanning PHB %s\\n\"",
            "of_node_full_name(node)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "node"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "resources"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
  },
  {
    "function_name": "fake_pci_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1554-1566",
    "snippet": "static struct pci_bus *\nfake_pci_bus(struct pci_controller *hose, int busnr)\n{\n\tstatic struct pci_bus bus;\n\n\tif (hose == NULL) {\n\t\tprintk(KERN_ERR \"Can't find hose for PCI bus %d!\\n\", busnr);\n\t}\n\tbus.number = busnr;\n\tbus.sysdata = hose;\n\tbus.ops = hose? hose->ops: &null_pci_ops;\n\treturn &bus;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_ops null_pci_ops =\n{\n\t.read = null_read_config,\n\t.write = null_write_config,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't find hose for PCI bus %d!\\n\"",
            "busnr"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_ops null_pci_ops =\n{\n\t.read = null_read_config,\n\t.write = null_write_config,\n};\n\nstatic struct pci_bus *\nfake_pci_bus(struct pci_controller *hose, int busnr)\n{\n\tstatic struct pci_bus bus;\n\n\tif (hose == NULL) {\n\t\tprintk(KERN_ERR \"Can't find hose for PCI bus %d!\\n\", busnr);\n\t}\n\tbus.number = busnr;\n\tbus.sysdata = hose;\n\tbus.ops = hose? hose->ops: &null_pci_ops;\n\treturn &bus;\n}"
  },
  {
    "function_name": "null_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1537-1542",
    "snippet": "static int\nnull_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t  int len, u32 val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int\nnull_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t  int len, u32 val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}"
  },
  {
    "function_name": "null_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1530-1535",
    "snippet": "static int\nnull_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t int len, u32 *val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int\nnull_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t int len, u32 *val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}"
  },
  {
    "function_name": "pcibios_setup_phb_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1477-1517",
    "snippet": "static void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_info(\"PCI: I/O resource not set for host\"\n\t\t       \" bridge %s (domain %d)\\n\",\n\t\t       hose->dn->full_name, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags) {\n\t\t\tif (i == 0)\n\t\t\t\tprintk(KERN_ERR \"PCI: Memory resource 0 not set for \"\n\t\t\t\t       \"host bridge %s (domain %d)\\n\",\n\t\t\t\t       hose->dn->full_name, hose->global_number);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = hose->mem_offset[i];\n\n\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_add_resource_offset",
          "args": [
            "resources",
            "res",
            "offset"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\"",
            "i",
            "res",
            "(unsigned long long)offset"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PCI: Memory resource 0 not set for \"\n\t\t\t\t       \"host bridge %s (domain %d)\\n\"",
            "hose->dn->full_name",
            "hose->global_number"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_resource_offset",
          "args": [
            "resources",
            "res",
            "offset"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\"",
            "res",
            "(unsigned long long)offset"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_space_offset",
          "args": [
            "hose"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_space_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1472-1475",
          "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"PCI: I/O resource not set for host\"\n\t\t       \" bridge %s (domain %d)\\n\"",
            "hose->dn->full_name",
            "hose->global_number"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_info(\"PCI: I/O resource not set for host\"\n\t\t       \" bridge %s (domain %d)\\n\",\n\t\t       hose->dn->full_name, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags) {\n\t\t\tif (i == 0)\n\t\t\t\tprintk(KERN_ERR \"PCI: Memory resource 0 not set for \"\n\t\t\t\t       \"host bridge %s (domain %d)\\n\",\n\t\t\t\t       hose->dn->full_name, hose->global_number);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = hose->mem_offset[i];\n\n\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}"
  },
  {
    "function_name": "pcibios_io_space_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1472-1475",
    "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
  },
  {
    "function_name": "pcibios_disable_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1464-1470",
    "snippet": "void pcibios_disable_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.disable_device)\n\t\tphb->controller_ops.disable_device(dev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.disable_device",
          "args": [
            "dev"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_disable_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.disable_device)\n\t\tphb->controller_ops.disable_device(dev);\n}"
  },
  {
    "function_name": "pcibios_enable_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1453-1462",
    "snippet": "int pcibios_enable_device(struct pci_dev *dev, int mask)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.enable_device_hook)\n\t\tif (!phb->controller_ops.enable_device_hook(dev))\n\t\t\treturn -EINVAL;\n\n\treturn pci_enable_resources(dev, mask);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_enable_resources",
          "args": [
            "dev",
            "mask"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.enable_device_hook",
          "args": [
            "dev"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_enable_device(struct pci_dev *dev, int mask)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.enable_device_hook)\n\t\tif (!phb->controller_ops.enable_device_hook(dev))\n\t\t\treturn -EINVAL;\n\n\treturn pci_enable_resources(dev, mask);\n}"
  },
  {
    "function_name": "pcibios_finish_adding_to_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1431-1450",
    "snippet": "void pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY))\n\t\tpci_assign_unassigned_bus_resources(bus);\n\n\t/* Fixup EEH */\n\teeh_add_device_tree_late(bus);\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_sysfs_files",
          "args": [
            "bus"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_sysfs_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1198-1210",
          "snippet": "void eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "bus"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_device_tree_late",
          "args": [
            "bus"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1175-1187",
          "snippet": "void eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_assign_unassigned_bus_resources",
          "args": [
            "bus"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "bus"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1395-1421",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "bus"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1163-1232",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY))\n\t\tpci_assign_unassigned_bus_resources(bus);\n\n\t/* Fixup EEH */\n\teeh_add_device_tree_late(bus);\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(bus);\n}"
  },
  {
    "function_name": "pcibios_claim_one_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1395-1421",
    "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "child_bus"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1395-1421",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_bus",
            "&bus->children",
            "node"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_bridge_resource",
          "args": [
            "dev",
            "i"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_resource",
          "args": [
            "dev",
            "i"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Claiming %s: Resource %d: %pR\\n\"",
            "pci_name(dev)",
            "i",
            "r"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
  },
  {
    "function_name": "pcibios_resource_survey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1358-1388",
    "snippet": "void __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tpcibios_allocate_resources(0);\n\tpcibios_allocate_resources(1);\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup",
          "args": [],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_assign_unassigned_resources",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Assigning unassigned resources...\\n\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_reserve_legacy_regions",
          "args": [
            "b"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_reserve_legacy_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1302-1356",
          "snippet": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&pci_root_buses",
            "node"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_resources",
          "args": [
            "1"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1255-1300",
          "snippet": "static void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "b"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1163-1232",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&pci_root_buses",
            "node"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tpcibios_allocate_resources(0);\n\tpcibios_allocate_resources(1);\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n}"
  },
  {
    "function_name": "pcibios_reserve_legacy_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1302-1356",
    "snippet": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "res"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pres",
            "res"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Candidate VGA memory: %pR\\n\"",
            "res"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res == NULL"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "GFP_KERNEL"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"hose mem res: %pR\\n\"",
            "pres"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "res"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "&hose->io_resource",
            "res"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Candidate legacy IO: %pR\\n\"",
            "res"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res == NULL"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "GFP_KERNEL"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Reserving legacy ranges for domain %04x\\n\"",
            "pci_domain_nr(bus)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}"
  },
  {
    "function_name": "pcibios_allocate_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1255-1300",
    "snippet": "static void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config_dword",
          "args": [
            "dev",
            "dev->rom_base_reg",
            "reg & ~PCI_ROM_ADDRESS_ENABLE"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Switching off ROM of %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_dword",
          "args": [
            "dev",
            "dev->rom_base_reg",
            "&reg"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "dev",
            "idx"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1234-1253",
          "snippet": "static inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "alloc_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1234-1253",
    "snippet": "static inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:  parent is %p: %pR\\n\"",
            "pr",
            "pr"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\"",
            "idx",
            "pci_name(dev)"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pr",
            "r"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_parent_resource",
          "args": [
            "dev",
            "r"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Allocating %s: Resource %d: %pR\\n\"",
            "pci_name(dev)",
            "idx",
            "r"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}"
  },
  {
    "function_name": "pcibios_allocate_bus_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1163-1232",
    "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "b"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1163-1232",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&bus->children",
            "node"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warning",
          "args": [
            "\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\"",
            "i",
            "bus->number"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_bridge_resource",
          "args": [
            "dev",
            "i + PCI_BRIDGE_RESOURCES"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reparent_resources",
          "args": [
            "pr",
            "res"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "reparent_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1099-1128",
          "snippet": "static int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pr",
            "res"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\"",
            "bus->self ? pci_name(bus->self) : \"PHB\"",
            "bus->number",
            "i",
            "res",
            "pr",
            "(pr && pr->name) ? pr->name : \"nil\""
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "bus->self"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_parent_resource",
          "args": [
            "bus->self",
            "res"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_for_each_resource",
          "args": [
            "bus",
            "res",
            "i"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Allocating bus resources for %04x:%02x...\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warning(\"PCI: Cannot allocate resource region \"\n\t\t\t   \"%d of PCI bridge %d, will remap\\n\", i, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
  },
  {
    "function_name": "reparent_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1099-1128",
    "snippet": "static int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Reparented %s %pR under %s\\n\"",
            "p->name",
            "p",
            "res->name"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_align_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1078-1092",
    "snippet": "resource_size_t pcibios_align_resource(void *data, const struct resource *res,\n\t\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pci_dev *dev = data;\n\tresource_size_t start = res->start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (skip_isa_ioresource_align(dev))\n\t\t\treturn start;\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t}\n\n\treturn start;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_isa_ioresource_align",
          "args": [
            "dev"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "skip_isa_ioresource_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1057-1063",
          "snippet": "static int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\n\t\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pci_dev *dev = data;\n\tresource_size_t start = res->start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (skip_isa_ioresource_align(dev))\n\t\t\treturn start;\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t}\n\n\treturn start;\n}"
  },
  {
    "function_name": "skip_isa_ioresource_align",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1057-1063",
    "snippet": "static int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_CAN_SKIP_ISA_ALIGN"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_fixup_cardbus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1050-1054",
    "snippet": "void pci_fixup_cardbus(struct pci_bus *bus)\n{\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_setup_bus_devices",
          "args": [
            "bus"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1011-1027",
          "snippet": "void pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_fixup_cardbus(struct pci_bus *bus)\n{\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}"
  },
  {
    "function_name": "pcibios_fixup_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1034-1047",
    "snippet": "void pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_setup_bus_devices",
          "args": [
            "bus"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1011-1027",
          "snippet": "void pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_setup_bus_self",
          "args": [
            "bus"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "951-969",
          "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_read_bridge_bases",
          "args": [
            "bus"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}"
  },
  {
    "function_name": "pcibios_set_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1029-1032",
    "snippet": "void pcibios_set_master(struct pci_dev *dev)\n{\n\t/* No special bus mastering setup handling */\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_set_master(struct pci_dev *dev)\n{\n\t/* No special bus mastering setup handling */\n}"
  },
  {
    "function_name": "pcibios_setup_bus_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1011-1027",
    "snippet": "void pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_setup_device",
          "args": [
            "dev"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "971-992",
          "snippet": "static void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dma_map_ops *pci_dma_ops = &dma_direct_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct dma_map_ops *pci_dma_ops = &dma_direct_ops;\n\nstatic void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Fixup bus devices %d (%s)\\n\"",
            "bus->number",
            "bus->self ? pci_name(bus->self) : \"PHB\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "bus->self"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"PCI: Fixup bus devices %d (%s)\\n\",\n\t\t bus->number, bus->self ? pci_name(bus->self) : \"PHB\");\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Cardbus can call us to add new devices to a bus, so ignore\n\t\t * those who are already fully discovered\n\t\t */\n\t\tif (dev->is_added)\n\t\t\tcontinue;\n\n\t\tpcibios_setup_device(dev);\n\t}\n}"
  },
  {
    "function_name": "pcibios_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "994-1009",
    "snippet": "int pcibios_add_device(struct pci_dev *dev)\n{\n\t/*\n\t * We can only call pcibios_setup_device() after bus setup is complete,\n\t * since some of the platform specific DMA setup code depends on it.\n\t */\n\tif (dev->bus->is_added)\n\t\tpcibios_setup_device(dev);\n\n#ifdef CONFIG_PCI_IOV\n\tif (ppc_md.pcibios_fixup_sriov)\n\t\tppc_md.pcibios_fixup_sriov(dev);\n#endif /* CONFIG_PCI_IOV */\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_sriov",
          "args": [
            "dev"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_device",
          "args": [
            "dev"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "971-992",
          "snippet": "static void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dma_map_ops *pci_dma_ops = &dma_direct_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct dma_map_ops *pci_dma_ops = &dma_direct_ops;\n\nstatic void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_add_device(struct pci_dev *dev)\n{\n\t/*\n\t * We can only call pcibios_setup_device() after bus setup is complete,\n\t * since some of the platform specific DMA setup code depends on it.\n\t */\n\tif (dev->bus->is_added)\n\t\tpcibios_setup_device(dev);\n\n#ifdef CONFIG_PCI_IOV\n\tif (ppc_md.pcibios_fixup_sriov)\n\t\tppc_md.pcibios_fixup_sriov(dev);\n#endif /* CONFIG_PCI_IOV */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_setup_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "971-992",
    "snippet": "static void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dma_map_ops *pci_dma_ops = &dma_direct_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pci_irq_fixup",
          "args": [
            "dev"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_irq_line",
          "args": [
            "dev"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "pci_read_irq_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "235-287",
          "snippet": "static int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tstruct of_phandle_args oirq;\n\tunsigned int virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n#ifdef DEBUG\n\tmemset(&oirq, 0xff, sizeof(oirq));\n#endif\n\t/* Try to get a mapping from the device-tree */\n\tif (of_irq_parse_pci(pci_dev, &oirq)) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq != NO_IRQ)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t} else {\n\t\tpr_debug(\" Got one, spec %d cells (0x%08x 0x%08x...) on %s\\n\",\n\t\t\t oirq.args_count, oirq.args[0], oirq.args[1],\n\t\t\t of_node_full_name(oirq.np));\n\n\t\tvirq = irq_create_of_mapping(&oirq);\n\t}\n\tif(virq == NO_IRQ) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tstruct of_phandle_args oirq;\n\tunsigned int virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n#ifdef DEBUG\n\tmemset(&oirq, 0xff, sizeof(oirq));\n#endif\n\t/* Try to get a mapping from the device-tree */\n\tif (of_irq_parse_pci(pci_dev, &oirq)) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq != NO_IRQ)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t} else {\n\t\tpr_debug(\" Got one, spec %d cells (0x%08x 0x%08x...) on %s\\n\",\n\t\t\t oirq.args_count, oirq.args[0], oirq.args[1],\n\t\t\t of_node_full_name(oirq.np));\n\n\t\tvirq = irq_create_of_mapping(&oirq);\n\t}\n\tif(virq == NO_IRQ) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_dev_setup",
          "args": [
            "dev"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dma_offset",
          "args": [
            "&dev->dev",
            "PCI_DRAM_OFFSET"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dma_ops",
          "args": [
            "&dev->dev",
            "pci_dma_ops"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dev_node",
          "args": [
            "&dev->dev",
            "pcibus_to_node(dev->bus)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibus_to_node",
          "args": [
            "dev->bus"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "pcibus_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "261-265",
          "snippet": "int pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct dma_map_ops *pci_dma_ops = &dma_direct_ops;\n\nstatic void pcibios_setup_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tset_dma_offset(&dev->dev, PCI_DRAM_OFFSET);\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n}"
  },
  {
    "function_name": "pcibios_setup_bus_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "951-969",
    "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_bus_setup",
          "args": [
            "bus"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_bus",
          "args": [
            "bus"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1034-1047",
          "snippet": "void pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n\n\t/* Now fixup devices on that bus */\n\tpcibios_setup_bus_devices(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_fixup_bridge",
          "args": [
            "bus"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "915-949",
          "snippet": "static void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
  },
  {
    "function_name": "pcibios_fixup_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "915-949",
    "snippet": "static void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s            (unassigned)\\n\"",
            "pci_name(dev)"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_uninitialized_bridge_resource",
          "args": [
            "bus",
            "res"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_uninitialized_bridge_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "849-912",
          "snippet": "static int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Bus rsrc %d %pR\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_for_each_resource",
          "args": [
            "bus",
            "res",
            "i"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcibios_uninitialized_bridge_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "849-912",
    "snippet": "static int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_to_bus",
          "args": [
            "dev->bus",
            "&region",
            "res"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "pcibios_fixup_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "797-841",
    "snippet": "static void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_resources",
          "args": [
            "dev"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "797-841",
          "snippet": "static void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Resource %d %pR\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Resource %d %pR is unassigned\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_to_bus",
          "args": [
            "dev->bus",
            "&reg",
            "res"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"No host bridge for PCI dev %s !\\n\"",
            "pci_name(dev)"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}"
  },
  {
    "function_name": "pcibios_root_bridge_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "786-792",
    "snippet": "int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_root_bridge_prepare",
          "args": [
            "bridge"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_root_bridge_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "786-792",
          "snippet": "int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_proc_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "775-784",
    "snippet": "int pci_proc_domain(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (!pci_has_flag(PCI_ENABLE_PROC_DOMAINS))\n\t\treturn 0;\n\tif (pci_has_flag(PCI_COMPAT_DOMAIN_0))\n\t\treturn hose->global_number != 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_COMPAT_DOMAIN_0"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_ENABLE_PROC_DOMAINS"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_proc_domain(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (!pci_has_flag(PCI_ENABLE_PROC_DOMAINS))\n\t\treturn 0;\n\tif (pci_has_flag(PCI_COMPAT_DOMAIN_0))\n\t\treturn hose->global_number != 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "pci_process_bridge_OF_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "672-772",
    "snippet": "void pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %s %s ranges:\\n\",\n\t       dev->full_name, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.pci_space & 0x40000000) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "resource_size_t isa_mem_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\"",
            "range.cpu_addr",
            "range.cpu_addr + range.size - 1",
            "range.pci_addr",
            "(range.pci_space & 0x40000000) ?\n\t\t\t       \"Prefetch\" : \"\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "range.cpu_addr",
            "range.size"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\""
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\"",
            "range.cpu_addr",
            "range.cpu_addr + range.size - 1",
            "range.pci_addr"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_of_pci_range",
          "args": [
            "&parser",
            "&range"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_pci_range_parser_init",
          "args": [
            "&parser",
            "dev"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"PCI host bridge %s %s ranges:\\n\"",
            "dev->full_name",
            "primary ? \"(primary)\" : \"\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t isa_mem_base;\n\nvoid pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %s %s ranges:\\n\",\n\t       dev->full_name, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.pci_space & 0x40000000) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pci_resource_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "609-646",
    "snippet": "void pci_resource_to_user(const struct pci_dev *dev, int bar,\n\t\t\t  const struct resource *rsrc,\n\t\t\t  resource_size_t *start, resource_size_t *end)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tresource_size_t offset = 0;\n\n\tif (hose == NULL)\n\t\treturn;\n\n\tif (rsrc->flags & IORESOURCE_IO)\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\t/* We pass a fully fixed up address to userland for MMIO instead of\n\t * a BAR value because X is lame and expects to be able to use that\n\t * to pass to /dev/mem !\n\t *\n\t * That means that we'll have potentially 64 bits values where some\n\t * userland apps only expect 32 (like X itself since it thinks only\n\t * Sparc has 64 bits MMIO) but if we don't do that, we break it on\n\t * 32 bits CHRPs :-(\n\t *\n\t * Hopefully, the sysfs insterface is immune to that gunk. Once X\n\t * has been fixed (and the fix spread enough), we can re-enable the\n\t * 2 lines below and pass down a BAR value to userland. In that case\n\t * we'll also have to re-enable the matching code in\n\t * __pci_mmap_make_offset().\n\t *\n\t * BenH.\n\t */\n#if 0\n\telse if (rsrc->flags & IORESOURCE_MEM)\n\t\toffset = hose->pci_mem_offset;\n#endif\n\n\t*start = rsrc->start - offset;\n\t*end = rsrc->end - offset;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_resource_to_user(const struct pci_dev *dev, int bar,\n\t\t\t  const struct resource *rsrc,\n\t\t\t  resource_size_t *start, resource_size_t *end)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tresource_size_t offset = 0;\n\n\tif (hose == NULL)\n\t\treturn;\n\n\tif (rsrc->flags & IORESOURCE_IO)\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\t/* We pass a fully fixed up address to userland for MMIO instead of\n\t * a BAR value because X is lame and expects to be able to use that\n\t * to pass to /dev/mem !\n\t *\n\t * That means that we'll have potentially 64 bits values where some\n\t * userland apps only expect 32 (like X itself since it thinks only\n\t * Sparc has 64 bits MMIO) but if we don't do that, we break it on\n\t * 32 bits CHRPs :-(\n\t *\n\t * Hopefully, the sysfs insterface is immune to that gunk. Once X\n\t * has been fixed (and the fix spread enough), we can re-enable the\n\t * 2 lines below and pass down a BAR value to userland. In that case\n\t * we'll also have to re-enable the matching code in\n\t * __pci_mmap_make_offset().\n\t *\n\t * BenH.\n\t */\n#if 0\n\telse if (rsrc->flags & IORESOURCE_MEM)\n\t\toffset = hose->pci_mem_offset;\n#endif\n\n\t*start = rsrc->start - offset;\n\t*end = rsrc->end - offset;\n}"
  },
  {
    "function_name": "pci_mmap_legacy_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "557-607",
    "snippet": "int pci_mmap_legacy_page_range(struct pci_bus *bus,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tresource_size_t size = vma->vm_end - vma->vm_start;\n\tstruct resource *rp;\n\n\tpr_debug(\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\",\n\t\t pci_domain_nr(bus), bus->number,\n\t\t mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\",\n\t\t (unsigned long long)offset,\n\t\t (unsigned long long)(offset + size - 1));\n\n\tif (mmap_state == pci_mmap_mem) {\n\t\t/* Hack alert !\n\t\t *\n\t\t * Because X is lame and can fail starting if it gets an error trying\n\t\t * to mmap legacy_mem (instead of just moving on without legacy memory\n\t\t * access) we fake it here by giving it anonymous memory, effectively\n\t\t * behaving just like /dev/zero\n\t\t */\n\t\tif ((offset + size) > hose->isa_mem_size) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\",\n\t\t\t       current->comm, current->pid, pci_domain_nr(bus), bus->number);\n\t\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\t\treturn shmem_zero_setup(vma);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += hose->isa_mem_phys;\n\t} else {\n\t\tunsigned long io_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tunsigned long roffset = offset + io_offset;\n\t\trp = &hose->io_resource;\n\t\tif (!(rp->flags & IORESOURCE_IO))\n\t\t\treturn -ENXIO;\n\t\tif (roffset < rp->start || (roffset + size) > rp->end)\n\t\t\treturn -ENXIO;\n\t\toffset += hose->io_base_phys;\n\t}\n\tpr_debug(\" -> mapping phys %llx\\n\", (unsigned long long)offset);\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_pgoff",
            "vma->vm_end - vma->vm_start",
            "vma->vm_page_prot"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" -> mapping phys %llx\\n\"",
            "(unsigned long long)offset"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_zero_setup",
          "args": [
            "vma"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\"",
            "current->comm",
            "current->pid",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "203-208",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\"",
            "(unsigned long long)offset",
            "(unsigned long long)(offset + size - 1)"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_mmap_legacy_page_range(struct pci_bus *bus,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tresource_size_t size = vma->vm_end - vma->vm_start;\n\tstruct resource *rp;\n\n\tpr_debug(\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\",\n\t\t pci_domain_nr(bus), bus->number,\n\t\t mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\",\n\t\t (unsigned long long)offset,\n\t\t (unsigned long long)(offset + size - 1));\n\n\tif (mmap_state == pci_mmap_mem) {\n\t\t/* Hack alert !\n\t\t *\n\t\t * Because X is lame and can fail starting if it gets an error trying\n\t\t * to mmap legacy_mem (instead of just moving on without legacy memory\n\t\t * access) we fake it here by giving it anonymous memory, effectively\n\t\t * behaving just like /dev/zero\n\t\t */\n\t\tif ((offset + size) > hose->isa_mem_size) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\",\n\t\t\t       current->comm, current->pid, pci_domain_nr(bus), bus->number);\n\t\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\t\treturn shmem_zero_setup(vma);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += hose->isa_mem_phys;\n\t} else {\n\t\tunsigned long io_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tunsigned long roffset = offset + io_offset;\n\t\trp = &hose->io_resource;\n\t\tif (!(rp->flags & IORESOURCE_IO))\n\t\t\treturn -ENXIO;\n\t\tif (roffset < rp->start || (roffset + size) > rp->end)\n\t\t\treturn -ENXIO;\n\t\toffset += hose->io_base_phys;\n\t}\n\tpr_debug(\" -> mapping phys %llx\\n\", (unsigned long long)offset);\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}"
  },
  {
    "function_name": "pci_legacy_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "512-554",
    "snippet": "int pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\t/* WARNING: The generic code is idiotic. It gets passed a pointer\n\t * to what can be a 1, 2 or 4 byte quantity and always reads that\n\t * as a u32, which means that we have to correct the location of\n\t * the data read within those 32 bits for size 1 and 2\n\t */\n\tswitch(size) {\n\tcase 1:\n\t\tout_8(addr, val >> 24);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\tout_le16(addr, val >> 16);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\tout_le32(addr, val);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out_le32",
          "args": [
            "addr",
            "val"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_le16",
          "args": [
            "addr",
            "val >> 16"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_8",
          "args": [
            "addr",
            "val >> 24"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\t/* WARNING: The generic code is idiotic. It gets passed a pointer\n\t * to what can be a 1, 2 or 4 byte quantity and always reads that\n\t * as a u32, which means that we have to correct the location of\n\t * the data read within those 32 bits for size 1 and 2\n\t */\n\tswitch(size) {\n\tcase 1:\n\t\tout_8(addr, val >> 24);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\tout_le16(addr, val >> 16);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\tout_le32(addr, val);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pci_legacy_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "472-509",
    "snippet": "int pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\tswitch(size) {\n\tcase 1:\n\t\t*((u8 *)val) = in_8(addr);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\t*((u16 *)val) = in_le16(addr);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\t*((u32 *)val) = in_le32(addr);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_le32",
          "args": [
            "addr"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_le16",
          "args": [
            "addr"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_8",
          "args": [
            "addr"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\tswitch(size) {\n\tcase 1:\n\t\t*((u8 *)val) = in_8(addr);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\t*((u16 *)val) = in_le16(addr);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\t*((u32 *)val) = in_le32(addr);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pci_mmap_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "448-469",
    "snippet": "int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,\n\t\t\tenum pci_mmap_state mmap_state, int write_combine)\n{\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tstruct resource *rp;\n\tint ret;\n\n\trp = __pci_mmap_make_offset(dev, &offset, mmap_state);\n\tif (rp == NULL)\n\t\treturn -EINVAL;\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = __pci_mmap_set_pgprot(dev, rp,\n\t\t\t\t\t\t  vma->vm_page_prot,\n\t\t\t\t\t\t  mmap_state, write_combine);\n\n\tret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start, vma->vm_page_prot);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_pgoff",
            "vma->vm_end - vma->vm_start",
            "vma->vm_page_prot"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pci_mmap_set_pgprot",
          "args": [
            "dev",
            "rp",
            "vma->vm_page_prot",
            "mmap_state",
            "write_combine"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__pci_mmap_set_pgprot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "362-386",
          "snippet": "static pgprot_t __pci_mmap_set_pgprot(struct pci_dev *dev, struct resource *rp,\n\t\t\t\t      pgprot_t protection,\n\t\t\t\t      enum pci_mmap_state mmap_state,\n\t\t\t\t      int write_combine)\n{\n\n\t/* Write combine is always 0 on non-memory space mappings. On\n\t * memory space, if the user didn't pass 1, we check for a\n\t * \"prefetchable\" resource. This is a bit hackish, but we use\n\t * this to workaround the inability of /sysfs to provide a write\n\t * combine bit\n\t */\n\tif (mmap_state != pci_mmap_mem)\n\t\twrite_combine = 0;\n\telse if (write_combine == 0) {\n\t\tif (rp->flags & IORESOURCE_PREFETCH)\n\t\t\twrite_combine = 1;\n\t}\n\n\t/* XXX would be nice to have a way to ask for write-through */\n\tif (write_combine)\n\t\treturn pgprot_noncached_wc(protection);\n\telse\n\t\treturn pgprot_noncached(protection);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic pgprot_t __pci_mmap_set_pgprot(struct pci_dev *dev, struct resource *rp,\n\t\t\t\t      pgprot_t protection,\n\t\t\t\t      enum pci_mmap_state mmap_state,\n\t\t\t\t      int write_combine)\n{\n\n\t/* Write combine is always 0 on non-memory space mappings. On\n\t * memory space, if the user didn't pass 1, we check for a\n\t * \"prefetchable\" resource. This is a bit hackish, but we use\n\t * this to workaround the inability of /sysfs to provide a write\n\t * combine bit\n\t */\n\tif (mmap_state != pci_mmap_mem)\n\t\twrite_combine = 0;\n\telse if (write_combine == 0) {\n\t\tif (rp->flags & IORESOURCE_PREFETCH)\n\t\t\twrite_combine = 1;\n\t}\n\n\t/* XXX would be nice to have a way to ask for write-through */\n\tif (write_combine)\n\t\treturn pgprot_noncached_wc(protection);\n\telse\n\t\treturn pgprot_noncached(protection);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pci_mmap_make_offset",
          "args": [
            "dev",
            "&offset",
            "mmap_state"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__pci_mmap_make_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "306-356",
          "snippet": "static struct resource *__pci_mmap_make_offset(struct pci_dev *dev,\n\t\t\t\t\t       resource_size_t *offset,\n\t\t\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tunsigned long io_offset = 0;\n\tint i, res_bit;\n\n\tif (hose == NULL)\n\t\treturn NULL;\t\t/* should never happen */\n\n\t/* If memory, add on the PCI bridge address offset */\n\tif (mmap_state == pci_mmap_mem) {\n#if 0 /* See comment in pci_resource_to_user() for why this is disabled */\n\t\t*offset += hose->pci_mem_offset;\n#endif\n\t\tres_bit = IORESOURCE_MEM;\n\t} else {\n\t\tio_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t*offset += io_offset;\n\t\tres_bit = IORESOURCE_IO;\n\t}\n\n\t/*\n\t * Check that the offset requested corresponds to one of the\n\t * resources of the device.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tstruct resource *rp = &dev->resource[i];\n\t\tint flags = rp->flags;\n\n\t\t/* treat ROM as memory (should be already) */\n\t\tif (i == PCI_ROM_RESOURCE)\n\t\t\tflags |= IORESOURCE_MEM;\n\n\t\t/* Active and same type? */\n\t\tif ((flags & res_bit) == 0)\n\t\t\tcontinue;\n\n\t\t/* In the range of this resource? */\n\t\tif (*offset < (rp->start & PAGE_MASK) || *offset > rp->end)\n\t\t\tcontinue;\n\n\t\t/* found it! construct the final physical address */\n\t\tif (mmap_state == pci_mmap_io)\n\t\t\t*offset += hose->io_base_phys - io_offset;\n\t\treturn rp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct resource *__pci_mmap_make_offset(struct pci_dev *dev,\n\t\t\t\t\t       resource_size_t *offset,\n\t\t\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tunsigned long io_offset = 0;\n\tint i, res_bit;\n\n\tif (hose == NULL)\n\t\treturn NULL;\t\t/* should never happen */\n\n\t/* If memory, add on the PCI bridge address offset */\n\tif (mmap_state == pci_mmap_mem) {\n#if 0 /* See comment in pci_resource_to_user() for why this is disabled */\n\t\t*offset += hose->pci_mem_offset;\n#endif\n\t\tres_bit = IORESOURCE_MEM;\n\t} else {\n\t\tio_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t*offset += io_offset;\n\t\tres_bit = IORESOURCE_IO;\n\t}\n\n\t/*\n\t * Check that the offset requested corresponds to one of the\n\t * resources of the device.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tstruct resource *rp = &dev->resource[i];\n\t\tint flags = rp->flags;\n\n\t\t/* treat ROM as memory (should be already) */\n\t\tif (i == PCI_ROM_RESOURCE)\n\t\t\tflags |= IORESOURCE_MEM;\n\n\t\t/* Active and same type? */\n\t\tif ((flags & res_bit) == 0)\n\t\t\tcontinue;\n\n\t\t/* In the range of this resource? */\n\t\tif (*offset < (rp->start & PAGE_MASK) || *offset > rp->end)\n\t\t\tcontinue;\n\n\t\t/* found it! construct the final physical address */\n\t\tif (mmap_state == pci_mmap_io)\n\t\t\t*offset += hose->io_base_phys - io_offset;\n\t\treturn rp;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,\n\t\t\tenum pci_mmap_state mmap_state, int write_combine)\n{\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tstruct resource *rp;\n\tint ret;\n\n\trp = __pci_mmap_make_offset(dev, &offset, mmap_state);\n\tif (rp == NULL)\n\t\treturn -EINVAL;\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = __pci_mmap_set_pgprot(dev, rp,\n\t\t\t\t\t\t  vma->vm_page_prot,\n\t\t\t\t\t\t  mmap_state, write_combine);\n\n\tret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start, vma->vm_page_prot);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pci_phys_mem_access_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "393-435",
    "snippet": "pgprot_t pci_phys_mem_access_prot(struct file *file,\n\t\t\t\t  unsigned long pfn,\n\t\t\t\t  unsigned long size,\n\t\t\t\t  pgprot_t prot)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct resource *found = NULL;\n\tresource_size_t offset = ((resource_size_t)pfn) << PAGE_SHIFT;\n\tint i;\n\n\tif (page_is_ram(pfn))\n\t\treturn prot;\n\n\tprot = pgprot_noncached(prot);\n\tfor_each_pci_dev(pdev) {\n\t\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\t\tstruct resource *rp = &pdev->resource[i];\n\t\t\tint flags = rp->flags;\n\n\t\t\t/* Active and same type? */\n\t\t\tif ((flags & IORESOURCE_MEM) == 0)\n\t\t\t\tcontinue;\n\t\t\t/* In the range of this resource? */\n\t\t\tif (offset < (rp->start & PAGE_MASK) ||\n\t\t\t    offset > rp->end)\n\t\t\t\tcontinue;\n\t\t\tfound = rp;\n\t\t\tbreak;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (found) {\n\t\tif (found->flags & IORESOURCE_PREFETCH)\n\t\t\tprot = pgprot_noncached_wc(prot);\n\t\tpci_dev_put(pdev);\n\t}\n\n\tpr_debug(\"PCI: Non-PCI map for %llx, prot: %lx\\n\",\n\t\t (unsigned long long)offset, pgprot_val(prot));\n\n\treturn prot;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Non-PCI map for %llx, prot: %lx\\n\"",
            "(unsigned long long)offset",
            "pgprot_val(prot)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "prot"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached_wc",
          "args": [
            "prot"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "prot"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_ram",
          "args": [
            "pfn"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\npgprot_t pci_phys_mem_access_prot(struct file *file,\n\t\t\t\t  unsigned long pfn,\n\t\t\t\t  unsigned long size,\n\t\t\t\t  pgprot_t prot)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct resource *found = NULL;\n\tresource_size_t offset = ((resource_size_t)pfn) << PAGE_SHIFT;\n\tint i;\n\n\tif (page_is_ram(pfn))\n\t\treturn prot;\n\n\tprot = pgprot_noncached(prot);\n\tfor_each_pci_dev(pdev) {\n\t\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\t\tstruct resource *rp = &pdev->resource[i];\n\t\t\tint flags = rp->flags;\n\n\t\t\t/* Active and same type? */\n\t\t\tif ((flags & IORESOURCE_MEM) == 0)\n\t\t\t\tcontinue;\n\t\t\t/* In the range of this resource? */\n\t\t\tif (offset < (rp->start & PAGE_MASK) ||\n\t\t\t    offset > rp->end)\n\t\t\t\tcontinue;\n\t\t\tfound = rp;\n\t\t\tbreak;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (found) {\n\t\tif (found->flags & IORESOURCE_PREFETCH)\n\t\t\tprot = pgprot_noncached_wc(prot);\n\t\tpci_dev_put(pdev);\n\t}\n\n\tpr_debug(\"PCI: Non-PCI map for %llx, prot: %lx\\n\",\n\t\t (unsigned long long)offset, pgprot_val(prot));\n\n\treturn prot;\n}"
  },
  {
    "function_name": "__pci_mmap_set_pgprot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "362-386",
    "snippet": "static pgprot_t __pci_mmap_set_pgprot(struct pci_dev *dev, struct resource *rp,\n\t\t\t\t      pgprot_t protection,\n\t\t\t\t      enum pci_mmap_state mmap_state,\n\t\t\t\t      int write_combine)\n{\n\n\t/* Write combine is always 0 on non-memory space mappings. On\n\t * memory space, if the user didn't pass 1, we check for a\n\t * \"prefetchable\" resource. This is a bit hackish, but we use\n\t * this to workaround the inability of /sysfs to provide a write\n\t * combine bit\n\t */\n\tif (mmap_state != pci_mmap_mem)\n\t\twrite_combine = 0;\n\telse if (write_combine == 0) {\n\t\tif (rp->flags & IORESOURCE_PREFETCH)\n\t\t\twrite_combine = 1;\n\t}\n\n\t/* XXX would be nice to have a way to ask for write-through */\n\tif (write_combine)\n\t\treturn pgprot_noncached_wc(protection);\n\telse\n\t\treturn pgprot_noncached(protection);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "protection"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached_wc",
          "args": [
            "protection"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic pgprot_t __pci_mmap_set_pgprot(struct pci_dev *dev, struct resource *rp,\n\t\t\t\t      pgprot_t protection,\n\t\t\t\t      enum pci_mmap_state mmap_state,\n\t\t\t\t      int write_combine)\n{\n\n\t/* Write combine is always 0 on non-memory space mappings. On\n\t * memory space, if the user didn't pass 1, we check for a\n\t * \"prefetchable\" resource. This is a bit hackish, but we use\n\t * this to workaround the inability of /sysfs to provide a write\n\t * combine bit\n\t */\n\tif (mmap_state != pci_mmap_mem)\n\t\twrite_combine = 0;\n\telse if (write_combine == 0) {\n\t\tif (rp->flags & IORESOURCE_PREFETCH)\n\t\t\twrite_combine = 1;\n\t}\n\n\t/* XXX would be nice to have a way to ask for write-through */\n\tif (write_combine)\n\t\treturn pgprot_noncached_wc(protection);\n\telse\n\t\treturn pgprot_noncached(protection);\n}"
  },
  {
    "function_name": "__pci_mmap_make_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "306-356",
    "snippet": "static struct resource *__pci_mmap_make_offset(struct pci_dev *dev,\n\t\t\t\t\t       resource_size_t *offset,\n\t\t\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tunsigned long io_offset = 0;\n\tint i, res_bit;\n\n\tif (hose == NULL)\n\t\treturn NULL;\t\t/* should never happen */\n\n\t/* If memory, add on the PCI bridge address offset */\n\tif (mmap_state == pci_mmap_mem) {\n#if 0 /* See comment in pci_resource_to_user() for why this is disabled */\n\t\t*offset += hose->pci_mem_offset;\n#endif\n\t\tres_bit = IORESOURCE_MEM;\n\t} else {\n\t\tio_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t*offset += io_offset;\n\t\tres_bit = IORESOURCE_IO;\n\t}\n\n\t/*\n\t * Check that the offset requested corresponds to one of the\n\t * resources of the device.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tstruct resource *rp = &dev->resource[i];\n\t\tint flags = rp->flags;\n\n\t\t/* treat ROM as memory (should be already) */\n\t\tif (i == PCI_ROM_RESOURCE)\n\t\t\tflags |= IORESOURCE_MEM;\n\n\t\t/* Active and same type? */\n\t\tif ((flags & res_bit) == 0)\n\t\t\tcontinue;\n\n\t\t/* In the range of this resource? */\n\t\tif (*offset < (rp->start & PAGE_MASK) || *offset > rp->end)\n\t\t\tcontinue;\n\n\t\t/* found it! construct the final physical address */\n\t\tif (mmap_state == pci_mmap_io)\n\t\t\t*offset += hose->io_base_phys - io_offset;\n\t\treturn rp;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct resource *__pci_mmap_make_offset(struct pci_dev *dev,\n\t\t\t\t\t       resource_size_t *offset,\n\t\t\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tunsigned long io_offset = 0;\n\tint i, res_bit;\n\n\tif (hose == NULL)\n\t\treturn NULL;\t\t/* should never happen */\n\n\t/* If memory, add on the PCI bridge address offset */\n\tif (mmap_state == pci_mmap_mem) {\n#if 0 /* See comment in pci_resource_to_user() for why this is disabled */\n\t\t*offset += hose->pci_mem_offset;\n#endif\n\t\tres_bit = IORESOURCE_MEM;\n\t} else {\n\t\tio_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t*offset += io_offset;\n\t\tres_bit = IORESOURCE_IO;\n\t}\n\n\t/*\n\t * Check that the offset requested corresponds to one of the\n\t * resources of the device.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tstruct resource *rp = &dev->resource[i];\n\t\tint flags = rp->flags;\n\n\t\t/* treat ROM as memory (should be already) */\n\t\tif (i == PCI_ROM_RESOURCE)\n\t\t\tflags |= IORESOURCE_MEM;\n\n\t\t/* Active and same type? */\n\t\tif ((flags & res_bit) == 0)\n\t\t\tcontinue;\n\n\t\t/* In the range of this resource? */\n\t\tif (*offset < (rp->start & PAGE_MASK) || *offset > rp->end)\n\t\t\tcontinue;\n\n\t\t/* found it! construct the final physical address */\n\t\tif (mmap_state == pci_mmap_io)\n\t\t\t*offset += hose->io_base_phys - io_offset;\n\t\treturn rp;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_read_irq_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "235-287",
    "snippet": "static int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tstruct of_phandle_args oirq;\n\tunsigned int virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n#ifdef DEBUG\n\tmemset(&oirq, 0xff, sizeof(oirq));\n#endif\n\t/* Try to get a mapping from the device-tree */\n\tif (of_irq_parse_pci(pci_dev, &oirq)) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq != NO_IRQ)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t} else {\n\t\tpr_debug(\" Got one, spec %d cells (0x%08x 0x%08x...) on %s\\n\",\n\t\t\t oirq.args_count, oirq.args[0], oirq.args[1],\n\t\t\t of_node_full_name(oirq.np));\n\n\t\tvirq = irq_create_of_mapping(&oirq);\n\t}\n\tif(virq == NO_IRQ) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" Mapped to linux irq %d\\n\"",
            "virq"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" Failed to map !\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_create_of_mapping",
          "args": [
            "&oirq"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" Got one, spec %d cells (0x%08x 0x%08x...) on %s\\n\"",
            "oirq.args_count",
            "oirq.args[0]",
            "oirq.args[1]",
            "of_node_full_name(oirq.np)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "oirq.np"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_irq_type",
          "args": [
            "virq",
            "IRQ_TYPE_LEVEL_LOW"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_create_mapping",
          "args": [
            "NULL",
            "line"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" No map ! Using line %d (pin %d) from PCI config\\n\"",
            "line",
            "pin"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_byte",
          "args": [
            "pci_dev",
            "PCI_INTERRUPT_LINE",
            "&line"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_byte",
          "args": [
            "pci_dev",
            "PCI_INTERRUPT_PIN",
            "&pin"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_irq_parse_pci",
          "args": [
            "pci_dev",
            "&oirq"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&oirq",
            "0xff",
            "sizeof(oirq)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Try to map irq for %s...\\n\"",
            "pci_name(pci_dev)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pci_dev"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tstruct of_phandle_args oirq;\n\tunsigned int virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n#ifdef DEBUG\n\tmemset(&oirq, 0xff, sizeof(oirq));\n#endif\n\t/* Try to get a mapping from the device-tree */\n\tif (of_irq_parse_pci(pci_dev, &oirq)) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq != NO_IRQ)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t} else {\n\t\tpr_debug(\" Got one, spec %d cells (0x%08x 0x%08x...) on %s\\n\",\n\t\t\t oirq.args_count, oirq.args[0], oirq.args[1],\n\t\t\t of_node_full_name(oirq.np));\n\n\t\tvirq = irq_create_of_mapping(&oirq);\n\t}\n\tif(virq == NO_IRQ) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_find_hose_for_OF_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "218-228",
    "snippet": "struct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_domain_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "203-208",
    "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
  },
  {
    "function_name": "pci_address_to_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "177-197",
    "snippet": "unsigned long pci_address_to_pio(phys_addr_t address)\n{\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\tunsigned long ret = ~0;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_phys &&\n\t\t    address < (hose->io_base_phys + size)) {\n\t\t\tunsigned long base =\n\t\t\t\t(unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t\tret = base + (address - hose->io_base_phys);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_size",
          "args": [
            "hose"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "149-156",
          "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nunsigned long pci_address_to_pio(phys_addr_t address)\n{\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\tunsigned long ret = ~0;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_phys &&\n\t\t    address < (hose->io_base_phys + size)) {\n\t\t\tunsigned long base =\n\t\t\t\t(unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t\tret = base + (address - hose->io_base_phys);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pcibios_vaddr_is_ioport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "158-175",
    "snippet": "int pcibios_vaddr_is_ioport(void __iomem *address)\n{\n\tint ret = 0;\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_virt &&\n\t\t    address < (hose->io_base_virt + size)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_size",
          "args": [
            "hose"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "149-156",
          "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nint pcibios_vaddr_is_ioport(void __iomem *address)\n{\n\tint ret = 0;\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_virt &&\n\t\t    address < (hose->io_base_virt + size)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pcibios_io_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "149-156",
    "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "&hose->io_resource"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
  },
  {
    "function_name": "pcibios_iov_resource_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "140-146",
    "snippet": "resource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_iov_resource_size",
          "args": [
            "pdev",
            "resno"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_iov_resource_alignment",
          "args": [
            "pdev",
            "resno"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_iov_resource_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "140-146",
          "snippet": "resource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}"
  },
  {
    "function_name": "pcibios_reset_secondary_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "127-137",
    "snippet": "void pcibios_reset_secondary_bus(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.reset_secondary_bus) {\n\t\tphb->controller_ops.reset_secondary_bus(dev);\n\t\treturn;\n\t}\n\n\tpci_reset_secondary_bus(dev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_reset_secondary_bus",
          "args": [
            "dev"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.reset_secondary_bus",
          "args": [
            "dev"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_reset_secondary_bus(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.reset_secondary_bus) {\n\t\tphb->controller_ops.reset_secondary_bus(dev);\n\t\treturn;\n\t}\n\n\tpci_reset_secondary_bus(dev);\n}"
  },
  {
    "function_name": "pcibios_window_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "111-125",
    "snippet": "resource_size_t pcibios_window_alignment(struct pci_bus *bus,\n\t\t\t\t\t unsigned long type)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\n\tif (phb->controller_ops.window_alignment)\n\t\treturn phb->controller_ops.window_alignment(bus, type);\n\n\t/*\n\t * PCI core will figure out the default\n\t * alignment: 4KiB for I/O and 1MiB for\n\t * memory window.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.window_alignment",
          "args": [
            "bus",
            "type"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_window_alignment(struct pci_bus *bus,\n\t\t\t\t\t unsigned long type)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\n\tif (phb->controller_ops.window_alignment)\n\t\treturn phb->controller_ops.window_alignment(bus, type);\n\n\t/*\n\t * PCI core will figure out the default\n\t * alignment: 4KiB for I/O and 1MiB for\n\t * memory window.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "pcibios_free_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "94-102",
    "snippet": "void pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "phb"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&phb->list_node"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nvoid pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}"
  },
  {
    "function_name": "pcibios_alloc_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "67-91",
    "snippet": "struct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = global_phb_number++;\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = -1;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);",
      "static int global_phb_number;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PHB_SET_NODE",
          "args": [
            "phb",
            "nid"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "nid"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "dev"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&phb->list_node",
            "&hose_list"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_maybe_bootmem",
          "args": [
            "sizeof(struct pci_controller)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\nstatic int global_phb_number;\n\nstruct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = global_phb_number++;\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = -1;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}"
  },
  {
    "function_name": "get_pci_dma_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "61-64",
    "snippet": "struct dma_map_ops *get_pci_dma_ops(void)\n{\n\treturn pci_dma_ops;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dma_map_ops *pci_dma_ops = &dma_direct_ops;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct dma_map_ops *pci_dma_ops = &dma_direct_ops;\n\nstruct dma_map_ops *get_pci_dma_ops(void)\n{\n\treturn pci_dma_ops;\n}"
  },
  {
    "function_name": "set_pci_dma_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "56-59",
    "snippet": "void set_pci_dma_ops(struct dma_map_ops *dma_ops)\n{\n\tpci_dma_ops = dma_ops;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dma_map_ops *pci_dma_ops = &dma_direct_ops;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct dma_map_ops *pci_dma_ops = &dma_direct_ops;\n\nvoid set_pci_dma_ops(struct dma_map_ops *dma_ops)\n{\n\tpci_dma_ops = dma_ops;\n}"
  }
]