[
  {
    "function_name": "pci_dev_pdn_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "463-473",
    "snippet": "static void pci_dev_pdn_setup(struct pci_dev *pdev)\n{\n\tstruct pci_dn *pdn;\n\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn;\n\n\t/* Setup the fast path */\n\tpdn = pci_get_pdn(pdev);\n\tpdev->dev.archdata.pci_data = pdn;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "107-137",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_dev_pdn_setup(struct pci_dev *pdev)\n{\n\tstruct pci_dn *pdn;\n\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn;\n\n\t/* Setup the fast path */\n\tpdn = pci_get_pdn(pdev);\n\tpdev->dev.archdata.pci_data = pdn;\n}"
  },
  {
    "function_name": "pci_devs_phb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "454-461",
    "snippet": "void __init pci_devs_phb_init(void)\n{\n\tstruct pci_controller *phb, *tmp;\n\n\t/* This must be done first so the device nodes have valid pci info! */\n\tlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\n\t\tpci_devs_phb_init_dynamic(phb);\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_devs_phb_init_dynamic",
          "args": [
            "phb"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devs_phb_init_dynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "426-443",
          "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "phb",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pci_devs_phb_init(void)\n{\n\tstruct pci_controller *phb, *tmp;\n\n\t/* This must be done first so the device nodes have valid pci info! */\n\tlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\n\t\tpci_devs_phb_init_dynamic(phb);\n}"
  },
  {
    "function_name": "pci_devs_phb_init_dynamic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "426-443",
    "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "traverse_pci_devices",
          "args": [
            "dn",
            "update_dn_pci_info",
            "phb"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "traverse_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "338-376",
          "snippet": "void *traverse_pci_devices(struct device_node *start, traverse_func pre,\n\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (pre && ((ret = pre(dn, data)) != NULL))\n\t\t\treturn ret;\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *traverse_pci_devices(struct device_node *start, traverse_func pre,\n\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (pre && ((ret = pre(dn, data)) != NULL))\n\t\t\treturn ret;\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dn_pci_info",
          "args": [
            "dn",
            "phb"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "update_dn_pci_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "272-318",
          "snippet": "void *update_dn_pci_info(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *phb = data;\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n\n\tpdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->node = dn;\n\tpdn->phb = phb;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *update_dn_pci_info(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *phb = data;\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n\n\tpdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->node = dn;\n\tpdn->phb = phb;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}"
  },
  {
    "function_name": "traverse_pci_dn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "400-416",
    "snippet": "void *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pdn",
            "data"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dn_next_one",
          "args": [
            "root",
            "pdn"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "pci_dn_next_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "378-398",
          "snippet": "static struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_dn_next_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "378-398",
    "snippet": "static struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structpci_dn",
            "list"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structpci_dn",
            "list"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}"
  },
  {
    "function_name": "traverse_pci_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "338-376",
    "snippet": "void *traverse_pci_devices(struct device_node *start, traverse_func pre,\n\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (pre && ((ret = pre(dn, data)) != NULL))\n\t\t\treturn ret;\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pre",
          "args": [
            "dn",
            "data"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_indicator_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "605-628",
          "snippet": "bool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nbool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "classp",
            "1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"class-code\"",
            "NULL"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *traverse_pci_devices(struct device_node *start, traverse_func pre,\n\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (pre && ((ret = pre(dn, data)) != NULL))\n\t\t\treturn ret;\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "update_dn_pci_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "272-318",
    "snippet": "void *update_dn_pci_info(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *phb = data;\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n\n\tpdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->node = dn;\n\tpdn->phb = phb;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pdn->list",
            "&pdn->parent->child_list"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "parent"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "dn"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->list"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->child_list"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "type",
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"class-code\"",
            "NULL"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"device-id\"",
            "NULL"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"vendor-id\"",
            "NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"reg\"",
            "NULL"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_maybe_bootmem",
          "args": [
            "sizeof(*pdn)",
            "GFP_KERNEL"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,pci-config-space-type\"",
            "NULL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *update_dn_pci_info(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *phb = data;\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n\n\tpdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->node = dn;\n\tpdn->phb = phb;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "remove_dev_pci_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "213-266",
    "snippet": "void remove_dev_pci_data(struct pci_dev *pdev)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dn *parent;\n\tstruct pci_dn *pdn, *tmp;\n\tint i;\n\n\t/*\n\t * VF and VF PE are created/released dynamically, so we need to\n\t * bind/unbind them.  Otherwise the VF and VF PE would be mismatched\n\t * when re-enabling SR-IOV.\n\t */\n\tif (pdev->is_virtfn) {\n\t\tpdn = pci_get_pdn(pdev);\n#ifdef CONFIG_PPC_POWERNV\n\t\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\t\treturn;\n\t}\n\n\t/* Only support IOV PF for now */\n\tif (!pdev->is_physfn)\n\t\treturn;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || !(pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn;\n\n\tpdn->flags &= ~PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn;\n\n\t/*\n\t * We might introduce flag to pci_dn in future\n\t * so that we can release VF's firmware data in\n\t * a batch mode.\n\t */\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tlist_for_each_entry_safe(pdn, tmp,\n\t\t\t&parent->child_list, list) {\n\t\t\tif (pdn->busno != pci_iov_virtfn_bus(pdev, i) ||\n\t\t\t    pdn->devfn != pci_iov_virtfn_devfn(pdev, i))\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&pdn->list))\n\t\t\t\tlist_del(&pdn->list);\n\n\t\t\tkfree(pdn);\n\t\t}\n\t}\n#endif /* CONFIG_PCI_IOV */\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdn"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pdn->list"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pdn->list"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_devfn",
          "args": [
            "pdev",
            "i"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_bus",
          "args": [
            "pdev",
            "i"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pdn",
            "tmp",
            "&parent->child_list",
            "list"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sriov_get_totalvfs",
          "args": [
            "pdev"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "42-68",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "107-137",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid remove_dev_pci_data(struct pci_dev *pdev)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dn *parent;\n\tstruct pci_dn *pdn, *tmp;\n\tint i;\n\n\t/*\n\t * VF and VF PE are created/released dynamically, so we need to\n\t * bind/unbind them.  Otherwise the VF and VF PE would be mismatched\n\t * when re-enabling SR-IOV.\n\t */\n\tif (pdev->is_virtfn) {\n\t\tpdn = pci_get_pdn(pdev);\n#ifdef CONFIG_PPC_POWERNV\n\t\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\t\treturn;\n\t}\n\n\t/* Only support IOV PF for now */\n\tif (!pdev->is_physfn)\n\t\treturn;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || !(pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn;\n\n\tpdn->flags &= ~PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn;\n\n\t/*\n\t * We might introduce flag to pci_dn in future\n\t * so that we can release VF's firmware data in\n\t * a batch mode.\n\t */\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tlist_for_each_entry_safe(pdn, tmp,\n\t\t\t&parent->child_list, list) {\n\t\t\tif (pdn->busno != pci_iov_virtfn_bus(pdev, i) ||\n\t\t\t    pdn->devfn != pci_iov_virtfn_devfn(pdev, i))\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&pdn->list))\n\t\t\t\tlist_del(&pdn->list);\n\n\t\t\tkfree(pdn);\n\t\t}\n\t}\n#endif /* CONFIG_PCI_IOV */\n}"
  },
  {
    "function_name": "add_dev_pci_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "178-211",
    "snippet": "struct pci_dn *add_dev_pci_data(struct pci_dev *pdev)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dn *parent, *pdn;\n\tint i;\n\n\t/* Only support IOV for now */\n\tif (!pdev->is_physfn)\n\t\treturn pci_get_pdn(pdev);\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || (pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn NULL;\n\n\tpdn->flags |= PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tpdn = add_one_dev_pci_data(parent, NULL,\n\t\t\t\t\t   pci_iov_virtfn_bus(pdev, i),\n\t\t\t\t\t   pci_iov_virtfn_devfn(pdev, i));\n\t\tif (!pdn) {\n\t\t\tdev_warn(&pdev->dev, \"%s: Cannot create firmware data for VF#%d\\n\",\n\t\t\t\t __func__, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif /* CONFIG_PCI_IOV */\n\n\treturn pci_get_pdn(pdev);\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "107-137",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "&pdev->dev",
            "\"%s: Cannot create firmware data for VF#%d\\n\"",
            "__func__",
            "i"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_one_dev_pci_data",
          "args": [
            "parent",
            "NULL",
            "pci_iov_virtfn_bus(pdev, i)",
            "pci_iov_virtfn_devfn(pdev, i)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "add_one_dev_pci_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "140-175",
          "snippet": "static struct pci_dn *add_one_dev_pci_data(struct pci_dn *parent,\n\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn) {\n\t\tdev_warn(&pdev->dev, \"%s: Out of memory!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\t/*\n\t * If we already have PCI device instance, lets\n\t * bind them.\n\t */\n\tif (pdev)\n\t\tpdev->dev.archdata.pci_data = pdn;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *add_one_dev_pci_data(struct pci_dn *parent,\n\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn) {\n\t\tdev_warn(&pdev->dev, \"%s: Out of memory!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\t/*\n\t * If we already have PCI device instance, lets\n\t * bind them.\n\t */\n\tif (pdev)\n\t\tpdev->dev.archdata.pci_data = pdn;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_devfn",
          "args": [
            "pdev",
            "i"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_bus",
          "args": [
            "pdev",
            "i"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sriov_get_totalvfs",
          "args": [
            "pdev"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "42-68",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *add_dev_pci_data(struct pci_dev *pdev)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct pci_dn *parent, *pdn;\n\tint i;\n\n\t/* Only support IOV for now */\n\tif (!pdev->is_physfn)\n\t\treturn pci_get_pdn(pdev);\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || (pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn NULL;\n\n\tpdn->flags |= PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tpdn = add_one_dev_pci_data(parent, NULL,\n\t\t\t\t\t   pci_iov_virtfn_bus(pdev, i),\n\t\t\t\t\t   pci_iov_virtfn_devfn(pdev, i));\n\t\tif (!pdn) {\n\t\t\tdev_warn(&pdev->dev, \"%s: Cannot create firmware data for VF#%d\\n\",\n\t\t\t\t __func__, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif /* CONFIG_PCI_IOV */\n\n\treturn pci_get_pdn(pdev);\n}"
  },
  {
    "function_name": "add_one_dev_pci_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "140-175",
    "snippet": "static struct pci_dn *add_one_dev_pci_data(struct pci_dn *parent,\n\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn) {\n\t\tdev_warn(&pdev->dev, \"%s: Out of memory!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\t/*\n\t * If we already have PCI device instance, lets\n\t * bind them.\n\t */\n\tif (pdev)\n\t\tpdev->dev.archdata.pci_data = pdn;\n\n\treturn pdn;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pdn->list",
            "&parent->child_list"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->list"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->child_list"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "&pdev->dev",
            "\"%s: Out of memory!\\n\"",
            "__func__"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pdn)",
            "GFP_KERNEL"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *add_one_dev_pci_data(struct pci_dn *parent,\n\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn) {\n\t\tdev_warn(&pdev->dev, \"%s: Out of memory!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n#ifdef CONFIG_PPC_POWERNV\n\tpdn->pe_number = IODA_INVALID_PE;\n#endif\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\t/*\n\t * If we already have PCI device instance, lets\n\t * bind them.\n\t */\n\tif (pdev)\n\t\tpdev->dev.archdata.pci_data = pdn;\n\n\treturn pdn;\n}"
  },
  {
    "function_name": "pci_get_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "107-137",
    "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdn",
            "&parent->child_list",
            "list"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "42-68",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_get_pdn_by_devfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "70-105",
    "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdn",
            "&parent->child_list",
            "list"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "bus"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "42-68",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_bus_to_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "42-68",
    "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
    "includes": [
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "pbus"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_is_root_bus",
          "args": [
            "pbus"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
  }
]