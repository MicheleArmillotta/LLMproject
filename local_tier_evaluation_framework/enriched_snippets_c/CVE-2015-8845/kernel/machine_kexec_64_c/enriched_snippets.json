[
  {
    "function_name": "export_htab_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "401-429",
    "snippet": "static int __init export_htab_values(void)\n{\n\tstruct device_node *node;\n\tstruct property *prop;\n\n\t/* On machines with no htab htab_address is NULL */\n\tif (!htab_address)\n\t\treturn -ENODEV;\n\n\tnode = of_find_node_by_path(\"/chosen\");\n\tif (!node)\n\t\treturn -ENODEV;\n\n\t/* remove any stale propertys so ours can be found */\n\tprop = of_find_property(node, htab_base_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\tprop = of_find_property(node, htab_size_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\thtab_base = cpu_to_be64(__pa(htab_address));\n\tof_add_property(node, &htab_base_prop);\n\thtab_size = cpu_to_be64(htab_size_bytes);\n\tof_add_property(node, &htab_size_prop);\n\n\tof_node_put(node);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "node"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "node",
            "&htab_size_prop"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "htab_size_bytes"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "node",
            "&htab_base_prop"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "__pa(htab_address)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "htab_address"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_remove_property",
          "args": [
            "node",
            "prop"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "node",
            "htab_size_prop.name",
            "NULL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_remove_property",
          "args": [
            "node",
            "prop"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "node",
            "htab_base_prop.name",
            "NULL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/chosen\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic int __init export_htab_values(void)\n{\n\tstruct device_node *node;\n\tstruct property *prop;\n\n\t/* On machines with no htab htab_address is NULL */\n\tif (!htab_address)\n\t\treturn -ENODEV;\n\n\tnode = of_find_node_by_path(\"/chosen\");\n\tif (!node)\n\t\treturn -ENODEV;\n\n\t/* remove any stale propertys so ours can be found */\n\tprop = of_find_property(node, htab_base_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\tprop = of_find_property(node, htab_size_prop.name, NULL);\n\tif (prop)\n\t\tof_remove_property(node, prop);\n\n\thtab_base = cpu_to_be64(__pa(htab_address));\n\tof_add_property(node, &htab_base_prop);\n\thtab_size = cpu_to_be64(htab_size_bytes);\n\tof_add_property(node, &htab_size_prop);\n\n\tof_node_put(node);\n\treturn 0;\n}"
  },
  {
    "function_name": "default_machine_kexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "335-382",
    "snippet": "void default_machine_kexec(struct kimage *image)\n{\n\t/* prepare control code if any */\n\n\t/*\n        * If the kexec boot is the normal one, need to shutdown other cpus\n        * into our wait loop and quiesce interrupts.\n        * Otherwise, in the case of crashed mode (crashing_cpu >= 0),\n        * stopping other CPUs and collecting their pt_regs is done before\n        * using debugger IPI.\n        */\n\n\tif (!kdump_in_progress())\n\t\tkexec_prepare_cpus();\n\n\tpr_debug(\"kexec: Starting switchover sequence.\\n\");\n\n\t/* switch to a staticly allocated stack.  Based on irq stack code.\n\t * We setup preempt_count to avoid using VMX in memcpy.\n\t * XXX: the task struct will likely be invalid once we do the copy!\n\t */\n\tkexec_stack.thread_info.task = current_thread_info()->task;\n\tkexec_stack.thread_info.flags = 0;\n\tkexec_stack.thread_info.preempt_count = HARDIRQ_OFFSET;\n\tkexec_stack.thread_info.cpu = current_thread_info()->cpu;\n\n\t/* We need a static PACA, too; copy this CPU's PACA over and switch to\n\t * it.  Also poison per_cpu_offset to catch anyone using non-static\n\t * data.\n\t */\n\tmemcpy(&kexec_paca, get_paca(), sizeof(struct paca_struct));\n\tkexec_paca.data_offset = 0xedeaddeadeeeeeeeUL;\n\tpaca = (struct paca_struct *)RELOC_HIDE(&kexec_paca, 0) -\n\t\tkexec_paca.paca_index;\n\tsetup_paca(&kexec_paca);\n\n\t/* XXX: If anyone does 'dynamic lppacas' this will also need to be\n\t * switched to a static version!\n\t */\n\n\t/* Some things are best done in assembly.  Finding globals with\n\t * a toc is easier in C, so pass in what we can.\n\t */\n\tkexec_sequence(&kexec_stack, image->start, image,\n\t\t\tpage_address(image->control_code_page),\n\t\t\tppc_md.hpte_clear_all);\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct paca_struct kexec_paca;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_sequence",
          "args": [
            "&kexec_stack",
            "image->start",
            "image",
            "page_address(image->control_code_page)",
            "ppc_md.hpte_clear_all"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "image->control_code_page"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_paca",
          "args": [
            "&kexec_paca"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "setup_paca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "183-201",
          "snippet": "void setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/* In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/* In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "RELOC_HIDE",
          "args": [
            "&kexec_paca",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&kexec_paca",
            "get_paca()",
            "sizeof(struct paca_struct)"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kexec: Starting switchover sequence.\\n\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_prepare_cpus",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_prepare_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
          "lines": "288-304",
          "snippet": "static void kexec_prepare_cpus(void)\n{\n\t/*\n\t * move the secondarys to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t *\n\t * We need to release the cpus if we are ever going from an\n\t * UP to an SMP kernel.\n\t */\n\tsmp_release_cpus();\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n}",
          "includes": [
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/sections.h>\t/* _end */",
            "#include <asm/mmu.h>",
            "#include <asm/paca.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/machdep.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/init_task.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/smp.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_prepare_cpus(void)\n{\n\t/*\n\t * move the secondarys to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t *\n\t * We need to release the cpus if we are ever going from an\n\t * UP to an SMP kernel.\n\t */\n\tsmp_release_cpus();\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdump_in_progress",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstruct paca_struct kexec_paca;\n\nvoid default_machine_kexec(struct kimage *image)\n{\n\t/* prepare control code if any */\n\n\t/*\n        * If the kexec boot is the normal one, need to shutdown other cpus\n        * into our wait loop and quiesce interrupts.\n        * Otherwise, in the case of crashed mode (crashing_cpu >= 0),\n        * stopping other CPUs and collecting their pt_regs is done before\n        * using debugger IPI.\n        */\n\n\tif (!kdump_in_progress())\n\t\tkexec_prepare_cpus();\n\n\tpr_debug(\"kexec: Starting switchover sequence.\\n\");\n\n\t/* switch to a staticly allocated stack.  Based on irq stack code.\n\t * We setup preempt_count to avoid using VMX in memcpy.\n\t * XXX: the task struct will likely be invalid once we do the copy!\n\t */\n\tkexec_stack.thread_info.task = current_thread_info()->task;\n\tkexec_stack.thread_info.flags = 0;\n\tkexec_stack.thread_info.preempt_count = HARDIRQ_OFFSET;\n\tkexec_stack.thread_info.cpu = current_thread_info()->cpu;\n\n\t/* We need a static PACA, too; copy this CPU's PACA over and switch to\n\t * it.  Also poison per_cpu_offset to catch anyone using non-static\n\t * data.\n\t */\n\tmemcpy(&kexec_paca, get_paca(), sizeof(struct paca_struct));\n\tkexec_paca.data_offset = 0xedeaddeadeeeeeeeUL;\n\tpaca = (struct paca_struct *)RELOC_HIDE(&kexec_paca, 0) -\n\t\tkexec_paca.paca_index;\n\tsetup_paca(&kexec_paca);\n\n\t/* XXX: If anyone does 'dynamic lppacas' this will also need to be\n\t * switched to a static version!\n\t */\n\n\t/* Some things are best done in assembly.  Finding globals with\n\t * a toc is easier in C, so pass in what we can.\n\t */\n\tkexec_sequence(&kexec_stack, image->start, image,\n\t\t\tpage_address(image->control_code_page),\n\t\t\tppc_md.hpte_clear_all);\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "kexec_prepare_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "288-304",
    "snippet": "static void kexec_prepare_cpus(void)\n{\n\t/*\n\t * move the secondarys to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t *\n\t * We need to release the cpus if we are ever going from an\n\t * UP to an SMP kernel.\n\t */\n\tsmp_release_cpus();\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.kexec_cpu_down",
          "args": [
            "0",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_release_cpus",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "smp_release_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_64.c",
          "lines": "355-386",
          "snippet": "void smp_release_cpus(void)\n{\n\tunsigned long *ptr;\n\tint i;\n\n\tif (!use_spinloop())\n\t\treturn;\n\n\tDBG(\" -> smp_release_cpus()\\n\");\n\n\t/* All secondary cpus are spinning on a common spinloop, release them\n\t * all now so they can start to spin on their individual paca\n\t * spinloops. For non SMP kernels, the secondary cpus never get out\n\t * of the common spinloop.\n\t */\n\n\tptr  = (unsigned long *)((unsigned long)&__secondary_hold_spinloop\n\t\t\t- PHYSICAL_START);\n\t*ptr = ppc_function_entry(generic_secondary_smp_init);\n\n\t/* And wait a bit for them to catch up */\n\tfor (i = 0; i < 100000; i++) {\n\t\tmb();\n\t\tHMT_low();\n\t\tif (spinning_secondaries == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDBG(\"spinning_secondaries = %d\\n\", spinning_secondaries);\n\n\tDBG(\" <- smp_release_cpus()\\n\");\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/hugetlb.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/kexec.h>",
            "#include <asm/udbg.h>",
            "#include <asm/xmon.h>",
            "#include <asm/firmware.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/paca.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memory.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memblock.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/pci.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/tty.h>",
            "#include <linux/utsname.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int spinning_secondaries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/hugetlb.h>\n#include <asm/kvm_ppc.h>\n#include <asm/code-patching.h>\n#include <asm/mmu_context.h>\n#include <asm/kexec.h>\n#include <asm/udbg.h>\n#include <asm/xmon.h>\n#include <asm/firmware.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/paca.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <linux/nmi.h>\n#include <linux/memory.h>\n#include <linux/hugetlb.h>\n#include <linux/memblock.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/bootmem.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/tty.h>\n#include <linux/utsname.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nint spinning_secondaries;\n\nvoid smp_release_cpus(void)\n{\n\tunsigned long *ptr;\n\tint i;\n\n\tif (!use_spinloop())\n\t\treturn;\n\n\tDBG(\" -> smp_release_cpus()\\n\");\n\n\t/* All secondary cpus are spinning on a common spinloop, release them\n\t * all now so they can start to spin on their individual paca\n\t * spinloops. For non SMP kernels, the secondary cpus never get out\n\t * of the common spinloop.\n\t */\n\n\tptr  = (unsigned long *)((unsigned long)&__secondary_hold_spinloop\n\t\t\t- PHYSICAL_START);\n\t*ptr = ppc_function_entry(generic_secondary_smp_init);\n\n\t/* And wait a bit for them to catch up */\n\tfor (i = 0; i < 100000; i++) {\n\t\tmb();\n\t\tHMT_low();\n\t\tif (spinning_secondaries == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDBG(\"spinning_secondaries = %d\\n\", spinning_secondaries);\n\n\tDBG(\" <- smp_release_cpus()\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_prepare_cpus(void)\n{\n\t/*\n\t * move the secondarys to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t *\n\t * We need to release the cpus if we are ever going from an\n\t * UP to an SMP kernel.\n\t */\n\tsmp_release_cpus();\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n}"
  },
  {
    "function_name": "kexec_prepare_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "259-284",
    "snippet": "static void kexec_prepare_cpus(void)\n{\n\twake_offline_cpus();\n\tsmp_call_function(kexec_smp_down, NULL, /* wait */0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n\n\tmb(); /* make sure IRQs are disabled before we say they are */\n\tget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\n\n\tkexec_prepare_cpus_wait(KEXEC_STATE_IRQS_OFF);\n\t/* we are sure every CPU has IRQs off at this point */\n\tkexec_all_irq_disabled = 1;\n\n\t/* after we tell the others to go down */\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\n\t/*\n\t * Before removing MMU mappings make sure all CPUs have entered real\n\t * mode:\n\t */\n\tkexec_prepare_cpus_wait(KEXEC_STATE_REAL_MODE);\n\n\tput_cpu();\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_prepare_cpus_wait",
          "args": [
            "KEXEC_STATE_REAL_MODE"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_prepare_cpus_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
          "lines": "199-234",
          "snippet": "static void kexec_prepare_cpus_wait(int wait_state)\n{\n\tint my_cpu, i, notified=-1;\n\n\thw_breakpoint_disable();\n\tmy_cpu = get_cpu();\n\t/* Make sure each CPU has at least made it to the state we need.\n\t *\n\t * FIXME: There is a (slim) chance of a problem if not all of the CPUs\n\t * are correctly onlined.  If somehow we start a CPU on boot with RTAS\n\t * start-cpu, but somehow that CPU doesn't write callin_cpu_map[] in\n\t * time, the boot CPU will timeout.  If it does eventually execute\n\t * stuff, the secondary will start up (paca[].cpu_start was written) and\n\t * get into a peculiar state.  If the platform supports\n\t * smp_ops->take_timebase(), the secondary CPU will probably be spinning\n\t * in there.  If not (i.e. pseries), the secondary will continue on and\n\t * try to online itself/idle/etc. If it survives that, we need to find\n\t * these possible-but-not-online-but-should-be CPUs and chaperone them\n\t * into kexec_smp_wait().\n\t */\n\tfor_each_online_cpu(i) {\n\t\tif (i == my_cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < wait_state) {\n\t\t\tbarrier();\n\t\t\tif (i != notified) {\n\t\t\t\tprintk(KERN_INFO \"kexec: waiting for cpu %d \"\n\t\t\t\t       \"(physical %d) to enter %i state\\n\",\n\t\t\t\t       i, paca[i].hw_cpu_id, wait_state);\n\t\t\t\tnotified = i;\n\t\t\t}\n\t\t}\n\t}\n\tmb();\n}",
          "includes": [
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/sections.h>\t/* _end */",
            "#include <asm/mmu.h>",
            "#include <asm/paca.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/machdep.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/init_task.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/smp.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_prepare_cpus_wait(int wait_state)\n{\n\tint my_cpu, i, notified=-1;\n\n\thw_breakpoint_disable();\n\tmy_cpu = get_cpu();\n\t/* Make sure each CPU has at least made it to the state we need.\n\t *\n\t * FIXME: There is a (slim) chance of a problem if not all of the CPUs\n\t * are correctly onlined.  If somehow we start a CPU on boot with RTAS\n\t * start-cpu, but somehow that CPU doesn't write callin_cpu_map[] in\n\t * time, the boot CPU will timeout.  If it does eventually execute\n\t * stuff, the secondary will start up (paca[].cpu_start was written) and\n\t * get into a peculiar state.  If the platform supports\n\t * smp_ops->take_timebase(), the secondary CPU will probably be spinning\n\t * in there.  If not (i.e. pseries), the secondary will continue on and\n\t * try to online itself/idle/etc. If it survives that, we need to find\n\t * these possible-but-not-online-but-should-be CPUs and chaperone them\n\t * into kexec_smp_wait().\n\t */\n\tfor_each_online_cpu(i) {\n\t\tif (i == my_cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < wait_state) {\n\t\t\tbarrier();\n\t\t\tif (i != notified) {\n\t\t\t\tprintk(KERN_INFO \"kexec: waiting for cpu %d \"\n\t\t\t\t       \"(physical %d) to enter %i state\\n\",\n\t\t\t\t       i, paca[i].hw_cpu_id, wait_state);\n\t\t\t\tnotified = i;\n\t\t\t}\n\t\t}\n\t}\n\tmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.kexec_cpu_down",
          "args": [
            "0",
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "kexec_smp_down",
            "NULL",
            "/* wait */0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_offline_cpus",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "wake_offline_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
          "lines": "246-257",
          "snippet": "static void wake_offline_cpus(void)\n{\n\tint cpu = 0;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (!cpu_online(cpu)) {\n\t\t\tprintk(KERN_INFO \"kexec: Waking offline cpu %d.\\n\",\n\t\t\t       cpu);\n\t\t\tWARN_ON(cpu_up(cpu));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/sections.h>\t/* _end */",
            "#include <asm/mmu.h>",
            "#include <asm/paca.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/machdep.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/init_task.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/smp.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void wake_offline_cpus(void)\n{\n\tint cpu = 0;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (!cpu_online(cpu)) {\n\t\t\tprintk(KERN_INFO \"kexec: Waking offline cpu %d.\\n\",\n\t\t\t       cpu);\n\t\t\tWARN_ON(cpu_up(cpu));\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_prepare_cpus(void)\n{\n\twake_offline_cpus();\n\tsmp_call_function(kexec_smp_down, NULL, /* wait */0);\n\tlocal_irq_disable();\n\thard_irq_disable();\n\n\tmb(); /* make sure IRQs are disabled before we say they are */\n\tget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\n\n\tkexec_prepare_cpus_wait(KEXEC_STATE_IRQS_OFF);\n\t/* we are sure every CPU has IRQs off at this point */\n\tkexec_all_irq_disabled = 1;\n\n\t/* after we tell the others to go down */\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 0);\n\n\t/*\n\t * Before removing MMU mappings make sure all CPUs have entered real\n\t * mode:\n\t */\n\tkexec_prepare_cpus_wait(KEXEC_STATE_REAL_MODE);\n\n\tput_cpu();\n}"
  },
  {
    "function_name": "wake_offline_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "246-257",
    "snippet": "static void wake_offline_cpus(void)\n{\n\tint cpu = 0;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (!cpu_online(cpu)) {\n\t\t\tprintk(KERN_INFO \"kexec: Waking offline cpu %d.\\n\",\n\t\t\t       cpu);\n\t\t\tWARN_ON(cpu_up(cpu));\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu_up(cpu)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "cpu"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "generic_set_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp.c",
          "lines": "447-450",
          "snippet": "void generic_set_cpu_up(unsigned int cpu)\n{\n\tper_cpu(cpu_state, cpu) = CPU_UP_PREPARE;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid generic_set_cpu_up(unsigned int cpu)\n{\n\tper_cpu(cpu_state, cpu) = CPU_UP_PREPARE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kexec: Waking offline cpu %d.\\n\"",
            "cpu"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/sysfs.c",
          "lines": "788-866",
          "snippet": "static void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}",
          "includes": [
            "#include <asm/lppaca.h>",
            "#include <asm/paca.h>",
            "#include \"cacheinfo.h\"",
            "#include <asm/firmware.h>",
            "#include <asm/pmc.h>",
            "#include <asm/smp.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/cputable.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define HAS_PPC_PMC_G4\t\t1",
            "#define HAS_PPC_PMC_IBM\t\t1",
            "#define HAS_PPC_PMC_PA6T\t1",
            "#define HAS_PPC_PMC_IBM\t\t1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu, cpu_devices);",
            "static DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/lppaca.h>\n#include <asm/paca.h>\n#include \"cacheinfo.h\"\n#include <asm/firmware.h>\n#include <asm/pmc.h>\n#include <asm/smp.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/hvcall.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/notifier.h>\n#include <linux/cpumask.h>\n#include <linux/nodemask.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n\n#define HAS_PPC_PMC_G4\t\t1\n#define HAS_PPC_PMC_IBM\t\t1\n#define HAS_PPC_PMC_PA6T\t1\n#define HAS_PPC_PMC_IBM\t\t1\n\nstatic DEFINE_PER_CPU(struct cpu, cpu_devices);\nstatic DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);\n\nstatic void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void wake_offline_cpus(void)\n{\n\tint cpu = 0;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (!cpu_online(cpu)) {\n\t\t\tprintk(KERN_INFO \"kexec: Waking offline cpu %d.\\n\",\n\t\t\t       cpu);\n\t\t\tWARN_ON(cpu_up(cpu));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kexec_prepare_cpus_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "199-234",
    "snippet": "static void kexec_prepare_cpus_wait(int wait_state)\n{\n\tint my_cpu, i, notified=-1;\n\n\thw_breakpoint_disable();\n\tmy_cpu = get_cpu();\n\t/* Make sure each CPU has at least made it to the state we need.\n\t *\n\t * FIXME: There is a (slim) chance of a problem if not all of the CPUs\n\t * are correctly onlined.  If somehow we start a CPU on boot with RTAS\n\t * start-cpu, but somehow that CPU doesn't write callin_cpu_map[] in\n\t * time, the boot CPU will timeout.  If it does eventually execute\n\t * stuff, the secondary will start up (paca[].cpu_start was written) and\n\t * get into a peculiar state.  If the platform supports\n\t * smp_ops->take_timebase(), the secondary CPU will probably be spinning\n\t * in there.  If not (i.e. pseries), the secondary will continue on and\n\t * try to online itself/idle/etc. If it survives that, we need to find\n\t * these possible-but-not-online-but-should-be CPUs and chaperone them\n\t * into kexec_smp_wait().\n\t */\n\tfor_each_online_cpu(i) {\n\t\tif (i == my_cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < wait_state) {\n\t\t\tbarrier();\n\t\t\tif (i != notified) {\n\t\t\t\tprintk(KERN_INFO \"kexec: waiting for cpu %d \"\n\t\t\t\t       \"(physical %d) to enter %i state\\n\",\n\t\t\t\t       i, paca[i].hw_cpu_id, wait_state);\n\t\t\t\tnotified = i;\n\t\t\t}\n\t\t}\n\t}\n\tmb();\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kexec: waiting for cpu %d \"\n\t\t\t\t       \"(physical %d) to enter %i state\\n\"",
            "i",
            "paca[i].hw_cpu_id",
            "wait_state"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_prepare_cpus_wait(int wait_state)\n{\n\tint my_cpu, i, notified=-1;\n\n\thw_breakpoint_disable();\n\tmy_cpu = get_cpu();\n\t/* Make sure each CPU has at least made it to the state we need.\n\t *\n\t * FIXME: There is a (slim) chance of a problem if not all of the CPUs\n\t * are correctly onlined.  If somehow we start a CPU on boot with RTAS\n\t * start-cpu, but somehow that CPU doesn't write callin_cpu_map[] in\n\t * time, the boot CPU will timeout.  If it does eventually execute\n\t * stuff, the secondary will start up (paca[].cpu_start was written) and\n\t * get into a peculiar state.  If the platform supports\n\t * smp_ops->take_timebase(), the secondary CPU will probably be spinning\n\t * in there.  If not (i.e. pseries), the secondary will continue on and\n\t * try to online itself/idle/etc. If it survives that, we need to find\n\t * these possible-but-not-online-but-should-be CPUs and chaperone them\n\t * into kexec_smp_wait().\n\t */\n\tfor_each_online_cpu(i) {\n\t\tif (i == my_cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < wait_state) {\n\t\t\tbarrier();\n\t\t\tif (i != notified) {\n\t\t\t\tprintk(KERN_INFO \"kexec: waiting for cpu %d \"\n\t\t\t\t       \"(physical %d) to enter %i state\\n\",\n\t\t\t\t       i, paca[i].hw_cpu_id, wait_state);\n\t\t\t\tnotified = i;\n\t\t\t}\n\t\t}\n\t}\n\tmb();\n}"
  },
  {
    "function_name": "kexec_smp_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "177-197",
    "snippet": "static void kexec_smp_down(void *arg)\n{\n\tlocal_irq_disable();\n\thard_irq_disable();\n\n\tmb(); /* make sure our irqs are disabled before we say they are */\n\tget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\n\twhile(kexec_all_irq_disabled == 0)\n\t\tcpu_relax();\n\tmb(); /* make sure all irqs are disabled before this */\n\thw_breakpoint_disable();\n\t/*\n\t * Now every CPU has IRQs off, we can clear out any pending\n\t * IPIs and be sure that no more will come in after this.\n\t */\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 1);\n\n\tkexec_smp_wait();\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_smp_wait",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.kexec_cpu_down",
          "args": [
            "0",
            "1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void kexec_smp_down(void *arg)\n{\n\tlocal_irq_disable();\n\thard_irq_disable();\n\n\tmb(); /* make sure our irqs are disabled before we say they are */\n\tget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\n\twhile(kexec_all_irq_disabled == 0)\n\t\tcpu_relax();\n\tmb(); /* make sure all irqs are disabled before this */\n\thw_breakpoint_disable();\n\t/*\n\t * Now every CPU has IRQs off, we can clear out any pending\n\t * IPIs and be sure that no more will come in after this.\n\t */\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(0, 1);\n\n\tkexec_smp_wait();\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "kexec_copy_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "148-171",
    "snippet": "void kexec_copy_flush(struct kimage *image)\n{\n\tlong i, nr_segments = image->nr_segments;\n\tstruct  kexec_segment ranges[KEXEC_SEGMENT_MAX];\n\n\t/* save the ranges on the stack to efficiently flush the icache */\n\tmemcpy(ranges, image->segment, sizeof(ranges));\n\n\t/*\n\t * After this call we may not use anything allocated in dynamic\n\t * memory, including *image.\n\t *\n\t * Only globals and the stack are allowed.\n\t */\n\tcopy_segments(image->head);\n\n\t/*\n\t * we need to clear the icache for all dest pages sometime,\n\t * including ones that were in place on the original copy\n\t */\n\tfor (i = 0; i < nr_segments; i++)\n\t\tflush_icache_range((unsigned long)__va(ranges[i].mem),\n\t\t\t(unsigned long)__va(ranges[i].mem + ranges[i].memsz));\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)__va(ranges[i].mem)",
            "(unsigned long)__va(ranges[i].mem + ranges[i].memsz)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "ranges[i].mem + ranges[i].memsz"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "ranges[i].mem"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_segments",
          "args": [
            "image->head"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "copy_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
          "lines": "115-146",
          "snippet": "static void copy_segments(unsigned long ind)\n{\n\tunsigned long entry;\n\tunsigned long *ptr;\n\tvoid *dest;\n\tvoid *addr;\n\n\t/*\n\t * We rely on kexec_load to create a lists that properly\n\t * initializes these pointers before they are used.\n\t * We will still crash if the list is wrong, but at least\n\t * the compiler will be quiet.\n\t */\n\tptr = NULL;\n\tdest = NULL;\n\n\tfor (entry = ind; !(entry & IND_DONE); entry = *ptr++) {\n\t\taddr = __va(entry & PAGE_MASK);\n\n\t\tswitch (entry & IND_FLAGS) {\n\t\tcase IND_DESTINATION:\n\t\t\tdest = addr;\n\t\t\tbreak;\n\t\tcase IND_INDIRECTION:\n\t\t\tptr = addr;\n\t\t\tbreak;\n\t\tcase IND_SOURCE:\n\t\t\tcopy_page(dest, addr);\n\t\t\tdest += PAGE_SIZE;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/sections.h>\t/* _end */",
            "#include <asm/mmu.h>",
            "#include <asm/paca.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/machdep.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/init_task.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/smp.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void copy_segments(unsigned long ind)\n{\n\tunsigned long entry;\n\tunsigned long *ptr;\n\tvoid *dest;\n\tvoid *addr;\n\n\t/*\n\t * We rely on kexec_load to create a lists that properly\n\t * initializes these pointers before they are used.\n\t * We will still crash if the list is wrong, but at least\n\t * the compiler will be quiet.\n\t */\n\tptr = NULL;\n\tdest = NULL;\n\n\tfor (entry = ind; !(entry & IND_DONE); entry = *ptr++) {\n\t\taddr = __va(entry & PAGE_MASK);\n\n\t\tswitch (entry & IND_FLAGS) {\n\t\tcase IND_DESTINATION:\n\t\t\tdest = addr;\n\t\t\tbreak;\n\t\tcase IND_INDIRECTION:\n\t\t\tptr = addr;\n\t\t\tbreak;\n\t\tcase IND_SOURCE:\n\t\t\tcopy_page(dest, addr);\n\t\t\tdest += PAGE_SIZE;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ranges",
            "image->segment",
            "sizeof(ranges)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nvoid kexec_copy_flush(struct kimage *image)\n{\n\tlong i, nr_segments = image->nr_segments;\n\tstruct  kexec_segment ranges[KEXEC_SEGMENT_MAX];\n\n\t/* save the ranges on the stack to efficiently flush the icache */\n\tmemcpy(ranges, image->segment, sizeof(ranges));\n\n\t/*\n\t * After this call we may not use anything allocated in dynamic\n\t * memory, including *image.\n\t *\n\t * Only globals and the stack are allowed.\n\t */\n\tcopy_segments(image->head);\n\n\t/*\n\t * we need to clear the icache for all dest pages sometime,\n\t * including ones that were in place on the original copy\n\t */\n\tfor (i = 0; i < nr_segments; i++)\n\t\tflush_icache_range((unsigned long)__va(ranges[i].mem),\n\t\t\t(unsigned long)__va(ranges[i].mem + ranges[i].memsz));\n}"
  },
  {
    "function_name": "copy_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "115-146",
    "snippet": "static void copy_segments(unsigned long ind)\n{\n\tunsigned long entry;\n\tunsigned long *ptr;\n\tvoid *dest;\n\tvoid *addr;\n\n\t/*\n\t * We rely on kexec_load to create a lists that properly\n\t * initializes these pointers before they are used.\n\t * We will still crash if the list is wrong, but at least\n\t * the compiler will be quiet.\n\t */\n\tptr = NULL;\n\tdest = NULL;\n\n\tfor (entry = ind; !(entry & IND_DONE); entry = *ptr++) {\n\t\taddr = __va(entry & PAGE_MASK);\n\n\t\tswitch (entry & IND_FLAGS) {\n\t\tcase IND_DESTINATION:\n\t\t\tdest = addr;\n\t\t\tbreak;\n\t\tcase IND_INDIRECTION:\n\t\t\tptr = addr;\n\t\t\tbreak;\n\t\tcase IND_SOURCE:\n\t\t\tcopy_page(dest, addr);\n\t\t\tdest += PAGE_SIZE;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_page",
          "args": [
            "dest",
            "addr"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "entry & PAGE_MASK"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nstatic void copy_segments(unsigned long ind)\n{\n\tunsigned long entry;\n\tunsigned long *ptr;\n\tvoid *dest;\n\tvoid *addr;\n\n\t/*\n\t * We rely on kexec_load to create a lists that properly\n\t * initializes these pointers before they are used.\n\t * We will still crash if the list is wrong, but at least\n\t * the compiler will be quiet.\n\t */\n\tptr = NULL;\n\tdest = NULL;\n\n\tfor (entry = ind; !(entry & IND_DONE); entry = *ptr++) {\n\t\taddr = __va(entry & PAGE_MASK);\n\n\t\tswitch (entry & IND_FLAGS) {\n\t\tcase IND_DESTINATION:\n\t\t\tdest = addr;\n\t\t\tbreak;\n\t\tcase IND_INDIRECTION:\n\t\t\tptr = addr;\n\t\t\tbreak;\n\t\tcase IND_SOURCE:\n\t\t\tcopy_page(dest, addr);\n\t\t\tdest += PAGE_SIZE;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "default_machine_kexec_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "48-112",
    "snippet": "int default_machine_kexec_prepare(struct kimage *image)\n{\n\tint i;\n\tunsigned long begin, end;\t/* limits of segment */\n\tunsigned long low, high;\t/* limits of blocked memory range */\n\tstruct device_node *node;\n\tconst unsigned long *basep;\n\tconst unsigned int *sizep;\n\n\tif (!ppc_md.hpte_clear_all)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we use the kernel fault handlers and paging code to\n\t * handle the virtual mode, we must make sure no destination\n\t * overlaps kernel static data or bss.\n\t */\n\tfor (i = 0; i < image->nr_segments; i++)\n\t\tif (image->segment[i].mem < __pa(_end))\n\t\t\treturn -ETXTBSY;\n\n\t/*\n\t * For non-LPAR, we absolutely can not overwrite the mmu hash\n\t * table, since we are still using the bolted entries in it to\n\t * do the copy.  Check that here.\n\t *\n\t * It is safe if the end is below the start of the blocked\n\t * region (end <= low), or if the beginning is after the\n\t * end of the blocked region (begin >= high).  Use the\n\t * boolean identity !(a || b)  === (!a && !b).\n\t */\n\tif (htab_address) {\n\t\tlow = __pa(htab_address);\n\t\thigh = low + htab_size_bytes;\n\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tbegin = image->segment[i].mem;\n\t\t\tend = begin + image->segment[i].memsz;\n\n\t\t\tif ((begin < high) && (end > low))\n\t\t\t\treturn -ETXTBSY;\n\t\t}\n\t}\n\n\t/* We also should not overwrite the tce tables */\n\tfor_each_node_by_type(node, \"pci\") {\n\t\tbasep = of_get_property(node, \"linux,tce-base\", NULL);\n\t\tsizep = of_get_property(node, \"linux,tce-size\", NULL);\n\t\tif (basep == NULL || sizep == NULL)\n\t\t\tcontinue;\n\n\t\tlow = *basep;\n\t\thigh = low + (*sizep);\n\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tbegin = image->segment[i].mem;\n\t\t\tend = begin + image->segment[i].memsz;\n\n\t\t\tif ((begin < high) && (end > low))\n\t\t\t\treturn -ETXTBSY;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"linux,tce-size\"",
            "NULL"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"linux,tce-base\"",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_by_type",
          "args": [
            "node",
            "\"pci\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "htab_address"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nint default_machine_kexec_prepare(struct kimage *image)\n{\n\tint i;\n\tunsigned long begin, end;\t/* limits of segment */\n\tunsigned long low, high;\t/* limits of blocked memory range */\n\tstruct device_node *node;\n\tconst unsigned long *basep;\n\tconst unsigned int *sizep;\n\n\tif (!ppc_md.hpte_clear_all)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we use the kernel fault handlers and paging code to\n\t * handle the virtual mode, we must make sure no destination\n\t * overlaps kernel static data or bss.\n\t */\n\tfor (i = 0; i < image->nr_segments; i++)\n\t\tif (image->segment[i].mem < __pa(_end))\n\t\t\treturn -ETXTBSY;\n\n\t/*\n\t * For non-LPAR, we absolutely can not overwrite the mmu hash\n\t * table, since we are still using the bolted entries in it to\n\t * do the copy.  Check that here.\n\t *\n\t * It is safe if the end is below the start of the blocked\n\t * region (end <= low), or if the beginning is after the\n\t * end of the blocked region (begin >= high).  Use the\n\t * boolean identity !(a || b)  === (!a && !b).\n\t */\n\tif (htab_address) {\n\t\tlow = __pa(htab_address);\n\t\thigh = low + htab_size_bytes;\n\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tbegin = image->segment[i].mem;\n\t\t\tend = begin + image->segment[i].memsz;\n\n\t\t\tif ((begin < high) && (end > low))\n\t\t\t\treturn -ETXTBSY;\n\t\t}\n\t}\n\n\t/* We also should not overwrite the tce tables */\n\tfor_each_node_by_type(node, \"pci\") {\n\t\tbasep = of_get_property(node, \"linux,tce-base\", NULL);\n\t\tsizep = of_get_property(node, \"linux,tce-size\", NULL);\n\t\tif (basep == NULL || sizep == NULL)\n\t\t\tcontinue;\n\n\t\tlow = *basep;\n\t\thigh = low + (*sizep);\n\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tbegin = image->segment[i].mem;\n\t\t\tend = begin + image->segment[i].memsz;\n\n\t\t\tif ((begin < high) && (end > low))\n\t\t\t\treturn -ETXTBSY;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "default_machine_kexec_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_64.c",
    "lines": "34-46",
    "snippet": "int default_machine_kexec_prepare(struct kimage *image)\n{\n\tint i;\n\t/*\n\t * Since we use the kernel fault handlers and paging code to\n\t * handle the virtual mode, we must make sure no destination\n\t * overlaps kernel static data or bss.\n\t */\n\tfor (i = 0; i < image->nr_segments; i++)\n\t\tif (image->segment[i].mem < __pa(_end))\n\t\t\treturn -ETXTBSY;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hw_breakpoint.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/sections.h>\t/* _end */",
      "#include <asm/mmu.h>",
      "#include <asm/paca.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/machdep.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/init_task.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/smp.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "_end"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/hw_breakpoint.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/sections.h>\t/* _end */\n#include <asm/mmu.h>\n#include <asm/paca.h>\n#include <asm/cacheflush.h>\n#include <asm/machdep.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <linux/hardirq.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/thread_info.h>\n#include <linux/smp.h>\n#include <linux/kexec.h>\n\nint default_machine_kexec_prepare(struct kimage *image)\n{\n\tint i;\n\t/*\n\t * Since we use the kernel fault handlers and paging code to\n\t * handle the virtual mode, we must make sure no destination\n\t * overlaps kernel static data or bss.\n\t */\n\tfor (i = 0; i < image->nr_segments; i++)\n\t\tif (image->segment[i].mem < __pa(_end))\n\t\t\treturn -ETXTBSY;\n\treturn 0;\n}"
  }
]