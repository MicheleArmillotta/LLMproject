[
  {
    "function_name": "eeh_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "929-935",
    "snippet": "void eeh_handle_event(struct eeh_pe *pe)\n{\n\tif (pe)\n\t\teeh_handle_normal_event(pe);\n\telse\n\t\teeh_handle_special_event();\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_handle_special_event",
          "args": [],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_special_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "820-910",
          "snippet": "static void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc == EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\t\t\telse\n\t\t\t\teeh_pe_state_mark(pe,\n\t\t\t\t\tEEH_PE_ISOLATED | EEH_PE_RECOVERING);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_handle_normal_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Notify all devices to be down */\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\teeh_pe_dev_traverse(pe,\n\t\t\t\t\teeh_report_failure, NULL);\n\t\t\t\tpcibios_remove_pci_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc == EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\t\t\telse\n\t\t\t\teeh_pe_state_mark(pe,\n\t\t\t\t\tEEH_PE_ISOLATED | EEH_PE_RECOVERING);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_handle_normal_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Notify all devices to be down */\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\teeh_pe_dev_traverse(pe,\n\t\t\t\t\teeh_report_failure, NULL);\n\t\t\t\tpcibios_remove_pci_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_handle_normal_event",
          "args": [
            "pe"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_normal_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "642-818",
          "snippet": "static void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define MAX_WAIT_FOR_RECOVERY 300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nstatic void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nvoid eeh_handle_event(struct eeh_pe *pe)\n{\n\tif (pe)\n\t\teeh_handle_normal_event(pe);\n\telse\n\t\teeh_handle_special_event();\n}"
  },
  {
    "function_name": "eeh_handle_special_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "820-910",
    "snippet": "static void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc == EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\t\t\telse\n\t\t\t\teeh_pe_state_mark(pe,\n\t\t\t\t\tEEH_PE_ISOLATED | EEH_PE_RECOVERING);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_handle_normal_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Notify all devices to be down */\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\teeh_pe_dev_traverse(pe,\n\t\t\t\t\teeh_report_failure, NULL);\n\t\t\t\tpcibios_remove_pci_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_remove_pci_devices",
          "args": [
            "bus"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_remove_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "47-62",
          "snippet": "void pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_report_failure",
            "NULL"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "phb_pe"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "924-947",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "hose"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "120-135",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_handle_normal_event",
          "args": [
            "pe"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_normal_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "642-818",
          "snippet": "static void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define MAX_WAIT_FOR_RECOVERY 300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nstatic void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid value %d from next_error()\\n\"",
            "__func__",
            "rc"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_ISOLATED | EEH_PE_RECOVERING"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_remove_event",
          "args": [
            "pe",
            "true"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_remove_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "162-196",
          "snippet": "void eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\n\nvoid eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->next_error",
          "args": [
            "&pe"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc == EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_ISOLATED);\n\t\t\telse\n\t\t\t\teeh_pe_state_mark(pe,\n\t\t\t\t\tEEH_PE_ISOLATED | EEH_PE_RECOVERING);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_handle_normal_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Notify all devices to be down */\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\teeh_pe_dev_traverse(pe,\n\t\t\t\t\teeh_report_failure, NULL);\n\t\t\t\tpcibios_remove_pci_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}"
  },
  {
    "function_name": "eeh_handle_normal_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "642-818",
    "snippet": "static void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define MAX_WAIT_FOR_RECOVERY 300"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_remove_pci_devices",
          "args": [
            "frozen_bus"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_remove_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "47-62",
          "snippet": "void pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_mode_mark",
          "args": [
            "pe",
            "EEH_DEV_REMOVED"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_mode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "595-598",
          "snippet": "void eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_REMOVED"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_report_failure",
            "NULL"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_slot_error_detail",
          "args": [
            "pe",
            "EEH_LOG_PERM"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_slot_error_detail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "295-334",
          "snippet": "void eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\"",
            "pe->phb->global_number",
            "pe->addr",
            "pe->freeze_count"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device driver to resume\\n\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Not recovered\\n\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Cannot reset, err=%d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_reset_device",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_reset_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "549-635",
          "snippet": "static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\n{\n\tstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\n\tstruct timeval tstamp;\n\tint cnt, rc, removed = 0;\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pcibios_add_pci_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (bus) {\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t} else if (frozen_bus) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_reset_pe(pe);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * If it's PHB PE, the frozen state on all available PEs should have\n\t * been cleared by the PHB reset. Otherwise, we unfreeze the PE and its\n\t * child PEs because they might be in frozen state.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\trc = eeh_clear_pe_frozen_state(pe, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (bus) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of complete hotplug\\n\");\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(bus);\n\t} else if (frozen_bus && removed) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of partial hotplug\\n\");\n\t\tssleep(5);\n\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(frozen_bus);\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\n{\n\tstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\n\tstruct timeval tstamp;\n\tint cnt, rc, removed = 0;\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pcibios_add_pci_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (bus) {\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t} else if (frozen_bus) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_reset_pe(pe);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * If it's PHB PE, the frozen state on all available PEs should have\n\t * been cleared by the PHB reset. Otherwise, we unfreeze the PE and its\n\t * child PEs because they might be in frozen state.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\trc = eeh_clear_pe_frozen_state(pe, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (bus) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of complete hotplug\\n\");\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(bus);\n\t} else if (frozen_bus && removed) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of partial hotplug\\n\");\n\t\tssleep(5);\n\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(frozen_bus);\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Reset without hotplug activity\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Device driver gave up\\n\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "623-690",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%d-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc <= 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Enabled DMA for affected devices\\n\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device drivers to resume I/O\\n\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Enable I/O for affected devices\\n\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unable to reset, err=%d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Reset with hotplug activity\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Collect temporary log\\n\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Permanent failure\\n\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->wait_state",
          "args": [
            "pe",
            "MAX_WAIT_FOR_RECOVERY*1000"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device drivers to shutdown\\n\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: This PCI device has failed %d times in the last hour\\n\"",
            "pe->freeze_count"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_update_time_stamp",
          "args": [
            "pe"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_update_time_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "509-525",
          "snippet": "void eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\tstruct timeval tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tdo_gettimeofday(&pe->tstamp);\n\t} else {\n\t\tdo_gettimeofday(&tstamp);\n\t\tif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\tstruct timeval tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tdo_gettimeofday(&pe->tstamp);\n\t} else {\n\t\tdo_gettimeofday(&tstamp);\n\t\tif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\"",
            "__func__",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "pe"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "924-947",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nstatic void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *frozen_bus;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\n\tfrozen_bus = eeh_pe_bus_get(pe);\n\tif (!frozen_bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%d-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes)\n\t\tgoto excess_failures;\n\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour\\n\",\n\t\tpe->freeze_count);\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\tif ((pe->type & EEH_PE_PHB) &&\n\t    result != PCI_ERS_RESULT_NONE &&\n\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\trc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tpr_info(\"EEH: Collect temporary log\\n\");\n\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, frozen_bus);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0)\n\t\t\tgoto hard_fail;\n\t\tif (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device has a hard failure, then shut off everything. */\n\tif (result == PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: Device driver gave up\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, NULL);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto hard_fail;\n\t\t}\n\n\t\tpr_info(\"EEH: Notify device drivers \"\n\t\t\t\"the completion of reset\\n\");\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\t}\n\n\t/* All devices should claim they have recovered by now. */\n\tif ((result != PCI_ERS_RESULT_RECOVERED) &&\n\t    (result != PCI_ERS_RESULT_NONE)) {\n\t\tpr_warn(\"EEH: Not recovered\\n\");\n\t\tgoto hard_fail;\n\t}\n\n\t/* Tell all device drivers that they can resume operations */\n\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\treturn;\n\nexcess_failures:\n\t/*\n\t * About 90% of all real-life EEH failures in the field\n\t * are due to poorly seated PCI cards. Only 10% or so are\n\t * due to actual, failed cards.\n\t */\n\tpr_err(\"EEH: PHB#%d-PE#%x has failed %d times in the\\n\"\n\t       \"last hour and has been permanently disabled.\\n\"\n\t       \"Please try reseating or replacing it.\\n\",\n\t\tpe->phb->global_number, pe->addr,\n\t\tpe->freeze_count);\n\tgoto perm_error;\n\nhard_fail:\n\tpr_err(\"EEH: Unable to recover from failure from PHB#%d-PE#%x.\\n\"\n\t       \"Please try reseating or replacing it\\n\",\n\t\tpe->phb->global_number, pe->addr);\n\nperm_error:\n\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t/* Notify all devices that they're about to go down. */\n\teeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\n\n\t/* Mark the PE to be removed permanently */\n\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t/*\n\t * Shut down the device drivers for good. We mark\n\t * all removed devices correctly to avoid access\n\t * the their PCI config any more.\n\t */\n\tif (frozen_bus) {\n\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(frozen_bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n}"
  },
  {
    "function_name": "eeh_reset_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "549-635",
    "snippet": "static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\n{\n\tstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\n\tstruct timeval tstamp;\n\tint cnt, rc, removed = 0;\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pcibios_add_pci_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (bus) {\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t} else if (frozen_bus) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_reset_pe(pe);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * If it's PHB PE, the frozen state on all available PEs should have\n\t * been cleared by the PHB reset. Otherwise, we unfreeze the PE and its\n\t * child PEs because they might be in frozen state.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\trc = eeh_clear_pe_frozen_state(pe, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (bus) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of complete hotplug\\n\");\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(bus);\n\t} else if (frozen_bus && removed) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of partial hotplug\\n\");\n\t\tssleep(5);\n\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(frozen_bus);\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_KEEP"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_add_pci_devices",
          "args": [
            "frozen_bus"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_add_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "77-116",
          "snippet": "void pcibios_add_pci_devices(struct pci_bus * bus)\n{\n\tint slotno, mode, pass, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\teeh_add_device_tree_early(PCI_DN(dn));\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tpcibios_setup_bus_devices(bus);\n\t\tmax = bus->busn_res.start;\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t\t\tif (pci_is_bridge(dev))\n\t\t\t\t\tmax = pci_scan_bridge(bus, dev,\n\t\t\t\t\t\t\t      max, pass);\n\t\t\t}\n\t\t}\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_add_pci_devices(struct pci_bus * bus)\n{\n\tint slotno, mode, pass, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\teeh_add_device_tree_early(PCI_DN(dn));\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tpcibios_setup_bus_devices(bus);\n\t\tmax = bus->busn_res.start;\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t\t\tif (pci_is_bridge(dev))\n\t\t\t\t\tmax = pci_scan_bridge(bus, dev,\n\t\t\t\t\t\t\t      max, pass);\n\t\t\t}\n\t\t}\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "eeh_pe_detach_dev",
            "NULL"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "5"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Sleep 5s ahead of partial hotplug\\n\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "5"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Sleep 5s ahead of complete hotplug\\n\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_clear_pe_frozen_state",
          "args": [
            "pe",
            "false"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_clear_pe_frozen_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "482-492",
          "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "865-872",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->configure_bridge",
          "args": [
            "pe"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_reset_pe",
          "args": [
            "pe"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_reset_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "847-885",
          "snippet": "int eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_rmv_device",
            "&removed"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_remove_pci_devices",
          "args": [
            "bus"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_remove_pci_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "47-62",
          "snippet": "void pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_remove_pci_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_remove_pci_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_KEEP"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "pe"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "924-947",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\n{\n\tstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\n\tstruct timeval tstamp;\n\tint cnt, rc, removed = 0;\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pcibios_add_pci_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (bus) {\n\t\tpci_lock_rescan_remove();\n\t\tpcibios_remove_pci_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t} else if (frozen_bus) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_reset_pe(pe);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * If it's PHB PE, the frozen state on all available PEs should have\n\t * been cleared by the PHB reset. Otherwise, we unfreeze the PE and its\n\t * child PEs because they might be in frozen state.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\trc = eeh_clear_pe_frozen_state(pe, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (bus) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of complete hotplug\\n\");\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(bus);\n\t} else if (frozen_bus && removed) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of partial hotplug\\n\");\n\t\tssleep(5);\n\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tpcibios_add_pci_devices(frozen_bus);\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_reset_and_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "494-538",
    "snippet": "int eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint result, ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Report error */\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\n\t/* Issue reset */\n\tret = eeh_reset_pe(pe);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Notify completion of reset */\n\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Resume */\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_report_resume",
            "NULL"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_clear_pe_frozen_state",
          "args": [
            "pe",
            "true"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_clear_pe_frozen_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "482-492",
          "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_reset_pe",
          "args": [
            "pe"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_reset_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "847-885",
          "snippet": "int eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_reset_pe(struct eeh_pe *pe)\n{\n\tint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\n\tint i, state, ret;\n\n\t/* Mark as reset and block config space */\n\teeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\n\t/* Take three shots at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\teeh_reset_pe_once(pe);\n\n\t\t/*\n\t\t * EEH_PE_ISOLATED is expected to be removed after\n\t\t * BAR restore.\n\t\t */\n\t\tstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif ((state & flags) == flags) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"%s: Unrecoverable slot failure on PHB#%d-PE#%x\",\n\t\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* We might run out of credits */\n\t\tret = -EIO;\n\t\tpr_warn(\"%s: Failure %d resetting PHB#%x-PE#%x\\n (%d)\\n\",\n\t\t\t__func__, state, pe->phb->global_number, pe->addr, (i + 1));\n\t}\n\nout:\n\teeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nint eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint result, ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Report error */\n\teeh_pe_dev_traverse(pe, eeh_report_error, &result);\n\n\t/* Issue reset */\n\tret = eeh_reset_pe(pe);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\treturn ret;\n\t}\n\n\t/* Notify completion of reset */\n\teeh_pe_dev_traverse(pe, eeh_report_reset, &result);\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Resume */\n\teeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_clear_pe_frozen_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "482-492",
    "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "__eeh_clear_pe_frozen_state",
            "&clear_sw_state"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\n\t\t\t\t     bool clear_sw_state)\n{\n\tvoid *rc;\n\n\trc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\n\tif (!rc)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn rc ? -EIO : 0;\n}"
  },
  {
    "function_name": "__eeh_clear_pe_frozen_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "463-480",
    "snippet": "static void *__eeh_clear_pe_frozen_state(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tbool *clear_sw_state = flag;\n\tint i, rc = 1;\n\n\tfor (i = 0; rc && i < 3; i++)\n\t\trc = eeh_unfreeze_pe(pe, clear_sw_state);\n\n\t/* Stop immediately on any errors */\n\tif (rc) {\n\t\tpr_warn(\"%s: Failure %d unfreezing PHB#%x-PE#%x\\n\",\n\t\t\t__func__, rc, pe->phb->global_number, pe->addr);\n\t\treturn (void *)pe;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d unfreezing PHB#%x-PE#%x\\n\"",
            "__func__",
            "rc",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe",
            "clear_sw_state"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1265-1288",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\t/* Clear software isolated state */\n\tif (sw_state && (pe->state & EEH_PE_ISOLATED))\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_clear_pe_frozen_state(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tbool *clear_sw_state = flag;\n\tint i, rc = 1;\n\n\tfor (i = 0; rc && i < 3; i++)\n\t\trc = eeh_unfreeze_pe(pe, clear_sw_state);\n\n\t/* Stop immediately on any errors */\n\tif (rc) {\n\t\tpr_warn(\"%s: Failure %d unfreezing PHB#%x-PE#%x\\n\",\n\t\t\t__func__, rc, pe->phb->global_number, pe->addr);\n\t\treturn (void *)pe;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_detach_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "440-454",
    "snippet": "static void *eeh_pe_detach_dev(void *data, void *userdata)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tif (!(edev->mode & EEH_DEV_DISCONNECTED))\n\t\t\tcontinue;\n\n\t\tedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\n\t\teeh_rmv_from_parent_pe(edev);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_rmv_from_parent_pe",
          "args": [
            "edev"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_rmv_from_parent_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "439-498",
          "snippet": "int eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_pe_detach_dev(void *data, void *userdata)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tif (!(edev->mode & EEH_DEV_DISCONNECTED))\n\t\t\tcontinue;\n\n\t\tedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\n\t\teeh_rmv_from_parent_pe(edev);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_rmv_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "389-438",
    "snippet": "static void *eeh_rmv_device(void *data, void *userdata)\n{\n\tstruct pci_driver *driver;\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tint *removed = (int *)userdata;\n\n\t/*\n\t * Actually, we should remove the PCI bridges as well.\n\t * However, that's lots of complexity to do that,\n\t * particularly some of devices under the bridge might\n\t * support EEH. So we just care about PCI devices for\n\t * simplicity here.\n\t */\n\tif (!dev || (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE))\n\t\treturn NULL;\n\n\t/*\n\t * We rely on count-based pcibios_release_device() to\n\t * detach permanently offlined PEs. Unfortunately, that's\n\t * not reliable enough. We might have the permanently\n\t * offlined PEs attached, but we needn't take care of\n\t * them and their child devices.\n\t */\n\tif (eeh_dev_removed(edev))\n\t\treturn NULL;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\teeh_pcid_put(dev);\n\t\tif (driver->err_handler &&\n\t\t    driver->err_handler->error_detected &&\n\t\t    driver->err_handler->slot_reset &&\n\t\t    driver->err_handler->resume)\n\t\t\treturn NULL;\n\t}\n\n\t/* Remove it from PCI subsystem */\n\tpr_debug(\"EEH: Removing %s without EEH sensitive driver\\n\",\n\t\t pci_name(dev));\n\tedev->bus = dev->bus;\n\tedev->mode |= EEH_DEV_DISCONNECTED;\n\t(*removed)++;\n\n\tpci_lock_rescan_remove();\n\tpci_stop_and_remove_bus_device(dev);\n\tpci_unlock_rescan_remove();\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_stop_and_remove_bus_device",
          "args": [
            "dev"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Removing %s without EEH sensitive driver\\n\"",
            "pci_name(dev)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_rmv_device(void *data, void *userdata)\n{\n\tstruct pci_driver *driver;\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tint *removed = (int *)userdata;\n\n\t/*\n\t * Actually, we should remove the PCI bridges as well.\n\t * However, that's lots of complexity to do that,\n\t * particularly some of devices under the bridge might\n\t * support EEH. So we just care about PCI devices for\n\t * simplicity here.\n\t */\n\tif (!dev || (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE))\n\t\treturn NULL;\n\n\t/*\n\t * We rely on count-based pcibios_release_device() to\n\t * detach permanently offlined PEs. Unfortunately, that's\n\t * not reliable enough. We might have the permanently\n\t * offlined PEs attached, but we needn't take care of\n\t * them and their child devices.\n\t */\n\tif (eeh_dev_removed(edev))\n\t\treturn NULL;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\teeh_pcid_put(dev);\n\t\tif (driver->err_handler &&\n\t\t    driver->err_handler->error_detected &&\n\t\t    driver->err_handler->slot_reset &&\n\t\t    driver->err_handler->resume)\n\t\t\treturn NULL;\n\t}\n\n\t/* Remove it from PCI subsystem */\n\tpr_debug(\"EEH: Removing %s without EEH sensitive driver\\n\",\n\t\t pci_name(dev));\n\tedev->bus = dev->bus;\n\tedev->mode |= EEH_DEV_DISCONNECTED;\n\t(*removed)++;\n\n\tpci_lock_rescan_remove();\n\tpci_stop_and_remove_bus_device(dev);\n\tpci_unlock_rescan_remove();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "362-387",
    "snippet": "static void *eeh_report_failure(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_perm_failure;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_disable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->error_detected) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\tdriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->err_handler->error_detected",
          "args": [
            "dev",
            "pci_channel_io_perm_failure"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_disable_irq",
          "args": [
            "dev"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_disable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "96-112",
          "snippet": "static void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_report_failure(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_perm_failure;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_disable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->error_detected) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\tdriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "325-352",
    "snippet": "static void *eeh_report_resume(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_normal;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_enable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->resume ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\tdriver->err_handler->resume(dev);\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->err_handler->resume",
          "args": [
            "dev"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enable_irq",
          "args": [
            "dev"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_enable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "121-150",
          "snippet": "static void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_report_resume(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_normal;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_enable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->resume ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\tdriver->err_handler->resume(dev);\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_dev_restore_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "300-314",
    "snippet": "static void *eeh_dev_restore_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn NULL;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpci_restore_state(pdev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_restore_state",
          "args": [
            "pdev"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_dev_restore_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn NULL;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpci_restore_state(pdev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "267-298",
    "snippet": "static void *eeh_report_reset(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_normal;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_enable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->slot_reset ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->slot_reset(dev);\n\tif ((*res == PCI_ERS_RESULT_NONE) ||\n\t    (*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\n\tif (*res == PCI_ERS_RESULT_DISCONNECT &&\n\t     rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->err_handler->slot_reset",
          "args": [
            "dev"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enable_irq",
          "args": [
            "dev"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_enable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "121-150",
          "snippet": "static void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_report_reset(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_normal;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_enable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->slot_reset ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->slot_reset(dev);\n\tif ((*res == PCI_ERS_RESULT_NONE) ||\n\t    (*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\n\tif (*res == PCI_ERS_RESULT_DISCONNECT &&\n\t     rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_mmio_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "227-255",
    "snippet": "static void *eeh_report_mmio_enabled(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->mmio_enabled ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->mmio_enabled(dev);\n\n\t/* A driver that needs a reset trumps all others */\n\tif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\tif (*res == PCI_ERS_RESULT_NONE) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->err_handler->mmio_enabled",
          "args": [
            "dev"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_report_mmio_enabled(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->mmio_enabled ||\n\t    (edev->mode & EEH_DEV_NO_HANDLER)) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->mmio_enabled(dev);\n\n\t/* A driver that needs a reset trumps all others */\n\tif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\tif (*res == PCI_ERS_RESULT_NONE) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "186-216",
    "snippet": "static void *eeh_report_error(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_frozen;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_disable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->error_detected) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->error_detected(dev, pci_channel_io_frozen);\n\n\t/* A driver that needs a reset trumps all others */\n\tif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\tif (*res == PCI_ERS_RESULT_NONE) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "78-84",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->err_handler->error_detected",
          "args": [
            "dev",
            "pci_channel_io_frozen"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_disable_irq",
          "args": [
            "dev"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_disable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "96-112",
          "snippet": "static void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "60-69",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "152-159",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_report_error(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tenum pci_ers_result rc, *res = userdata;\n\tstruct pci_driver *driver;\n\n\tif (!dev || eeh_dev_removed(edev))\n\t\treturn NULL;\n\tdev->error_state = pci_channel_io_frozen;\n\n\tdriver = eeh_pcid_get(dev);\n\tif (!driver) return NULL;\n\n\teeh_disable_irq(dev);\n\n\tif (!driver->err_handler ||\n\t    !driver->err_handler->error_detected) {\n\t\teeh_pcid_put(dev);\n\t\treturn NULL;\n\t}\n\n\trc = driver->err_handler->error_detected(dev, pci_channel_io_frozen);\n\n\t/* A driver that needs a reset trumps all others */\n\tif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\n\tif (*res == PCI_ERS_RESULT_NONE) *res = rc;\n\n\teeh_pcid_put(dev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_dev_save_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "161-175",
    "snippet": "static void *eeh_dev_save_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn NULL;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpci_save_state(pdev);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_save_state",
          "args": [
            "pdev"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_dev_save_state(void *data, void *userdata)\n{\n\tstruct eeh_dev *edev = data;\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn NULL;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpci_save_state(pdev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_dev_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "152-159",
    "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\t/* EEH device removed ? */\n\tif (!edev || (edev->mode & EEH_DEV_REMOVED))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "eeh_enable_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "121-150",
    "snippet": "static void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "dev->irq"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_enable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "121-150",
          "snippet": "static void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "irq_get_irq_data(dev->irq)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "dev->irq"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_enable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their assymetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\n\t\t\tenable_irq(dev->irq);\n\t}\n}"
  },
  {
    "function_name": "eeh_disable_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "96-112",
    "snippet": "static void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_irq_nosync",
          "args": [
            "dev->irq"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_has_action",
          "args": [
            "dev->irq"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_irq(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (dev->msi_enabled || dev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(dev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(dev->irq);\n}"
  },
  {
    "function_name": "eeh_pcid_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "78-84",
    "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "pdev->driver->driver.owner"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
  },
  {
    "function_name": "eeh_pcid_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "60-69",
    "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "pdev->driver->driver.owner"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
  },
  {
    "function_name": "eeh_pcid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "44-49",
    "snippet": "static inline const char *eeh_pcid_name(struct pci_dev *pdev)\n{\n\tif (pdev && pdev->dev.driver)\n\t\treturn pdev->dev.driver->name;\n\treturn \"\";\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline const char *eeh_pcid_name(struct pci_dev *pdev)\n{\n\tif (pdev && pdev->dev.driver)\n\t\treturn pdev->dev.driver->name;\n\treturn \"\";\n}"
  }
]