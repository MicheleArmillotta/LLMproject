[
  {
    "function_name": "identify_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2182-2197",
    "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_cpu_spec",
          "args": [
            "offset",
            "s"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cpu_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2114-2180",
          "snippet": "static struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/* Copy everything, then do fixups */\n\t*t = *s;\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->oprofile_type = old.oprofile_type;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpu_spec* cur_cpu_spec = NULL;",
            "const char *powerpc_base_platform;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec* cur_cpu_spec = NULL;\nconst char *powerpc_base_platform;\n\nstatic struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/* Copy everything, then do fixups */\n\t*t = *s;\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->oprofile_type = old.oprofile_type;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cpu_specs"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "s"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "setup_cpu_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2114-2180",
    "snippet": "static struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/* Copy everything, then do fixups */\n\t*t = *s;\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->oprofile_type = old.oprofile_type;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpu_spec* cur_cpu_spec = NULL;",
      "const char *powerpc_base_platform;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->cpu_setup",
          "args": [
            "offset",
            "t"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&powerpc_base_platform"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&powerpc_base_platform"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&cur_cpu_spec"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "t"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec* cur_cpu_spec = NULL;\nconst char *powerpc_base_platform;\n\nstatic struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/* Copy everything, then do fixups */\n\t*t = *s;\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->oprofile_type = old.oprofile_type;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}"
  }
]