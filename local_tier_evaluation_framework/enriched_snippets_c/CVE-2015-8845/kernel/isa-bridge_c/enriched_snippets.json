[
  {
    "function_name": "isa_bridge_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "261-265",
    "snippet": "static int __init isa_bridge_init(void)\n{\n\tbus_register_notifier(&pci_bus_type, &isa_bridge_notifier);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block isa_bridge_notifier = {\n\t.notifier_call = isa_bridge_notify\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&isa_bridge_notifier"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct notifier_block isa_bridge_notifier = {\n\t.notifier_call = isa_bridge_notify\n};\n\nstatic int __init isa_bridge_init(void)\n{\n\tbus_register_notifier(&pci_bus_type, &isa_bridge_notifier);\n\treturn 0;\n}"
  },
  {
    "function_name": "isa_bridge_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "218-251",
    "snippet": "static int isa_bridge_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct device_node *devnode = pci_device_to_OF_node(pdev);\n\n\tswitch(action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\t/* Check if we have an early ISA device, without PCI dev */\n\t\tif (isa_bridge_devnode && isa_bridge_devnode == devnode &&\n\t\t    !isa_bridge_pcidev) {\n\t\t\tpr_debug(\"ISA bridge PCI attached: %s\\n\",\n\t\t\t\t pci_name(pdev));\n\t\t\tisa_bridge_pcidev = pdev;\n\t\t}\n\n\t\t/* Check if we have no ISA device, and this happens to be one,\n\t\t * register it as such if it has an OF device\n\t\t */\n\t\tif (!isa_bridge_devnode && devnode && devnode->type &&\n\t\t    !strcmp(devnode->type, \"isa\"))\n\t\t\tisa_bridge_find_late(pdev, devnode);\n\n\t\treturn 0;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\t/* Check if this our existing ISA device */\n\t\tif (pdev == isa_bridge_pcidev ||\n\t\t    (devnode && devnode == isa_bridge_devnode))\n\t\t\tisa_bridge_remove();\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_bridge_remove",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "isa_bridge_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "195-213",
          "snippet": "static void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\t__iounmap_at((void *)ISA_IO_BASE, 0x10000);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long isa_io_base;",
            "static struct device_node *isa_bridge_devnode;",
            "struct pci_dev *isa_bridge_pcidev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\t__iounmap_at((void *)ISA_IO_BASE, 0x10000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_bridge_find_late",
          "args": [
            "pdev",
            "devnode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "isa_bridge_find_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "173-190",
          "snippet": "static void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %s on %s\\n\",\n\t\t devnode->full_name, pci_name(pdev));\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long isa_io_base;",
            "static struct device_node *isa_bridge_devnode;",
            "struct pci_dev *isa_bridge_pcidev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %s on %s\\n\",\n\t\t devnode->full_name, pci_name(pdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "devnode->type",
            "\"isa\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge PCI attached: %s\\n\"",
            "pci_name(pdev)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic int isa_bridge_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct device_node *devnode = pci_device_to_OF_node(pdev);\n\n\tswitch(action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\t/* Check if we have an early ISA device, without PCI dev */\n\t\tif (isa_bridge_devnode && isa_bridge_devnode == devnode &&\n\t\t    !isa_bridge_pcidev) {\n\t\t\tpr_debug(\"ISA bridge PCI attached: %s\\n\",\n\t\t\t\t pci_name(pdev));\n\t\t\tisa_bridge_pcidev = pdev;\n\t\t}\n\n\t\t/* Check if we have no ISA device, and this happens to be one,\n\t\t * register it as such if it has an OF device\n\t\t */\n\t\tif (!isa_bridge_devnode && devnode && devnode->type &&\n\t\t    !strcmp(devnode->type, \"isa\"))\n\t\t\tisa_bridge_find_late(pdev, devnode);\n\n\t\treturn 0;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\t/* Check if this our existing ISA device */\n\t\tif (pdev == isa_bridge_pcidev ||\n\t\t    (devnode && devnode == isa_bridge_devnode))\n\t\t\tisa_bridge_remove();\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "isa_bridge_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "195-213",
    "snippet": "static void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\t__iounmap_at((void *)ISA_IO_BASE, 0x10000);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__iounmap_at",
          "args": [
            "(void *)ISA_IO_BASE",
            "0x10000"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "isa_bridge_devnode"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge removed !\\n\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\t__iounmap_at((void *)ISA_IO_BASE, 0x10000);\n}"
  },
  {
    "function_name": "isa_bridge_find_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "173-190",
    "snippet": "static void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %s on %s\\n\",\n\t\t devnode->full_name, pci_name(pdev));\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge (late) is %s on %s\\n\"",
            "devnode->full_name",
            "pci_name(pdev)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_process_ISA_OF_ranges",
          "args": [
            "devnode",
            "hose->io_base_phys"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_ISA_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "44-120",
          "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define ISA_SPACE_IO 0x1",
            "#define ISA_SPACE_MASK 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "devnode"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %s on %s\\n\",\n\t\t devnode->full_name, pci_name(pdev));\n}"
  },
  {
    "function_name": "isa_bridge_find_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "129-167",
    "snippet": "void __init isa_bridge_find_early(struct pci_controller *hose)\n{\n\tstruct device_node *np, *parent = NULL, *tmp;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\t/* For each \"isa\" node in the system. Note : we do a search by\n\t * type and not by name. It might be better to do by name but that's\n\t * what the code used to do and I don't want to break too much at\n\t * once. We can look into changing that separately\n\t */\n\tfor_each_node_by_type(np, \"isa\") {\n\t\t/* Look for our hose being a parent */\n\t\tfor (parent = of_get_parent(np); parent;) {\n\t\t\tif (parent == hose->dn) {\n\t\t\t\tof_node_put(parent);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = parent;\n\t\t\tparent = of_get_parent(parent);\n\t\t\tof_node_put(tmp);\n\t\t}\n\t\tif (parent != NULL)\n\t\t\tbreak;\n\t}\n\tif (np == NULL)\n\t\treturn;\n\tisa_bridge_devnode = np;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(np, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (early) is %s\\n\", np->full_name);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge (early) is %s\\n\"",
            "np->full_name"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_process_ISA_OF_ranges",
          "args": [
            "np",
            "hose->io_base_phys"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_ISA_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "44-120",
          "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define ISA_SPACE_IO 0x1",
            "#define ISA_SPACE_MASK 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "tmp"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "parent"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_by_type",
          "args": [
            "np",
            "\"isa\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\n\nvoid __init isa_bridge_find_early(struct pci_controller *hose)\n{\n\tstruct device_node *np, *parent = NULL, *tmp;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\t/* For each \"isa\" node in the system. Note : we do a search by\n\t * type and not by name. It might be better to do by name but that's\n\t * what the code used to do and I don't want to break too much at\n\t * once. We can look into changing that separately\n\t */\n\tfor_each_node_by_type(np, \"isa\") {\n\t\t/* Look for our hose being a parent */\n\t\tfor (parent = of_get_parent(np); parent;) {\n\t\t\tif (parent == hose->dn) {\n\t\t\t\tof_node_put(parent);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = parent;\n\t\t\tparent = of_get_parent(parent);\n\t\t\tof_node_put(tmp);\n\t\t}\n\t\tif (parent != NULL)\n\t\t\tbreak;\n\t}\n\tif (np == NULL)\n\t\treturn;\n\tisa_bridge_devnode = np;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(np, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (early) is %s\\n\", np->full_name);\n}"
  },
  {
    "function_name": "pci_process_ISA_OF_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "44-120",
    "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define ISA_SPACE_IO 0x1",
      "#define ISA_SPACE_MASK 0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ioremap_at",
          "args": [
            "phb_io_base_phys",
            "(void *)ISA_IO_BASE",
            "0x10000",
            "_PAGE_NO_CACHE|_PAGE_GUARDED"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ioremap_at",
          "args": [
            "phb_io_base_phys",
            "(void *)ISA_IO_BASE",
            "size",
            "_PAGE_NO_CACHE|_PAGE_GUARDED"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "range->size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unexpected isa to pci mapping: %s\\n\"",
            "__func__"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "isa_node",
            "\"ranges\"",
            "&rlen"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     size, _PAGE_NO_CACHE|_PAGE_GUARDED);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\t__ioremap_at(phb_io_base_phys, (void *)ISA_IO_BASE,\n\t\t     0x10000, _PAGE_NO_CACHE|_PAGE_GUARDED);\n}"
  }
]