[
  {
    "function_name": "_do_mail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "367-466",
    "snippet": "static int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_NO_ENV\t\t0x0040",
      "#define PAM_LOGOUT_TOO\t\t0x0004",
      "#define PAM_NO_LOGIN\t\t0x0002",
      "#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"",
      "#define MAIL_ENV_NAME             \"MAIL\""
    ],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "folder"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "folder"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "MAIL_ENV_NAME"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_mail",
          "args": [
            "pamh",
            "ctrl",
            "type",
            "folder"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "report_mail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "272-327",
          "snippet": "static int\nreport_mail(pam_handle_t *pamh, int ctrl, int type, const char *folder)\n{\n    int retval;\n\n    if ((ctrl & PAM_MAIL_SILENT) ||\n\t((ctrl & PAM_QUIET_MAIL) && type != HAVE_NEW_MAIL))\n      {\n\tD((\"keeping quiet\"));\n\tretval = PAM_SUCCESS;\n      }\n    else\n      {\n\tif (ctrl & PAM_STANDARD_MAIL)\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have no mail.\"));\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have new mail.\"));\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have old mail.\"));\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have mail.\"));\n\t      break;\n\t    }\n\telse\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, _(\"You have no mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, _(\"You have new mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, _(\"You have old mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, _(\"You have mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    }\n      }\n\n    D((\"returning %s\", pam_strerror(pamh, retval)));\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define HAVE_MAIL               0x4",
            "#define HAVE_NO_MAIL            0x3",
            "#define HAVE_OLD_MAIL           0x2",
            "#define HAVE_NEW_MAIL           0x1",
            "#define PAM_QUIET_MAIL\t\t0x1000",
            "#define PAM_STANDARD_MAIL\t0x0400",
            "#define PAM_MAIL_SILENT\t\t0x0020"
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define HAVE_MAIL               0x4\n#define HAVE_NO_MAIL            0x3\n#define HAVE_OLD_MAIL           0x2\n#define HAVE_NEW_MAIL           0x1\n#define PAM_QUIET_MAIL\t\t0x1000\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_MAIL_SILENT\t\t0x0020\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nreport_mail(pam_handle_t *pamh, int ctrl, int type, const char *folder)\n{\n    int retval;\n\n    if ((ctrl & PAM_MAIL_SILENT) ||\n\t((ctrl & PAM_QUIET_MAIL) && type != HAVE_NEW_MAIL))\n      {\n\tD((\"keeping quiet\"));\n\tretval = PAM_SUCCESS;\n      }\n    else\n      {\n\tif (ctrl & PAM_STANDARD_MAIL)\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have no mail.\"));\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have new mail.\"));\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have old mail.\"));\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have mail.\"));\n\t      break;\n\t    }\n\telse\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, _(\"You have no mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, _(\"You have new mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, _(\"You have old mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, _(\"You have mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    }\n      }\n\n    D((\"returning %s\", pam_strerror(pamh, retval)));\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mail_status",
          "args": [
            "pamh",
            "ctrl",
            "folder"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "get_mail_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "194-270",
          "snippet": "static int\nget_mail_status(pam_handle_t *pamh, int ctrl, const char *folder)\n{\n    int type = 0;\n    struct stat mail_st;\n\n    if (stat(folder, &mail_st) < 0)\n\treturn 0;\n\n    if (S_ISDIR(mail_st.st_mode)) {\t/* Assume Maildir format */\n\tint i, save_errno;\n\tchar *dir;\n\tstruct dirent **namelist;\n\n\tif (asprintf(&dir, \"%s/new\", folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    goto get_mail_status_cleanup;\n\t}\n\ti = scandir(dir, &namelist, 0, alphasort);\n\tsave_errno = errno;\n\t_pam_overwrite(dir);\n\t_pam_drop(dir);\n\tif (i < 0) {\n\t    type = 0;\n\t    namelist = NULL;\n\t    if (save_errno == ENOMEM) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t}\n\ttype = (i > 2) ? HAVE_NEW_MAIL : 0;\n\twhile (--i >= 0)\n\t    _pam_drop(namelist[i]);\n\t_pam_drop(namelist);\n\tif (type == 0) {\n\t    if (asprintf(&dir, \"%s/cur\", folder) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t    i = scandir(dir, &namelist, 0, alphasort);\n\t    save_errno = errno;\n\t    _pam_overwrite(dir);\n\t    _pam_drop(dir);\n\t    if (i < 0) {\n\t\ttype = 0;\n\t\tnamelist = NULL;\n\t\tif (save_errno == ENOMEM) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    goto get_mail_status_cleanup;\n\t\t}\n\t    }\n\t    if (i > 2)\n\t        type = HAVE_OLD_MAIL;\n\t    else\n\t        type = (ctrl & PAM_EMPTY_TOO) ? HAVE_NO_MAIL : 0;\n\t    while (--i >= 0)\n\t\t_pam_drop(namelist[i]);\n\t    _pam_drop(namelist);\n\t}\n    } else {\n\tif (mail_st.st_size > 0) {\n\t    if (mail_st.st_atime < mail_st.st_mtime)\t/* new */\n\t        type = HAVE_NEW_MAIL;\n\t    else\t\t/* old */\n\t        type = (ctrl & PAM_STANDARD_MAIL) ? HAVE_MAIL : HAVE_OLD_MAIL;\n\t} else if (ctrl & PAM_EMPTY_TOO) {\n\t    type = HAVE_NO_MAIL;\n\t} else {\n\t    type = 0;\n\t}\n    }\n\n  get_mail_status_cleanup:\n    memset(&mail_st, 0, sizeof(mail_st));\n    D((\"user has %d mail in %s folder\", type, folder));\n    return type;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define HAVE_MAIL               0x4",
            "#define HAVE_NO_MAIL            0x3",
            "#define HAVE_OLD_MAIL           0x2",
            "#define HAVE_NEW_MAIL           0x1",
            "#define PAM_STANDARD_MAIL\t0x0400",
            "#define PAM_EMPTY_TOO\t\t0x0200"
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define HAVE_MAIL               0x4\n#define HAVE_NO_MAIL            0x3\n#define HAVE_OLD_MAIL           0x2\n#define HAVE_NEW_MAIL           0x1\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_EMPTY_TOO\t\t0x0200\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nget_mail_status(pam_handle_t *pamh, int ctrl, const char *folder)\n{\n    int type = 0;\n    struct stat mail_st;\n\n    if (stat(folder, &mail_st) < 0)\n\treturn 0;\n\n    if (S_ISDIR(mail_st.st_mode)) {\t/* Assume Maildir format */\n\tint i, save_errno;\n\tchar *dir;\n\tstruct dirent **namelist;\n\n\tif (asprintf(&dir, \"%s/new\", folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    goto get_mail_status_cleanup;\n\t}\n\ti = scandir(dir, &namelist, 0, alphasort);\n\tsave_errno = errno;\n\t_pam_overwrite(dir);\n\t_pam_drop(dir);\n\tif (i < 0) {\n\t    type = 0;\n\t    namelist = NULL;\n\t    if (save_errno == ENOMEM) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t}\n\ttype = (i > 2) ? HAVE_NEW_MAIL : 0;\n\twhile (--i >= 0)\n\t    _pam_drop(namelist[i]);\n\t_pam_drop(namelist);\n\tif (type == 0) {\n\t    if (asprintf(&dir, \"%s/cur\", folder) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t    i = scandir(dir, &namelist, 0, alphasort);\n\t    save_errno = errno;\n\t    _pam_overwrite(dir);\n\t    _pam_drop(dir);\n\t    if (i < 0) {\n\t\ttype = 0;\n\t\tnamelist = NULL;\n\t\tif (save_errno == ENOMEM) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    goto get_mail_status_cleanup;\n\t\t}\n\t    }\n\t    if (i > 2)\n\t        type = HAVE_OLD_MAIL;\n\t    else\n\t        type = (ctrl & PAM_EMPTY_TOO) ? HAVE_NO_MAIL : 0;\n\t    while (--i >= 0)\n\t\t_pam_drop(namelist[i]);\n\t    _pam_drop(namelist);\n\t}\n    } else {\n\tif (mail_st.st_size > 0) {\n\t    if (mail_st.st_atime < mail_st.st_mtime)\t/* new */\n\t        type = HAVE_NEW_MAIL;\n\t    else\t\t/* old */\n\t        type = (ctrl & PAM_STANDARD_MAIL) ? HAVE_MAIL : HAVE_OLD_MAIL;\n\t} else if (ctrl & PAM_EMPTY_TOO) {\n\t    type = HAVE_NO_MAIL;\n\t} else {\n\t    type = 0;\n\t}\n    }\n\n  get_mail_status_cleanup:\n    memset(&mail_st, 0, sizeof(mail_st));\n    D((\"user has %d mail in %s folder\", type, folder));\n    return type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "&privs",
            "pwd"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"not setting \" MAIL_ENV_NAME \" variable\")"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"unable to set \" MAIL_ENV_NAME \" variable\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "tmp"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "tmp"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "tmp"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for \" MAIL_ENV_NAME \" variable\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "MAIL_ENV_FORMAT",
            "folder"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_folder",
          "args": [
            "pamh",
            "ctrl",
            "path_mail",
            "&folder",
            "hashcount",
            "pwd"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "get_folder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "117-192",
          "snippet": "static int\nget_folder(pam_handle_t *pamh, int ctrl,\n\t   const char *path_mail, char **folder_p, size_t hashcount,\n\t   const struct passwd *pwd)\n{\n    int retval;\n    const char *path;\n    char *folder = NULL;\n\n    if (ctrl & PAM_NEW_MAIL_DIR) {\n\tpath = path_mail;\n\tif (*path == '~') {\t/* support for $HOME delivery */\n\t    /*\n\t     * \"~/xxx\" and \"~xxx\" are treated as same\n\t     */\n\t    if (!*++path || (*path == '/' && !*++path)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"badly formed mail path [%s]\", path_mail);\n\t\tretval = PAM_SERVICE_ERR;\n\t\tgoto get_folder_cleanup;\n\t    }\n\t    ctrl |= PAM_HOME_MAIL;\n\t    if (hashcount != 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot do hash= and home directory mail\");\n\t    }\n\t}\n    } else {\n\tpath = DEFAULT_MAIL_DIRECTORY;\n    }\n\n    /* put folder together */\n\n    hashcount = hashcount < strlen(pwd->pw_name) ?\n      hashcount : strlen(pwd->pw_name);\n\n    retval = PAM_BUF_ERR;\n    if (ctrl & PAM_HOME_MAIL) {\n\tif (asprintf(&folder, MAIL_FILE_FORMAT, pwd->pw_dir, \"\", path) < 0)\n\t    goto get_folder_cleanup;\n    } else {\n\tint rc;\n\tsize_t i;\n\tchar *hash;\n\n\tif ((hash = malloc(2 * hashcount + 1)) == NULL)\n\t    goto get_folder_cleanup;\n\n\tfor (i = 0; i < hashcount; i++) {\n\t    hash[2 * i] = '/';\n\t    hash[2 * i + 1] = pwd->pw_name[i];\n\t}\n\thash[2 * i] = '\\0';\n\n\trc = asprintf(&folder, MAIL_FILE_FORMAT, path, hash, pwd->pw_name);\n\t_pam_overwrite(hash);\n\t_pam_drop(hash);\n\tif (rc < 0)\n\t    goto get_folder_cleanup;\n    }\n    D((\"folder=[%s]\", folder));\n    retval = PAM_SUCCESS;\n\n    /* tidy up */\n\n  get_folder_cleanup:\n    path = NULL;\n\n    *folder_p = folder;\n    folder = NULL;\n\n    if (retval == PAM_BUF_ERR)\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory for mail folder\");\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_HOME_MAIL\t\t0x0100",
            "#define PAM_NEW_MAIL_DIR\t0x0010",
            "#define MAIL_FILE_FORMAT          \"%s%s/%s\"",
            "#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR"
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_HOME_MAIL\t\t0x0100\n#define PAM_NEW_MAIL_DIR\t0x0010\n#define MAIL_FILE_FORMAT          \"%s%s/%s\"\n#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nget_folder(pam_handle_t *pamh, int ctrl,\n\t   const char *path_mail, char **folder_p, size_t hashcount,\n\t   const struct passwd *pwd)\n{\n    int retval;\n    const char *path;\n    char *folder = NULL;\n\n    if (ctrl & PAM_NEW_MAIL_DIR) {\n\tpath = path_mail;\n\tif (*path == '~') {\t/* support for $HOME delivery */\n\t    /*\n\t     * \"~/xxx\" and \"~xxx\" are treated as same\n\t     */\n\t    if (!*++path || (*path == '/' && !*++path)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"badly formed mail path [%s]\", path_mail);\n\t\tretval = PAM_SERVICE_ERR;\n\t\tgoto get_folder_cleanup;\n\t    }\n\t    ctrl |= PAM_HOME_MAIL;\n\t    if (hashcount != 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot do hash= and home directory mail\");\n\t    }\n\t}\n    } else {\n\tpath = DEFAULT_MAIL_DIRECTORY;\n    }\n\n    /* put folder together */\n\n    hashcount = hashcount < strlen(pwd->pw_name) ?\n      hashcount : strlen(pwd->pw_name);\n\n    retval = PAM_BUF_ERR;\n    if (ctrl & PAM_HOME_MAIL) {\n\tif (asprintf(&folder, MAIL_FILE_FORMAT, pwd->pw_dir, \"\", path) < 0)\n\t    goto get_folder_cleanup;\n    } else {\n\tint rc;\n\tsize_t i;\n\tchar *hash;\n\n\tif ((hash = malloc(2 * hashcount + 1)) == NULL)\n\t    goto get_folder_cleanup;\n\n\tfor (i = 0; i < hashcount; i++) {\n\t    hash[2 * i] = '/';\n\t    hash[2 * i + 1] = pwd->pw_name[i];\n\t}\n\thash[2 * i] = '\\0';\n\n\trc = asprintf(&folder, MAIL_FILE_FORMAT, path, hash, pwd->pw_name);\n\t_pam_overwrite(hash);\n\t_pam_drop(hash);\n\tif (rc < 0)\n\t    goto get_folder_cleanup;\n    }\n    D((\"folder=[%s]\", folder));\n    retval = PAM_SUCCESS;\n\n    /* tidy up */\n\n  get_folder_cleanup:\n    path = NULL;\n\n    *folder_p = folder;\n    folder = NULL;\n\n    if (retval == PAM_BUF_ERR)\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory for mail folder\");\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user unknown\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "&path_mail",
            "&hashcount"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "57-115",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int flags, int argc,\n\t    const char **argv, const char **maildir, size_t *hashcount)\n{\n    int ctrl=0;\n\n    if (flags & PAM_SILENT) {\n\tctrl |= PAM_MAIL_SILENT;\n    }\n\n    *hashcount = 0;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"quiet\"))\n\t    ctrl |= PAM_QUIET_MAIL;\n\telse if (!strcmp(*argv,\"standard\"))\n\t    ctrl |= PAM_STANDARD_MAIL | PAM_EMPTY_TOO;\n\telse if ((str = pam_str_skip_prefix(*argv, \"dir=\")) != NULL) {\n\t    *maildir = str;\n\t    if (**maildir != '\\0') {\n\t\tD((\"new mail directory: %s\", *maildir));\n\t\tctrl |= PAM_NEW_MAIL_DIR;\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"dir= specification missing argument - ignored\");\n\t    }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"hash=\")) != NULL) {\n\t    char *ep = NULL;\n\t    *hashcount = strtoul(str,&ep,10);\n\t    if (!ep) {\n\t\t*hashcount = 0;\n\t    }\n\t} else if (!strcmp(*argv,\"close\")) {\n\t    ctrl |= PAM_LOGOUT_TOO;\n\t} else if (!strcmp(*argv,\"nopen\")) {\n\t    ctrl |= PAM_NO_LOGIN;\n\t} else if (!strcmp(*argv,\"noenv\")) {\n\t    ctrl |= PAM_NO_ENV;\n\t} else if (!strcmp(*argv,\"empty\")) {\n\t    ctrl |= PAM_EMPTY_TOO;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if ((*hashcount != 0) && !(ctrl & PAM_NEW_MAIL_DIR)) {\n\t*maildir = DEFAULT_MAIL_DIRECTORY;\n\tctrl |= PAM_NEW_MAIL_DIR;\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_QUIET_MAIL\t\t0x1000",
            "#define PAM_STANDARD_MAIL\t0x0400",
            "#define PAM_EMPTY_TOO\t\t0x0200",
            "#define PAM_NO_ENV\t\t0x0040",
            "#define PAM_MAIL_SILENT\t\t0x0020",
            "#define PAM_NEW_MAIL_DIR\t0x0010",
            "#define PAM_LOGOUT_TOO\t\t0x0004",
            "#define PAM_NO_LOGIN\t\t0x0002",
            "#define PAM_DEBUG_ARG\t\t0x0001",
            "#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR"
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_QUIET_MAIL\t\t0x1000\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_EMPTY_TOO\t\t0x0200\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_MAIL_SILENT\t\t0x0020\n#define PAM_NEW_MAIL_DIR\t0x0010\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define PAM_DEBUG_ARG\t\t0x0001\n#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int flags, int argc,\n\t    const char **argv, const char **maildir, size_t *hashcount)\n{\n    int ctrl=0;\n\n    if (flags & PAM_SILENT) {\n\tctrl |= PAM_MAIL_SILENT;\n    }\n\n    *hashcount = 0;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"quiet\"))\n\t    ctrl |= PAM_QUIET_MAIL;\n\telse if (!strcmp(*argv,\"standard\"))\n\t    ctrl |= PAM_STANDARD_MAIL | PAM_EMPTY_TOO;\n\telse if ((str = pam_str_skip_prefix(*argv, \"dir=\")) != NULL) {\n\t    *maildir = str;\n\t    if (**maildir != '\\0') {\n\t\tD((\"new mail directory: %s\", *maildir));\n\t\tctrl |= PAM_NEW_MAIL_DIR;\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"dir= specification missing argument - ignored\");\n\t    }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"hash=\")) != NULL) {\n\t    char *ep = NULL;\n\t    *hashcount = strtoul(str,&ep,10);\n\t    if (!ep) {\n\t\t*hashcount = 0;\n\t    }\n\t} else if (!strcmp(*argv,\"close\")) {\n\t    ctrl |= PAM_LOGOUT_TOO;\n\t} else if (!strcmp(*argv,\"nopen\")) {\n\t    ctrl |= PAM_NO_LOGIN;\n\t} else if (!strcmp(*argv,\"noenv\")) {\n\t    ctrl |= PAM_NO_ENV;\n\t} else if (!strcmp(*argv,\"empty\")) {\n\t    ctrl |= PAM_EMPTY_TOO;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if ((*hashcount != 0) && !(ctrl & PAM_NEW_MAIL_DIR)) {\n\t*maildir = DEFAULT_MAIL_DIRECTORY;\n\tctrl |= PAM_NEW_MAIL_DIR;\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"\n#define MAIL_ENV_NAME             \"MAIL\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "358-362",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc,\n    const char **argv)\n{\n    return _do_mail(pamh,flags,argc,argv,1);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_do_mail",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "1"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "_do_mail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "367-466",
          "snippet": "static int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NO_ENV\t\t0x0040",
            "#define PAM_LOGOUT_TOO\t\t0x0004",
            "#define PAM_NO_LOGIN\t\t0x0002",
            "#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"",
            "#define MAIL_ENV_NAME             \"MAIL\""
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"\n#define MAIL_ENV_NAME             \"MAIL\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags, int argc,\n    const char **argv)\n{\n    return _do_mail(pamh,flags,argc,argv,1);\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "351-355",
    "snippet": "int pam_sm_close_session(pam_handle_t *pamh,int flags,int argc\n\t\t\t ,const char **argv)\n{\n    return _do_mail(pamh,flags,argc,argv,0);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_do_mail",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "0"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "_do_mail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "367-466",
          "snippet": "static int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NO_ENV\t\t0x0040",
            "#define PAM_LOGOUT_TOO\t\t0x0004",
            "#define PAM_NO_LOGIN\t\t0x0002",
            "#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"",
            "#define MAIL_ENV_NAME             \"MAIL\""
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"\n#define MAIL_ENV_NAME             \"MAIL\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nint pam_sm_close_session(pam_handle_t *pamh,int flags,int argc\n\t\t\t ,const char **argv)\n{\n    return _do_mail(pamh,flags,argc,argv,0);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "341-347",
    "snippet": "int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc,\n    const char **argv)\n{\n    if (!(flags & (PAM_ESTABLISH_CRED|PAM_DELETE_CRED)))\n      return PAM_IGNORE;\n    return _do_mail(pamh,flags,argc,argv,(flags & PAM_ESTABLISH_CRED));\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_do_mail",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "(flags & PAM_ESTABLISH_CRED)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "_do_mail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
          "lines": "367-466",
          "snippet": "static int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NO_ENV\t\t0x0040",
            "#define PAM_LOGOUT_TOO\t\t0x0004",
            "#define PAM_NO_LOGIN\t\t0x0002",
            "#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"",
            "#define MAIL_ENV_NAME             \"MAIL\""
          ],
          "globals_used": [
            "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define MAIL_ENV_FORMAT           MAIL_ENV_NAME \"=%s\"\n#define MAIL_ENV_NAME             \"MAIL\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int _do_mail(pam_handle_t *pamh, int flags, int argc,\n    const char **argv, int est)\n{\n    int retval, ctrl, type;\n    size_t hashcount;\n    char *folder = NULL;\n    const char *user;\n    const char *path_mail = NULL;\n    const struct passwd *pwd = NULL;\n\n    /*\n     * this module (un)sets the MAIL environment variable, and checks if\n     * the user has any new mail.\n     */\n\n    ctrl = _pam_parse(pamh, flags, argc, argv, &path_mail, &hashcount);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* which folder? */\n\n    retval = get_folder(pamh, ctrl, path_mail, &folder, hashcount, pwd);\n    if (retval != PAM_SUCCESS) {\n\tD((\"failed to find folder\"));\n\treturn retval;\n    }\n\n    /* set the MAIL variable? */\n\n    if (!(ctrl & PAM_NO_ENV) && est) {\n\tchar *tmp;\n\n\tif (asprintf(&tmp, MAIL_ENV_FORMAT, folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"no memory for \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n\tD((\"setting env: %s\", tmp));\n\tretval = pam_putenv(pamh, tmp);\n\t_pam_overwrite(tmp);\n\t_pam_drop(tmp);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_CRIT,\n\t\t       \"unable to set \" MAIL_ENV_NAME \" variable\");\n\t    retval = PAM_BUF_ERR;\n\t    goto do_mail_cleanup;\n\t}\n    } else {\n\tD((\"not setting \" MAIL_ENV_NAME \" variable\"));\n    }\n\n    /*\n     * OK. we've got the mail folder... what about its status?\n     */\n\n    if ((est && !(ctrl & PAM_NO_LOGIN))\n\t|| (!est && (ctrl & PAM_LOGOUT_TOO))) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd)) {\n\t  retval = PAM_SESSION_ERR;\n\t  goto do_mail_cleanup;\n\t} else {\n\t  type = get_mail_status(pamh, ctrl, folder);\n\t  if (pam_modutil_regain_priv(pamh, &privs)) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto do_mail_cleanup;\n\t  }\n\t}\n\n\tif (type != 0) {\n\t    retval = report_mail(pamh, ctrl, type, folder);\n\t    type = 0;\n\t}\n    }\n\n    /* Delete environment variable? */\n    if ( ! est && ! (ctrl & PAM_NO_ENV) )\n\t(void) pam_putenv(pamh, MAIL_ENV_NAME);\n\n  do_mail_cleanup:\n    _pam_overwrite(folder);\n    _pam_drop(folder);\n\n    /* indicate success or failure */\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nint pam_sm_setcred(pam_handle_t *pamh, int flags, int argc,\n    const char **argv)\n{\n    if (!(flags & (PAM_ESTABLISH_CRED|PAM_DELETE_CRED)))\n      return PAM_IGNORE;\n    return _do_mail(pamh,flags,argc,argv,(flags & PAM_ESTABLISH_CRED));\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "333-338",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nint\npam_sm_authenticate (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_IGNORE;\n}"
  },
  {
    "function_name": "report_mail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "272-327",
    "snippet": "static int\nreport_mail(pam_handle_t *pamh, int ctrl, int type, const char *folder)\n{\n    int retval;\n\n    if ((ctrl & PAM_MAIL_SILENT) ||\n\t((ctrl & PAM_QUIET_MAIL) && type != HAVE_NEW_MAIL))\n      {\n\tD((\"keeping quiet\"));\n\tretval = PAM_SUCCESS;\n      }\n    else\n      {\n\tif (ctrl & PAM_STANDARD_MAIL)\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have no mail.\"));\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have new mail.\"));\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have old mail.\"));\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have mail.\"));\n\t      break;\n\t    }\n\telse\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, _(\"You have no mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, _(\"You have new mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, _(\"You have old mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, _(\"You have mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    }\n      }\n\n    D((\"returning %s\", pam_strerror(pamh, retval)));\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define HAVE_MAIL               0x4",
      "#define HAVE_NO_MAIL            0x3",
      "#define HAVE_OLD_MAIL           0x2",
      "#define HAVE_NEW_MAIL           0x1",
      "#define PAM_QUIET_MAIL\t\t0x1000",
      "#define PAM_STANDARD_MAIL\t0x0400",
      "#define PAM_MAIL_SILENT\t\t0x0020"
    ],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"returning %s\", pam_strerror(pamh, retval))"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"You have mail in folder %s.\")",
            "folder"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"You have mail in folder %s.\""
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "get_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "406-412",
          "snippet": "static const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DATANAME \"pam_selinux_context\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_selinux_context\"\n\nstatic const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"You have old mail in folder %s.\")",
            "folder"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"You have new mail in folder %s.\")",
            "folder"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"You have no mail in folder %s.\")",
            "folder"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "_(\"You have mail.\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "_(\"You have old mail.\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "_(\"You have new mail.\")"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "_(\"You have no mail.\")"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define HAVE_MAIL               0x4\n#define HAVE_NO_MAIL            0x3\n#define HAVE_OLD_MAIL           0x2\n#define HAVE_NEW_MAIL           0x1\n#define PAM_QUIET_MAIL\t\t0x1000\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_MAIL_SILENT\t\t0x0020\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nreport_mail(pam_handle_t *pamh, int ctrl, int type, const char *folder)\n{\n    int retval;\n\n    if ((ctrl & PAM_MAIL_SILENT) ||\n\t((ctrl & PAM_QUIET_MAIL) && type != HAVE_NEW_MAIL))\n      {\n\tD((\"keeping quiet\"));\n\tretval = PAM_SUCCESS;\n      }\n    else\n      {\n\tif (ctrl & PAM_STANDARD_MAIL)\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have no mail.\"));\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have new mail.\"));\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have old mail.\"));\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, \"%s\", _(\"You have mail.\"));\n\t      break;\n\t    }\n\telse\n\t  switch (type)\n\t    {\n\t    case HAVE_NO_MAIL:\n\t      retval = pam_info (pamh, _(\"You have no mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_NEW_MAIL:\n\t      retval = pam_info (pamh, _(\"You have new mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_OLD_MAIL:\n\t      retval = pam_info (pamh, _(\"You have old mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    case HAVE_MAIL:\n\t    default:\n\t      retval = pam_info (pamh, _(\"You have mail in folder %s.\"),\n\t\t\t\t folder);\n\t      break;\n\t    }\n      }\n\n    D((\"returning %s\", pam_strerror(pamh, retval)));\n    return retval;\n}"
  },
  {
    "function_name": "get_mail_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "194-270",
    "snippet": "static int\nget_mail_status(pam_handle_t *pamh, int ctrl, const char *folder)\n{\n    int type = 0;\n    struct stat mail_st;\n\n    if (stat(folder, &mail_st) < 0)\n\treturn 0;\n\n    if (S_ISDIR(mail_st.st_mode)) {\t/* Assume Maildir format */\n\tint i, save_errno;\n\tchar *dir;\n\tstruct dirent **namelist;\n\n\tif (asprintf(&dir, \"%s/new\", folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    goto get_mail_status_cleanup;\n\t}\n\ti = scandir(dir, &namelist, 0, alphasort);\n\tsave_errno = errno;\n\t_pam_overwrite(dir);\n\t_pam_drop(dir);\n\tif (i < 0) {\n\t    type = 0;\n\t    namelist = NULL;\n\t    if (save_errno == ENOMEM) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t}\n\ttype = (i > 2) ? HAVE_NEW_MAIL : 0;\n\twhile (--i >= 0)\n\t    _pam_drop(namelist[i]);\n\t_pam_drop(namelist);\n\tif (type == 0) {\n\t    if (asprintf(&dir, \"%s/cur\", folder) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t    i = scandir(dir, &namelist, 0, alphasort);\n\t    save_errno = errno;\n\t    _pam_overwrite(dir);\n\t    _pam_drop(dir);\n\t    if (i < 0) {\n\t\ttype = 0;\n\t\tnamelist = NULL;\n\t\tif (save_errno == ENOMEM) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    goto get_mail_status_cleanup;\n\t\t}\n\t    }\n\t    if (i > 2)\n\t        type = HAVE_OLD_MAIL;\n\t    else\n\t        type = (ctrl & PAM_EMPTY_TOO) ? HAVE_NO_MAIL : 0;\n\t    while (--i >= 0)\n\t\t_pam_drop(namelist[i]);\n\t    _pam_drop(namelist);\n\t}\n    } else {\n\tif (mail_st.st_size > 0) {\n\t    if (mail_st.st_atime < mail_st.st_mtime)\t/* new */\n\t        type = HAVE_NEW_MAIL;\n\t    else\t\t/* old */\n\t        type = (ctrl & PAM_STANDARD_MAIL) ? HAVE_MAIL : HAVE_OLD_MAIL;\n\t} else if (ctrl & PAM_EMPTY_TOO) {\n\t    type = HAVE_NO_MAIL;\n\t} else {\n\t    type = 0;\n\t}\n    }\n\n  get_mail_status_cleanup:\n    memset(&mail_st, 0, sizeof(mail_st));\n    D((\"user has %d mail in %s folder\", type, folder));\n    return type;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define HAVE_MAIL               0x4",
      "#define HAVE_NO_MAIL            0x3",
      "#define HAVE_OLD_MAIL           0x2",
      "#define HAVE_NEW_MAIL           0x1",
      "#define PAM_STANDARD_MAIL\t0x0400",
      "#define PAM_EMPTY_TOO\t\t0x0200"
    ],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"user has %d mail in %s folder\", type, folder)"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mail_st",
            "0",
            "sizeof(mail_st)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "namelist"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "namelist[i]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dir"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "dir"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "dir",
            "&namelist",
            "0",
            "alphasort"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dir",
            "\"%s/cur\"",
            "folder"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "namelist"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "namelist[i]"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dir"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "dir"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "dir",
            "&namelist",
            "0",
            "alphasort"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dir",
            "\"%s/new\"",
            "folder"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mail_st.st_mode"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "folder",
            "&mail_st"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define HAVE_MAIL               0x4\n#define HAVE_NO_MAIL            0x3\n#define HAVE_OLD_MAIL           0x2\n#define HAVE_NEW_MAIL           0x1\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_EMPTY_TOO\t\t0x0200\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nget_mail_status(pam_handle_t *pamh, int ctrl, const char *folder)\n{\n    int type = 0;\n    struct stat mail_st;\n\n    if (stat(folder, &mail_st) < 0)\n\treturn 0;\n\n    if (S_ISDIR(mail_st.st_mode)) {\t/* Assume Maildir format */\n\tint i, save_errno;\n\tchar *dir;\n\tstruct dirent **namelist;\n\n\tif (asprintf(&dir, \"%s/new\", folder) < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    goto get_mail_status_cleanup;\n\t}\n\ti = scandir(dir, &namelist, 0, alphasort);\n\tsave_errno = errno;\n\t_pam_overwrite(dir);\n\t_pam_drop(dir);\n\tif (i < 0) {\n\t    type = 0;\n\t    namelist = NULL;\n\t    if (save_errno == ENOMEM) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t}\n\ttype = (i > 2) ? HAVE_NEW_MAIL : 0;\n\twhile (--i >= 0)\n\t    _pam_drop(namelist[i]);\n\t_pam_drop(namelist);\n\tif (type == 0) {\n\t    if (asprintf(&dir, \"%s/cur\", folder) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tgoto get_mail_status_cleanup;\n\t    }\n\t    i = scandir(dir, &namelist, 0, alphasort);\n\t    save_errno = errno;\n\t    _pam_overwrite(dir);\n\t    _pam_drop(dir);\n\t    if (i < 0) {\n\t\ttype = 0;\n\t\tnamelist = NULL;\n\t\tif (save_errno == ENOMEM) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    goto get_mail_status_cleanup;\n\t\t}\n\t    }\n\t    if (i > 2)\n\t        type = HAVE_OLD_MAIL;\n\t    else\n\t        type = (ctrl & PAM_EMPTY_TOO) ? HAVE_NO_MAIL : 0;\n\t    while (--i >= 0)\n\t\t_pam_drop(namelist[i]);\n\t    _pam_drop(namelist);\n\t}\n    } else {\n\tif (mail_st.st_size > 0) {\n\t    if (mail_st.st_atime < mail_st.st_mtime)\t/* new */\n\t        type = HAVE_NEW_MAIL;\n\t    else\t\t/* old */\n\t        type = (ctrl & PAM_STANDARD_MAIL) ? HAVE_MAIL : HAVE_OLD_MAIL;\n\t} else if (ctrl & PAM_EMPTY_TOO) {\n\t    type = HAVE_NO_MAIL;\n\t} else {\n\t    type = 0;\n\t}\n    }\n\n  get_mail_status_cleanup:\n    memset(&mail_st, 0, sizeof(mail_st));\n    D((\"user has %d mail in %s folder\", type, folder));\n    return type;\n}"
  },
  {
    "function_name": "get_folder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "117-192",
    "snippet": "static int\nget_folder(pam_handle_t *pamh, int ctrl,\n\t   const char *path_mail, char **folder_p, size_t hashcount,\n\t   const struct passwd *pwd)\n{\n    int retval;\n    const char *path;\n    char *folder = NULL;\n\n    if (ctrl & PAM_NEW_MAIL_DIR) {\n\tpath = path_mail;\n\tif (*path == '~') {\t/* support for $HOME delivery */\n\t    /*\n\t     * \"~/xxx\" and \"~xxx\" are treated as same\n\t     */\n\t    if (!*++path || (*path == '/' && !*++path)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"badly formed mail path [%s]\", path_mail);\n\t\tretval = PAM_SERVICE_ERR;\n\t\tgoto get_folder_cleanup;\n\t    }\n\t    ctrl |= PAM_HOME_MAIL;\n\t    if (hashcount != 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot do hash= and home directory mail\");\n\t    }\n\t}\n    } else {\n\tpath = DEFAULT_MAIL_DIRECTORY;\n    }\n\n    /* put folder together */\n\n    hashcount = hashcount < strlen(pwd->pw_name) ?\n      hashcount : strlen(pwd->pw_name);\n\n    retval = PAM_BUF_ERR;\n    if (ctrl & PAM_HOME_MAIL) {\n\tif (asprintf(&folder, MAIL_FILE_FORMAT, pwd->pw_dir, \"\", path) < 0)\n\t    goto get_folder_cleanup;\n    } else {\n\tint rc;\n\tsize_t i;\n\tchar *hash;\n\n\tif ((hash = malloc(2 * hashcount + 1)) == NULL)\n\t    goto get_folder_cleanup;\n\n\tfor (i = 0; i < hashcount; i++) {\n\t    hash[2 * i] = '/';\n\t    hash[2 * i + 1] = pwd->pw_name[i];\n\t}\n\thash[2 * i] = '\\0';\n\n\trc = asprintf(&folder, MAIL_FILE_FORMAT, path, hash, pwd->pw_name);\n\t_pam_overwrite(hash);\n\t_pam_drop(hash);\n\tif (rc < 0)\n\t    goto get_folder_cleanup;\n    }\n    D((\"folder=[%s]\", folder));\n    retval = PAM_SUCCESS;\n\n    /* tidy up */\n\n  get_folder_cleanup:\n    path = NULL;\n\n    *folder_p = folder;\n    folder = NULL;\n\n    if (retval == PAM_BUF_ERR)\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory for mail folder\");\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_HOME_MAIL\t\t0x0100",
      "#define PAM_NEW_MAIL_DIR\t0x0010",
      "#define MAIL_FILE_FORMAT          \"%s%s/%s\"",
      "#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR"
    ],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory for mail folder\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"folder=[%s]\", folder)"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "hash"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "hash"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&folder",
            "MAIL_FILE_FORMAT",
            "path",
            "hash",
            "pwd->pw_name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 * hashcount + 1"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&folder",
            "MAIL_FILE_FORMAT",
            "pwd->pw_dir",
            "\"\"",
            "path"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pwd->pw_name"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pwd->pw_name"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot do hash= and home directory mail\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"badly formed mail path [%s]\"",
            "path_mail"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_HOME_MAIL\t\t0x0100\n#define PAM_NEW_MAIL_DIR\t0x0010\n#define MAIL_FILE_FORMAT          \"%s%s/%s\"\n#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\nget_folder(pam_handle_t *pamh, int ctrl,\n\t   const char *path_mail, char **folder_p, size_t hashcount,\n\t   const struct passwd *pwd)\n{\n    int retval;\n    const char *path;\n    char *folder = NULL;\n\n    if (ctrl & PAM_NEW_MAIL_DIR) {\n\tpath = path_mail;\n\tif (*path == '~') {\t/* support for $HOME delivery */\n\t    /*\n\t     * \"~/xxx\" and \"~xxx\" are treated as same\n\t     */\n\t    if (!*++path || (*path == '/' && !*++path)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"badly formed mail path [%s]\", path_mail);\n\t\tretval = PAM_SERVICE_ERR;\n\t\tgoto get_folder_cleanup;\n\t    }\n\t    ctrl |= PAM_HOME_MAIL;\n\t    if (hashcount != 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot do hash= and home directory mail\");\n\t    }\n\t}\n    } else {\n\tpath = DEFAULT_MAIL_DIRECTORY;\n    }\n\n    /* put folder together */\n\n    hashcount = hashcount < strlen(pwd->pw_name) ?\n      hashcount : strlen(pwd->pw_name);\n\n    retval = PAM_BUF_ERR;\n    if (ctrl & PAM_HOME_MAIL) {\n\tif (asprintf(&folder, MAIL_FILE_FORMAT, pwd->pw_dir, \"\", path) < 0)\n\t    goto get_folder_cleanup;\n    } else {\n\tint rc;\n\tsize_t i;\n\tchar *hash;\n\n\tif ((hash = malloc(2 * hashcount + 1)) == NULL)\n\t    goto get_folder_cleanup;\n\n\tfor (i = 0; i < hashcount; i++) {\n\t    hash[2 * i] = '/';\n\t    hash[2 * i + 1] = pwd->pw_name[i];\n\t}\n\thash[2 * i] = '\\0';\n\n\trc = asprintf(&folder, MAIL_FILE_FORMAT, path, hash, pwd->pw_name);\n\t_pam_overwrite(hash);\n\t_pam_drop(hash);\n\tif (rc < 0)\n\t    goto get_folder_cleanup;\n    }\n    D((\"folder=[%s]\", folder));\n    retval = PAM_SUCCESS;\n\n    /* tidy up */\n\n  get_folder_cleanup:\n    path = NULL;\n\n    *folder_p = folder;\n    folder = NULL;\n\n    if (retval == PAM_BUF_ERR)\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory for mail folder\");\n\n    return retval;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mail/pam_mail.c",
    "lines": "57-115",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int flags, int argc,\n\t    const char **argv, const char **maildir, size_t *hashcount)\n{\n    int ctrl=0;\n\n    if (flags & PAM_SILENT) {\n\tctrl |= PAM_MAIL_SILENT;\n    }\n\n    *hashcount = 0;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"quiet\"))\n\t    ctrl |= PAM_QUIET_MAIL;\n\telse if (!strcmp(*argv,\"standard\"))\n\t    ctrl |= PAM_STANDARD_MAIL | PAM_EMPTY_TOO;\n\telse if ((str = pam_str_skip_prefix(*argv, \"dir=\")) != NULL) {\n\t    *maildir = str;\n\t    if (**maildir != '\\0') {\n\t\tD((\"new mail directory: %s\", *maildir));\n\t\tctrl |= PAM_NEW_MAIL_DIR;\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"dir= specification missing argument - ignored\");\n\t    }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"hash=\")) != NULL) {\n\t    char *ep = NULL;\n\t    *hashcount = strtoul(str,&ep,10);\n\t    if (!ep) {\n\t\t*hashcount = 0;\n\t    }\n\t} else if (!strcmp(*argv,\"close\")) {\n\t    ctrl |= PAM_LOGOUT_TOO;\n\t} else if (!strcmp(*argv,\"nopen\")) {\n\t    ctrl |= PAM_NO_LOGIN;\n\t} else if (!strcmp(*argv,\"noenv\")) {\n\t    ctrl |= PAM_NO_ENV;\n\t} else if (!strcmp(*argv,\"empty\")) {\n\t    ctrl |= PAM_EMPTY_TOO;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if ((*hashcount != 0) && !(ctrl & PAM_NEW_MAIL_DIR)) {\n\t*maildir = DEFAULT_MAIL_DIRECTORY;\n\tctrl |= PAM_NEW_MAIL_DIR;\n    }\n\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_QUIET_MAIL\t\t0x1000",
      "#define PAM_STANDARD_MAIL\t0x0400",
      "#define PAM_EMPTY_TOO\t\t0x0200",
      "#define PAM_NO_ENV\t\t0x0040",
      "#define PAM_MAIL_SILENT\t\t0x0020",
      "#define PAM_NEW_MAIL_DIR\t0x0010",
      "#define PAM_LOGOUT_TOO\t\t0x0004",
      "#define PAM_NO_LOGIN\t\t0x0002",
      "#define PAM_DEBUG_ARG\t\t0x0001",
      "#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR"
    ],
    "globals_used": [
      "static int _do_mail(pam_handle_t *, int, int, const char **, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"empty\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noenv\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"nopen\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"close\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "str",
            "&ep",
            "10"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"hash=\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dir= specification missing argument - ignored\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"new mail directory: %s\", *maildir)"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"dir=\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"standard\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"quiet\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <paths.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_QUIET_MAIL\t\t0x1000\n#define PAM_STANDARD_MAIL\t0x0400\n#define PAM_EMPTY_TOO\t\t0x0200\n#define PAM_NO_ENV\t\t0x0040\n#define PAM_MAIL_SILENT\t\t0x0020\n#define PAM_NEW_MAIL_DIR\t0x0010\n#define PAM_LOGOUT_TOO\t\t0x0004\n#define PAM_NO_LOGIN\t\t0x0002\n#define PAM_DEBUG_ARG\t\t0x0001\n#define DEFAULT_MAIL_DIRECTORY    PAM_PATH_MAILDIR\n\nstatic int _do_mail(pam_handle_t *, int, int, const char **, int);\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int flags, int argc,\n\t    const char **argv, const char **maildir, size_t *hashcount)\n{\n    int ctrl=0;\n\n    if (flags & PAM_SILENT) {\n\tctrl |= PAM_MAIL_SILENT;\n    }\n\n    *hashcount = 0;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"quiet\"))\n\t    ctrl |= PAM_QUIET_MAIL;\n\telse if (!strcmp(*argv,\"standard\"))\n\t    ctrl |= PAM_STANDARD_MAIL | PAM_EMPTY_TOO;\n\telse if ((str = pam_str_skip_prefix(*argv, \"dir=\")) != NULL) {\n\t    *maildir = str;\n\t    if (**maildir != '\\0') {\n\t\tD((\"new mail directory: %s\", *maildir));\n\t\tctrl |= PAM_NEW_MAIL_DIR;\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"dir= specification missing argument - ignored\");\n\t    }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"hash=\")) != NULL) {\n\t    char *ep = NULL;\n\t    *hashcount = strtoul(str,&ep,10);\n\t    if (!ep) {\n\t\t*hashcount = 0;\n\t    }\n\t} else if (!strcmp(*argv,\"close\")) {\n\t    ctrl |= PAM_LOGOUT_TOO;\n\t} else if (!strcmp(*argv,\"nopen\")) {\n\t    ctrl |= PAM_NO_LOGIN;\n\t} else if (!strcmp(*argv,\"noenv\")) {\n\t    ctrl |= PAM_NO_ENV;\n\t} else if (!strcmp(*argv,\"empty\")) {\n\t    ctrl |= PAM_EMPTY_TOO;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if ((*hashcount != 0) && !(ctrl & PAM_NEW_MAIL_DIR)) {\n\t*maildir = DEFAULT_MAIL_DIRECTORY;\n\tctrl |= PAM_NEW_MAIL_DIR;\n    }\n\n    return ctrl;\n}"
  }
]