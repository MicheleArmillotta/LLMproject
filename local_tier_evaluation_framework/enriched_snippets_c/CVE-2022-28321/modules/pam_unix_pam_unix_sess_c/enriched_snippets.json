[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_sess.c",
    "lines": "105-134",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tchar *user_name, *service;\n\tunsigned long long ctrl;\n\tint retval;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, (void *) &user_name);\n\tif (user_name == NULL || *user_name == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\"close_session - error recovering username\");\n\t\treturn PAM_SESSION_ERR;\t\t/* How did we get authenticated with\n\t\t\t\t\t\t   no username?! */\n\t}\n\tretval = pam_get_item(pamh, PAM_SERVICE, (void *) &service);\n\tif (service == NULL || *service == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\"close_session - error recovering service\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (off (UNIX_QUIET, ctrl))\n\t\tpam_syslog(pamh, LOG_INFO, \"session closed for user %s\",\n\t\t\tuser_name);\n\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"support.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"session closed for user %s\"",
            "user_name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_QUIET",
            "ctrl"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"close_session - error recovering service\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "(void *) &service"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"close_session - error recovering username\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "(void *) &user_name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "NULL",
            "NULL",
            "NULL",
            "argc",
            "argv"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called.\")"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"support.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tchar *user_name, *service;\n\tunsigned long long ctrl;\n\tint retval;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, (void *) &user_name);\n\tif (user_name == NULL || *user_name == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\"close_session - error recovering username\");\n\t\treturn PAM_SESSION_ERR;\t\t/* How did we get authenticated with\n\t\t\t\t\t\t   no username?! */\n\t}\n\tretval = pam_get_item(pamh, PAM_SERVICE, (void *) &service);\n\tif (service == NULL || *service == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\"close_session - error recovering service\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (off (UNIX_QUIET, ctrl))\n\t\tpam_syslog(pamh, LOG_INFO, \"session closed for user %s\",\n\t\t\tuser_name);\n\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_sess.c",
    "lines": "62-103",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tchar *user_name, *service;\n\tunsigned long long ctrl;\n\tint retval;\n\tconst char *login_name;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, (void *) &user_name);\n\tif (user_name == NULL || *user_name == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\"open_session - error recovering username\");\n\t\treturn PAM_SESSION_ERR;\t\t/* How did we get authenticated with\n\t\t\t\t\t\t   no username?! */\n\t}\n\tretval = pam_get_item(pamh, PAM_SERVICE, (void *) &service);\n\tif (service == NULL || *service == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\"open_session - error recovering service\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tlogin_name = pam_modutil_getlogin(pamh);\n\tif (login_name == NULL) {\n\t\tlogin_name = \"\";\n\t}\n\tif (off (UNIX_QUIET, ctrl)) {\n\t\tchar uid[32];\n\t\tstruct passwd *pwd = pam_modutil_getpwnam (pamh, user_name);\n\t\tif (pwd == NULL) {\n\t\t\tsnprintf (uid, 32, \"getpwnam error\");\n\t\t}\n\t\telse {\n\t\t\tsnprintf (uid, 32, \"%u\", pwd->pw_uid);\n\t\t}\n\t\tpam_syslog(pamh, LOG_INFO, \"session opened for user %s(uid=%s) by %s(uid=%lu)\", user_name, uid, login_name, (unsigned long)getuid());\n\t}\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"support.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"session opened for user %s(uid=%s) by %s(uid=%lu)\"",
            "user_name",
            "uid",
            "login_name",
            "(unsigned long)getuid()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uid",
            "32",
            "\"%u\"",
            "pwd->pw_uid"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "uid",
            "32",
            "\"getpwnam error\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user_name"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_QUIET",
            "ctrl"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getlogin",
          "args": [
            "pamh"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"open_session - error recovering service\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "(void *) &service"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"open_session - error recovering username\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "(void *) &user_name"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "NULL",
            "NULL",
            "NULL",
            "argc",
            "argv"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called.\")"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"support.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tchar *user_name, *service;\n\tunsigned long long ctrl;\n\tint retval;\n\tconst char *login_name;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, (void *) &user_name);\n\tif (user_name == NULL || *user_name == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\"open_session - error recovering username\");\n\t\treturn PAM_SESSION_ERR;\t\t/* How did we get authenticated with\n\t\t\t\t\t\t   no username?! */\n\t}\n\tretval = pam_get_item(pamh, PAM_SERVICE, (void *) &service);\n\tif (service == NULL || *service == '\\0' || retval != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\"open_session - error recovering service\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tlogin_name = pam_modutil_getlogin(pamh);\n\tif (login_name == NULL) {\n\t\tlogin_name = \"\";\n\t}\n\tif (off (UNIX_QUIET, ctrl)) {\n\t\tchar uid[32];\n\t\tstruct passwd *pwd = pam_modutil_getpwnam (pamh, user_name);\n\t\tif (pwd == NULL) {\n\t\t\tsnprintf (uid, 32, \"getpwnam error\");\n\t\t}\n\t\telse {\n\t\t\tsnprintf (uid, 32, \"%u\", pwd->pw_uid);\n\t\t}\n\t\tpam_syslog(pamh, LOG_INFO, \"session opened for user %s(uid=%s) by %s(uid=%lu)\", user_name, uid, login_name, (unsigned long)getuid());\n\t}\n\treturn PAM_SUCCESS;\n}"
  }
]