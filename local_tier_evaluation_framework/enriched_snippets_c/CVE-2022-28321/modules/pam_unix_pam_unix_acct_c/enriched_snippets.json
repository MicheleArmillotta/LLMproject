[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_acct.c",
    "lines": "186-291",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl;\n\tconst void *void_uname;\n\tconst char *uname;\n\tint retval, daysleft = -1;\n\tchar buf[256];\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, &void_uname);\n\tuname = void_uname;\n\tD((\"user = `%s'\", uname));\n\tif (retval != PAM_SUCCESS || uname == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t \"could not identify user (from uid=%lu)\",\n\t\t\t (unsigned long int)getuid());\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tretval = _unix_verify_user(pamh, ctrl, uname, &daysleft);\n\n\tif (on(UNIX_NO_PASS_EXPIRY, ctrl)) {\n\t\tconst void *pretval = NULL;\n\t\tint authrv = PAM_AUTHINFO_UNAVAIL; /* authentication not called */\n\n\t\tif (pam_get_data(pamh, \"unix_setcred_return\", &pretval) == PAM_SUCCESS\n\t\t\t&& pretval)\n\t\t\tauthrv = *(const int *)pretval;\n\n\t\tif (authrv != PAM_SUCCESS\n\t\t\t&& (retval == PAM_NEW_AUTHTOK_REQD || retval == PAM_AUTHTOK_EXPIRED))\n\t\t\tretval = PAM_SUCCESS;\n\t}\n\n\tswitch (retval) {\n\tcase PAM_ACCT_EXPIRED:\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"account %s has expired (account expired)\",\n\t\t\tuname);\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t_(\"Your account has expired; please contact your system administrator.\"));\n\t\tbreak;\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\tif (daysleft == 0) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\"expired password for user %s (root enforced)\",\n\t\t\t\tuname);\n\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t_(\"You are required to change your password immediately (administrator enforced).\"));\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"expired password for user %s (password aged)\",\n\t\t\t\tuname);\n\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t_(\"You are required to change your password immediately (password expired).\"));\n\t\t}\n\t\tbreak;\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"account %s has expired (failed to change password)\",\n\t\t\tuname);\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t_(\"Your account has expired; please contact your system administrator.\"));\n\t\tbreak;\n\tcase PAM_AUTHTOK_ERR:\n\t\t/*\n\t\t * We ignore \"password changed too early\" error\n\t\t * as it is relevant only for password change.\n\t\t */\n\t\tretval = PAM_SUCCESS;\n\t\t/* fallthrough */\n\tcase PAM_SUCCESS:\n\t\tif (daysleft >= 0) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"password for user %s will expire in %d days\",\n\t\t\t\tuname, daysleft);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tsnprintf (buf, sizeof (buf),\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t  \"Warning: your password will expire in %d day.\",\n\t\t\t\t  \"Warning: your password will expire in %d days.\",\n\t\t\t\t  daysleft),\n\t\t\t\tdaysleft);\n#else\n\t\t\tif (daysleft == 1)\n\t\t\t    snprintf(buf, sizeof (buf),\n\t\t\t\t_(\"Warning: your password will expire in %d day.\"),\n\t\t\t\tdaysleft);\n\t\t\telse\n\t\t\t    snprintf(buf, sizeof (buf),\n\t\t\t    /* TRANSLATORS: only used if dngettext is not supported */\n\t\t\t\t_(\"Warning: your password will expire in %d days.\"),\n\t\t\t\tdaysleft);\n#endif\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO, buf);\n\t\t}\n\t}\n\n\tD((\"all done\"));\n\n\treturn retval;\n}",
    "includes": [
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/wait.h>",
      "#include <errno.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"all done\")"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_make_remark",
          "args": [
            "pamh",
            "ctrl",
            "PAM_TEXT_INFO",
            "buf"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "_make_remark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "38-47",
          "snippet": "int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof (buf)",
            "/* TRANSLATORS: only used if dngettext is not supported */_(\"Warning: your password will expire in %d days.\")",
            "daysleft"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Warning: your password will expire in %d days.\""
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "_check_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_chkpwd.c",
          "lines": "38-60",
          "snippet": "static int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"passverify.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <libaudit.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <libaudit.h>\n#include <errno.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof (buf)",
            "_(\"Warning: your password will expire in %d day.\")",
            "daysleft"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof (buf)",
            "dngettext(PACKAGE,\n\t\t\t\t  \"Warning: your password will expire in %d day.\",\n\t\t\t\t  \"Warning: your password will expire in %d days.\",\n\t\t\t\t  daysleft)",
            "daysleft"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dngettext",
          "args": [
            "PACKAGE",
            "\"Warning: your password will expire in %d day.\"",
            "\"Warning: your password will expire in %d days.\"",
            "daysleft"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"password for user %s will expire in %d days\"",
            "uname",
            "daysleft"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"account %s has expired (failed to change password)\"",
            "uname"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"expired password for user %s (password aged)\"",
            "uname"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"expired password for user %s (root enforced)\"",
            "uname"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"account %s has expired (account expired)\"",
            "uname"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "\"unix_setcred_return\"",
            "&pretval"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_NO_PASS_EXPIRY",
            "ctrl"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unix_verify_user",
          "args": [
            "pamh",
            "ctrl",
            "uname",
            "&daysleft"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_verify_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "819-854",
          "snippet": "int\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"could not identify user (from uid=%lu)\"",
            "(unsigned long int)getuid()"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&void_uname"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "NULL",
            "NULL",
            "NULL",
            "argc",
            "argv"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl;\n\tconst void *void_uname;\n\tconst char *uname;\n\tint retval, daysleft = -1;\n\tchar buf[256];\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = pam_get_item(pamh, PAM_USER, &void_uname);\n\tuname = void_uname;\n\tD((\"user = `%s'\", uname));\n\tif (retval != PAM_SUCCESS || uname == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t \"could not identify user (from uid=%lu)\",\n\t\t\t (unsigned long int)getuid());\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tretval = _unix_verify_user(pamh, ctrl, uname, &daysleft);\n\n\tif (on(UNIX_NO_PASS_EXPIRY, ctrl)) {\n\t\tconst void *pretval = NULL;\n\t\tint authrv = PAM_AUTHINFO_UNAVAIL; /* authentication not called */\n\n\t\tif (pam_get_data(pamh, \"unix_setcred_return\", &pretval) == PAM_SUCCESS\n\t\t\t&& pretval)\n\t\t\tauthrv = *(const int *)pretval;\n\n\t\tif (authrv != PAM_SUCCESS\n\t\t\t&& (retval == PAM_NEW_AUTHTOK_REQD || retval == PAM_AUTHTOK_EXPIRED))\n\t\t\tretval = PAM_SUCCESS;\n\t}\n\n\tswitch (retval) {\n\tcase PAM_ACCT_EXPIRED:\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"account %s has expired (account expired)\",\n\t\t\tuname);\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t_(\"Your account has expired; please contact your system administrator.\"));\n\t\tbreak;\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\tif (daysleft == 0) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\"expired password for user %s (root enforced)\",\n\t\t\t\tuname);\n\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t_(\"You are required to change your password immediately (administrator enforced).\"));\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"expired password for user %s (password aged)\",\n\t\t\t\tuname);\n\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t_(\"You are required to change your password immediately (password expired).\"));\n\t\t}\n\t\tbreak;\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"account %s has expired (failed to change password)\",\n\t\t\tuname);\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t_(\"Your account has expired; please contact your system administrator.\"));\n\t\tbreak;\n\tcase PAM_AUTHTOK_ERR:\n\t\t/*\n\t\t * We ignore \"password changed too early\" error\n\t\t * as it is relevant only for password change.\n\t\t */\n\t\tretval = PAM_SUCCESS;\n\t\t/* fallthrough */\n\tcase PAM_SUCCESS:\n\t\tif (daysleft >= 0) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"password for user %s will expire in %d days\",\n\t\t\t\tuname, daysleft);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tsnprintf (buf, sizeof (buf),\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t  \"Warning: your password will expire in %d day.\",\n\t\t\t\t  \"Warning: your password will expire in %d days.\",\n\t\t\t\t  daysleft),\n\t\t\t\tdaysleft);\n#else\n\t\t\tif (daysleft == 1)\n\t\t\t    snprintf(buf, sizeof (buf),\n\t\t\t\t_(\"Warning: your password will expire in %d day.\"),\n\t\t\t\tdaysleft);\n\t\t\telse\n\t\t\t    snprintf(buf, sizeof (buf),\n\t\t\t    /* TRANSLATORS: only used if dngettext is not supported */\n\t\t\t\t_(\"Warning: your password will expire in %d days.\"),\n\t\t\t\tdaysleft);\n#endif\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO, buf);\n\t\t}\n\t}\n\n\tD((\"all done\"));\n\n\treturn retval;\n}"
  },
  {
    "function_name": "_unix_run_verify_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_acct.c",
    "lines": "64-179",
    "snippet": "int _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}",
    "includes": [
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/wait.h>",
      "#include <errno.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Returning %d\",retval)"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Fork failed: %m\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"read unix_chkpwd output error %d: %m\"",
            "rc"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "daysleft"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fds[0]",
            "buf",
            "sizeof(buf) - 1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_chkpwd abnormal exit: %d\"",
            "retval"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_chkpwd waitpid returned %d: %m\"",
            "rc"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-1\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"helper binary execve failed: %m\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "CHKPWD_HELPER",
            "(char *const *) args",
            "envp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-1\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setuid failed: %m\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdout\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fds[1]",
            "STDOUT_FILENO"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not make pipe: %m\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}"
  }
]