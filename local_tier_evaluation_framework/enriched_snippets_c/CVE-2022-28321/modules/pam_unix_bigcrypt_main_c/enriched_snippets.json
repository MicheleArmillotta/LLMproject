[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt_main.c",
    "lines": "6-18",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s password salt\\n\",\n\t\t\tstrchr(argv[0], '/') ?\n\t\t\t(strchr(argv[0], '/') + 1) :\n\t\t\targv[0]);\n\t\treturn 0;\n\t}\n\tfprintf(stdout, \"%s\\n\", bigcrypt(argv[1], argv[2]));\n\treturn 0;\n}",
    "includes": [
      "#include \"bigcrypt.h\"",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "bigcrypt(argv[1], argv[2])"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bigcrypt",
          "args": [
            "argv[1]",
            "argv[2]"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "bigcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt.c",
          "lines": "51-163",
          "snippet": "char *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}",
          "includes": [
            "#include \"bigcrypt.h\"",
            "#include <crypt.h>",
            "#include <security/_pam_macros.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)",
            "#define ESEGMENT_SIZE      11",
            "#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)",
            "#define SALT_SIZE          2",
            "#define SEGMENT_SIZE       8",
            "#define MAX_PASS_LEN       16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bigcrypt.h\"\n#include <crypt.h>\n#include <security/_pam_macros.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)\n#define ESEGMENT_SIZE      11\n#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)\n#define SALT_SIZE          2\n#define SEGMENT_SIZE       8\n#define MAX_PASS_LEN       16\n\nchar *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: %s password salt\\n\"",
            "strchr(argv[0], '/') ?\n\t\t\t(strchr(argv[0], '/') + 1) :\n\t\t\targv[0]"
          ],
          "line": 10
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 11
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bigcrypt.h\"\n#include <string.h>\n#include <stdio.h>\n\nint\nmain(int argc, char **argv)\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s password salt\\n\",\n\t\t\tstrchr(argv[0], '/') ?\n\t\t\t(strchr(argv[0], '/') + 1) :\n\t\t\targv[0]);\n\t\treturn 0;\n\t}\n\tfprintf(stdout, \"%s\\n\", bigcrypt(argv[1], argv[2]));\n\treturn 0;\n}"
  }
]