[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
    "lines": "263-267",
    "snippet": "int pam_sm_close_session (pam_handle_t * pamh UNUSED, int flags UNUSED,\n\t\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n   return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nint pam_sm_close_session (pam_handle_t * pamh UNUSED, int flags UNUSED,\n\t\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n   return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
    "lines": "219-260",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc,\n\t\t     const char **argv)\n{\n   int retval;\n   options_t opt;\n   const void *user;\n   const struct passwd *pwd;\n   struct stat St;\n\n   /* Parse the flag values */\n   _pam_parse(pamh, flags, argc, argv, &opt);\n\n   /* Determine the user name so we can get the home directory */\n   retval = pam_get_item(pamh, PAM_USER, &user);\n   if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0')\n   {\n      pam_syslog(pamh, LOG_NOTICE, \"Cannot obtain the user name.\");\n      return PAM_USER_UNKNOWN;\n   }\n\n   /* Get the password entry */\n   pwd = pam_modutil_getpwnam (pamh, user);\n   if (pwd == NULL)\n   {\n      pam_syslog(pamh, LOG_NOTICE, \"User unknown.\");\n      D((\"couldn't identify user %s\", user));\n      return PAM_USER_UNKNOWN;\n   }\n\n   /* Stat the home directory, if something exists then we assume it is\n      correct and return a success*/\n   if (stat(pwd->pw_dir, &St) == 0) {\n      if (opt.ctrl & MKHOMEDIR_DEBUG) {\n          pam_syslog(pamh, LOG_DEBUG, \"Home directory %s already exists.\",\n              pwd->pw_dir);\n      }\n      return PAM_SUCCESS;\n   }\n\n   return create_homedir(pamh, &opt, user, pwd->pw_dir);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_homedir",
          "args": [
            "pamh",
            "&opt",
            "user",
            "pwd->pw_dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "create_homedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
          "lines": "112-215",
          "snippet": "static int\ncreate_homedir (pam_handle_t *pamh, options_t *opt,\n\t\tconst char *user, const char *dir)\n{\n   int retval, child;\n   struct sigaction newsa, oldsa;\n   char *login_umask = NULL;\n   char *login_homemode = NULL;\n\n   /* Mention what is happening, if the notification fails that is OK */\n   if (!(opt->ctrl & MKHOMEDIR_QUIET))\n      pam_info(pamh, _(\"Creating directory '%s'.\"), dir);\n\n\n   D((\"called.\"));\n\n   /*\n    * This code arranges that the demise of the child does not cause\n    * the application to receive a signal it is not expecting - which\n    * may kill the application or worse.\n    */\n   memset(&newsa, '\\0', sizeof(newsa));\n   newsa.sa_handler = SIG_DFL;\n   sigaction(SIGCHLD, &newsa, &oldsa);\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"Executing mkhomedir_helper.\");\n   }\n\n   /* fetch UMASK from /etc/login.defs if not in argv */\n   if (opt->umask == NULL) {\n      login_umask = pam_modutil_search_key(pamh, LOGIN_DEFS, \"UMASK\");\n      login_homemode = pam_modutil_search_key(pamh, LOGIN_DEFS, \"HOME_MODE\");\n      if (login_homemode == NULL) {\n         if (login_umask != NULL) {\n            login_homemode = _pam_conv_str_umask_to_homemode(login_umask);\n         } else {\n            login_homemode = _pam_conv_str_umask_to_homemode(UMASK_DEFAULT);\n         }\n      }\n   } else {\n      login_homemode = _pam_conv_str_umask_to_homemode(opt->umask);\n   }\n\n   /* fork */\n   child = fork();\n   if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0)\n\t\t_exit(PAM_SYSTEM_ERR);\n\n\t/* exec the mkhomedir helper */\n\targs[0] = MKHOMEDIR_HELPER;\n\targs[1] = user;\n\targs[2] = opt->umask ? opt->umask : UMASK_DEFAULT;\n\targs[3] = opt->skeldir;\n\targs[4] = login_homemode;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(MKHOMEDIR_HELPER, (char **)args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_SYSTEM_ERR);\n   } else if (child > 0) {\n\tint rc;\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc < 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"waitpid failed: %m\");\n\t  retval = PAM_SYSTEM_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"mkhomedir_helper abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n   } else {\n\tD((\"fork failed\"));\n\tpam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n\tretval = PAM_SYSTEM_ERR;\n   }\n\n   sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"mkhomedir_helper returned %d\", retval);\n   }\n\n   if (retval != PAM_SUCCESS && !(opt->ctrl & MKHOMEDIR_QUIET)) {\n\tpam_error(pamh, _(\"Unable to create and initialize directory '%s'.\"),\n\t\t  dir);\n   }\n\n   free(login_umask);\n   free(login_homemode);\n\n   D((\"returning %d\", retval));\n   return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define UMASK_DEFAULT        \"0022\"",
            "#define LOGIN_DEFS           \"/etc/login.defs\"",
            "#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */",
            "#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define UMASK_DEFAULT        \"0022\"\n#define LOGIN_DEFS           \"/etc/login.defs\"\n#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */\n#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */\n\nstatic int\ncreate_homedir (pam_handle_t *pamh, options_t *opt,\n\t\tconst char *user, const char *dir)\n{\n   int retval, child;\n   struct sigaction newsa, oldsa;\n   char *login_umask = NULL;\n   char *login_homemode = NULL;\n\n   /* Mention what is happening, if the notification fails that is OK */\n   if (!(opt->ctrl & MKHOMEDIR_QUIET))\n      pam_info(pamh, _(\"Creating directory '%s'.\"), dir);\n\n\n   D((\"called.\"));\n\n   /*\n    * This code arranges that the demise of the child does not cause\n    * the application to receive a signal it is not expecting - which\n    * may kill the application or worse.\n    */\n   memset(&newsa, '\\0', sizeof(newsa));\n   newsa.sa_handler = SIG_DFL;\n   sigaction(SIGCHLD, &newsa, &oldsa);\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"Executing mkhomedir_helper.\");\n   }\n\n   /* fetch UMASK from /etc/login.defs if not in argv */\n   if (opt->umask == NULL) {\n      login_umask = pam_modutil_search_key(pamh, LOGIN_DEFS, \"UMASK\");\n      login_homemode = pam_modutil_search_key(pamh, LOGIN_DEFS, \"HOME_MODE\");\n      if (login_homemode == NULL) {\n         if (login_umask != NULL) {\n            login_homemode = _pam_conv_str_umask_to_homemode(login_umask);\n         } else {\n            login_homemode = _pam_conv_str_umask_to_homemode(UMASK_DEFAULT);\n         }\n      }\n   } else {\n      login_homemode = _pam_conv_str_umask_to_homemode(opt->umask);\n   }\n\n   /* fork */\n   child = fork();\n   if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0)\n\t\t_exit(PAM_SYSTEM_ERR);\n\n\t/* exec the mkhomedir helper */\n\targs[0] = MKHOMEDIR_HELPER;\n\targs[1] = user;\n\targs[2] = opt->umask ? opt->umask : UMASK_DEFAULT;\n\targs[3] = opt->skeldir;\n\targs[4] = login_homemode;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(MKHOMEDIR_HELPER, (char **)args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_SYSTEM_ERR);\n   } else if (child > 0) {\n\tint rc;\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc < 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"waitpid failed: %m\");\n\t  retval = PAM_SYSTEM_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"mkhomedir_helper abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n   } else {\n\tD((\"fork failed\"));\n\tpam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n\tretval = PAM_SYSTEM_ERR;\n   }\n\n   sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"mkhomedir_helper returned %d\", retval);\n   }\n\n   if (retval != PAM_SUCCESS && !(opt->ctrl & MKHOMEDIR_QUIET)) {\n\tpam_error(pamh, _(\"Unable to create and initialize directory '%s'.\"),\n\t\t  dir);\n   }\n\n   free(login_umask);\n   free(login_homemode);\n\n   D((\"returning %d\", retval));\n   return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Home directory %s already exists.\"",
            "pwd->pw_dir"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "pwd->pw_dir",
            "&St"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"couldn't identify user %s\", user)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"User unknown.\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Cannot obtain the user name.\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&user"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "&opt"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
          "lines": "69-98",
          "snippet": "static void\n_pam_parse (const pam_handle_t *pamh, int flags, int argc, const char **argv,\n\t    options_t *opt)\n{\n   opt->ctrl = 0;\n   opt->umask = NULL;\n   opt->skeldir = \"/etc/skel\";\n\n   /* does the application require quiet? */\n   if ((flags & PAM_SILENT) == PAM_SILENT)\n      opt->ctrl |= MKHOMEDIR_QUIET;\n\n   /* step through arguments */\n   for (; argc-- > 0; ++argv)\n   {\n      const char *str;\n\n      if (!strcmp(*argv, \"silent\")) {\n\t opt->ctrl |= MKHOMEDIR_QUIET;\n      } else if (!strcmp(*argv, \"debug\")) {\n         opt->ctrl |= MKHOMEDIR_DEBUG;\n      } else if ((str = pam_str_skip_prefix(*argv, \"umask=\")) != NULL) {\n\t opt->umask = str;\n      } else if ((str = pam_str_skip_prefix(*argv, \"skel=\")) != NULL) {\n\t opt->skeldir = str;\n      } else {\n\t pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n      }\n   }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */",
            "#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */\n#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */\n\nstatic void\n_pam_parse (const pam_handle_t *pamh, int flags, int argc, const char **argv,\n\t    options_t *opt)\n{\n   opt->ctrl = 0;\n   opt->umask = NULL;\n   opt->skeldir = \"/etc/skel\";\n\n   /* does the application require quiet? */\n   if ((flags & PAM_SILENT) == PAM_SILENT)\n      opt->ctrl |= MKHOMEDIR_QUIET;\n\n   /* step through arguments */\n   for (; argc-- > 0; ++argv)\n   {\n      const char *str;\n\n      if (!strcmp(*argv, \"silent\")) {\n\t opt->ctrl |= MKHOMEDIR_QUIET;\n      } else if (!strcmp(*argv, \"debug\")) {\n         opt->ctrl |= MKHOMEDIR_DEBUG;\n      } else if ((str = pam_str_skip_prefix(*argv, \"umask=\")) != NULL) {\n\t opt->umask = str;\n      } else if ((str = pam_str_skip_prefix(*argv, \"skel=\")) != NULL) {\n\t opt->skeldir = str;\n      } else {\n\t pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n      }\n   }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc,\n\t\t     const char **argv)\n{\n   int retval;\n   options_t opt;\n   const void *user;\n   const struct passwd *pwd;\n   struct stat St;\n\n   /* Parse the flag values */\n   _pam_parse(pamh, flags, argc, argv, &opt);\n\n   /* Determine the user name so we can get the home directory */\n   retval = pam_get_item(pamh, PAM_USER, &user);\n   if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0')\n   {\n      pam_syslog(pamh, LOG_NOTICE, \"Cannot obtain the user name.\");\n      return PAM_USER_UNKNOWN;\n   }\n\n   /* Get the password entry */\n   pwd = pam_modutil_getpwnam (pamh, user);\n   if (pwd == NULL)\n   {\n      pam_syslog(pamh, LOG_NOTICE, \"User unknown.\");\n      D((\"couldn't identify user %s\", user));\n      return PAM_USER_UNKNOWN;\n   }\n\n   /* Stat the home directory, if something exists then we assume it is\n      correct and return a success*/\n   if (stat(pwd->pw_dir, &St) == 0) {\n      if (opt.ctrl & MKHOMEDIR_DEBUG) {\n          pam_syslog(pamh, LOG_DEBUG, \"Home directory %s already exists.\",\n              pwd->pw_dir);\n      }\n      return PAM_SUCCESS;\n   }\n\n   return create_homedir(pamh, &opt, user, pwd->pw_dir);\n}"
  },
  {
    "function_name": "create_homedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
    "lines": "112-215",
    "snippet": "static int\ncreate_homedir (pam_handle_t *pamh, options_t *opt,\n\t\tconst char *user, const char *dir)\n{\n   int retval, child;\n   struct sigaction newsa, oldsa;\n   char *login_umask = NULL;\n   char *login_homemode = NULL;\n\n   /* Mention what is happening, if the notification fails that is OK */\n   if (!(opt->ctrl & MKHOMEDIR_QUIET))\n      pam_info(pamh, _(\"Creating directory '%s'.\"), dir);\n\n\n   D((\"called.\"));\n\n   /*\n    * This code arranges that the demise of the child does not cause\n    * the application to receive a signal it is not expecting - which\n    * may kill the application or worse.\n    */\n   memset(&newsa, '\\0', sizeof(newsa));\n   newsa.sa_handler = SIG_DFL;\n   sigaction(SIGCHLD, &newsa, &oldsa);\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"Executing mkhomedir_helper.\");\n   }\n\n   /* fetch UMASK from /etc/login.defs if not in argv */\n   if (opt->umask == NULL) {\n      login_umask = pam_modutil_search_key(pamh, LOGIN_DEFS, \"UMASK\");\n      login_homemode = pam_modutil_search_key(pamh, LOGIN_DEFS, \"HOME_MODE\");\n      if (login_homemode == NULL) {\n         if (login_umask != NULL) {\n            login_homemode = _pam_conv_str_umask_to_homemode(login_umask);\n         } else {\n            login_homemode = _pam_conv_str_umask_to_homemode(UMASK_DEFAULT);\n         }\n      }\n   } else {\n      login_homemode = _pam_conv_str_umask_to_homemode(opt->umask);\n   }\n\n   /* fork */\n   child = fork();\n   if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0)\n\t\t_exit(PAM_SYSTEM_ERR);\n\n\t/* exec the mkhomedir helper */\n\targs[0] = MKHOMEDIR_HELPER;\n\targs[1] = user;\n\targs[2] = opt->umask ? opt->umask : UMASK_DEFAULT;\n\targs[3] = opt->skeldir;\n\targs[4] = login_homemode;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(MKHOMEDIR_HELPER, (char **)args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_SYSTEM_ERR);\n   } else if (child > 0) {\n\tint rc;\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc < 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"waitpid failed: %m\");\n\t  retval = PAM_SYSTEM_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"mkhomedir_helper abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n   } else {\n\tD((\"fork failed\"));\n\tpam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n\tretval = PAM_SYSTEM_ERR;\n   }\n\n   sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"mkhomedir_helper returned %d\", retval);\n   }\n\n   if (retval != PAM_SUCCESS && !(opt->ctrl & MKHOMEDIR_QUIET)) {\n\tpam_error(pamh, _(\"Unable to create and initialize directory '%s'.\"),\n\t\t  dir);\n   }\n\n   free(login_umask);\n   free(login_homemode);\n\n   D((\"returning %d\", retval));\n   return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define UMASK_DEFAULT        \"0022\"",
      "#define LOGIN_DEFS           \"/etc/login.defs\"",
      "#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */",
      "#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"returning %d\", retval)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "login_homemode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"Unable to create and initialize directory '%s'.\")",
            "dir"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create and initialize directory '%s'.\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_conv_str_umask_to_homemode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
          "lines": "100-109",
          "snippet": "static char*\n_pam_conv_str_umask_to_homemode(const char *umask)\n{\n   unsigned int m = 0;\n   char tmp[5];\n\n   m = 0777 & ~strtoul(umask, NULL, 8);\n   (void) snprintf(tmp, sizeof(tmp), \"0%o\", m);\n   return strdup(tmp);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic char*\n_pam_conv_str_umask_to_homemode(const char *umask)\n{\n   unsigned int m = 0;\n   char tmp[5];\n\n   m = 0777 & ~strtoul(umask, NULL, 8);\n   (void) snprintf(tmp, sizeof(tmp), \"0%o\", m);\n   return strdup(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"mkhomedir_helper returned %d\"",
            "retval"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"fork failed: %m\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"mkhomedir_helper abnormal exit: %d\"",
            "retval"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"waitpid failed: %m\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "MKHOMEDIR_HELPER",
            "(char **)args",
            "envp"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "\"HOME_MODE\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "\"UMASK\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Executing mkhomedir_helper.\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Creating directory '%s'.\")",
            "dir"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define UMASK_DEFAULT        \"0022\"\n#define LOGIN_DEFS           \"/etc/login.defs\"\n#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */\n#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */\n\nstatic int\ncreate_homedir (pam_handle_t *pamh, options_t *opt,\n\t\tconst char *user, const char *dir)\n{\n   int retval, child;\n   struct sigaction newsa, oldsa;\n   char *login_umask = NULL;\n   char *login_homemode = NULL;\n\n   /* Mention what is happening, if the notification fails that is OK */\n   if (!(opt->ctrl & MKHOMEDIR_QUIET))\n      pam_info(pamh, _(\"Creating directory '%s'.\"), dir);\n\n\n   D((\"called.\"));\n\n   /*\n    * This code arranges that the demise of the child does not cause\n    * the application to receive a signal it is not expecting - which\n    * may kill the application or worse.\n    */\n   memset(&newsa, '\\0', sizeof(newsa));\n   newsa.sa_handler = SIG_DFL;\n   sigaction(SIGCHLD, &newsa, &oldsa);\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"Executing mkhomedir_helper.\");\n   }\n\n   /* fetch UMASK from /etc/login.defs if not in argv */\n   if (opt->umask == NULL) {\n      login_umask = pam_modutil_search_key(pamh, LOGIN_DEFS, \"UMASK\");\n      login_homemode = pam_modutil_search_key(pamh, LOGIN_DEFS, \"HOME_MODE\");\n      if (login_homemode == NULL) {\n         if (login_umask != NULL) {\n            login_homemode = _pam_conv_str_umask_to_homemode(login_umask);\n         } else {\n            login_homemode = _pam_conv_str_umask_to_homemode(UMASK_DEFAULT);\n         }\n      }\n   } else {\n      login_homemode = _pam_conv_str_umask_to_homemode(opt->umask);\n   }\n\n   /* fork */\n   child = fork();\n   if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0)\n\t\t_exit(PAM_SYSTEM_ERR);\n\n\t/* exec the mkhomedir helper */\n\targs[0] = MKHOMEDIR_HELPER;\n\targs[1] = user;\n\targs[2] = opt->umask ? opt->umask : UMASK_DEFAULT;\n\targs[3] = opt->skeldir;\n\targs[4] = login_homemode;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(MKHOMEDIR_HELPER, (char **)args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_SYSTEM_ERR);\n   } else if (child > 0) {\n\tint rc;\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc < 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"waitpid failed: %m\");\n\t  retval = PAM_SYSTEM_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"mkhomedir_helper abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n   } else {\n\tD((\"fork failed\"));\n\tpam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n\tretval = PAM_SYSTEM_ERR;\n   }\n\n   sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n   if (opt->ctrl & MKHOMEDIR_DEBUG) {\n        pam_syslog(pamh, LOG_DEBUG, \"mkhomedir_helper returned %d\", retval);\n   }\n\n   if (retval != PAM_SUCCESS && !(opt->ctrl & MKHOMEDIR_QUIET)) {\n\tpam_error(pamh, _(\"Unable to create and initialize directory '%s'.\"),\n\t\t  dir);\n   }\n\n   free(login_umask);\n   free(login_homemode);\n\n   D((\"returning %d\", retval));\n   return retval;\n}"
  },
  {
    "function_name": "_pam_conv_str_umask_to_homemode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
    "lines": "100-109",
    "snippet": "static char*\n_pam_conv_str_umask_to_homemode(const char *umask)\n{\n   unsigned int m = 0;\n   char tmp[5];\n\n   m = 0777 & ~strtoul(umask, NULL, 8);\n   (void) snprintf(tmp, sizeof(tmp), \"0%o\", m);\n   return strdup(tmp);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "sizeof(tmp)",
            "\"0%o\"",
            "m"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "umask",
            "NULL",
            "8"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic char*\n_pam_conv_str_umask_to_homemode(const char *umask)\n{\n   unsigned int m = 0;\n   char tmp[5];\n\n   m = 0777 & ~strtoul(umask, NULL, 8);\n   (void) snprintf(tmp, sizeof(tmp), \"0%o\", m);\n   return strdup(tmp);\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/pam_mkhomedir.c",
    "lines": "69-98",
    "snippet": "static void\n_pam_parse (const pam_handle_t *pamh, int flags, int argc, const char **argv,\n\t    options_t *opt)\n{\n   opt->ctrl = 0;\n   opt->umask = NULL;\n   opt->skeldir = \"/etc/skel\";\n\n   /* does the application require quiet? */\n   if ((flags & PAM_SILENT) == PAM_SILENT)\n      opt->ctrl |= MKHOMEDIR_QUIET;\n\n   /* step through arguments */\n   for (; argc-- > 0; ++argv)\n   {\n      const char *str;\n\n      if (!strcmp(*argv, \"silent\")) {\n\t opt->ctrl |= MKHOMEDIR_QUIET;\n      } else if (!strcmp(*argv, \"debug\")) {\n         opt->ctrl |= MKHOMEDIR_DEBUG;\n      } else if ((str = pam_str_skip_prefix(*argv, \"umask=\")) != NULL) {\n\t opt->umask = str;\n      } else if ((str = pam_str_skip_prefix(*argv, \"skel=\")) != NULL) {\n\t opt->skeldir = str;\n      } else {\n\t pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n      }\n   }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */",
      "#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"skel=\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"umask=\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"silent\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MKHOMEDIR_QUIET      040\t/* keep quiet about things */\n#define MKHOMEDIR_DEBUG      020\t/* be verbose about things */\n\nstatic void\n_pam_parse (const pam_handle_t *pamh, int flags, int argc, const char **argv,\n\t    options_t *opt)\n{\n   opt->ctrl = 0;\n   opt->umask = NULL;\n   opt->skeldir = \"/etc/skel\";\n\n   /* does the application require quiet? */\n   if ((flags & PAM_SILENT) == PAM_SILENT)\n      opt->ctrl |= MKHOMEDIR_QUIET;\n\n   /* step through arguments */\n   for (; argc-- > 0; ++argv)\n   {\n      const char *str;\n\n      if (!strcmp(*argv, \"silent\")) {\n\t opt->ctrl |= MKHOMEDIR_QUIET;\n      } else if (!strcmp(*argv, \"debug\")) {\n         opt->ctrl |= MKHOMEDIR_DEBUG;\n      } else if ((str = pam_str_skip_prefix(*argv, \"umask=\")) != NULL) {\n\t opt->umask = str;\n      } else if ((str = pam_str_skip_prefix(*argv, \"skel=\")) != NULL) {\n\t opt->skeldir = str;\n      } else {\n\t pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n      }\n   }\n}"
  }
]