[
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_auth.c",
    "lines": "189-215",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh, int flags,\n\t\tint argc, const char **argv)\n{\n\tint retval;\n\tconst void *pretval = NULL;\n\tunsigned long long ctrl;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = PAM_SUCCESS;\n\n\tD((\"recovering return code from auth call\"));\n\t/* We will only find something here if UNIX_LIKE_AUTH is set --\n\t   don't worry about an explicit check of argv. */\n\tif (on(UNIX_LIKE_AUTH, ctrl)\n\t    && pam_get_data(pamh, \"unix_setcred_return\", &pretval) == PAM_SUCCESS\n\t    && pretval) {\n\t        retval = *(const int *)pretval;\n\t\tpam_set_data(pamh, \"unix_setcred_return\", NULL, NULL);\n\t\tD((\"recovered data indicates that old retval was %d\", retval));\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include \"support.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"recovered data indicates that old retval was %d\", retval)"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "\"unix_setcred_return\"",
            "NULL",
            "NULL"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "\"unix_setcred_return\"",
            "&pretval"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_LIKE_AUTH",
            "ctrl"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "NULL",
            "NULL",
            "NULL",
            "argc",
            "argv"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"support.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh, int flags,\n\t\tint argc, const char **argv)\n{\n\tint retval;\n\tconst void *pretval = NULL;\n\tunsigned long long ctrl;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\tretval = PAM_SUCCESS;\n\n\tD((\"recovering return code from auth call\"));\n\t/* We will only find something here if UNIX_LIKE_AUTH is set --\n\t   don't worry about an explicit check of argv. */\n\tif (on(UNIX_LIKE_AUTH, ctrl)\n\t    && pam_get_data(pamh, \"unix_setcred_return\", &pretval) == PAM_SUCCESS\n\t    && pretval) {\n\t        retval = *(const int *)pretval;\n\t\tpam_set_data(pamh, \"unix_setcred_return\", NULL, NULL);\n\t\tD((\"recovered data indicates that old retval was %d\", retval));\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_auth.c",
    "lines": "93-177",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl;\n\tint retval, *ret_data = NULL;\n\tconst char *name;\n\tconst char *p;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\t/* Get a few bytes so we can pass our return value to\n\t   pam_sm_setcred() and pam_sm_acct_mgmt(). */\n\tret_data = malloc(sizeof(int));\n\tif (!ret_data) {\n\t\tD((\"cannot malloc ret_data\"));\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t\"pam_unix_auth: cannot allocate ret_data\");\n\t\treturn PAM_BUF_ERR;\n\t}\n\n\t/* get the user'name' */\n\n\tretval = pam_get_user(pamh, &name, NULL);\n\tif (retval == PAM_SUCCESS) {\n\t\t/*\n\t\t * Various libraries at various times have had bugs related to\n\t\t * '+' or '-' as the first character of a user name. Don't\n\t\t * allow this characters here.\n\t\t */\n\t\tif (name[0] == '-' || name[0] == '+') {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"bad username [%s]\", name);\n\t\t\tretval = PAM_USER_UNKNOWN;\n\t\t\tAUTH_RETURN;\n\t\t}\n\t\tif (on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"username [%s] obtained\", name);\n\t} else {\n\t\tif (retval == PAM_CONV_AGAIN) {\n\t\t\tD((\"pam_get_user/conv() function is not ready yet\"));\n\t\t\t/* it is safe to resume this function so we translate this\n\t\t\t * retval to the value that indicates we're happy to resume.\n\t\t\t */\n\t\t\tretval = PAM_INCOMPLETE;\n\t\t} else if (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"could not obtain username\");\n\t\t}\n\t\tAUTH_RETURN;\n\t}\n\n\t/* if this user does not have a password... */\n\n\tif (_unix_blankpasswd(pamh, ctrl, name)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"user [%s] has blank password; authenticated without it\", name);\n\t\tname = NULL;\n\t\tretval = PAM_SUCCESS;\n\t\tAUTH_RETURN;\n\t}\n\t/* get this user's authentication token */\n\n\tretval = pam_get_authtok(pamh, PAM_AUTHTOK, &p , NULL);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval != PAM_CONV_AGAIN) {\n\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t    \"auth could not identify password for [%s]\", name);\n\t\t} else {\n\t\t\tD((\"conversation function is not ready yet\"));\n\t\t\t/*\n\t\t\t * it is safe to resume this function so we translate this\n\t\t\t * retval to the value that indicates we're happy to resume.\n\t\t\t */\n\t\t\tretval = PAM_INCOMPLETE;\n\t\t}\n\t\tname = NULL;\n\t\tAUTH_RETURN;\n\t}\n\tD((\"user=%s, password=[%s]\", name, p));\n\n\t/* verify the password of this user */\n\tretval = _unix_verify_password(pamh, name, p, ctrl);\n\tname = p = NULL;\n\n\tAUTH_RETURN;\n}",
    "includes": [
      "#include \"support.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define AUTH_RETURN\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tD((\"recording return code for next time [%d]\",\t\t\\\n\t\t\t\tretval));\t\t\t\\\n\t*ret_data = retval;\t\t\t\t\t\\\n\tpam_set_data(pamh, \"unix_setcred_return\",\t\t\\\n\t\t\t (void *) ret_data, setcred_free);\t\\\n\tD((\"done. [%s]\", pam_strerror(pamh, retval)));\t\t\\\n\treturn retval;\t\t\t\t\t\t\\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_unix_verify_password",
          "args": [
            "pamh",
            "name",
            "p",
            "ctrl"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_verify_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "661-817",
          "snippet": "int _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define UNIX_MAX_RETRIES              3",
            "#define FAIL_PREFIX                   \"-UN*X-FAIL-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define UNIX_MAX_RETRIES              3\n#define FAIL_PREFIX                   \"-UN*X-FAIL-\"\n\nint _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"user=%s, password=[%s]\", name, p)"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"auth could not identify password for [%s]\"",
            "name"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_authtok",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&p",
            "NULL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user [%s] has blank password; authenticated without it\"",
            "name"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_blankpasswd",
          "args": [
            "pamh",
            "ctrl",
            "name"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_blankpasswd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "597-659",
          "snippet": "int\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"could not obtain username\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_DEBUG",
            "ctrl"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"username [%s] obtained\"",
            "name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"bad username [%s]\"",
            "name"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&name",
            "NULL"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"pam_unix_auth: cannot allocate ret_data\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(int)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "NULL",
            "NULL",
            "NULL",
            "argc",
            "argv"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"support.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define AUTH_RETURN\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tD((\"recording return code for next time [%d]\",\t\t\\\n\t\t\t\tretval));\t\t\t\\\n\t*ret_data = retval;\t\t\t\t\t\\\n\tpam_set_data(pamh, \"unix_setcred_return\",\t\t\\\n\t\t\t (void *) ret_data, setcred_free);\t\\\n\tD((\"done. [%s]\", pam_strerror(pamh, retval)));\t\t\\\n\treturn retval;\t\t\t\t\t\t\\\n} while (0)\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl;\n\tint retval, *ret_data = NULL;\n\tconst char *name;\n\tconst char *p;\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, NULL, NULL, NULL, argc, argv);\n\n\t/* Get a few bytes so we can pass our return value to\n\t   pam_sm_setcred() and pam_sm_acct_mgmt(). */\n\tret_data = malloc(sizeof(int));\n\tif (!ret_data) {\n\t\tD((\"cannot malloc ret_data\"));\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t\"pam_unix_auth: cannot allocate ret_data\");\n\t\treturn PAM_BUF_ERR;\n\t}\n\n\t/* get the user'name' */\n\n\tretval = pam_get_user(pamh, &name, NULL);\n\tif (retval == PAM_SUCCESS) {\n\t\t/*\n\t\t * Various libraries at various times have had bugs related to\n\t\t * '+' or '-' as the first character of a user name. Don't\n\t\t * allow this characters here.\n\t\t */\n\t\tif (name[0] == '-' || name[0] == '+') {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"bad username [%s]\", name);\n\t\t\tretval = PAM_USER_UNKNOWN;\n\t\t\tAUTH_RETURN;\n\t\t}\n\t\tif (on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"username [%s] obtained\", name);\n\t} else {\n\t\tif (retval == PAM_CONV_AGAIN) {\n\t\t\tD((\"pam_get_user/conv() function is not ready yet\"));\n\t\t\t/* it is safe to resume this function so we translate this\n\t\t\t * retval to the value that indicates we're happy to resume.\n\t\t\t */\n\t\t\tretval = PAM_INCOMPLETE;\n\t\t} else if (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"could not obtain username\");\n\t\t}\n\t\tAUTH_RETURN;\n\t}\n\n\t/* if this user does not have a password... */\n\n\tif (_unix_blankpasswd(pamh, ctrl, name)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"user [%s] has blank password; authenticated without it\", name);\n\t\tname = NULL;\n\t\tretval = PAM_SUCCESS;\n\t\tAUTH_RETURN;\n\t}\n\t/* get this user's authentication token */\n\n\tretval = pam_get_authtok(pamh, PAM_AUTHTOK, &p , NULL);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval != PAM_CONV_AGAIN) {\n\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t    \"auth could not identify password for [%s]\", name);\n\t\t} else {\n\t\t\tD((\"conversation function is not ready yet\"));\n\t\t\t/*\n\t\t\t * it is safe to resume this function so we translate this\n\t\t\t * retval to the value that indicates we're happy to resume.\n\t\t\t */\n\t\t\tretval = PAM_INCOMPLETE;\n\t\t}\n\t\tname = NULL;\n\t\tAUTH_RETURN;\n\t}\n\tD((\"user=%s, password=[%s]\", name, p));\n\n\t/* verify the password of this user */\n\tretval = _unix_verify_password(pamh, name, p, ctrl);\n\tname = p = NULL;\n\n\tAUTH_RETURN;\n}"
  },
  {
    "function_name": "setcred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_auth.c",
    "lines": "86-91",
    "snippet": "static void\nsetcred_free (pam_handle_t *pamh UNUSED, void *ptr, int err UNUSED)\n{\n\tif (ptr)\n\t\tfree (ptr);\n}",
    "includes": [
      "#include \"support.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"support.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nsetcred_free (pam_handle_t *pamh UNUSED, void *ptr, int err UNUSED)\n{\n\tif (ptr)\n\t\tfree (ptr);\n}"
  }
]