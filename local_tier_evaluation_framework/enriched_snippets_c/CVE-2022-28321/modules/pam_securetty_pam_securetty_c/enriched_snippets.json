[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
    "lines": "273-284",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags UNUSED,\n\t\t  int argc, const char **argv)\n{\n    int ctrl;\n\n    /* parse the arguments */\n    ctrl = _pam_parse (pamh, argc, argv);\n\n    /* take the easy route */\n    return securetty_perform_check(pamh, ctrl, __FUNCTION__);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "securetty_perform_check",
          "args": [
            "pamh",
            "ctrl",
            "__FUNCTION__"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "securetty_perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
          "lines": "63-249",
          "snippet": "static int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"",
            "#define CMDLINE_FILE   \"/proc/cmdline\"",
            "#define TTY_PREFIX     \"/dev/\"",
            "#define SECURETTY2_FILE VENDORDIR\"/securetty\"",
            "#define SECURETTY_FILE \"/etc/securetty\"",
            "#define PAM_NOCONSOLE_ARG   0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"\n#define CMDLINE_FILE   \"/proc/cmdline\"\n#define TTY_PREFIX     \"/dev/\"\n#define SECURETTY2_FILE VENDORDIR\"/securetty\"\n#define SECURETTY_FILE \"/etc/securetty\"\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
          "lines": "41-61",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NOCONSOLE_ARG   0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags UNUSED,\n\t\t  int argc, const char **argv)\n{\n    int ctrl;\n\n    /* parse the arguments */\n    ctrl = _pam_parse (pamh, argc, argv);\n\n    /* take the easy route */\n    return securetty_perform_check(pamh, ctrl, __FUNCTION__);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
    "lines": "264-269",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
    "lines": "253-262",
    "snippet": "int pam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED, int argc,\n\t\t\tconst char **argv)\n{\n    int ctrl;\n\n    /* parse the arguments */\n    ctrl = _pam_parse (pamh, argc, argv);\n\n    return securetty_perform_check(pamh, ctrl, __FUNCTION__);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "securetty_perform_check",
          "args": [
            "pamh",
            "ctrl",
            "__FUNCTION__"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "securetty_perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
          "lines": "63-249",
          "snippet": "static int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"",
            "#define CMDLINE_FILE   \"/proc/cmdline\"",
            "#define TTY_PREFIX     \"/dev/\"",
            "#define SECURETTY2_FILE VENDORDIR\"/securetty\"",
            "#define SECURETTY_FILE \"/etc/securetty\"",
            "#define PAM_NOCONSOLE_ARG   0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"\n#define CMDLINE_FILE   \"/proc/cmdline\"\n#define TTY_PREFIX     \"/dev/\"\n#define SECURETTY2_FILE VENDORDIR\"/securetty\"\n#define SECURETTY_FILE \"/etc/securetty\"\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
          "lines": "41-61",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NOCONSOLE_ARG   0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint pam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED, int argc,\n\t\t\tconst char **argv)\n{\n    int ctrl;\n\n    /* parse the arguments */\n    ctrl = _pam_parse (pamh, argc, argv);\n\n    return securetty_perform_check(pamh, ctrl, __FUNCTION__);\n}"
  },
  {
    "function_name": "securetty_perform_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
    "lines": "63-249",
    "snippet": "static int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"",
      "#define CMDLINE_FILE   \"/proc/cmdline\"",
      "#define TTY_PREFIX     \"/dev/\"",
      "#define SECURETTY2_FILE VENDORDIR\"/securetty\"",
      "#define SECURETTY_FILE \"/etc/securetty\"",
      "#define PAM_NOCONSOLE_ARG   0x0002",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"access allowed for '%s' on '%s'\"",
            "username",
            "uttyname"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"access denied: tty '%s' is not secure !\"",
            "uttyname"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "uttyname"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "' '"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "consoleactivefile"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "consoleactivefile"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "CONSOLEACTIVE_FILE",
            "\"r\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix_len",
          "args": [
            "p + 8",
            "uttyname",
            "strlen(uttyname)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "uttyname"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"console=\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cmdlinefile"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "cmdlinefile"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "CMDLINE_FILE",
            "\"r\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "ttyfile"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptname",
            "uttyname"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ttyfileline",
            "uttyname"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ttyfileline"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ttyfileline"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "ttyfileline",
            "sizeof(ttyfileline)-1",
            "ttyfile"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptname",
            "sizeof(ptname)",
            "\"pts/%s\"",
            "uttyname"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "uttyname[0]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error opening %s: %m\"",
            "securettyfile"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "securettyfile",
            "\"r\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s is either world writable or not a normal file\"",
            "securettyfile"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ttyfileinfo.st_mode"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Couldn't open %s: %m\"",
            "SECURETTY_FILE"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Couldn't open %s: %m\"",
            "SECURETTY2_FILE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "SECURETTY2_FILE",
            "&ttyfileinfo"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "uttyname",
            "TTY_PREFIX"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot determine user's tty\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&void_uttyname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_securetty called via %s function\"",
            "function_name"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define CONSOLEACTIVE_FILE\t\"/sys/class/tty/console/active\"\n#define CMDLINE_FILE   \"/proc/cmdline\"\n#define TTY_PREFIX     \"/dev/\"\n#define SECURETTY2_FILE VENDORDIR\"/securetty\"\n#define SECURETTY_FILE \"/etc/securetty\"\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nsecuretty_perform_check (pam_handle_t *pamh, int ctrl,\n\t\t\t const char *function_name)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *securettyfile;\n    const char *username;\n    const char *uttyname;\n    const char *str;\n    const void *void_uttyname;\n    char ttyfileline[256];\n    char ptname[256];\n    struct stat ttyfileinfo;\n    struct passwd *user_pwd;\n    FILE *ttyfile;\n\n    /* log a trail for debugging */\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG, \"pam_securetty called via %s function\",\n\t\t   function_name);\n    }\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE : retval);\n    }\n\n    user_pwd = pam_modutil_getpwnam(pamh, username);\n    if (user_pwd != NULL && user_pwd->pw_uid != 0) {\n\t/* If the user is not root, securetty's does not apply to them */\n\treturn PAM_SUCCESS;\n    }\n    /* The user is now either root or an invalid / mistyped username */\n\n    retval = pam_get_item(pamh, PAM_TTY, &void_uttyname);\n    uttyname = void_uttyname;\n    if (retval != PAM_SUCCESS || uttyname == NULL) {\n        pam_syslog (pamh, LOG_ERR, \"cannot determine user's tty\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    /* The PAM_TTY item may be prefixed with \"/dev/\" - skip that */\n    if ((str = pam_str_skip_prefix(uttyname, TTY_PREFIX)) != NULL)\n\tuttyname = str;\n\n    if (stat(SECURETTY_FILE, &ttyfileinfo)) {\n#ifdef VENDORDIR\n      if (errno == ENOENT) {\n\tif (stat(SECURETTY2_FILE, &ttyfileinfo)) {\n\t  if (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"Couldn't open %s: %m\", SECURETTY2_FILE);\n\t  return PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t\t this needs to succeed.  But we still log the\n\t\t\t\t error. */\n\t}\n\tsecurettyfile = SECURETTY2_FILE;\n      } else {\n#endif\n\tif (ctrl & PAM_DEBUG_ARG)\n\t  pam_syslog(pamh, LOG_DEBUG, \"Couldn't open %s: %m\", SECURETTY_FILE);\n\treturn PAM_SUCCESS; /* for compatibility with old securetty handling,\n\t\t\t       this needs to succeed.  But we still log the\n\t\t\t       error. */\n#ifdef VENDORDIR\n      }\n#endif\n    } else {\n      securettyfile = SECURETTY_FILE;\n    }\n\n    if ((ttyfileinfo.st_mode & S_IWOTH) || !S_ISREG(ttyfileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   securettyfile);\n\treturn PAM_AUTH_ERR;\n    }\n\n    ttyfile = fopen(securettyfile,\"r\");\n    if (ttyfile == NULL) { /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", securettyfile);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if (isdigit(uttyname[0])) {\n\tsnprintf(ptname, sizeof(ptname), \"pts/%s\", uttyname);\n    } else {\n\tptname[0] = '\\0';\n    }\n\n    retval = 1;\n\n    while ((fgets(ttyfileline, sizeof(ttyfileline)-1, ttyfile) != NULL)\n\t   && retval) {\n\tif (ttyfileline[strlen(ttyfileline) - 1] == '\\n')\n\t    ttyfileline[strlen(ttyfileline) - 1] = '\\0';\n\n\tretval = ( strcmp(ttyfileline, uttyname)\n\t\t   && (!ptname[0] || strcmp(ptname, uttyname)) );\n    }\n    fclose(ttyfile);\n\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *cmdlinefile;\n\n        /* Allow access from the kernel console, if enabled */\n        cmdlinefile = fopen(CMDLINE_FILE, \"r\");\n\n        if (cmdlinefile != NULL) {\n            char line[LINE_MAX], *p;\n\n            p = fgets(line, sizeof(line), cmdlinefile);\n            fclose(cmdlinefile);\n\n            for (; p; p = strstr(p+1, \"console=\")) {\n                const char *e;\n\n                /* Test whether this is a beginning of a word? */\n                if (p > line && p[-1] != ' ')\n                    continue;\n\n                /* Is this our console? */\n                if ((e = pam_str_skip_prefix_len(p + 8, uttyname, strlen(uttyname))) == NULL)\n                    continue;\n\n                /* Is there any garbage after the TTY name? */\n                if (*e == ',' || *e == ' ' || *e == '\\n' || *e == 0) {\n                    retval = 0;\n                    break;\n                }\n            }\n        }\n    }\n    if (retval && !(ctrl & PAM_NOCONSOLE_ARG)) {\n        FILE *consoleactivefile;\n\n        /* Allow access from the active console */\n        consoleactivefile = fopen(CONSOLEACTIVE_FILE, \"r\");\n\n        if (consoleactivefile != NULL) {\n            char line[LINE_MAX], *p, *n;\n\n            line[0] = 0;\n            p = fgets(line, sizeof(line), consoleactivefile);\n            fclose(consoleactivefile);\n\n\t    if (p) {\n\t\t/* remove the newline character at end */\n\t\tif (line[strlen(line)-1] == '\\n')\n\t\t    line[strlen(line)-1] = 0;\n\n\t\tfor (n = p; n != NULL; p = n+1) {\n\t\t    if ((n = strchr(p, ' ')) != NULL)\n\t\t\t*n = '\\0';\n\n\t\t    if (strcmp(p, uttyname) == 0) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (retval) {\n\t    pam_syslog(pamh, LOG_NOTICE, \"access denied: tty '%s' is not secure !\",\n\t\t     uttyname);\n\n\t    retval = PAM_AUTH_ERR;\n\t    if (user_pwd == NULL) {\n\t\tretval = PAM_USER_UNKNOWN;\n\t    }\n    } else {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"access allowed for '%s' on '%s'\",\n\t\t     username, uttyname);\n\t}\n\tretval = PAM_SUCCESS;\n\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_securetty/pam_securetty.c",
    "lines": "41-61",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_NOCONSOLE_ARG   0x0002",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noconsole\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <string.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_NOCONSOLE_ARG   0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n        else if (!strcmp(*argv, \"noconsole\"))\n            ctrl |= PAM_NOCONSOLE_ARG;\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    return ctrl;\n}"
  }
]