[
  {
    "function_name": "hmac_generate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "361-379",
    "snippet": "int\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmac_management",
          "args": [
            "pamh",
            "debug",
            "mac",
            "mac_length",
            "key",
            "key_length",
            "text",
            "text_length"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_management",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "227-309",
          "snippet": "static int\nhmac_management(pam_handle_t *pamh, int debug, void **out, size_t *out_length,\n                char *key, size_t key_length,\n                const void *text, size_t text_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    unsigned char *hmac_message = NULL;\n    size_t hmac_length;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, (const unsigned char *)key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_update(ctx, (const unsigned char *)text, text_length);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to update hmac context\");\n        goto done;\n    }\n\n    hmac_message = (unsigned char*)malloc(sizeof(unsigned char) * MAX_HMAC_LENGTH);\n    if (!hmac_message) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    ret = EVP_MAC_final(ctx, hmac_message, &hmac_length, MAX_HMAC_LENGTH);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to calculate hmac message\");\n        goto done;\n    }\n\n    *out_length = hmac_length;\n    *out = malloc(*out_length);\n    if (*out == NULL) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    memcpy(*out, hmac_message, *out_length);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (hmac_message != NULL) {\n        free(hmac_message);\n    }\n    if (key != NULL) {\n        memset(key, 0, key_length);\n        free(key);\n    }\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_HMAC_LENGTH     512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_HMAC_LENGTH     512\n\nstatic int\nhmac_management(pam_handle_t *pamh, int debug, void **out, size_t *out_length,\n                char *key, size_t key_length,\n                const void *text, size_t text_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    unsigned char *hmac_message = NULL;\n    size_t hmac_length;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, (const unsigned char *)key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_update(ctx, (const unsigned char *)text, text_length);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to update hmac context\");\n        goto done;\n    }\n\n    hmac_message = (unsigned char*)malloc(sizeof(unsigned char) * MAX_HMAC_LENGTH);\n    if (!hmac_message) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    ret = EVP_MAC_final(ctx, hmac_message, &hmac_length, MAX_HMAC_LENGTH);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to calculate hmac message\");\n        goto done;\n    }\n\n    *out_length = hmac_length;\n    *out = malloc(*out_length);\n    if (*out == NULL) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    memcpy(*out, hmac_message, *out_length);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (hmac_message != NULL) {\n        free(hmac_message);\n    }\n    if (key != NULL) {\n        memset(key, 0, key_length);\n        free(key);\n    }\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_management",
          "args": [
            "pamh",
            "key_file",
            "&key",
            "key_length",
            "owner",
            "group"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "key_management",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "195-225",
          "snippet": "static int\nkey_management(pam_handle_t *pamh, const char *file_name, char **text,\n                size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n\n    fd = open(file_name, O_RDONLY | O_NOFOLLOW);\n    if (fd == -1) {\n        if (errno == ENOENT) {\n            if (generate_key(pamh, text, text_length)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to generate key\");\n                return PAM_AUTH_ERR;\n            }\n\n            if (write_file(pamh, file_name, *text, text_length, owner, group)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to write key\");\n                return PAM_AUTH_ERR;\n            }\n        } else {\n            pam_syslog(pamh, LOG_ERR, \"Unable to open %s: %m\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    } else {\n        if (read_file(pamh, fd, text, &text_length)) {\n            pam_syslog(pamh, LOG_ERR, \"Error reading key file %s\\n\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nkey_management(pam_handle_t *pamh, const char *file_name, char **text,\n                size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n\n    fd = open(file_name, O_RDONLY | O_NOFOLLOW);\n    if (fd == -1) {\n        if (errno == ENOENT) {\n            if (generate_key(pamh, text, text_length)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to generate key\");\n                return PAM_AUTH_ERR;\n            }\n\n            if (write_file(pamh, file_name, *text, text_length, owner, group)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to write key\");\n                return PAM_AUTH_ERR;\n            }\n        } else {\n            pam_syslog(pamh, LOG_ERR, \"Unable to open %s: %m\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    } else {\n        if (read_file(pamh, fd, text, &text_length)) {\n            pam_syslog(pamh, LOG_ERR, \"Error reading key file %s\\n\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "hmac_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "311-359",
    "snippet": "int\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "algo"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_MAC_free",
          "args": [
            "evp_mac"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_CTX_get_mac_size",
          "args": [
            "ctx"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to initialize hmac context\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_init",
          "args": [
            "ctx",
            "key",
            "key_length",
            "subalg_param"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to create hmac context\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_CTX_new",
          "args": [
            "evp_mac"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to create hmac implementation\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_fetch",
          "args": [
            "NULL",
            "\"HMAC\"",
            "NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OSSL_PARAM_construct_utf8_string",
          "args": [
            "OSSL_MAC_PARAM_DIGEST",
            "algo",
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_crypto_algorithm",
          "args": [
            "pamh",
            "debug"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "get_crypto_algorithm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "64-80",
          "snippet": "static char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_ALGORITHM   \"SHA512\"",
            "#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"",
            "#define LOGIN_DEFS          \"/etc/login.defs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define DEFAULT_ALGORITHM   \"SHA512\"\n#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"\n#define LOGIN_DEFS          \"/etc/login.defs\"\n\nstatic char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}"
  },
  {
    "function_name": "hmac_management",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "227-309",
    "snippet": "static int\nhmac_management(pam_handle_t *pamh, int debug, void **out, size_t *out_length,\n                char *key, size_t key_length,\n                const void *text, size_t text_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    unsigned char *hmac_message = NULL;\n    size_t hmac_length;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, (const unsigned char *)key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_update(ctx, (const unsigned char *)text, text_length);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to update hmac context\");\n        goto done;\n    }\n\n    hmac_message = (unsigned char*)malloc(sizeof(unsigned char) * MAX_HMAC_LENGTH);\n    if (!hmac_message) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    ret = EVP_MAC_final(ctx, hmac_message, &hmac_length, MAX_HMAC_LENGTH);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to calculate hmac message\");\n        goto done;\n    }\n\n    *out_length = hmac_length;\n    *out = malloc(*out_length);\n    if (*out == NULL) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    memcpy(*out, hmac_message, *out_length);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (hmac_message != NULL) {\n        free(hmac_message);\n    }\n    if (key != NULL) {\n        memset(key, 0, key_length);\n        free(key);\n    }\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_HMAC_LENGTH     512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "algo"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_MAC_free",
          "args": [
            "evp_mac"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "key_length"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*out",
            "hmac_message",
            "*out_length"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Not enough memory\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "*out_length"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to calculate hmac message\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_final",
          "args": [
            "ctx",
            "hmac_message",
            "&hmac_length",
            "MAX_HMAC_LENGTH"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Not enough memory\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(unsigned char) * MAX_HMAC_LENGTH"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to update hmac context\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_update",
          "args": [
            "ctx",
            "(const unsigned char *)text",
            "text_length"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to initialize hmac context\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_init",
          "args": [
            "ctx",
            "(const unsigned char *)key",
            "key_length",
            "subalg_param"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to create hmac context\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_CTX_new",
          "args": [
            "evp_mac"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to create hmac implementation\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MAC_fetch",
          "args": [
            "NULL",
            "\"HMAC\"",
            "NULL"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OSSL_PARAM_construct_utf8_string",
          "args": [
            "OSSL_MAC_PARAM_DIGEST",
            "algo",
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_crypto_algorithm",
          "args": [
            "pamh",
            "debug"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "get_crypto_algorithm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "64-80",
          "snippet": "static char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_ALGORITHM   \"SHA512\"",
            "#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"",
            "#define LOGIN_DEFS          \"/etc/login.defs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define DEFAULT_ALGORITHM   \"SHA512\"\n#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"\n#define LOGIN_DEFS          \"/etc/login.defs\"\n\nstatic char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_HMAC_LENGTH     512\n\nstatic int\nhmac_management(pam_handle_t *pamh, int debug, void **out, size_t *out_length,\n                char *key, size_t key_length,\n                const void *text, size_t text_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    unsigned char *hmac_message = NULL;\n    size_t hmac_length;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, (const unsigned char *)key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_update(ctx, (const unsigned char *)text, text_length);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to update hmac context\");\n        goto done;\n    }\n\n    hmac_message = (unsigned char*)malloc(sizeof(unsigned char) * MAX_HMAC_LENGTH);\n    if (!hmac_message) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    ret = EVP_MAC_final(ctx, hmac_message, &hmac_length, MAX_HMAC_LENGTH);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to calculate hmac message\");\n        goto done;\n    }\n\n    *out_length = hmac_length;\n    *out = malloc(*out_length);\n    if (*out == NULL) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        goto done;\n    }\n\n    memcpy(*out, hmac_message, *out_length);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (hmac_message != NULL) {\n        free(hmac_message);\n    }\n    if (key != NULL) {\n        memset(key, 0, key_length);\n        free(key);\n    }\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}"
  },
  {
    "function_name": "key_management",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "195-225",
    "snippet": "static int\nkey_management(pam_handle_t *pamh, const char *file_name, char **text,\n                size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n\n    fd = open(file_name, O_RDONLY | O_NOFOLLOW);\n    if (fd == -1) {\n        if (errno == ENOENT) {\n            if (generate_key(pamh, text, text_length)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to generate key\");\n                return PAM_AUTH_ERR;\n            }\n\n            if (write_file(pamh, file_name, *text, text_length, owner, group)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to write key\");\n                return PAM_AUTH_ERR;\n            }\n        } else {\n            pam_syslog(pamh, LOG_ERR, \"Unable to open %s: %m\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    } else {\n        if (read_file(pamh, fd, text, &text_length)) {\n            pam_syslog(pamh, LOG_ERR, \"Error reading key file %s\\n\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error reading key file %s\\n\"",
            "file_name"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_file",
          "args": [
            "pamh",
            "fd",
            "text",
            "&text_length"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "read_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "116-156",
          "snippet": "static int\nread_file(pam_handle_t *pamh, int fd, char **text, size_t *text_length)\n{\n    struct stat st;\n    size_t bytes_read = 0;\n    char *tmp = NULL;\n\n    if (fstat(fd, &st) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to stat file: %m\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (st.st_size == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Key file size cannot be 0\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(st.st_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, st.st_size);\n    close(fd);\n\n    if (bytes_read < (size_t)st.st_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on key file\");\n        memset(tmp, 0, st.st_size);\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *text = tmp;\n    *text_length = st.st_size;\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nread_file(pam_handle_t *pamh, int fd, char **text, size_t *text_length)\n{\n    struct stat st;\n    size_t bytes_read = 0;\n    char *tmp = NULL;\n\n    if (fstat(fd, &st) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to stat file: %m\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (st.st_size == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Key file size cannot be 0\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(st.st_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, st.st_size);\n    close(fd);\n\n    if (bytes_read < (size_t)st.st_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on key file\");\n        memset(tmp, 0, st.st_size);\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *text = tmp;\n    *text_length = st.st_size;\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open %s: %m\"",
            "file_name"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to write key\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_file",
          "args": [
            "pamh",
            "file_name",
            "*text",
            "text_length",
            "owner",
            "group"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "158-193",
          "snippet": "static int\nwrite_file(pam_handle_t *pamh, const char *file_name, char *text,\n           size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n    size_t bytes_written = 0;\n\n    fd = open(file_name,\n              O_WRONLY | O_CREAT | O_TRUNC,\n              S_IRUSR | S_IWUSR);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to open [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    if (fchown(fd, owner, group) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to change ownership [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_written = pam_modutil_write(fd, text, text_length);\n    close(fd);\n\n    if (bytes_written < text_length) {\n        pam_syslog(pamh, LOG_ERR, \"Short write on %s\", file_name);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nwrite_file(pam_handle_t *pamh, const char *file_name, char *text,\n           size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n    size_t bytes_written = 0;\n\n    fd = open(file_name,\n              O_WRONLY | O_CREAT | O_TRUNC,\n              S_IRUSR | S_IWUSR);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to open [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    if (fchown(fd, owner, group) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to change ownership [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_written = pam_modutil_write(fd, text, text_length);\n    close(fd);\n\n    if (bytes_written < text_length) {\n        pam_syslog(pamh, LOG_ERR, \"Short write on %s\", file_name);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to generate key\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_key",
          "args": [
            "pamh",
            "text",
            "text_length"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "generate_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "82-114",
          "snippet": "static int\ngenerate_key(pam_handle_t *pamh, char **key, size_t key_size)\n{\n    int fd = 0;\n    size_t bytes_read = 0;\n    char * tmp = NULL;\n\n    fd = open(\"/dev/urandom\", O_RDONLY);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(key_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, key_size);\n    close(fd);\n\n    if (bytes_read < key_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *key = tmp;\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\ngenerate_key(pam_handle_t *pamh, char **key, size_t key_size)\n{\n    int fd = 0;\n    size_t bytes_read = 0;\n    char * tmp = NULL;\n\n    fd = open(\"/dev/urandom\", O_RDONLY);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(key_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, key_size);\n    close(fd);\n\n    if (bytes_read < key_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *key = tmp;\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file_name",
            "O_RDONLY | O_NOFOLLOW"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nkey_management(pam_handle_t *pamh, const char *file_name, char **text,\n                size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n\n    fd = open(file_name, O_RDONLY | O_NOFOLLOW);\n    if (fd == -1) {\n        if (errno == ENOENT) {\n            if (generate_key(pamh, text, text_length)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to generate key\");\n                return PAM_AUTH_ERR;\n            }\n\n            if (write_file(pamh, file_name, *text, text_length, owner, group)) {\n                pam_syslog(pamh, LOG_ERR, \"Unable to write key\");\n                return PAM_AUTH_ERR;\n            }\n        } else {\n            pam_syslog(pamh, LOG_ERR, \"Unable to open %s: %m\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    } else {\n        if (read_file(pamh, fd, text, &text_length)) {\n            pam_syslog(pamh, LOG_ERR, \"Error reading key file %s\\n\", file_name);\n            return PAM_AUTH_ERR;\n        }\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "158-193",
    "snippet": "static int\nwrite_file(pam_handle_t *pamh, const char *file_name, char *text,\n           size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n    size_t bytes_written = 0;\n\n    fd = open(file_name,\n              O_WRONLY | O_CREAT | O_TRUNC,\n              S_IRUSR | S_IWUSR);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to open [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    if (fchown(fd, owner, group) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to change ownership [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_written = pam_modutil_write(fd, text, text_length);\n    close(fd);\n\n    if (bytes_written < text_length) {\n        pam_syslog(pamh, LOG_ERR, \"Short write on %s\", file_name);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "text"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Short write on %s\"",
            "file_name"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fd",
            "text",
            "text_length"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "text",
            "0",
            "text_length"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to change ownership [%s]: %m\"",
            "file_name"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "owner",
            "group"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "text",
            "0",
            "text_length"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open [%s]: %m\"",
            "file_name"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file_name",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nwrite_file(pam_handle_t *pamh, const char *file_name, char *text,\n           size_t text_length, uid_t owner, gid_t group)\n{\n    int fd = 0;\n    size_t bytes_written = 0;\n\n    fd = open(file_name,\n              O_WRONLY | O_CREAT | O_TRUNC,\n              S_IRUSR | S_IWUSR);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to open [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    if (fchown(fd, owner, group) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to change ownership [%s]: %m\", file_name);\n        memset(text, 0, text_length);\n        free(text);\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_written = pam_modutil_write(fd, text, text_length);\n    close(fd);\n\n    if (bytes_written < text_length) {\n        pam_syslog(pamh, LOG_ERR, \"Short write on %s\", file_name);\n        free(text);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "116-156",
    "snippet": "static int\nread_file(pam_handle_t *pamh, int fd, char **text, size_t *text_length)\n{\n    struct stat st;\n    size_t bytes_read = 0;\n    char *tmp = NULL;\n\n    if (fstat(fd, &st) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to stat file: %m\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (st.st_size == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Key file size cannot be 0\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(st.st_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, st.st_size);\n    close(fd);\n\n    if (bytes_read < (size_t)st.st_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on key file\");\n        memset(tmp, 0, st.st_size);\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *text = tmp;\n    *text_length = st.st_size;\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "st.st_size"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Short read on key file\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "tmp",
            "st.st_size"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Not enough memory\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Key file size cannot be 0\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to stat file: %m\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nread_file(pam_handle_t *pamh, int fd, char **text, size_t *text_length)\n{\n    struct stat st;\n    size_t bytes_read = 0;\n    char *tmp = NULL;\n\n    if (fstat(fd, &st) == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to stat file: %m\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (st.st_size == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Key file size cannot be 0\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(st.st_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, st.st_size);\n    close(fd);\n\n    if (bytes_read < (size_t)st.st_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on key file\");\n        memset(tmp, 0, st.st_size);\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *text = tmp;\n    *text_length = st.st_size;\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "generate_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "82-114",
    "snippet": "static int\ngenerate_key(pam_handle_t *pamh, char **key, size_t key_size)\n{\n    int fd = 0;\n    size_t bytes_read = 0;\n    char * tmp = NULL;\n\n    fd = open(\"/dev/urandom\", O_RDONLY);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(key_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, key_size);\n    close(fd);\n\n    if (bytes_read < key_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *key = tmp;\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Short read on random device\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "tmp",
            "key_size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Not enough memory\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "key_size"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open /dev/urandom: %m\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\ngenerate_key(pam_handle_t *pamh, char **key, size_t key_size)\n{\n    int fd = 0;\n    size_t bytes_read = 0;\n    char * tmp = NULL;\n\n    fd = open(\"/dev/urandom\", O_RDONLY);\n    if (fd == -1) {\n        pam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n        return PAM_AUTH_ERR;\n    }\n\n    tmp = malloc(key_size);\n    if (!tmp) {\n        pam_syslog(pamh, LOG_CRIT, \"Not enough memory\");\n        close(fd);\n        return PAM_AUTH_ERR;\n    }\n\n    bytes_read = pam_modutil_read(fd, tmp, key_size);\n    close(fd);\n\n    if (bytes_read < key_size) {\n        pam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n        free(tmp);\n        return PAM_AUTH_ERR;\n    }\n\n    *key = tmp;\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "get_crypto_algorithm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
    "lines": "64-80",
    "snippet": "static char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}",
    "includes": [
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <openssl/core_names.h>",
      "#include <openssl/params.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_ALGORITHM   \"SHA512\"",
      "#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"",
      "#define LOGIN_DEFS          \"/etc/login.defs\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Key [%s] not found, falling back to default algorithm [%s]\\n\"",
            "CRYPTO_KEY",
            "DEFAULT_ALGORITHM"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "DEFAULT_ALGORITHM"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "CRYPTO_KEY"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define DEFAULT_ALGORITHM   \"SHA512\"\n#define CRYPTO_KEY          \"HMAC_CRYPTO_ALGO\"\n#define LOGIN_DEFS          \"/etc/login.defs\"\n\nstatic char *\nget_crypto_algorithm(pam_handle_t *pamh, int debug){\n    char *config_value = NULL;\n\n    config_value = pam_modutil_search_key(pamh, LOGIN_DEFS, CRYPTO_KEY);\n\n    if (config_value == NULL) {\n        config_value = strdup(DEFAULT_ALGORITHM);\n        if (debug) {\n            pam_syslog(pamh, LOG_DEBUG,\n                   \"Key [%s] not found, falling back to default algorithm [%s]\\n\",\n                   CRYPTO_KEY, DEFAULT_ALGORITHM);\n        }\n    }\n\n    return config_value;\n}"
  }
]