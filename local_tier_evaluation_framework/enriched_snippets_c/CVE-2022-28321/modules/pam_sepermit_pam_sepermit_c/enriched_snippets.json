[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "456-461",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n\treturn pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "368-447",
          "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n\tint i;\n\tint rv;\n\tint debug = 0;\n\tint sense = PAM_AUTH_ERR;\n\tconst char *user = NULL;\n\tchar *seuser = NULL;\n\tchar *level = NULL;\n\tconst char *cfgfile = NULL;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t} else if ((str = pam_str_skip_prefix(argv[i], \"conf=\")) != NULL) {\n\t\t\tcfgfile = str;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t\t}\n\t}\n\n\tif (cfgfile == NULL) {\n#ifdef SEPERMIT_VENDOR_CONF_FILE\n\t\tstruct stat buffer;\n\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n\t\tif (stat(cfgfile, &buffer) != 0 && errno == ENOENT)\n\t\t\tcfgfile = SEPERMIT_VENDOR_CONF_FILE;\n#else\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n#endif\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Parsing config file: %s\", cfgfile);\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tif (is_selinux_enabled() > 0) {\n\t\tif (security_getenforce() == 1) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Enforcing mode, access will be allowed on match\");\n\t\t\tsense = PAM_SUCCESS;\n\t\t}\n\t}\n\n\tif (getseuserbyname(user, &seuser, &level) != 0) {\n\t\tseuser = NULL;\n\t\tlevel = NULL;\n\t\tpam_syslog(pamh, LOG_ERR, \"getseuserbyname failed: %m\");\n\t}\n\n\tif (debug && sense != PAM_SUCCESS)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Access will not be allowed on match\");\n\n\trv = sepermit_match(pamh, cfgfile, user, seuser, debug, &sense);\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"sepermit_match returned: %d\", rv);\n\n\tfree(seuser);\n\tfree(level);\n\n\tswitch (rv) {\n\t\tcase -1:\n\t\t\treturn PAM_IGNORE;\n\t\tcase 0:\n\t\t\treturn sense;\n\t}\n\n\treturn rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SEPERMIT_CONF_FILE\t(SCONFIGDIR \"/sepermit.conf\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define SEPERMIT_CONF_FILE\t(SCONFIGDIR \"/sepermit.conf\")\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n\tint i;\n\tint rv;\n\tint debug = 0;\n\tint sense = PAM_AUTH_ERR;\n\tconst char *user = NULL;\n\tchar *seuser = NULL;\n\tchar *level = NULL;\n\tconst char *cfgfile = NULL;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t} else if ((str = pam_str_skip_prefix(argv[i], \"conf=\")) != NULL) {\n\t\t\tcfgfile = str;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t\t}\n\t}\n\n\tif (cfgfile == NULL) {\n#ifdef SEPERMIT_VENDOR_CONF_FILE\n\t\tstruct stat buffer;\n\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n\t\tif (stat(cfgfile, &buffer) != 0 && errno == ENOENT)\n\t\t\tcfgfile = SEPERMIT_VENDOR_CONF_FILE;\n#else\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n#endif\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Parsing config file: %s\", cfgfile);\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tif (is_selinux_enabled() > 0) {\n\t\tif (security_getenforce() == 1) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Enforcing mode, access will be allowed on match\");\n\t\t\tsense = PAM_SUCCESS;\n\t\t}\n\t}\n\n\tif (getseuserbyname(user, &seuser, &level) != 0) {\n\t\tseuser = NULL;\n\t\tlevel = NULL;\n\t\tpam_syslog(pamh, LOG_ERR, \"getseuserbyname failed: %m\");\n\t}\n\n\tif (debug && sense != PAM_SUCCESS)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Access will not be allowed on match\");\n\n\trv = sepermit_match(pamh, cfgfile, user, seuser, debug, &sense);\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"sepermit_match returned: %d\", rv);\n\n\tfree(seuser);\n\tfree(level);\n\n\tswitch (rv) {\n\t\tcase -1:\n\t\t\treturn PAM_IGNORE;\n\t\tcase 0:\n\t\t\treturn sense;\n\t}\n\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n\treturn pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "449-454",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n                int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n                int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "368-447",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n\tint i;\n\tint rv;\n\tint debug = 0;\n\tint sense = PAM_AUTH_ERR;\n\tconst char *user = NULL;\n\tchar *seuser = NULL;\n\tchar *level = NULL;\n\tconst char *cfgfile = NULL;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t} else if ((str = pam_str_skip_prefix(argv[i], \"conf=\")) != NULL) {\n\t\t\tcfgfile = str;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t\t}\n\t}\n\n\tif (cfgfile == NULL) {\n#ifdef SEPERMIT_VENDOR_CONF_FILE\n\t\tstruct stat buffer;\n\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n\t\tif (stat(cfgfile, &buffer) != 0 && errno == ENOENT)\n\t\t\tcfgfile = SEPERMIT_VENDOR_CONF_FILE;\n#else\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n#endif\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Parsing config file: %s\", cfgfile);\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tif (is_selinux_enabled() > 0) {\n\t\tif (security_getenforce() == 1) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Enforcing mode, access will be allowed on match\");\n\t\t\tsense = PAM_SUCCESS;\n\t\t}\n\t}\n\n\tif (getseuserbyname(user, &seuser, &level) != 0) {\n\t\tseuser = NULL;\n\t\tlevel = NULL;\n\t\tpam_syslog(pamh, LOG_ERR, \"getseuserbyname failed: %m\");\n\t}\n\n\tif (debug && sense != PAM_SUCCESS)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Access will not be allowed on match\");\n\n\trv = sepermit_match(pamh, cfgfile, user, seuser, debug, &sense);\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"sepermit_match returned: %d\", rv);\n\n\tfree(seuser);\n\tfree(level);\n\n\tswitch (rv) {\n\t\tcase -1:\n\t\t\treturn PAM_IGNORE;\n\t\tcase 0:\n\t\t\treturn sense;\n\t}\n\n\treturn rv;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SEPERMIT_CONF_FILE\t(SCONFIGDIR \"/sepermit.conf\")"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "level"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"sepermit_match returned: %d\"",
            "rv"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sepermit_match",
          "args": [
            "pamh",
            "cfgfile",
            "user",
            "seuser",
            "debug",
            "&sense"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sepermit_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "274-366",
          "snippet": "static int\nsepermit_match(pam_handle_t *pamh, const char *cfgfile, const char *user,\n\t       const char *seuser, int debug, int *sense)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tchar *start;\n\tsize_t len = 0;\n\tint matched = 0;\n\tint exclusive = 0;\n\tint ignore = 0;\n\n\tf = fopen(cfgfile, \"r\");\n\n\tif (!f) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open config file %s: %m\", cfgfile);\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (!matched && getline(&line, &len, f) != -1) {\n\t\tsize_t n;\n\t\tchar *sptr;\n\t\tchar *opt;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\n\t\tstart = line;\n\t\twhile (isspace(*start))\n\t\t\t++start;\n\t\tn = strlen(start);\n\t\twhile (n > 0 && isspace(start[n-1])) {\n\t\t\t--n;\n\t\t}\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tstart[n] = '\\0';\n\t\tstart = strtok_r(start, OPT_DELIM, &sptr);\n\n\t\tswitch (start[0]) {\n\t\t\tcase '@':\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against group %s\", user, start);\n\t\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, user, start)) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tif (seuser == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching seuser %s against seuser %s\", seuser, start);\n\t\t\t\tif (strcmp(seuser, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against user %s\", user, start);\n\t\t\t\tif (strcmp(user, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t}\n\t\tif (matched)\n\t\t\twhile ((opt=strtok_r(NULL, OPT_DELIM, &sptr)) != NULL) {\n\t\t\t\tif (strcmp(opt, \"exclusive\") == 0)\n\t\t\t\t\texclusive = 1;\n\t\t\t\telse if (strcmp(opt, \"ignore\") == 0)\n\t\t\t\t\tignore = 1;\n\t\t\t\telse if (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Unknown user option: %s\", opt);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\tif (matched) {\n\t\tif (*sense == PAM_SUCCESS) {\n\t\t\tif (ignore)\n\t\t\t\t*sense = PAM_IGNORE;\n\t\t\tif (geteuid() == 0 && exclusive && get_loginuid(pamh) == (uid_t)-1)\n\t\t\t\tif (sepermit_lock(pamh, user, debug) < 0)\n\t\t\t\t\t*sense = PAM_AUTH_ERR;\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define OPT_DELIM \":\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define OPT_DELIM \":\"\n\nstatic int\nsepermit_match(pam_handle_t *pamh, const char *cfgfile, const char *user,\n\t       const char *seuser, int debug, int *sense)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tchar *start;\n\tsize_t len = 0;\n\tint matched = 0;\n\tint exclusive = 0;\n\tint ignore = 0;\n\n\tf = fopen(cfgfile, \"r\");\n\n\tif (!f) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open config file %s: %m\", cfgfile);\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (!matched && getline(&line, &len, f) != -1) {\n\t\tsize_t n;\n\t\tchar *sptr;\n\t\tchar *opt;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\n\t\tstart = line;\n\t\twhile (isspace(*start))\n\t\t\t++start;\n\t\tn = strlen(start);\n\t\twhile (n > 0 && isspace(start[n-1])) {\n\t\t\t--n;\n\t\t}\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tstart[n] = '\\0';\n\t\tstart = strtok_r(start, OPT_DELIM, &sptr);\n\n\t\tswitch (start[0]) {\n\t\t\tcase '@':\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against group %s\", user, start);\n\t\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, user, start)) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tif (seuser == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching seuser %s against seuser %s\", seuser, start);\n\t\t\t\tif (strcmp(seuser, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against user %s\", user, start);\n\t\t\t\tif (strcmp(user, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t}\n\t\tif (matched)\n\t\t\twhile ((opt=strtok_r(NULL, OPT_DELIM, &sptr)) != NULL) {\n\t\t\t\tif (strcmp(opt, \"exclusive\") == 0)\n\t\t\t\t\texclusive = 1;\n\t\t\t\telse if (strcmp(opt, \"ignore\") == 0)\n\t\t\t\t\tignore = 1;\n\t\t\t\telse if (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Unknown user option: %s\", opt);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\tif (matched) {\n\t\tif (*sense == PAM_SUCCESS) {\n\t\t\tif (ignore)\n\t\t\t\t*sense = PAM_IGNORE;\n\t\t\tif (geteuid() == 0 && exclusive && get_loginuid(pamh) == (uid_t)-1)\n\t\t\t\tif (sepermit_lock(pamh, user, debug) < 0)\n\t\t\t\t\t*sense = PAM_AUTH_ERR;\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Access will not be allowed on match\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"getseuserbyname failed: %m\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getseuserbyname",
          "args": [
            "user",
            "&seuser",
            "&level"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Enforcing mode, access will be allowed on match\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Parsing config file: %s\"",
            "cfgfile"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfgfile",
            "&buffer"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "argv[i]"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"conf=\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define SEPERMIT_CONF_FILE\t(SCONFIGDIR \"/sepermit.conf\")\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n\tint i;\n\tint rv;\n\tint debug = 0;\n\tint sense = PAM_AUTH_ERR;\n\tconst char *user = NULL;\n\tchar *seuser = NULL;\n\tchar *level = NULL;\n\tconst char *cfgfile = NULL;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t} else if ((str = pam_str_skip_prefix(argv[i], \"conf=\")) != NULL) {\n\t\t\tcfgfile = str;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t\t}\n\t}\n\n\tif (cfgfile == NULL) {\n#ifdef SEPERMIT_VENDOR_CONF_FILE\n\t\tstruct stat buffer;\n\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n\t\tif (stat(cfgfile, &buffer) != 0 && errno == ENOENT)\n\t\t\tcfgfile = SEPERMIT_VENDOR_CONF_FILE;\n#else\n\t\tcfgfile = SEPERMIT_CONF_FILE;\n#endif\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Parsing config file: %s\", cfgfile);\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\tif (is_selinux_enabled() > 0) {\n\t\tif (security_getenforce() == 1) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Enforcing mode, access will be allowed on match\");\n\t\t\tsense = PAM_SUCCESS;\n\t\t}\n\t}\n\n\tif (getseuserbyname(user, &seuser, &level) != 0) {\n\t\tseuser = NULL;\n\t\tlevel = NULL;\n\t\tpam_syslog(pamh, LOG_ERR, \"getseuserbyname failed: %m\");\n\t}\n\n\tif (debug && sense != PAM_SUCCESS)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Access will not be allowed on match\");\n\n\trv = sepermit_match(pamh, cfgfile, user, seuser, debug, &sense);\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_NOTICE, \"sepermit_match returned: %d\", rv);\n\n\tfree(seuser);\n\tfree(level);\n\n\tswitch (rv) {\n\t\tcase -1:\n\t\t\treturn PAM_IGNORE;\n\t\tcase 0:\n\t\t\treturn sense;\n\t}\n\n\treturn rv;\n}"
  },
  {
    "function_name": "sepermit_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "274-366",
    "snippet": "static int\nsepermit_match(pam_handle_t *pamh, const char *cfgfile, const char *user,\n\t       const char *seuser, int debug, int *sense)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tchar *start;\n\tsize_t len = 0;\n\tint matched = 0;\n\tint exclusive = 0;\n\tint ignore = 0;\n\n\tf = fopen(cfgfile, \"r\");\n\n\tif (!f) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open config file %s: %m\", cfgfile);\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (!matched && getline(&line, &len, f) != -1) {\n\t\tsize_t n;\n\t\tchar *sptr;\n\t\tchar *opt;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\n\t\tstart = line;\n\t\twhile (isspace(*start))\n\t\t\t++start;\n\t\tn = strlen(start);\n\t\twhile (n > 0 && isspace(start[n-1])) {\n\t\t\t--n;\n\t\t}\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tstart[n] = '\\0';\n\t\tstart = strtok_r(start, OPT_DELIM, &sptr);\n\n\t\tswitch (start[0]) {\n\t\t\tcase '@':\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against group %s\", user, start);\n\t\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, user, start)) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tif (seuser == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching seuser %s against seuser %s\", seuser, start);\n\t\t\t\tif (strcmp(seuser, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against user %s\", user, start);\n\t\t\t\tif (strcmp(user, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t}\n\t\tif (matched)\n\t\t\twhile ((opt=strtok_r(NULL, OPT_DELIM, &sptr)) != NULL) {\n\t\t\t\tif (strcmp(opt, \"exclusive\") == 0)\n\t\t\t\t\texclusive = 1;\n\t\t\t\telse if (strcmp(opt, \"ignore\") == 0)\n\t\t\t\t\tignore = 1;\n\t\t\t\telse if (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Unknown user option: %s\", opt);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\tif (matched) {\n\t\tif (*sense == PAM_SUCCESS) {\n\t\t\tif (ignore)\n\t\t\t\t*sense = PAM_IGNORE;\n\t\t\tif (geteuid() == 0 && exclusive && get_loginuid(pamh) == (uid_t)-1)\n\t\t\t\tif (sepermit_lock(pamh, user, debug) < 0)\n\t\t\t\t\t*sense = PAM_AUTH_ERR;\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define OPT_DELIM \":\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sepermit_lock",
          "args": [
            "pamh",
            "user",
            "debug"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "sepermit_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "224-271",
          "snippet": "static int\nsepermit_lock(pam_handle_t *pamh, const char *user, int debug)\n{\n\tchar buf[PATH_MAX];\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tstruct passwd *pw = pam_modutil_getpwnam( pamh, user );\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to find uid for user %s\",\n\t\t\t   user);\n\t\treturn -1;\n\t}\n\tif (check_running(pamh, pw->pw_uid, 0, debug) > 0)  {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s processes are running. Exclusive login not allowed\", user);\n\t\treturn -1;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\tint fd = open(buf, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unable to open lock file %s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\t\treturn -1;\n\t}\n\n\t/* Need to close on exec */\n\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\tif (fcntl(fd, F_SETLK, &fl) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s with exclusive login already logged in\", user);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tstruct lockfd *lockfd=calloc(1, sizeof(struct lockfd));\n\tif (!lockfd) {\n\t\tclose(fd);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tlockfd->uid = pw->pw_uid;\n\tlockfd->debug = debug;\n\tlockfd->fd=fd;\n        pam_set_data(pamh, MODULE, lockfd, sepermit_unlock);\n\treturn 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MODULE \"pam_sepermit\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define MODULE \"pam_sepermit\"\n\nstatic int\nsepermit_lock(pam_handle_t *pamh, const char *user, int debug)\n{\n\tchar buf[PATH_MAX];\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tstruct passwd *pw = pam_modutil_getpwnam( pamh, user );\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to find uid for user %s\",\n\t\t\t   user);\n\t\treturn -1;\n\t}\n\tif (check_running(pamh, pw->pw_uid, 0, debug) > 0)  {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s processes are running. Exclusive login not allowed\", user);\n\t\treturn -1;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\tint fd = open(buf, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unable to open lock file %s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\t\treturn -1;\n\t}\n\n\t/* Need to close on exec */\n\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\tif (fcntl(fd, F_SETLK, &fl) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s with exclusive login already logged in\", user);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tstruct lockfd *lockfd=calloc(1, sizeof(struct lockfd));\n\tif (!lockfd) {\n\t\tclose(fd);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tlockfd->uid = pw->pw_uid;\n\tlockfd->debug = debug;\n\tlockfd->fd=fd;\n        pam_set_data(pamh, MODULE, lockfd, sepermit_unlock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loginuid",
          "args": [
            "pamh"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "get_loginuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "170-198",
          "snippet": "static uid_t get_loginuid(pam_handle_t *pamh)\n{\n\tint fd, count;\n\tchar loginuid[24];\n\tchar *eptr;\n\tuid_t rv = (uid_t)-1;\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"Cannot open /proc/self/loginuid: %m\");\n\t\t}\n\t\treturn rv;\n\t}\n\tif ((count = pam_modutil_read(fd, loginuid, sizeof(loginuid)-1)) < 1) {\n\t\tclose(fd);\n\t\treturn rv;\n\t}\n\tloginuid[count] = '\\0';\n\tclose(fd);\n\n\terrno = 0;\n\trv = strtoul(loginuid, &eptr, 10);\n\tif (errno != 0 || eptr == loginuid)\n\t\trv = (uid_t) -1;\n\n\treturn rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic uid_t get_loginuid(pam_handle_t *pamh)\n{\n\tint fd, count;\n\tchar loginuid[24];\n\tchar *eptr;\n\tuid_t rv = (uid_t)-1;\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"Cannot open /proc/self/loginuid: %m\");\n\t\t}\n\t\treturn rv;\n\t}\n\tif ((count = pam_modutil_read(fd, loginuid, sizeof(loginuid)-1)) < 1) {\n\t\tclose(fd);\n\t\treturn rv;\n\t}\n\tloginuid[count] = '\\0';\n\tclose(fd);\n\n\terrno = 0;\n\trv = strtoul(loginuid, &eptr, 10);\n\tif (errno != 0 || eptr == loginuid)\n\t\trv = (uid_t) -1;\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Unknown user option: %s\"",
            "opt"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opt",
            "\"ignore\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opt",
            "\"exclusive\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "OPT_DELIM",
            "&sptr"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "start"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Matching user %s against user %s\"",
            "user",
            "start"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "seuser",
            "start"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Matching seuser %s against seuser %s\"",
            "seuser",
            "start"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "user",
            "start"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Matching user %s against group %s\"",
            "user",
            "start"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "start",
            "OPT_DELIM",
            "&sptr"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "start[n-1]"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*start"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Failed to open config file %s: %m\"",
            "cfgfile"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "cfgfile",
            "\"r\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define OPT_DELIM \":\"\n\nstatic int\nsepermit_match(pam_handle_t *pamh, const char *cfgfile, const char *user,\n\t       const char *seuser, int debug, int *sense)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tchar *start;\n\tsize_t len = 0;\n\tint matched = 0;\n\tint exclusive = 0;\n\tint ignore = 0;\n\n\tf = fopen(cfgfile, \"r\");\n\n\tif (!f) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open config file %s: %m\", cfgfile);\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (!matched && getline(&line, &len, f) != -1) {\n\t\tsize_t n;\n\t\tchar *sptr;\n\t\tchar *opt;\n\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\n\t\tstart = line;\n\t\twhile (isspace(*start))\n\t\t\t++start;\n\t\tn = strlen(start);\n\t\twhile (n > 0 && isspace(start[n-1])) {\n\t\t\t--n;\n\t\t}\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tstart[n] = '\\0';\n\t\tstart = strtok_r(start, OPT_DELIM, &sptr);\n\n\t\tswitch (start[0]) {\n\t\t\tcase '@':\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against group %s\", user, start);\n\t\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, user, start)) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tif (seuser == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t++start;\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching seuser %s against seuser %s\", seuser, start);\n\t\t\t\tif (strcmp(seuser, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (debug)\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Matching user %s against user %s\", user, start);\n\t\t\t\tif (strcmp(user, start) == 0) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t}\n\t\t}\n\t\tif (matched)\n\t\t\twhile ((opt=strtok_r(NULL, OPT_DELIM, &sptr)) != NULL) {\n\t\t\t\tif (strcmp(opt, \"exclusive\") == 0)\n\t\t\t\t\texclusive = 1;\n\t\t\t\telse if (strcmp(opt, \"ignore\") == 0)\n\t\t\t\t\tignore = 1;\n\t\t\t\telse if (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Unknown user option: %s\", opt);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\tif (matched) {\n\t\tif (*sense == PAM_SUCCESS) {\n\t\t\tif (ignore)\n\t\t\t\t*sense = PAM_IGNORE;\n\t\t\tif (geteuid() == 0 && exclusive && get_loginuid(pamh) == (uid_t)-1)\n\t\t\t\tif (sepermit_lock(pamh, user, debug) < 0)\n\t\t\t\t\t*sense = PAM_AUTH_ERR;\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "sepermit_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "224-271",
    "snippet": "static int\nsepermit_lock(pam_handle_t *pamh, const char *user, int debug)\n{\n\tchar buf[PATH_MAX];\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tstruct passwd *pw = pam_modutil_getpwnam( pamh, user );\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to find uid for user %s\",\n\t\t\t   user);\n\t\treturn -1;\n\t}\n\tif (check_running(pamh, pw->pw_uid, 0, debug) > 0)  {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s processes are running. Exclusive login not allowed\", user);\n\t\treturn -1;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\tint fd = open(buf, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unable to open lock file %s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\t\treturn -1;\n\t}\n\n\t/* Need to close on exec */\n\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\tif (fcntl(fd, F_SETLK, &fl) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s with exclusive login already logged in\", user);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tstruct lockfd *lockfd=calloc(1, sizeof(struct lockfd));\n\tif (!lockfd) {\n\t\tclose(fd);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tlockfd->uid = pw->pw_uid;\n\tlockfd->debug = debug;\n\tlockfd->fd=fd;\n        pam_set_data(pamh, MODULE, lockfd, sepermit_unlock);\n\treturn 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MODULE \"pam_sepermit\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "MODULE",
            "lockfd",
            "sepermit_unlock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct lockfd)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"User %s with exclusive login already logged in\"",
            "user"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETLK",
            "&fl"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open lock file %s/%d.lock\"",
            "SEPERMIT_LOCKDIR",
            "pw->pw_uid"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "buf",
            "O_RDWR | O_CREAT",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s/%d.lock\"",
            "SEPERMIT_LOCKDIR",
            "pw->pw_uid"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"User %s processes are running. Exclusive login not allowed\"",
            "user"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_running",
          "args": [
            "pamh",
            "pw->pw_uid",
            "0",
            "debug"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "check_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "104-164",
          "snippet": "static int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PROC_BASE \"/proc\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PROC_BASE \"/proc\"\n\nstatic int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Unable to find uid for user %s\"",
            "user"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fl",
            "0",
            "sizeof(fl)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define MODULE \"pam_sepermit\"\n\nstatic int\nsepermit_lock(pam_handle_t *pamh, const char *user, int debug)\n{\n\tchar buf[PATH_MAX];\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tstruct passwd *pw = pam_modutil_getpwnam( pamh, user );\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to find uid for user %s\",\n\t\t\t   user);\n\t\treturn -1;\n\t}\n\tif (check_running(pamh, pw->pw_uid, 0, debug) > 0)  {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s processes are running. Exclusive login not allowed\", user);\n\t\treturn -1;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\tint fd = open(buf, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unable to open lock file %s/%d.lock\", SEPERMIT_LOCKDIR, pw->pw_uid);\n\t\treturn -1;\n\t}\n\n\t/* Need to close on exec */\n\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\tif (fcntl(fd, F_SETLK, &fl) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"User %s with exclusive login already logged in\", user);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tstruct lockfd *lockfd=calloc(1, sizeof(struct lockfd));\n\tif (!lockfd) {\n\t\tclose(fd);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tlockfd->uid = pw->pw_uid;\n\tlockfd->debug = debug;\n\tlockfd->fd=fd;\n        pam_set_data(pamh, MODULE, lockfd, sepermit_unlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "sepermit_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "200-222",
    "snippet": "static void\nsepermit_unlock(pam_handle_t *pamh, void *plockfd, int error_status UNUSED)\n{\n\tstruct lockfd *lockfd = plockfd;\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_UNLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tif (lockfd->debug)\n\t\tpam_syslog(pamh, LOG_ERR, \"Unlocking fd: %d uid: %d\", lockfd->fd, lockfd->uid);\n\n\t/* Don't kill uid==0 */\n\tif (lockfd->uid)\n\t\t/* This is a DOS but it prevents an app from forking to prevent killing */\n\t\twhile(check_running(pamh, lockfd->uid, 1, lockfd->debug) > 0)\n\t\t\tcontinue;\n\n\t(void)fcntl(lockfd->fd, F_SETLK, &fl);\n\t(void)close(lockfd->fd);\n\tfree(lockfd);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lockfd"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lockfd->fd"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "lockfd->fd",
            "F_SETLK",
            "&fl"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_running",
          "args": [
            "pamh",
            "lockfd->uid",
            "1",
            "lockfd->debug"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "check_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "104-164",
          "snippet": "static int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PROC_BASE \"/proc\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PROC_BASE \"/proc\"\n\nstatic int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unlocking fd: %d uid: %d\"",
            "lockfd->fd",
            "lockfd->uid"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fl",
            "0",
            "sizeof(fl)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nsepermit_unlock(pam_handle_t *pamh, void *plockfd, int error_status UNUSED)\n{\n\tstruct lockfd *lockfd = plockfd;\n\tstruct flock fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.l_type = F_UNLCK;\n\tfl.l_whence = SEEK_SET;\n\n\tif (lockfd->debug)\n\t\tpam_syslog(pamh, LOG_ERR, \"Unlocking fd: %d uid: %d\", lockfd->fd, lockfd->uid);\n\n\t/* Don't kill uid==0 */\n\tif (lockfd->uid)\n\t\t/* This is a DOS but it prevents an app from forking to prevent killing */\n\t\twhile(check_running(pamh, lockfd->uid, 1, lockfd->debug) > 0)\n\t\t\tcontinue;\n\n\t(void)fcntl(lockfd->fd, F_SETLK, &fl);\n\t(void)close(lockfd->fd);\n\tfree(lockfd);\n}"
  },
  {
    "function_name": "get_loginuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "170-198",
    "snippet": "static uid_t get_loginuid(pam_handle_t *pamh)\n{\n\tint fd, count;\n\tchar loginuid[24];\n\tchar *eptr;\n\tuid_t rv = (uid_t)-1;\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"Cannot open /proc/self/loginuid: %m\");\n\t\t}\n\t\treturn rv;\n\t}\n\tif ((count = pam_modutil_read(fd, loginuid, sizeof(loginuid)-1)) < 1) {\n\t\tclose(fd);\n\t\treturn rv;\n\t}\n\tloginuid[count] = '\\0';\n\tclose(fd);\n\n\terrno = 0;\n\trv = strtoul(loginuid, &eptr, 10);\n\tif (errno != 0 || eptr == loginuid)\n\t\trv = (uid_t) -1;\n\n\treturn rv;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "loginuid",
            "&eptr",
            "10"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "loginuid",
            "sizeof(loginuid)-1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open /proc/self/loginuid: %m\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc/self/loginuid\"",
            "O_NOFOLLOW|O_RDONLY"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic uid_t get_loginuid(pam_handle_t *pamh)\n{\n\tint fd, count;\n\tchar loginuid[24];\n\tchar *eptr;\n\tuid_t rv = (uid_t)-1;\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"Cannot open /proc/self/loginuid: %m\");\n\t\t}\n\t\treturn rv;\n\t}\n\tif ((count = pam_modutil_read(fd, loginuid, sizeof(loginuid)-1)) < 1) {\n\t\tclose(fd);\n\t\treturn rv;\n\t}\n\tloginuid[count] = '\\0';\n\tclose(fd);\n\n\terrno = 0;\n\trv = strtoul(loginuid, &eptr, 10);\n\tif (errno != 0 || eptr == loginuid)\n\t\trv = (uid_t) -1;\n\n\treturn rv;\n}"
  },
  {
    "function_name": "check_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "104-164",
    "snippet": "static int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PROC_BASE \"/proc\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pid_table"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "id",
            "SIGKILL"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "kill_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "154-201",
          "snippet": "static int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */"
          ],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\n\nstatic int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Attempting to kill %d\"",
            "id"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_process_uid",
          "args": [
            "pid_table[i]",
            "uid"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "match_process_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
          "lines": "82-102",
          "snippet": "static int\nmatch_process_uid(pid_t pid, uid_t uid)\n{\n\tchar buf[128];\n\tuid_t puid;\n\tFILE *f;\n\tint re = 0;\n\n\tsnprintf (buf, sizeof buf, PROC_BASE \"/%d/status\", pid);\n\tif (!(f = fopen (buf, \"r\")))\n\t\treturn 0;\n\n\twhile (fgets(buf, sizeof buf, f)) {\n\t\tif (sscanf (buf, \"Uid:\\t%d\", &puid)) {\n\t\t\tre = uid == puid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n\treturn re;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PROC_BASE \"/proc\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PROC_BASE \"/proc\"\n\nstatic int\nmatch_process_uid(pid_t pid, uid_t uid)\n{\n\tchar buf[128];\n\tuid_t puid;\n\tFILE *f;\n\tint re = 0;\n\n\tsnprintf (buf, sizeof buf, PROC_BASE \"/%d/status\", pid);\n\tif (!(f = fopen (buf, \"r\")))\n\t\treturn 0;\n\n\twhile (fgets(buf, sizeof buf, f)) {\n\t\tif (sscanf (buf, \"Uid:\\t%d\", &puid)) {\n\t\t\tre = uid == puid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n\treturn re;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "pid_table",
            "2*pids*sizeof(pid_t)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "de->d_name"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "max_pids * sizeof (pid_t)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Failed to open proc directory file %s:\"",
            "PROC_BASE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "PROC_BASE"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PROC_BASE \"/proc\"\n\nstatic int\ncheck_running (pam_handle_t *pamh, uid_t uid, int killall, int debug)\n{\n\tDIR *dir;\n\tstruct dirent *de;\n\tpid_t *pid_table, pid, self;\n\tint i;\n\tint pids, max_pids;\n\tint running = 0;\n\tself = getpid();\n\tif (!(dir = opendir(PROC_BASE))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Failed to open proc directory file %s:\", PROC_BASE);\n\t\treturn -1;\n\t}\n\tmax_pids = 256;\n\tpid_table = malloc(max_pids * sizeof (pid_t));\n\tif (!pid_table) {\n\t\t(void)closedir(dir);\n\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\treturn -1;\n\t}\n\tpids = 0;\n\twhile ((de = readdir (dir)) != NULL) {\n\t\tif (!(pid = (pid_t)atoi(de->d_name)) || pid == self)\n\t\t\tcontinue;\n\n\t\tif (pids == max_pids) {\n\t\t\tpid_t *npt;\n\n\t\t\tif (!(npt = realloc(pid_table, 2*pids*sizeof(pid_t)))) {\n\t\t\t\tfree(pid_table);\n\t\t\t\t(void)closedir(dir);\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid_table = npt;\n\t\t\tmax_pids *= 2;\n\t\t}\n\t\tpid_table[pids++] = pid;\n\t}\n\n\t(void)closedir(dir);\n\n\tfor (i = 0; i < pids; i++) {\n\t\tpid_t id;\n\n\t\tif (match_process_uid(pid_table[i], uid) == 0)\n\t\t\tcontinue;\n\t\tid = pid_table[i];\n\n\t\tif (killall) {\n\t\t\tif (debug)\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"Attempting to kill %d\", id);\n\t\t\tkill(id, SIGKILL);\n\t\t}\n\t\trunning++;\n\t}\n\n\tfree(pid_table);\n\treturn running;\n}"
  },
  {
    "function_name": "match_process_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_sepermit/pam_sepermit.c",
    "lines": "82-102",
    "snippet": "static int\nmatch_process_uid(pid_t pid, uid_t uid)\n{\n\tchar buf[128];\n\tuid_t puid;\n\tFILE *f;\n\tint re = 0;\n\n\tsnprintf (buf, sizeof buf, PROC_BASE \"/%d/status\", pid);\n\tif (!(f = fopen (buf, \"r\")))\n\t\treturn 0;\n\n\twhile (fgets(buf, sizeof buf, f)) {\n\t\tif (sscanf (buf, \"Uid:\\t%d\", &puid)) {\n\t\t\tre = uid == puid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n\treturn re;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <limits.h>",
      "#include <signal.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PROC_BASE \"/proc\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"Uid:\\t%d\"",
            "&puid"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof buf",
            "f"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "buf",
            "\"r\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "PROC_BASE \"/%d/status\"",
            "pid"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <limits.h>\n#include <signal.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define PROC_BASE \"/proc\"\n\nstatic int\nmatch_process_uid(pid_t pid, uid_t uid)\n{\n\tchar buf[128];\n\tuid_t puid;\n\tFILE *f;\n\tint re = 0;\n\n\tsnprintf (buf, sizeof buf, PROC_BASE \"/%d/status\", pid);\n\tif (!(f = fopen (buf, \"r\")))\n\t\treturn 0;\n\n\twhile (fgets(buf, sizeof buf, f)) {\n\t\tif (sscanf (buf, \"Uid:\\t%d\", &puid)) {\n\t\t\tre = uid == puid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n\treturn re;\n}"
  }
]