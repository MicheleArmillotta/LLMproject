[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
    "lines": "102-106",
    "snippet": "int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n    return perform_check(pamh);\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
          "lines": "28-84",
          "snippet": "static int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_SHELL \"/bin/sh\"",
            "#define SHELL_FILE \"/etc/shells\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n#define SHELL_FILE \"/etc/shells\"\n\nstatic int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\nint pam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n    return perform_check(pamh);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
    "lines": "94-98",
    "snippet": "int pam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t   int argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\nint pam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t   int argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
    "lines": "88-92",
    "snippet": "int pam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t        int argc UNUSED, const char **argv UNUSED)\n{\n    return perform_check(pamh);\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
          "lines": "28-84",
          "snippet": "static int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_SHELL \"/bin/sh\"",
            "#define SHELL_FILE \"/etc/shells\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n#define SHELL_FILE \"/etc/shells\"\n\nstatic int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\nint pam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t        int argc UNUSED, const char **argv UNUSED)\n{\n    return perform_check(pamh);\n}"
  },
  {
    "function_name": "perform_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_shells/pam_shells.c",
    "lines": "28-84",
    "snippet": "static int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_SHELL \"/bin/sh\"",
      "#define SHELL_FILE \"/etc/shells\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "shellFile"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "shellFileLine",
            "userShell"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "shellFileLine"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "shellFileLine"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "shellFileLine",
            "255",
            "shellFile"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error opening %s: %m\"",
            "SHELL_FILE"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "SHELL_FILE",
            "\"r\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s is either world writable or not a normal file\"",
            "SHELL_FILE"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot stat %s: %m\"",
            "SHELL_FILE"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "SHELL_FILE",
            "&sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "userName"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&userName",
            "NULL"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include \"config.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n#define SHELL_FILE \"/etc/shells\"\n\nstatic int perform_check(pam_handle_t *pamh)\n{\n    int retval = PAM_AUTH_ERR;\n    const char *userName;\n    const char *userShell;\n    char shellFileLine[256];\n    struct stat sb;\n    struct passwd * pw;\n    FILE * shellFile;\n\n    retval = pam_get_user(pamh, &userName, NULL);\n    if (retval != PAM_SUCCESS) {\n\treturn PAM_SERVICE_ERR;\n    }\n\n    pw = pam_modutil_getpwnam(pamh, userName);\n    if (pw == NULL || pw->pw_shell == NULL) {\n\treturn PAM_AUTH_ERR;\t\t/* user doesn't exist */\n    }\n    userShell = pw->pw_shell;\n    if (userShell[0] == '\\0')\n\tuserShell = DEFAULT_SHELL;\n\n    if (stat(SHELL_FILE,&sb)) {\n\tpam_syslog(pamh, LOG_ERR, \"Cannot stat %s: %m\", SHELL_FILE);\n\treturn PAM_AUTH_ERR;\t\t/* must have /etc/shells */\n    }\n\n    if ((sb.st_mode & S_IWOTH) || !S_ISREG(sb.st_mode)) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"%s is either world writable or not a normal file\",\n\t\t   SHELL_FILE);\n\treturn PAM_AUTH_ERR;\n    }\n\n    shellFile = fopen(SHELL_FILE,\"r\");\n    if (shellFile == NULL) {       /* Check that we opened it successfully */\n\tpam_syslog(pamh, LOG_ERR, \"Error opening %s: %m\", SHELL_FILE);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    retval = 1;\n\n    while(retval && (fgets(shellFileLine, 255, shellFile) != NULL)) {\n\tif (shellFileLine[strlen(shellFileLine) - 1] == '\\n')\n\t    shellFileLine[strlen(shellFileLine) - 1] = '\\0';\n\tretval = strcmp(shellFileLine, userShell);\n    }\n\n    fclose(shellFile);\n\n    if (retval) {\n\treturn PAM_AUTH_ERR;\n    } else {\n\treturn PAM_SUCCESS;\n    }\n}"
  }
]