[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pwhistory_helper.c",
    "lines": "90-121",
    "snippet": "int\nmain(int argc, char *argv[])\n{\n  const char *option;\n  const char *user;\n  const char *filename;\n\n  /*\n   * we establish that this program is running with non-tty stdin.\n   * this is to discourage casual use.\n   */\n\n  if (isatty(STDIN_FILENO) || argc < 5)\n    {\n      fprintf(stderr,\n            \"This binary is not designed for running in this way.\\n\");\n      return PAM_SYSTEM_ERR;\n    }\n\n  option = argv[1];\n  user = argv[2];\n  filename = argv[3];\n\n  if (strcmp(option, \"check\") == 0 && argc == 5)\n    return check_history(user, filename, argv[4]);\n  else if (strcmp(option, \"save\") == 0 && argc == 6)\n    return save_history(user, filename, argv[4], argv[5]);\n\n  fprintf(stderr, \"This binary is not designed for running in this way.\\n\");\n\n  return PAM_SYSTEM_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/_pam_types.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This binary is not designed for running in this way.\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_history",
          "args": [
            "user",
            "filename",
            "argv[4]",
            "argv[5]"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "save_history",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pwhistory_helper.c",
          "lines": "78-88",
          "snippet": "static int\nsave_history(const char *user, const char *filename, const char *howmany, const char *debug)\n{\n  int num = atoi(howmany);\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  retval = save_old_pass(user, num, filename, dbg);\n\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"opasswd.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nsave_history(const char *user, const char *filename, const char *howmany, const char *debug)\n{\n  int num = atoi(howmany);\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  retval = save_old_pass(user, num, filename, dbg);\n\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option",
            "\"save\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_history",
          "args": [
            "user",
            "filename",
            "argv[4]"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "check_history",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pwhistory_helper.c",
          "lines": "53-76",
          "snippet": "static int\ncheck_history(const char *user, const char *filename, const char *debug)\n{\n  char pass[PAM_MAX_RESP_SIZE + 1];\n  char *passwords[] = { pass };\n  int npass;\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  /* read the password from stdin (a pipe from the pam_pwhistory module) */\n  npass = pam_read_passwords(STDIN_FILENO, 1, passwords);\n\n  if (npass != 1)\n    { /* is it a valid password? */\n      helper_log_err(LOG_DEBUG, \"no password supplied\");\n      return PAM_AUTHTOK_ERR;\n    }\n\n  retval = check_old_pass(user, pass, filename, dbg);\n\n  memset(pass, '\\0', PAM_MAX_RESP_SIZE);\t/* clear memory of the password */\n\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"opasswd.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ncheck_history(const char *user, const char *filename, const char *debug)\n{\n  char pass[PAM_MAX_RESP_SIZE + 1];\n  char *passwords[] = { pass };\n  int npass;\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  /* read the password from stdin (a pipe from the pam_pwhistory module) */\n  npass = pam_read_passwords(STDIN_FILENO, 1, passwords);\n\n  if (npass != 1)\n    { /* is it a valid password? */\n      helper_log_err(LOG_DEBUG, \"no password supplied\");\n      return PAM_AUTHTOK_ERR;\n    }\n\n  retval = check_old_pass(user, pass, filename, dbg);\n\n  memset(pass, '\\0', PAM_MAX_RESP_SIZE);\t/* clear memory of the password */\n\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option",
            "\"check\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This binary is not designed for running in this way.\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\nmain(int argc, char *argv[])\n{\n  const char *option;\n  const char *user;\n  const char *filename;\n\n  /*\n   * we establish that this program is running with non-tty stdin.\n   * this is to discourage casual use.\n   */\n\n  if (isatty(STDIN_FILENO) || argc < 5)\n    {\n      fprintf(stderr,\n            \"This binary is not designed for running in this way.\\n\");\n      return PAM_SYSTEM_ERR;\n    }\n\n  option = argv[1];\n  user = argv[2];\n  filename = argv[3];\n\n  if (strcmp(option, \"check\") == 0 && argc == 5)\n    return check_history(user, filename, argv[4]);\n  else if (strcmp(option, \"save\") == 0 && argc == 6)\n    return save_history(user, filename, argv[4], argv[5]);\n\n  fprintf(stderr, \"This binary is not designed for running in this way.\\n\");\n\n  return PAM_SYSTEM_ERR;\n}"
  },
  {
    "function_name": "save_history",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pwhistory_helper.c",
    "lines": "78-88",
    "snippet": "static int\nsave_history(const char *user, const char *filename, const char *howmany, const char *debug)\n{\n  int num = atoi(howmany);\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  retval = save_old_pass(user, num, filename, dbg);\n\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/_pam_types.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_old_pass",
          "args": [
            "user",
            "num",
            "filename",
            "dbg"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "save_old_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "619-796",
          "snippet": "int\nsave_old_password(pam_handle_t *pamh, const char *forwho, const char *oldpass,\n\t\t  int howmany)\n#endif\n{\n    static char buf[16384];\n    static char nbuf[16384];\n    char *s_luser, *s_uid, *s_npas, *s_pas, *pass;\n    int npas;\n    FILE *pwfile, *opwfile;\n    int err = 0;\n    int oldmask;\n    int found = 0;\n    struct passwd *pwd = NULL;\n    struct stat st;\n    size_t len = strlen(forwho);\n#ifdef WITH_SELINUX\n    char *prev_context_raw = NULL;\n#endif\n\n    if (howmany < 0) {\n\treturn PAM_SUCCESS;\n    }\n\n    if (oldpass == NULL) {\n\treturn PAM_SUCCESS;\n    }\n\n    oldmask = umask(077);\n\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      char *passwd_context_raw = NULL;\n      if (getfilecon_raw(\"/etc/passwd\",&passwd_context_raw)<0) {\n        return PAM_AUTHTOK_ERR;\n      };\n      if (getfscreatecon_raw(&prev_context_raw)<0) {\n        freecon(passwd_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      if (setfscreatecon_raw(passwd_context_raw)) {\n        freecon(passwd_context_raw);\n        freecon(prev_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      freecon(passwd_context_raw);\n    }\n#endif\n    pwfile = fopen(OPW_TMPFILE, \"w\");\n    umask(oldmask);\n    if (pwfile == NULL) {\n      err = 1;\n      goto done;\n    }\n\n    opwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n    if (opwfile == NULL) {\n\tfclose(pwfile);\n      err = 1;\n      goto done;\n    }\n\n    if (fstat(fileno(opwfile), &st) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    if (fchown(fileno(pwfile), st.st_uid, st.st_gid) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n    if (fchmod(fileno(pwfile), st.st_mode) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    while (fgets(buf, 16380, opwfile)) {\n\tif (!strncmp(buf, forwho, len) && strchr(\":,\\n\", buf[len]) != NULL) {\n\t    char *sptr = NULL;\n\t    found = 1;\n\t    if (howmany == 0)\n\t\tcontinue;\n\t    buf[strlen(buf) - 1] = '\\0';\n\t    s_luser = strtok_r(buf, \":\", &sptr);\n\t    if (s_luser == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_uid = strtok_r(NULL, \":\", &sptr);\n\t    if (s_uid == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_npas = strtok_r(NULL, \":\", &sptr);\n\t    if (s_npas == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_pas = strtok_r(NULL, \":\", &sptr);\n\t    npas = strtol(s_npas, NULL, 10) + 1;\n\t    while (npas > howmany && s_pas != NULL) {\n\t\ts_pas = strpbrk(s_pas, \",\");\n\t\tif (s_pas != NULL)\n\t\t    s_pas++;\n\t\tnpas--;\n\t    }\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    if (s_pas == NULL)\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s:%s:%d:%s\\n\",\n\t\t\t s_luser, s_uid, npas, pass);\n\t    else\n\t\tsnprintf(nbuf, sizeof(nbuf),\"%s:%s:%d:%s,%s\\n\",\n\t\t\t s_luser, s_uid, npas, s_pas, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t\tbreak;\n\t    }\n\t} else if (fputs(buf, pwfile) < 0) {\n\t    err = 1;\n\t    break;\n\t}\n    }\n    fclose(opwfile);\n\n    if (!found) {\n\tpwd = pam_modutil_getpwnam(pamh, forwho);\n\tif (pwd == NULL) {\n\t    err = 1;\n\t} else {\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    snprintf(nbuf, sizeof(nbuf), \"%s:%lu:1:%s\\n\",\n\t\t     forwho, (unsigned long)pwd->pw_uid, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t    }\n\t}\n    }\n\n    if (fflush(pwfile) || fsync(fileno(pwfile))) {\n\tD((\"fflush or fsync error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\n    if (fclose(pwfile)) {\n\tD((\"fclose error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\ndone:\n    if (!err) {\n\tif (rename(OPW_TMPFILE, OLD_PASSWORDS_FILE))\n\t    err = 1;\n    }\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      if (setfscreatecon_raw(prev_context_raw)) {\n        err = 1;\n      }\n      if (prev_context_raw)\n        freecon(prev_context_raw);\n      prev_context_raw = NULL;\n    }\n#endif\n    if (!err) {\n\treturn PAM_SUCCESS;\n    } else {\n\tunlink(OPW_TMPFILE);\n\treturn PAM_AUTHTOK_ERR;\n    }\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define OPW_TMPFILE             SCONFIGDIR \"/nopasswd\"",
            "#define SELINUX_ENABLED 0",
            "#define SELINUX_ENABLED (is_selinux_enabled()>0)"
          ],
          "globals_used": [
            "PAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\n#define OPW_TMPFILE             SCONFIGDIR \"/nopasswd\"\n#define SELINUX_ENABLED 0\n#define SELINUX_ENABLED (is_selinux_enabled()>0)\n\nPAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);\n\nint\nsave_old_password(pam_handle_t *pamh, const char *forwho, const char *oldpass,\n\t\t  int howmany)\n#endif\n{\n    static char buf[16384];\n    static char nbuf[16384];\n    char *s_luser, *s_uid, *s_npas, *s_pas, *pass;\n    int npas;\n    FILE *pwfile, *opwfile;\n    int err = 0;\n    int oldmask;\n    int found = 0;\n    struct passwd *pwd = NULL;\n    struct stat st;\n    size_t len = strlen(forwho);\n#ifdef WITH_SELINUX\n    char *prev_context_raw = NULL;\n#endif\n\n    if (howmany < 0) {\n\treturn PAM_SUCCESS;\n    }\n\n    if (oldpass == NULL) {\n\treturn PAM_SUCCESS;\n    }\n\n    oldmask = umask(077);\n\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      char *passwd_context_raw = NULL;\n      if (getfilecon_raw(\"/etc/passwd\",&passwd_context_raw)<0) {\n        return PAM_AUTHTOK_ERR;\n      };\n      if (getfscreatecon_raw(&prev_context_raw)<0) {\n        freecon(passwd_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      if (setfscreatecon_raw(passwd_context_raw)) {\n        freecon(passwd_context_raw);\n        freecon(prev_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      freecon(passwd_context_raw);\n    }\n#endif\n    pwfile = fopen(OPW_TMPFILE, \"w\");\n    umask(oldmask);\n    if (pwfile == NULL) {\n      err = 1;\n      goto done;\n    }\n\n    opwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n    if (opwfile == NULL) {\n\tfclose(pwfile);\n      err = 1;\n      goto done;\n    }\n\n    if (fstat(fileno(opwfile), &st) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    if (fchown(fileno(pwfile), st.st_uid, st.st_gid) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n    if (fchmod(fileno(pwfile), st.st_mode) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    while (fgets(buf, 16380, opwfile)) {\n\tif (!strncmp(buf, forwho, len) && strchr(\":,\\n\", buf[len]) != NULL) {\n\t    char *sptr = NULL;\n\t    found = 1;\n\t    if (howmany == 0)\n\t\tcontinue;\n\t    buf[strlen(buf) - 1] = '\\0';\n\t    s_luser = strtok_r(buf, \":\", &sptr);\n\t    if (s_luser == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_uid = strtok_r(NULL, \":\", &sptr);\n\t    if (s_uid == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_npas = strtok_r(NULL, \":\", &sptr);\n\t    if (s_npas == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_pas = strtok_r(NULL, \":\", &sptr);\n\t    npas = strtol(s_npas, NULL, 10) + 1;\n\t    while (npas > howmany && s_pas != NULL) {\n\t\ts_pas = strpbrk(s_pas, \",\");\n\t\tif (s_pas != NULL)\n\t\t    s_pas++;\n\t\tnpas--;\n\t    }\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    if (s_pas == NULL)\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s:%s:%d:%s\\n\",\n\t\t\t s_luser, s_uid, npas, pass);\n\t    else\n\t\tsnprintf(nbuf, sizeof(nbuf),\"%s:%s:%d:%s,%s\\n\",\n\t\t\t s_luser, s_uid, npas, s_pas, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t\tbreak;\n\t    }\n\t} else if (fputs(buf, pwfile) < 0) {\n\t    err = 1;\n\t    break;\n\t}\n    }\n    fclose(opwfile);\n\n    if (!found) {\n\tpwd = pam_modutil_getpwnam(pamh, forwho);\n\tif (pwd == NULL) {\n\t    err = 1;\n\t} else {\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    snprintf(nbuf, sizeof(nbuf), \"%s:%lu:1:%s\\n\",\n\t\t     forwho, (unsigned long)pwd->pw_uid, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t    }\n\t}\n    }\n\n    if (fflush(pwfile) || fsync(fileno(pwfile))) {\n\tD((\"fflush or fsync error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\n    if (fclose(pwfile)) {\n\tD((\"fclose error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\ndone:\n    if (!err) {\n\tif (rename(OPW_TMPFILE, OLD_PASSWORDS_FILE))\n\t    err = 1;\n    }\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      if (setfscreatecon_raw(prev_context_raw)) {\n        err = 1;\n      }\n      if (prev_context_raw)\n        freecon(prev_context_raw);\n      prev_context_raw = NULL;\n    }\n#endif\n    if (!err) {\n\treturn PAM_SUCCESS;\n    } else {\n\tunlink(OPW_TMPFILE);\n\treturn PAM_AUTHTOK_ERR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "debug"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "howmany"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nsave_history(const char *user, const char *filename, const char *howmany, const char *debug)\n{\n  int num = atoi(howmany);\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  retval = save_old_pass(user, num, filename, dbg);\n\n  return retval;\n}"
  },
  {
    "function_name": "check_history",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pwhistory_helper.c",
    "lines": "53-76",
    "snippet": "static int\ncheck_history(const char *user, const char *filename, const char *debug)\n{\n  char pass[PAM_MAX_RESP_SIZE + 1];\n  char *passwords[] = { pass };\n  int npass;\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  /* read the password from stdin (a pipe from the pam_pwhistory module) */\n  npass = pam_read_passwords(STDIN_FILENO, 1, passwords);\n\n  if (npass != 1)\n    { /* is it a valid password? */\n      helper_log_err(LOG_DEBUG, \"no password supplied\");\n      return PAM_AUTHTOK_ERR;\n    }\n\n  retval = check_old_pass(user, pass, filename, dbg);\n\n  memset(pass, '\\0', PAM_MAX_RESP_SIZE);\t/* clear memory of the password */\n\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/_pam_types.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pass",
            "'\\0'",
            "PAM_MAX_RESP_SIZE"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_old_pass",
          "args": [
            "user",
            "pass",
            "filename",
            "dbg"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "helper_log_err",
          "args": [
            "LOG_DEBUG",
            "\"no password supplied\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "helper_log_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
          "lines": "91-101",
          "snippet": "void\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}",
          "includes": [
            "#include \"opasswd.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <crypt.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <time.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nvoid\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_read_passwords",
          "args": [
            "STDIN_FILENO",
            "1",
            "passwords"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "debug"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ncheck_history(const char *user, const char *filename, const char *debug)\n{\n  char pass[PAM_MAX_RESP_SIZE + 1];\n  char *passwords[] = { pass };\n  int npass;\n  int dbg = atoi(debug); /* no need to be too fancy here */\n  int retval;\n\n  /* read the password from stdin (a pipe from the pam_pwhistory module) */\n  npass = pam_read_passwords(STDIN_FILENO, 1, passwords);\n\n  if (npass != 1)\n    { /* is it a valid password? */\n      helper_log_err(LOG_DEBUG, \"no password supplied\");\n      return PAM_AUTHTOK_ERR;\n    }\n\n  retval = check_old_pass(user, pass, filename, dbg);\n\n  memset(pass, '\\0', PAM_MAX_RESP_SIZE);\t/* clear memory of the password */\n\n  return retval;\n}"
  }
]