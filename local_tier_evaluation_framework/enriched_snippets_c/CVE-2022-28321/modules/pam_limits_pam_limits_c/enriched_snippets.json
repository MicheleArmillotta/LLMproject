[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "1194-1200",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n     /* nothing to do */\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n     /* nothing to do */\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "1099-1192",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval;\n    int i;\n    int glob_rc;\n    char *user_name;\n    struct passwd *pwd;\n    int ctrl;\n    struct pam_limit_s plstruct;\n    struct pam_limit_s *pl = &plstruct;\n    glob_t globbuf;\n    const char *oldlocale;\n\n    D((\"called.\"));\n\n    memset(pl, 0, sizeof(*pl));\n    memset(&globbuf, 0, sizeof(globbuf));\n\n    ctrl = _pam_parse(pamh, argc, argv, pl);\n    retval = pam_get_item( pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(pamh, LOG_ERR, \"open_session - error recovering username\");\n        return PAM_SESSION_ERR;\n     }\n\n    pwd = pam_modutil_getpwnam(pamh, user_name);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG)\n            pam_syslog(pamh, LOG_WARNING,\n\t\t       \"open_session username '%s' does not exist\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    retval = init_limits(pamh, pl, ctrl);\n    if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"cannot initialize\");\n        return PAM_ABORT;\n    }\n\n    retval = parse_config_file(pamh, pwd->pw_name, pwd->pw_uid, pwd->pw_gid, ctrl, pl);\n    if (retval == PAM_IGNORE) {\n\tD((\"the configuration file ('%s') has an applicable '<domain> -' entry\", CONF_FILE));\n\treturn PAM_SUCCESS;\n    }\n    if (retval != PAM_SUCCESS || pl->conf_file != NULL)\n\t/* skip reading limits.d if config file explicitly specified */\n\tgoto out;\n\n    /* Read subsequent *.conf files, if they exist. */\n\n    /* set the LC_COLLATE so the sorting order doesn't depend\n\ton system locale */\n\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob_rc = glob(LIMITS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\n    if (oldlocale != NULL)\n\tsetlocale (LC_COLLATE, oldlocale);\n\n    if (!glob_rc) {\n\t/* Parse the *.conf files. */\n\tfor (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t    pl->conf_file = globbuf.gl_pathv[i];\n\t    retval = parse_config_file(pamh, pwd->pw_name, pwd->pw_uid, pwd->pw_gid, ctrl, pl);\n\t    if (retval == PAM_IGNORE) {\n\t\tD((\"the configuration file ('%s') has an applicable '<domain> -' entry\", pl->conf_file));\n\t\tglobfree(&globbuf);\n\t\treturn PAM_SUCCESS;\n\t    }\n\t    if (retval != PAM_SUCCESS)\n\t\tgoto out;\n        }\n    }\n\nout:\n    globfree(&globbuf);\n    if (retval != PAM_SUCCESS)\n    {\n\tpam_syslog(pamh, LOG_ERR, \"error parsing the configuration file: '%s' \",CONF_FILE);\n\treturn retval;\n    }\n\n    retval = setup_limits(pamh, pwd->pw_name, pwd->pw_uid, ctrl, pl);\n    if (retval & LOGIN_ERR)\n\tpam_error(pamh, _(\"There were too many logins for '%s'.\"),\n\t\t  pwd->pw_name);\n    if (retval != LIMITED_OK) {\n        return PAM_PERM_DENIED;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LOGIN_ERR  2 /* too many logins err */",
      "#define LIMITED_OK 0 /* limit setting appeared to work */",
      "#define LIMITS_CONF_GLOB\t(LIMITS_FILE_DIR \"/*.conf\")\n\n#define LIMITS_FILE\t(SCONFIGDIR \"/limits.conf\")\n#define CONF_FILE\t((pl->conf_file != NULL) ? pl->conf_file : LIMITS_FILE)\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    struct pam_limit_s *pl)\n{\n    int ctrl=0;\n\n    /* step through arguments */",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"There were too many logins for '%s'.\")",
            "pwd->pw_name"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"There were too many logins for '%s'.\""
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "str2rlim_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "363-372",
          "snippet": "static rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_limits",
          "args": [
            "pamh",
            "pwd->pw_name",
            "pwd->pw_uid",
            "ctrl",
            "pl"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "setup_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "1032-1096",
          "snippet": "static int setup_limits(pam_handle_t *pamh,\n\t\t\tconst char *uname, uid_t uid, int ctrl,\n\t\t\tstruct pam_limit_s *pl)\n{\n    int i;\n    int status;\n    int retval = LIMITED_OK;\n\n    for (i=0, status=LIMITED_OK; i<RLIM_NLIMITS; i++) {\n      int res;\n\n\tif (!pl->limits[i].supported) {\n\t    /* skip it if its not known to the system */\n\t    continue;\n\t}\n\tif (pl->limits[i].src_soft == LIMITS_DEF_NONE &&\n\t    pl->limits[i].src_hard == LIMITS_DEF_NONE) {\n\t    /* skip it if its not initialized */\n\t    continue;\n\t}\n        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)\n            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;\n\tres = setrlimit(i, &pl->limits[i].limit);\n\tif (res != 0)\n\t  pam_syslog(pamh, LOG_ERR, \"Could not set limit for '%s': %m\",\n\t\t     rlimit2str(i));\n\tstatus |= res;\n    }\n\n    if (status) {\n        retval = LIMIT_ERR;\n    }\n\n    status = setpriority(PRIO_PROCESS, 0, pl->priority);\n    if (status != 0) {\n        pam_syslog(pamh, LOG_ERR, \"Could not set limit for PRIO_PROCESS: %m\");\n        retval = LIMIT_ERR;\n    }\n\n    if (uid == 0) {\n\tD((\"skip login limit check for uid=0\"));\n    } else if (pl->login_limit > 0) {\n        if (check_logins(pamh, uname, pl->login_limit, ctrl, pl) == LOGIN_ERR) {\n#ifdef HAVE_LIBAUDIT\n\t    if (!(ctrl & PAM_NO_AUDIT)) {\n\t\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_SESSIONS,\n\t\t    \"pam_limits\", PAM_PERM_DENIED);\n\t\t/* ignore return value as we fail anyway */\n            }\n#endif\n            retval |= LOGIN_ERR;\n\t}\n    } else if (pl->login_limit == 0) {\n        retval |= LOGIN_ERR;\n    }\n\n    if (pl->nonewprivs) {\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not set prctl(PR_SET_NO_NEW_PRIVS): %m\");\n\t    retval |= LIMIT_ERR;\n\t}\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LOGIN_ERR  2 /* too many logins err */",
            "#define LIMIT_ERR  1 /* error setting a limit */",
            "#define LIMITED_OK 0 /* limit setting appeared to work */",
            "#define PAM_NO_AUDIT        0x0008",
            "#define LIMITS_DEF_NONE     6 /* this limit was not set yet */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LOGIN_ERR  2 /* too many logins err */\n#define LIMIT_ERR  1 /* error setting a limit */\n#define LIMITED_OK 0 /* limit setting appeared to work */\n#define PAM_NO_AUDIT        0x0008\n#define LIMITS_DEF_NONE     6 /* this limit was not set yet */\n\nstatic int setup_limits(pam_handle_t *pamh,\n\t\t\tconst char *uname, uid_t uid, int ctrl,\n\t\t\tstruct pam_limit_s *pl)\n{\n    int i;\n    int status;\n    int retval = LIMITED_OK;\n\n    for (i=0, status=LIMITED_OK; i<RLIM_NLIMITS; i++) {\n      int res;\n\n\tif (!pl->limits[i].supported) {\n\t    /* skip it if its not known to the system */\n\t    continue;\n\t}\n\tif (pl->limits[i].src_soft == LIMITS_DEF_NONE &&\n\t    pl->limits[i].src_hard == LIMITS_DEF_NONE) {\n\t    /* skip it if its not initialized */\n\t    continue;\n\t}\n        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)\n            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;\n\tres = setrlimit(i, &pl->limits[i].limit);\n\tif (res != 0)\n\t  pam_syslog(pamh, LOG_ERR, \"Could not set limit for '%s': %m\",\n\t\t     rlimit2str(i));\n\tstatus |= res;\n    }\n\n    if (status) {\n        retval = LIMIT_ERR;\n    }\n\n    status = setpriority(PRIO_PROCESS, 0, pl->priority);\n    if (status != 0) {\n        pam_syslog(pamh, LOG_ERR, \"Could not set limit for PRIO_PROCESS: %m\");\n        retval = LIMIT_ERR;\n    }\n\n    if (uid == 0) {\n\tD((\"skip login limit check for uid=0\"));\n    } else if (pl->login_limit > 0) {\n        if (check_logins(pamh, uname, pl->login_limit, ctrl, pl) == LOGIN_ERR) {\n#ifdef HAVE_LIBAUDIT\n\t    if (!(ctrl & PAM_NO_AUDIT)) {\n\t\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_SESSIONS,\n\t\t    \"pam_limits\", PAM_PERM_DENIED);\n\t\t/* ignore return value as we fail anyway */\n            }\n#endif\n            retval |= LOGIN_ERR;\n\t}\n    } else if (pl->login_limit == 0) {\n        retval |= LOGIN_ERR;\n    }\n\n    if (pl->nonewprivs) {\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not set prctl(PR_SET_NO_NEW_PRIVS): %m\");\n\t    retval |= LIMIT_ERR;\n\t}\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error parsing the configuration file: '%s' \"",
            "CONF_FILE"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"the configuration file ('%s') has an applicable '<domain> -' entry\", pl->conf_file)"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_config_file",
          "args": [
            "pamh",
            "pwd->pw_name",
            "pwd->pw_uid",
            "pwd->pw_gid",
            "ctrl",
            "pl"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "812-1030",
          "snippet": "static int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n\t\t\t     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH];\n\n    /* check for the CONF_FILE */\n    if (ctrl & PAM_DEBUG_ARG)\n        pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);\n    fil = fopen(CONF_FILE, \"r\");\n    if (fil == NULL) {\n      int err = errno;\n\n#ifdef VENDOR_SCONFIGDIR\n      /* if the specified file does not exist, and it is not provided by\n         the user, try the vendor file as fallback. */\n      if (pl->conf_file == NULL && err == ENOENT)\n        fil = fopen(VENDOR_SCONFIGDIR \"/limits.conf\", \"r\");\n\n      if (fil == NULL)\n#endif\n        {\n          if (err == ENOENT)\n            return PAM_SUCCESS;\n\n          pam_syslog (pamh, LOG_WARNING,\n                      \"cannot read settings from %s: %s\", CONF_FILE,\n                      strerror(err));\n          return PAM_SERVICE_ERR;\n        }\n    }\n\n    /* start the show */\n    while (fgets(buf, LINE_LENGTH, fil) != NULL) {\n        char domain[LINE_LENGTH];\n        char ltype[LINE_LENGTH];\n        char item[LINE_LENGTH];\n        char value[LINE_LENGTH];\n        int i;\n        int rngtype;\n        size_t j;\n        char *tptr,*line;\n        uid_t min_uid = (uid_t)-1, max_uid = (uid_t)-1;\n\n        line = buf;\n        /* skip the leading white space */\n        while (*line && isspace(*line))\n            line++;\n\n        /* Rip off the comments */\n        tptr = strchr(line,'#');\n        if (tptr)\n            *tptr = '\\0';\n        /* Rip off the newline char */\n        tptr = strchr(line,'\\n');\n        if (tptr)\n            *tptr = '\\0';\n        /* Anything left ? */\n        if (!strlen(line))\n            continue;\n\n\tdomain[0] = ltype[0] = item[0] = value[0] = '\\0';\n\n\ti = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value);\n\tD((\"scanned line[%d]: domain[%s], ltype[%s], item[%s], value[%s]\",\n\t   i, domain, ltype, item, value));\n\n        for(j=0; j < strlen(ltype); j++)\n            ltype[j]=tolower(ltype[j]);\n\n\tif ((rngtype=parse_uid_range(pamh, domain, &min_uid, &max_uid)) < 0) {\n\t    pam_syslog(pamh, LOG_WARNING, \"invalid uid range '%s' - skipped\", domain);\n\t    continue;\n\t}\n\n        if (i == 4) { /* a complete line */\n\t    for(j=0; j < strlen(item); j++)\n\t\titem[j]=tolower(item[j]);\n\t    for(j=0; j < strlen(value); j++)\n\t\tvalue[j]=tolower(value[j]);\n\n            if (strcmp(uname, domain) == 0) /* this user have a limit */\n                process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n            else if (domain[0]=='@') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid >= (gid_t)min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t}\n            } else if (domain[0]=='%') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain,\"%\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALL, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\telse if (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1)) {\n\t\t\t    strcpy(pl->login_group, domain+1);\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid)) {\n\t\t\t    struct group *grp;\n\t\t\t    grp = pam_modutil_getgrgid(pamh, (gid_t)max_uid);\n\t\t\t    strncpy(pl->login_group, grp->gr_name, sizeof(pl->login_group));\n\t\t\t    pl->login_group[sizeof(pl->login_group)-1] = '\\0';\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MIN:\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tpam_syslog(pamh, LOG_WARNING, \"range unsupported for %%group matching - ignored\");\n\t\t}\n            } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain, \"*\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n\t\t}\n\t    }\n\t} else if (i == 2 && ltype[0] == '-') { /* Probably a no-limit line */\n\t    if (strcmp(uname, domain) == 0) {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    } else if (domain[0] == '@') {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid < (gid_t)min_uid)\n\t\t\t    continue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"no limits for '%s' in group '%s'\",\n\t\t\t       uname, domain+1);\n\t\t}\n\t    } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tcontinue;  /* next line */\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    break;\n\t\t\tcontinue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    }\n\t    fclose(fil);\n\t    return PAM_IGNORE;\n        } else {\n            pam_syslog(pamh, LOG_WARNING, \"invalid line '%s' - skipped\", line);\n\t}\n    }\n    fclose(fil);\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x0001",
            "#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */",
            "#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */",
            "#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/",
            "#define LIMIT_RANGE_NONE    0 /* no range specified */",
            "#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */",
            "#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */",
            "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */",
            "#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */",
            "#define LIMITS_DEF_USER     0 /* limit was set by a user entry */",
            "#define LINE_LENGTH 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x0001\n#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */\n#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */\n#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/\n#define LIMIT_RANGE_NONE    0 /* no range specified */\n#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */\n#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */\n#define LIMITS_DEF_USER     0 /* limit was set by a user entry */\n#define LINE_LENGTH 1024\n\nstatic int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n\t\t\t     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH];\n\n    /* check for the CONF_FILE */\n    if (ctrl & PAM_DEBUG_ARG)\n        pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);\n    fil = fopen(CONF_FILE, \"r\");\n    if (fil == NULL) {\n      int err = errno;\n\n#ifdef VENDOR_SCONFIGDIR\n      /* if the specified file does not exist, and it is not provided by\n         the user, try the vendor file as fallback. */\n      if (pl->conf_file == NULL && err == ENOENT)\n        fil = fopen(VENDOR_SCONFIGDIR \"/limits.conf\", \"r\");\n\n      if (fil == NULL)\n#endif\n        {\n          if (err == ENOENT)\n            return PAM_SUCCESS;\n\n          pam_syslog (pamh, LOG_WARNING,\n                      \"cannot read settings from %s: %s\", CONF_FILE,\n                      strerror(err));\n          return PAM_SERVICE_ERR;\n        }\n    }\n\n    /* start the show */\n    while (fgets(buf, LINE_LENGTH, fil) != NULL) {\n        char domain[LINE_LENGTH];\n        char ltype[LINE_LENGTH];\n        char item[LINE_LENGTH];\n        char value[LINE_LENGTH];\n        int i;\n        int rngtype;\n        size_t j;\n        char *tptr,*line;\n        uid_t min_uid = (uid_t)-1, max_uid = (uid_t)-1;\n\n        line = buf;\n        /* skip the leading white space */\n        while (*line && isspace(*line))\n            line++;\n\n        /* Rip off the comments */\n        tptr = strchr(line,'#');\n        if (tptr)\n            *tptr = '\\0';\n        /* Rip off the newline char */\n        tptr = strchr(line,'\\n');\n        if (tptr)\n            *tptr = '\\0';\n        /* Anything left ? */\n        if (!strlen(line))\n            continue;\n\n\tdomain[0] = ltype[0] = item[0] = value[0] = '\\0';\n\n\ti = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value);\n\tD((\"scanned line[%d]: domain[%s], ltype[%s], item[%s], value[%s]\",\n\t   i, domain, ltype, item, value));\n\n        for(j=0; j < strlen(ltype); j++)\n            ltype[j]=tolower(ltype[j]);\n\n\tif ((rngtype=parse_uid_range(pamh, domain, &min_uid, &max_uid)) < 0) {\n\t    pam_syslog(pamh, LOG_WARNING, \"invalid uid range '%s' - skipped\", domain);\n\t    continue;\n\t}\n\n        if (i == 4) { /* a complete line */\n\t    for(j=0; j < strlen(item); j++)\n\t\titem[j]=tolower(item[j]);\n\t    for(j=0; j < strlen(value); j++)\n\t\tvalue[j]=tolower(value[j]);\n\n            if (strcmp(uname, domain) == 0) /* this user have a limit */\n                process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n            else if (domain[0]=='@') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid >= (gid_t)min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t}\n            } else if (domain[0]=='%') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain,\"%\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALL, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\telse if (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1)) {\n\t\t\t    strcpy(pl->login_group, domain+1);\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid)) {\n\t\t\t    struct group *grp;\n\t\t\t    grp = pam_modutil_getgrgid(pamh, (gid_t)max_uid);\n\t\t\t    strncpy(pl->login_group, grp->gr_name, sizeof(pl->login_group));\n\t\t\t    pl->login_group[sizeof(pl->login_group)-1] = '\\0';\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MIN:\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tpam_syslog(pamh, LOG_WARNING, \"range unsupported for %%group matching - ignored\");\n\t\t}\n            } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain, \"*\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n\t\t}\n\t    }\n\t} else if (i == 2 && ltype[0] == '-') { /* Probably a no-limit line */\n\t    if (strcmp(uname, domain) == 0) {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    } else if (domain[0] == '@') {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid < (gid_t)min_uid)\n\t\t\t    continue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"no limits for '%s' in group '%s'\",\n\t\t\t       uname, domain+1);\n\t\t}\n\t    } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tcontinue;  /* next line */\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    break;\n\t\t\tcontinue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    }\n\t    fclose(fil);\n\t    return PAM_IGNORE;\n        } else {\n            pam_syslog(pamh, LOG_WARNING, \"invalid line '%s' - skipped\", line);\n\t}\n    }\n    fclose(fil);\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "oldlocale"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "LIMITS_CONF_GLOB",
            "GLOB_ERR",
            "NULL",
            "&globbuf"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "\"C\""
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot initialize\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_limits",
          "args": [
            "pamh",
            "pl",
            "ctrl"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "init_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "450-493",
          "snippet": "static int init_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i;\n    int retval = PAM_SUCCESS;\n\n    D((\"called.\"));\n\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n\tint r = getrlimit(i, &pl->limits[i].limit);\n\tif (r == -1) {\n\t    pl->limits[i].supported = 0;\n\t    if (errno != EINVAL) {\n\t\tretval = !PAM_SUCCESS;\n\t    }\n\t} else {\n\t    pl->limits[i].supported = 1;\n\t    pl->limits[i].src_soft = LIMITS_DEF_NONE;\n\t    pl->limits[i].src_hard = LIMITS_DEF_NONE;\n\t}\n    }\n\n#ifdef __linux__\n    if (ctrl & PAM_SET_ALL) {\n      parse_kernel_limits(pamh, pl, ctrl);\n\n      for(i = 0; i < RLIM_NLIMITS; i++) {\n\tif (pl->limits[i].supported &&\n\t    (pl->limits[i].src_soft == LIMITS_DEF_NONE ||\n\t     pl->limits[i].src_hard == LIMITS_DEF_NONE)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"Did not find kernel RLIMIT for %s, using PAM default\", rlimit2str(i));\n\t}\n      }\n    }\n#endif\n\n    errno = 0;\n    pl->priority = getpriority (PRIO_PROCESS, 0);\n    if (pl->priority == -1 && errno != 0)\n      retval = !PAM_SUCCESS;\n    pl->login_limit = -2;\n    pl->login_limit_def = LIMITS_DEF_NONE;\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_SET_ALL         0x0010",
            "#define LIMITS_DEF_NONE     6 /* this limit was not set yet */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_SET_ALL         0x0010\n#define LIMITS_DEF_NONE     6 /* this limit was not set yet */\n\nstatic int init_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i;\n    int retval = PAM_SUCCESS;\n\n    D((\"called.\"));\n\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n\tint r = getrlimit(i, &pl->limits[i].limit);\n\tif (r == -1) {\n\t    pl->limits[i].supported = 0;\n\t    if (errno != EINVAL) {\n\t\tretval = !PAM_SUCCESS;\n\t    }\n\t} else {\n\t    pl->limits[i].supported = 1;\n\t    pl->limits[i].src_soft = LIMITS_DEF_NONE;\n\t    pl->limits[i].src_hard = LIMITS_DEF_NONE;\n\t}\n    }\n\n#ifdef __linux__\n    if (ctrl & PAM_SET_ALL) {\n      parse_kernel_limits(pamh, pl, ctrl);\n\n      for(i = 0; i < RLIM_NLIMITS; i++) {\n\tif (pl->limits[i].supported &&\n\t    (pl->limits[i].src_soft == LIMITS_DEF_NONE ||\n\t     pl->limits[i].src_hard == LIMITS_DEF_NONE)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"Did not find kernel RLIMIT for %s, using PAM default\", rlimit2str(i));\n\t}\n      }\n    }\n#endif\n\n    errno = 0;\n    pl->priority = getpriority (PRIO_PROCESS, 0);\n    if (pl->priority == -1 && errno != 0)\n      retval = !PAM_SUCCESS;\n    pl->login_limit = -2;\n    pl->login_limit_def = LIMITS_DEF_NONE;\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"open_session username '%s' does not exist\"",
            "user_name"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user_name"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"open_session - error recovering username\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "(void*) &user_name"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "pl"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "56-100",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NO_AUDIT        0x0002",
            "#define PAM_DEBUG_ARG       0x0001",
            "#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")",
            "#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_NO_AUDIT        0x0002\n#define PAM_DEBUG_ARG       0x0001\n#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")\n#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&globbuf",
            "0",
            "sizeof(globbuf)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pl",
            "0",
            "sizeof(*pl)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LOGIN_ERR  2 /* too many logins err */\n#define LIMITED_OK 0 /* limit setting appeared to work */\n#define LIMITS_CONF_GLOB\t(LIMITS_FILE_DIR \"/*.conf\")\n\n#define LIMITS_FILE\t(SCONFIGDIR \"/limits.conf\")\n#define CONF_FILE\t((pl->conf_file != NULL) ? pl->conf_file : LIMITS_FILE)\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    struct pam_limit_s *pl)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n#define PAM_DEBUG_ARG       0x0001\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval;\n    int i;\n    int glob_rc;\n    char *user_name;\n    struct passwd *pwd;\n    int ctrl;\n    struct pam_limit_s plstruct;\n    struct pam_limit_s *pl = &plstruct;\n    glob_t globbuf;\n    const char *oldlocale;\n\n    D((\"called.\"));\n\n    memset(pl, 0, sizeof(*pl));\n    memset(&globbuf, 0, sizeof(globbuf));\n\n    ctrl = _pam_parse(pamh, argc, argv, pl);\n    retval = pam_get_item( pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(pamh, LOG_ERR, \"open_session - error recovering username\");\n        return PAM_SESSION_ERR;\n     }\n\n    pwd = pam_modutil_getpwnam(pamh, user_name);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG)\n            pam_syslog(pamh, LOG_WARNING,\n\t\t       \"open_session username '%s' does not exist\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    retval = init_limits(pamh, pl, ctrl);\n    if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"cannot initialize\");\n        return PAM_ABORT;\n    }\n\n    retval = parse_config_file(pamh, pwd->pw_name, pwd->pw_uid, pwd->pw_gid, ctrl, pl);\n    if (retval == PAM_IGNORE) {\n\tD((\"the configuration file ('%s') has an applicable '<domain> -' entry\", CONF_FILE));\n\treturn PAM_SUCCESS;\n    }\n    if (retval != PAM_SUCCESS || pl->conf_file != NULL)\n\t/* skip reading limits.d if config file explicitly specified */\n\tgoto out;\n\n    /* Read subsequent *.conf files, if they exist. */\n\n    /* set the LC_COLLATE so the sorting order doesn't depend\n\ton system locale */\n\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob_rc = glob(LIMITS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\n    if (oldlocale != NULL)\n\tsetlocale (LC_COLLATE, oldlocale);\n\n    if (!glob_rc) {\n\t/* Parse the *.conf files. */\n\tfor (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t    pl->conf_file = globbuf.gl_pathv[i];\n\t    retval = parse_config_file(pamh, pwd->pw_name, pwd->pw_uid, pwd->pw_gid, ctrl, pl);\n\t    if (retval == PAM_IGNORE) {\n\t\tD((\"the configuration file ('%s') has an applicable '<domain> -' entry\", pl->conf_file));\n\t\tglobfree(&globbuf);\n\t\treturn PAM_SUCCESS;\n\t    }\n\t    if (retval != PAM_SUCCESS)\n\t\tgoto out;\n        }\n    }\n\nout:\n    globfree(&globbuf);\n    if (retval != PAM_SUCCESS)\n    {\n\tpam_syslog(pamh, LOG_ERR, \"error parsing the configuration file: '%s' \",CONF_FILE);\n\treturn retval;\n    }\n\n    retval = setup_limits(pamh, pwd->pw_name, pwd->pw_uid, ctrl, pl);\n    if (retval & LOGIN_ERR)\n\tpam_error(pamh, _(\"There were too many logins for '%s'.\"),\n\t\t  pwd->pw_name);\n    if (retval != LIMITED_OK) {\n        return PAM_PERM_DENIED;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "setup_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "1032-1096",
    "snippet": "static int setup_limits(pam_handle_t *pamh,\n\t\t\tconst char *uname, uid_t uid, int ctrl,\n\t\t\tstruct pam_limit_s *pl)\n{\n    int i;\n    int status;\n    int retval = LIMITED_OK;\n\n    for (i=0, status=LIMITED_OK; i<RLIM_NLIMITS; i++) {\n      int res;\n\n\tif (!pl->limits[i].supported) {\n\t    /* skip it if its not known to the system */\n\t    continue;\n\t}\n\tif (pl->limits[i].src_soft == LIMITS_DEF_NONE &&\n\t    pl->limits[i].src_hard == LIMITS_DEF_NONE) {\n\t    /* skip it if its not initialized */\n\t    continue;\n\t}\n        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)\n            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;\n\tres = setrlimit(i, &pl->limits[i].limit);\n\tif (res != 0)\n\t  pam_syslog(pamh, LOG_ERR, \"Could not set limit for '%s': %m\",\n\t\t     rlimit2str(i));\n\tstatus |= res;\n    }\n\n    if (status) {\n        retval = LIMIT_ERR;\n    }\n\n    status = setpriority(PRIO_PROCESS, 0, pl->priority);\n    if (status != 0) {\n        pam_syslog(pamh, LOG_ERR, \"Could not set limit for PRIO_PROCESS: %m\");\n        retval = LIMIT_ERR;\n    }\n\n    if (uid == 0) {\n\tD((\"skip login limit check for uid=0\"));\n    } else if (pl->login_limit > 0) {\n        if (check_logins(pamh, uname, pl->login_limit, ctrl, pl) == LOGIN_ERR) {\n#ifdef HAVE_LIBAUDIT\n\t    if (!(ctrl & PAM_NO_AUDIT)) {\n\t\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_SESSIONS,\n\t\t    \"pam_limits\", PAM_PERM_DENIED);\n\t\t/* ignore return value as we fail anyway */\n            }\n#endif\n            retval |= LOGIN_ERR;\n\t}\n    } else if (pl->login_limit == 0) {\n        retval |= LOGIN_ERR;\n    }\n\n    if (pl->nonewprivs) {\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not set prctl(PR_SET_NO_NEW_PRIVS): %m\");\n\t    retval |= LIMIT_ERR;\n\t}\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LOGIN_ERR  2 /* too many logins err */",
      "#define LIMIT_ERR  1 /* error setting a limit */",
      "#define LIMITED_OK 0 /* limit setting appeared to work */",
      "#define PAM_NO_AUDIT        0x0008",
      "#define LIMITS_DEF_NONE     6 /* this limit was not set yet */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not set prctl(PR_SET_NO_NEW_PRIVS): %m\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_audit_write",
          "args": [
            "pamh",
            "AUDIT_ANOM_LOGIN_SESSIONS",
            "\"pam_limits\"",
            "PAM_PERM_DENIED"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_logins",
          "args": [
            "pamh",
            "uname",
            "pl->login_limit",
            "ctrl",
            "pl"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "check_logins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "234-318",
          "snippet": "static int\ncheck_logins (pam_handle_t *pamh, const char *name, int limit, int ctrl,\n              struct pam_limit_s *pl)\n{\n    struct utmp *ut;\n    int count;\n\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG,\n\t\t   \"checking logins for '%s' (maximum of %d)\", name, limit);\n    }\n\n    if (limit < 0)\n        return 0; /* no limits imposed */\n    if (limit == 0) /* maximum 0 logins ? */ {\n        pam_syslog(pamh, LOG_WARNING, \"No logins allowed for '%s'\", name);\n        return LOGIN_ERR;\n    }\n\n    setutent();\n\n    /* Because there is no definition about when an application\n       actually adds a utmp entry, some applications bizarrely do the\n       utmp call before the have PAM authenticate them to the system:\n       you're logged it, sort of...? Anyway, you can use the\n       \"utmp_early\" module argument in your PAM config file to make\n       allowances for this sort of problem. (There should be a PAM\n       standard for this, since if a module wants to actually map a\n       username then any early utmp entry will be for the unmapped\n       name = broken.) */\n\n    if (ctrl & PAM_UTMP_EARLY) {\n\tcount = 0;\n    } else {\n\tcount = 1;\n    }\n\n    while((ut = getutent())) {\n#ifdef USER_PROCESS\n        if (ut->ut_type != USER_PROCESS) {\n            continue;\n\t}\n#endif\n        if (ut->UT_USER[0] == '\\0') {\n            continue;\n\t}\n        if (!pl->flag_numsyslogins) {\n\t    char user[sizeof(ut->UT_USER) + 1];\n\t    user[0] = '\\0';\n\t    strncat(user, ut->UT_USER, sizeof(ut->UT_USER));\n\n\t    if (((pl->login_limit_def == LIMITS_DEF_USER)\n\t         || (pl->login_limit_def == LIMITS_DEF_GROUP)\n\t\t || (pl->login_limit_def == LIMITS_DEF_DEFAULT))\n\t\t&& strcmp(name, user) != 0) {\n                continue;\n\t    }\n\t    if ((pl->login_limit_def == LIMITS_DEF_ALLGROUP)\n\t\t&& !pam_modutil_user_in_group_nam_nam(pamh, user, pl->login_group)) {\n                continue;\n\t    }\n\t    if (kill(ut->ut_pid, 0) == -1 && errno == ESRCH) {\n\t\t/* process does not exist anymore */\n\t\tpam_syslog(pamh, LOG_INFO,\n\t\t\t   \"Stale utmp entry (pid %d) for '%s' ignored\",\n\t\t\t   ut->ut_pid, user);\n\t\tcontinue;\n\t    }\n\t}\n\tif (++count > limit) {\n\t    break;\n\t}\n    }\n    endutent();\n    if (count > limit) {\n\tif (name) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Too many logins (max %d) for %s\", limit, name);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Too many system logins (max %d)\", limit);\n\t}\n        return LOGIN_ERR;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LOGIN_ERR  2 /* too many logins err */",
            "#define PAM_UTMP_EARLY      0x0004",
            "#define PAM_DEBUG_ARG       0x0001",
            "#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */",
            "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */",
            "#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */",
            "#define LIMITS_DEF_USER     0 /* limit was set by a user entry */",
            "#define UT_USER ut_user"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LOGIN_ERR  2 /* too many logins err */\n#define PAM_UTMP_EARLY      0x0004\n#define PAM_DEBUG_ARG       0x0001\n#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */\n#define LIMITS_DEF_USER     0 /* limit was set by a user entry */\n#define UT_USER ut_user\n\nstatic int\ncheck_logins (pam_handle_t *pamh, const char *name, int limit, int ctrl,\n              struct pam_limit_s *pl)\n{\n    struct utmp *ut;\n    int count;\n\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG,\n\t\t   \"checking logins for '%s' (maximum of %d)\", name, limit);\n    }\n\n    if (limit < 0)\n        return 0; /* no limits imposed */\n    if (limit == 0) /* maximum 0 logins ? */ {\n        pam_syslog(pamh, LOG_WARNING, \"No logins allowed for '%s'\", name);\n        return LOGIN_ERR;\n    }\n\n    setutent();\n\n    /* Because there is no definition about when an application\n       actually adds a utmp entry, some applications bizarrely do the\n       utmp call before the have PAM authenticate them to the system:\n       you're logged it, sort of...? Anyway, you can use the\n       \"utmp_early\" module argument in your PAM config file to make\n       allowances for this sort of problem. (There should be a PAM\n       standard for this, since if a module wants to actually map a\n       username then any early utmp entry will be for the unmapped\n       name = broken.) */\n\n    if (ctrl & PAM_UTMP_EARLY) {\n\tcount = 0;\n    } else {\n\tcount = 1;\n    }\n\n    while((ut = getutent())) {\n#ifdef USER_PROCESS\n        if (ut->ut_type != USER_PROCESS) {\n            continue;\n\t}\n#endif\n        if (ut->UT_USER[0] == '\\0') {\n            continue;\n\t}\n        if (!pl->flag_numsyslogins) {\n\t    char user[sizeof(ut->UT_USER) + 1];\n\t    user[0] = '\\0';\n\t    strncat(user, ut->UT_USER, sizeof(ut->UT_USER));\n\n\t    if (((pl->login_limit_def == LIMITS_DEF_USER)\n\t         || (pl->login_limit_def == LIMITS_DEF_GROUP)\n\t\t || (pl->login_limit_def == LIMITS_DEF_DEFAULT))\n\t\t&& strcmp(name, user) != 0) {\n                continue;\n\t    }\n\t    if ((pl->login_limit_def == LIMITS_DEF_ALLGROUP)\n\t\t&& !pam_modutil_user_in_group_nam_nam(pamh, user, pl->login_group)) {\n                continue;\n\t    }\n\t    if (kill(ut->ut_pid, 0) == -1 && errno == ESRCH) {\n\t\t/* process does not exist anymore */\n\t\tpam_syslog(pamh, LOG_INFO,\n\t\t\t   \"Stale utmp entry (pid %d) for '%s' ignored\",\n\t\t\t   ut->ut_pid, user);\n\t\tcontinue;\n\t    }\n\t}\n\tif (++count > limit) {\n\t    break;\n\t}\n    }\n    endutent();\n    if (count > limit) {\n\tif (name) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Too many logins (max %d) for %s\", limit, name);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Too many system logins (max %d)\", limit);\n\t}\n        return LOGIN_ERR;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"skip login limit check for uid=0\")"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not set limit for PRIO_PROCESS: %m\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpriority",
          "args": [
            "PRIO_PROCESS",
            "0",
            "pl->priority"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not set limit for '%s': %m\"",
            "rlimit2str(i)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit2str",
          "args": [
            "i"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "rlimit2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "161-226",
          "snippet": "static const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "i",
            "&pl->limits[i].limit"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LOGIN_ERR  2 /* too many logins err */\n#define LIMIT_ERR  1 /* error setting a limit */\n#define LIMITED_OK 0 /* limit setting appeared to work */\n#define PAM_NO_AUDIT        0x0008\n#define LIMITS_DEF_NONE     6 /* this limit was not set yet */\n\nstatic int setup_limits(pam_handle_t *pamh,\n\t\t\tconst char *uname, uid_t uid, int ctrl,\n\t\t\tstruct pam_limit_s *pl)\n{\n    int i;\n    int status;\n    int retval = LIMITED_OK;\n\n    for (i=0, status=LIMITED_OK; i<RLIM_NLIMITS; i++) {\n      int res;\n\n\tif (!pl->limits[i].supported) {\n\t    /* skip it if its not known to the system */\n\t    continue;\n\t}\n\tif (pl->limits[i].src_soft == LIMITS_DEF_NONE &&\n\t    pl->limits[i].src_hard == LIMITS_DEF_NONE) {\n\t    /* skip it if its not initialized */\n\t    continue;\n\t}\n        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)\n            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;\n\tres = setrlimit(i, &pl->limits[i].limit);\n\tif (res != 0)\n\t  pam_syslog(pamh, LOG_ERR, \"Could not set limit for '%s': %m\",\n\t\t     rlimit2str(i));\n\tstatus |= res;\n    }\n\n    if (status) {\n        retval = LIMIT_ERR;\n    }\n\n    status = setpriority(PRIO_PROCESS, 0, pl->priority);\n    if (status != 0) {\n        pam_syslog(pamh, LOG_ERR, \"Could not set limit for PRIO_PROCESS: %m\");\n        retval = LIMIT_ERR;\n    }\n\n    if (uid == 0) {\n\tD((\"skip login limit check for uid=0\"));\n    } else if (pl->login_limit > 0) {\n        if (check_logins(pamh, uname, pl->login_limit, ctrl, pl) == LOGIN_ERR) {\n#ifdef HAVE_LIBAUDIT\n\t    if (!(ctrl & PAM_NO_AUDIT)) {\n\t\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_SESSIONS,\n\t\t    \"pam_limits\", PAM_PERM_DENIED);\n\t\t/* ignore return value as we fail anyway */\n            }\n#endif\n            retval |= LOGIN_ERR;\n\t}\n    } else if (pl->login_limit == 0) {\n        retval |= LOGIN_ERR;\n    }\n\n    if (pl->nonewprivs) {\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not set prctl(PR_SET_NO_NEW_PRIVS): %m\");\n\t    retval |= LIMIT_ERR;\n\t}\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "parse_config_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "812-1030",
    "snippet": "static int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n\t\t\t     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH];\n\n    /* check for the CONF_FILE */\n    if (ctrl & PAM_DEBUG_ARG)\n        pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);\n    fil = fopen(CONF_FILE, \"r\");\n    if (fil == NULL) {\n      int err = errno;\n\n#ifdef VENDOR_SCONFIGDIR\n      /* if the specified file does not exist, and it is not provided by\n         the user, try the vendor file as fallback. */\n      if (pl->conf_file == NULL && err == ENOENT)\n        fil = fopen(VENDOR_SCONFIGDIR \"/limits.conf\", \"r\");\n\n      if (fil == NULL)\n#endif\n        {\n          if (err == ENOENT)\n            return PAM_SUCCESS;\n\n          pam_syslog (pamh, LOG_WARNING,\n                      \"cannot read settings from %s: %s\", CONF_FILE,\n                      strerror(err));\n          return PAM_SERVICE_ERR;\n        }\n    }\n\n    /* start the show */\n    while (fgets(buf, LINE_LENGTH, fil) != NULL) {\n        char domain[LINE_LENGTH];\n        char ltype[LINE_LENGTH];\n        char item[LINE_LENGTH];\n        char value[LINE_LENGTH];\n        int i;\n        int rngtype;\n        size_t j;\n        char *tptr,*line;\n        uid_t min_uid = (uid_t)-1, max_uid = (uid_t)-1;\n\n        line = buf;\n        /* skip the leading white space */\n        while (*line && isspace(*line))\n            line++;\n\n        /* Rip off the comments */\n        tptr = strchr(line,'#');\n        if (tptr)\n            *tptr = '\\0';\n        /* Rip off the newline char */\n        tptr = strchr(line,'\\n');\n        if (tptr)\n            *tptr = '\\0';\n        /* Anything left ? */\n        if (!strlen(line))\n            continue;\n\n\tdomain[0] = ltype[0] = item[0] = value[0] = '\\0';\n\n\ti = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value);\n\tD((\"scanned line[%d]: domain[%s], ltype[%s], item[%s], value[%s]\",\n\t   i, domain, ltype, item, value));\n\n        for(j=0; j < strlen(ltype); j++)\n            ltype[j]=tolower(ltype[j]);\n\n\tif ((rngtype=parse_uid_range(pamh, domain, &min_uid, &max_uid)) < 0) {\n\t    pam_syslog(pamh, LOG_WARNING, \"invalid uid range '%s' - skipped\", domain);\n\t    continue;\n\t}\n\n        if (i == 4) { /* a complete line */\n\t    for(j=0; j < strlen(item); j++)\n\t\titem[j]=tolower(item[j]);\n\t    for(j=0; j < strlen(value); j++)\n\t\tvalue[j]=tolower(value[j]);\n\n            if (strcmp(uname, domain) == 0) /* this user have a limit */\n                process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n            else if (domain[0]=='@') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid >= (gid_t)min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t}\n            } else if (domain[0]=='%') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain,\"%\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALL, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\telse if (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1)) {\n\t\t\t    strcpy(pl->login_group, domain+1);\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid)) {\n\t\t\t    struct group *grp;\n\t\t\t    grp = pam_modutil_getgrgid(pamh, (gid_t)max_uid);\n\t\t\t    strncpy(pl->login_group, grp->gr_name, sizeof(pl->login_group));\n\t\t\t    pl->login_group[sizeof(pl->login_group)-1] = '\\0';\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MIN:\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tpam_syslog(pamh, LOG_WARNING, \"range unsupported for %%group matching - ignored\");\n\t\t}\n            } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain, \"*\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n\t\t}\n\t    }\n\t} else if (i == 2 && ltype[0] == '-') { /* Probably a no-limit line */\n\t    if (strcmp(uname, domain) == 0) {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    } else if (domain[0] == '@') {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid < (gid_t)min_uid)\n\t\t\t    continue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"no limits for '%s' in group '%s'\",\n\t\t\t       uname, domain+1);\n\t\t}\n\t    } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tcontinue;  /* next line */\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    break;\n\t\t\tcontinue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    }\n\t    fclose(fil);\n\t    return PAM_IGNORE;\n        } else {\n            pam_syslog(pamh, LOG_WARNING, \"invalid line '%s' - skipped\", line);\n\t}\n    }\n    fclose(fil);\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x0001",
      "#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */",
      "#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */",
      "#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/",
      "#define LIMIT_RANGE_NONE    0 /* no range specified */",
      "#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */",
      "#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */",
      "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */",
      "#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */",
      "#define LIMITS_DEF_USER     0 /* limit was set by a user entry */",
      "#define LINE_LENGTH 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fil"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"invalid line '%s' - skipped\"",
            "line"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fil"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"no limits for '%s'\"",
            "uname"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"no limits for '%s' in group '%s'\"",
            "uname",
            "domain+1"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_gid",
          "args": [
            "pamh",
            "uname",
            "(gid_t)max_uid"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "uname",
            "domain+1"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"no limits for '%s'\"",
            "uname"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "domain"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_limit",
          "args": [
            "pamh",
            "LIMITS_DEF_USER",
            "ltype",
            "item",
            "value",
            "ctrl",
            "pl"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "process_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "530-810",
          "snippet": "static void\nprocess_limit (const pam_handle_t *pamh, int source, const char *lim_type,\n\t       const char *lim_item, const char *lim_value,\n\t       int ctrl, struct pam_limit_s *pl)\n{\n    int limit_item;\n    int limit_type = 0;\n    int int_value = 0;\n    rlim_t rlimit_value = 0;\n    char *endptr;\n    const char *value_orig = lim_value;\n\n    if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_DEBUG, \"%s: processing %s %s %s for %s\",\n\t\t    __FUNCTION__, lim_type, lim_item, lim_value,\n\t\t    limits_def_names[source]);\n\n    if (strcmp(lim_item, \"cpu\") == 0)\n        limit_item = RLIMIT_CPU;\n    else if (strcmp(lim_item, \"fsize\") == 0)\n        limit_item = RLIMIT_FSIZE;\n    else if (strcmp(lim_item, \"data\") == 0)\n\tlimit_item = RLIMIT_DATA;\n    else if (strcmp(lim_item, \"stack\") == 0)\n\tlimit_item = RLIMIT_STACK;\n    else if (strcmp(lim_item, \"core\") == 0)\n\tlimit_item = RLIMIT_CORE;\n    else if (strcmp(lim_item, \"rss\") == 0)\n\tlimit_item = RLIMIT_RSS;\n    else if (strcmp(lim_item, \"nproc\") == 0)\n\tlimit_item = RLIMIT_NPROC;\n    else if (strcmp(lim_item, \"nofile\") == 0)\n\tlimit_item = RLIMIT_NOFILE;\n    else if (strcmp(lim_item, \"memlock\") == 0)\n\tlimit_item = RLIMIT_MEMLOCK;\n#ifdef RLIMIT_AS\n    else if (strcmp(lim_item, \"as\") == 0)\n\tlimit_item = RLIMIT_AS;\n#endif /*RLIMIT_AS*/\n#ifdef RLIMIT_LOCKS\n    else if (strcmp(lim_item, \"locks\") == 0)\n\tlimit_item = RLIMIT_LOCKS;\n#endif\n#ifdef RLIMIT_SIGPENDING\n    else if (strcmp(lim_item, \"sigpending\") == 0)\n\tlimit_item = RLIMIT_SIGPENDING;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n    else if (strcmp(lim_item, \"msgqueue\") == 0)\n\tlimit_item = RLIMIT_MSGQUEUE;\n#endif\n#ifdef RLIMIT_NICE\n    else if (strcmp(lim_item, \"nice\") == 0)\n\tlimit_item = RLIMIT_NICE;\n#endif\n#ifdef RLIMIT_RTPRIO\n    else if (strcmp(lim_item, \"rtprio\") == 0)\n\tlimit_item = RLIMIT_RTPRIO;\n#endif\n    else if (strcmp(lim_item, \"maxlogins\") == 0) {\n\tlimit_item = LIMIT_LOGIN;\n\tpl->flag_numsyslogins = 0;\n    } else if (strcmp(lim_item, \"maxsyslogins\") == 0) {\n\tlimit_item = LIMIT_NUMSYSLOGINS;\n\tpl->flag_numsyslogins = 1;\n    } else if (strcmp(lim_item, \"priority\") == 0) {\n\tlimit_item = LIMIT_PRI;\n    } else if (strcmp(lim_item, \"nonewprivs\") == 0) {\n\tlimit_item = LIMIT_NONEWPRIVS;\n    } else {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit item '%s'\", lim_item);\n        return;\n    }\n\n    if (strcmp(lim_type,\"soft\")==0)\n\tlimit_type=LIMIT_SOFT;\n    else if (strcmp(lim_type, \"hard\")==0)\n\tlimit_type=LIMIT_HARD;\n    else if (strcmp(lim_type,\"-\")==0)\n\tlimit_type=LIMIT_SOFT | LIMIT_HARD;\n    else if (limit_item != LIMIT_LOGIN && limit_item != LIMIT_NUMSYSLOGINS\n\t\t&& limit_item != LIMIT_NONEWPRIVS) {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit type '%s'\", lim_type);\n        return;\n    }\n\tif (limit_item == LIMIT_NONEWPRIVS) {\n\t\t/* just require a bool-style 0 or 1 */\n\t\tif (strcmp(lim_value, \"0\") == 0) {\n\t\t\tint_value = 0;\n\t\t} else if (strcmp(lim_value, \"1\") == 0) {\n\t\t\tint_value = 1;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t}\n\t} else if (limit_item != LIMIT_PRI\n#ifdef RLIMIT_NICE\n\t    && limit_item != RLIMIT_NICE\n#endif\n\t    && (strcmp(lim_value, \"-1\") == 0\n\t\t|| strcmp(lim_value, \"-\") == 0 || strcmp(lim_value, \"unlimited\") == 0\n\t\t|| strcmp(lim_value, \"infinity\") == 0)) {\n\t\tint_value = -1;\n\t\trlimit_value = RLIM_INFINITY;\n\t} else if (limit_item == LIMIT_PRI || limit_item == LIMIT_LOGIN ||\n#ifdef RLIMIT_NICE\n\t\tlimit_item == RLIMIT_NICE ||\n#endif\n\t\tlimit_item == LIMIT_NUMSYSLOGINS) {\n\t\tlong temp;\n\t\ttemp = strtol (lim_value, &endptr, 10);\n\t\ttemp = temp < INT_MAX ? temp : INT_MAX;\n\t\tint_value = temp > INT_MIN ? temp : INT_MIN;\n\t\tif (int_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n            return;\n\t\t}\n\t} else {\n#ifdef __USE_FILE_OFFSET64\n\t\trlimit_value = strtoull (lim_value, &endptr, 10);\n#else\n\t\trlimit_value = strtoul (lim_value, &endptr, 10);\n#endif\n\t\tif (rlimit_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t\treturn;\n\t\t}\n\t}\n\n    /* one more special case when limiting logins */\n    if ((source == LIMITS_DEF_ALL || source == LIMITS_DEF_ALLGROUP)\n\t\t&& (limit_item != LIMIT_LOGIN)) {\n\tif (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"'%%' domain valid for maxlogins type only\");\n\treturn;\n    }\n\n    switch(limit_item) {\n        case RLIMIT_CPU:\n\t  if (rlimit_value != RLIM_INFINITY)\n\t    {\n\t      if (rlimit_value >= RLIM_INFINITY/60)\n\t\trlimit_value = RLIM_INFINITY;\n\t      else\n\t\trlimit_value *= 60;\n\t    }\n         break;\n        case RLIMIT_FSIZE:\n        case RLIMIT_DATA:\n        case RLIMIT_STACK:\n        case RLIMIT_CORE:\n        case RLIMIT_RSS:\n        case RLIMIT_MEMLOCK:\n#ifdef RLIMIT_AS\n        case RLIMIT_AS:\n#endif\n         if (rlimit_value != RLIM_INFINITY)\n\t   {\n\t     if (rlimit_value >= RLIM_INFINITY/1024)\n\t       rlimit_value = RLIM_INFINITY;\n\t     else\n\t       rlimit_value *= 1024;\n\t   }\n\t break;\n#ifdef RLIMIT_NICE\n\tcase RLIMIT_NICE:\n\t if (int_value > 19)\n\t    int_value = 19;\n\t if (int_value < -20)\n\t   int_value = -20;\n\t rlimit_value = 20 - int_value;\n         break;\n#endif\n\tcase RLIMIT_NOFILE:\n\t/*\n\t * If nofile is to be set to \"unlimited\", try to set it to\n\t * the value in /proc/sys/fs/nr_open instead.\n\t */\n\tif (rlimit_value == RLIM_INFINITY) {\n\t    if (!value_from_file(\"/proc/sys/fs/nr_open\", &rlimit_value))\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t   \"Cannot set \\\"nofile\\\" to a sensible value\");\n\t    else if (ctrl & PAM_DEBUG_ARG)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Setting \\\"nofile\\\" limit to %llu\",\n\t\t\t   (unsigned long long) rlimit_value);\n\t}\n\tbreak;\n    }\n\n    if ( (limit_item != LIMIT_LOGIN)\n\t && (limit_item != LIMIT_NUMSYSLOGINS)\n\t && (limit_item != LIMIT_PRI)\n\t && (limit_item != LIMIT_NONEWPRIVS) ) {\n        if (limit_type & LIMIT_SOFT) {\n\t    if (pl->limits[limit_item].src_soft < source) {\n                return;\n\t    } else {\n                pl->limits[limit_item].limit.rlim_cur = rlimit_value;\n                pl->limits[limit_item].src_soft = source;\n            }\n\t}\n        if (limit_type & LIMIT_HARD) {\n\t    if (pl->limits[limit_item].src_hard < source) {\n                return;\n            } else {\n                pl->limits[limit_item].limit.rlim_max = rlimit_value;\n                pl->limits[limit_item].src_hard = source;\n            }\n\t}\n    } else {\n\t/* recent kernels support negative priority limits (=raise priority) */\n\n\tif (limit_item == LIMIT_PRI) {\n\t    pl->priority = int_value;\n\t} else if (limit_item == LIMIT_NONEWPRIVS) {\n\t    pl->nonewprivs = int_value;\n\t} else {\n\t    if (pl->login_limit_def < source) {\n\t\treturn;\n\t    } else {\n\t\tpl->login_limit = int_value;\n\t\tpl->login_limit_def = source;\n\t    }\n\t}\n    }\n    return;\n}\n\nstatic int\nparse_uid_range(pam_handle_t *pamh, const char *domain,\n\t\tuid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = domain;\n    char *pmax;\n    char *endptr;\n    int rv = LIMIT_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n\treturn LIMIT_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == '@' || range[0] == '%')\n\t++range;\n\n    if (range[0] == ':')\n\trv = LIMIT_RANGE_ONE;\n    else {\n\t    errno = 0;\n\t    *min_uid = strtoul (range, &endptr, 10);\n\t    if (errno != 0 || (range == endptr) || *endptr != ':') {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"wrong min_uid/gid value in '%s'\", domain);\n\t\treturn LIMIT_RANGE_ERR;\n\t    }\n    }\n\n    if (*pmax == '\\0') {\n\tif (rv == LIMIT_RANGE_ONE)\n\t    return LIMIT_RANGE_ERR;\n\telse\n\t    return LIMIT_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t   \"wrong max_uid/gid value in '%s'\", domain);\n\treturn LIMIT_RANGE_ERR;\n    }\n\n    if (rv == LIMIT_RANGE_ONE)\n\t*min_uid = *max_uid;\n    return rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x0001",
            "#define LIMIT_HARD  2",
            "#define LIMIT_SOFT  1",
            "#define LIMIT_NONEWPRIVS RLIM_NLIMITS+4",
            "#define LIMIT_PRI RLIM_NLIMITS+3",
            "#define LIMIT_NUMSYSLOGINS RLIM_NLIMITS+2",
            "#define LIMIT_LOGIN RLIM_NLIMITS+1",
            "#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */",
            "#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */",
            "#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/",
            "#define LIMIT_RANGE_NONE    0 /* no range specified */",
            "#define LIMIT_RANGE_ERR    -1 /* error in specified uid/gid range */",
            "#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */",
            "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */"
          ],
          "globals_used": [
            "static const char *limits_def_names[] = {\n       \"USER\",\n       \"GROUP\",\n       \"ALLGROUP\",\n       \"ALL\",\n       \"DEFAULT\",\n       \"KERNEL\",\n       \"NONE\",\n       NULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x0001\n#define LIMIT_HARD  2\n#define LIMIT_SOFT  1\n#define LIMIT_NONEWPRIVS RLIM_NLIMITS+4\n#define LIMIT_PRI RLIM_NLIMITS+3\n#define LIMIT_NUMSYSLOGINS RLIM_NLIMITS+2\n#define LIMIT_LOGIN RLIM_NLIMITS+1\n#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */\n#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */\n#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/\n#define LIMIT_RANGE_NONE    0 /* no range specified */\n#define LIMIT_RANGE_ERR    -1 /* error in specified uid/gid range */\n#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n\nstatic const char *limits_def_names[] = {\n       \"USER\",\n       \"GROUP\",\n       \"ALLGROUP\",\n       \"ALL\",\n       \"DEFAULT\",\n       \"KERNEL\",\n       \"NONE\",\n       NULL\n};\n\nstatic void\nprocess_limit (const pam_handle_t *pamh, int source, const char *lim_type,\n\t       const char *lim_item, const char *lim_value,\n\t       int ctrl, struct pam_limit_s *pl)\n{\n    int limit_item;\n    int limit_type = 0;\n    int int_value = 0;\n    rlim_t rlimit_value = 0;\n    char *endptr;\n    const char *value_orig = lim_value;\n\n    if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_DEBUG, \"%s: processing %s %s %s for %s\",\n\t\t    __FUNCTION__, lim_type, lim_item, lim_value,\n\t\t    limits_def_names[source]);\n\n    if (strcmp(lim_item, \"cpu\") == 0)\n        limit_item = RLIMIT_CPU;\n    else if (strcmp(lim_item, \"fsize\") == 0)\n        limit_item = RLIMIT_FSIZE;\n    else if (strcmp(lim_item, \"data\") == 0)\n\tlimit_item = RLIMIT_DATA;\n    else if (strcmp(lim_item, \"stack\") == 0)\n\tlimit_item = RLIMIT_STACK;\n    else if (strcmp(lim_item, \"core\") == 0)\n\tlimit_item = RLIMIT_CORE;\n    else if (strcmp(lim_item, \"rss\") == 0)\n\tlimit_item = RLIMIT_RSS;\n    else if (strcmp(lim_item, \"nproc\") == 0)\n\tlimit_item = RLIMIT_NPROC;\n    else if (strcmp(lim_item, \"nofile\") == 0)\n\tlimit_item = RLIMIT_NOFILE;\n    else if (strcmp(lim_item, \"memlock\") == 0)\n\tlimit_item = RLIMIT_MEMLOCK;\n#ifdef RLIMIT_AS\n    else if (strcmp(lim_item, \"as\") == 0)\n\tlimit_item = RLIMIT_AS;\n#endif /*RLIMIT_AS*/\n#ifdef RLIMIT_LOCKS\n    else if (strcmp(lim_item, \"locks\") == 0)\n\tlimit_item = RLIMIT_LOCKS;\n#endif\n#ifdef RLIMIT_SIGPENDING\n    else if (strcmp(lim_item, \"sigpending\") == 0)\n\tlimit_item = RLIMIT_SIGPENDING;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n    else if (strcmp(lim_item, \"msgqueue\") == 0)\n\tlimit_item = RLIMIT_MSGQUEUE;\n#endif\n#ifdef RLIMIT_NICE\n    else if (strcmp(lim_item, \"nice\") == 0)\n\tlimit_item = RLIMIT_NICE;\n#endif\n#ifdef RLIMIT_RTPRIO\n    else if (strcmp(lim_item, \"rtprio\") == 0)\n\tlimit_item = RLIMIT_RTPRIO;\n#endif\n    else if (strcmp(lim_item, \"maxlogins\") == 0) {\n\tlimit_item = LIMIT_LOGIN;\n\tpl->flag_numsyslogins = 0;\n    } else if (strcmp(lim_item, \"maxsyslogins\") == 0) {\n\tlimit_item = LIMIT_NUMSYSLOGINS;\n\tpl->flag_numsyslogins = 1;\n    } else if (strcmp(lim_item, \"priority\") == 0) {\n\tlimit_item = LIMIT_PRI;\n    } else if (strcmp(lim_item, \"nonewprivs\") == 0) {\n\tlimit_item = LIMIT_NONEWPRIVS;\n    } else {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit item '%s'\", lim_item);\n        return;\n    }\n\n    if (strcmp(lim_type,\"soft\")==0)\n\tlimit_type=LIMIT_SOFT;\n    else if (strcmp(lim_type, \"hard\")==0)\n\tlimit_type=LIMIT_HARD;\n    else if (strcmp(lim_type,\"-\")==0)\n\tlimit_type=LIMIT_SOFT | LIMIT_HARD;\n    else if (limit_item != LIMIT_LOGIN && limit_item != LIMIT_NUMSYSLOGINS\n\t\t&& limit_item != LIMIT_NONEWPRIVS) {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit type '%s'\", lim_type);\n        return;\n    }\n\tif (limit_item == LIMIT_NONEWPRIVS) {\n\t\t/* just require a bool-style 0 or 1 */\n\t\tif (strcmp(lim_value, \"0\") == 0) {\n\t\t\tint_value = 0;\n\t\t} else if (strcmp(lim_value, \"1\") == 0) {\n\t\t\tint_value = 1;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t}\n\t} else if (limit_item != LIMIT_PRI\n#ifdef RLIMIT_NICE\n\t    && limit_item != RLIMIT_NICE\n#endif\n\t    && (strcmp(lim_value, \"-1\") == 0\n\t\t|| strcmp(lim_value, \"-\") == 0 || strcmp(lim_value, \"unlimited\") == 0\n\t\t|| strcmp(lim_value, \"infinity\") == 0)) {\n\t\tint_value = -1;\n\t\trlimit_value = RLIM_INFINITY;\n\t} else if (limit_item == LIMIT_PRI || limit_item == LIMIT_LOGIN ||\n#ifdef RLIMIT_NICE\n\t\tlimit_item == RLIMIT_NICE ||\n#endif\n\t\tlimit_item == LIMIT_NUMSYSLOGINS) {\n\t\tlong temp;\n\t\ttemp = strtol (lim_value, &endptr, 10);\n\t\ttemp = temp < INT_MAX ? temp : INT_MAX;\n\t\tint_value = temp > INT_MIN ? temp : INT_MIN;\n\t\tif (int_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n            return;\n\t\t}\n\t} else {\n#ifdef __USE_FILE_OFFSET64\n\t\trlimit_value = strtoull (lim_value, &endptr, 10);\n#else\n\t\trlimit_value = strtoul (lim_value, &endptr, 10);\n#endif\n\t\tif (rlimit_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t\treturn;\n\t\t}\n\t}\n\n    /* one more special case when limiting logins */\n    if ((source == LIMITS_DEF_ALL || source == LIMITS_DEF_ALLGROUP)\n\t\t&& (limit_item != LIMIT_LOGIN)) {\n\tif (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"'%%' domain valid for maxlogins type only\");\n\treturn;\n    }\n\n    switch(limit_item) {\n        case RLIMIT_CPU:\n\t  if (rlimit_value != RLIM_INFINITY)\n\t    {\n\t      if (rlimit_value >= RLIM_INFINITY/60)\n\t\trlimit_value = RLIM_INFINITY;\n\t      else\n\t\trlimit_value *= 60;\n\t    }\n         break;\n        case RLIMIT_FSIZE:\n        case RLIMIT_DATA:\n        case RLIMIT_STACK:\n        case RLIMIT_CORE:\n        case RLIMIT_RSS:\n        case RLIMIT_MEMLOCK:\n#ifdef RLIMIT_AS\n        case RLIMIT_AS:\n#endif\n         if (rlimit_value != RLIM_INFINITY)\n\t   {\n\t     if (rlimit_value >= RLIM_INFINITY/1024)\n\t       rlimit_value = RLIM_INFINITY;\n\t     else\n\t       rlimit_value *= 1024;\n\t   }\n\t break;\n#ifdef RLIMIT_NICE\n\tcase RLIMIT_NICE:\n\t if (int_value > 19)\n\t    int_value = 19;\n\t if (int_value < -20)\n\t   int_value = -20;\n\t rlimit_value = 20 - int_value;\n         break;\n#endif\n\tcase RLIMIT_NOFILE:\n\t/*\n\t * If nofile is to be set to \"unlimited\", try to set it to\n\t * the value in /proc/sys/fs/nr_open instead.\n\t */\n\tif (rlimit_value == RLIM_INFINITY) {\n\t    if (!value_from_file(\"/proc/sys/fs/nr_open\", &rlimit_value))\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t   \"Cannot set \\\"nofile\\\" to a sensible value\");\n\t    else if (ctrl & PAM_DEBUG_ARG)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Setting \\\"nofile\\\" limit to %llu\",\n\t\t\t   (unsigned long long) rlimit_value);\n\t}\n\tbreak;\n    }\n\n    if ( (limit_item != LIMIT_LOGIN)\n\t && (limit_item != LIMIT_NUMSYSLOGINS)\n\t && (limit_item != LIMIT_PRI)\n\t && (limit_item != LIMIT_NONEWPRIVS) ) {\n        if (limit_type & LIMIT_SOFT) {\n\t    if (pl->limits[limit_item].src_soft < source) {\n                return;\n\t    } else {\n                pl->limits[limit_item].limit.rlim_cur = rlimit_value;\n                pl->limits[limit_item].src_soft = source;\n            }\n\t}\n        if (limit_type & LIMIT_HARD) {\n\t    if (pl->limits[limit_item].src_hard < source) {\n                return;\n            } else {\n                pl->limits[limit_item].limit.rlim_max = rlimit_value;\n                pl->limits[limit_item].src_hard = source;\n            }\n\t}\n    } else {\n\t/* recent kernels support negative priority limits (=raise priority) */\n\n\tif (limit_item == LIMIT_PRI) {\n\t    pl->priority = int_value;\n\t} else if (limit_item == LIMIT_NONEWPRIVS) {\n\t    pl->nonewprivs = int_value;\n\t} else {\n\t    if (pl->login_limit_def < source) {\n\t\treturn;\n\t    } else {\n\t\tpl->login_limit = int_value;\n\t\tpl->login_limit_def = source;\n\t    }\n\t}\n    }\n    return;\n}\n\nstatic int\nparse_uid_range(pam_handle_t *pamh, const char *domain,\n\t\tuid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = domain;\n    char *pmax;\n    char *endptr;\n    int rv = LIMIT_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n\treturn LIMIT_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == '@' || range[0] == '%')\n\t++range;\n\n    if (range[0] == ':')\n\trv = LIMIT_RANGE_ONE;\n    else {\n\t    errno = 0;\n\t    *min_uid = strtoul (range, &endptr, 10);\n\t    if (errno != 0 || (range == endptr) || *endptr != ':') {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"wrong min_uid/gid value in '%s'\", domain);\n\t\treturn LIMIT_RANGE_ERR;\n\t    }\n    }\n\n    if (*pmax == '\\0') {\n\tif (rv == LIMIT_RANGE_ONE)\n\t    return LIMIT_RANGE_ERR;\n\telse\n\t    return LIMIT_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t   \"wrong max_uid/gid value in '%s'\", domain);\n\treturn LIMIT_RANGE_ERR;\n    }\n\n    if (rv == LIMIT_RANGE_ONE)\n\t*min_uid = *max_uid;\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domain",
            "\"*\""
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"range unsupported for %%group matching - ignored\""
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pl->login_group",
            "grp->gr_name",
            "sizeof(pl->login_group)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getgrgid",
          "args": [
            "pamh",
            "(gid_t)max_uid"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_gid",
          "args": [
            "pamh",
            "uname",
            "(gid_t)max_uid"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "pl->login_group",
            "domain+1"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "uname",
            "domain+1"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domain",
            "\"%\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"checking if %s is in group %s\"",
            "uname",
            "domain + 1"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_gid",
          "args": [
            "pamh",
            "uname",
            "(gid_t)max_uid"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "uname",
            "domain+1"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"checking if %s is in group %s\"",
            "uname",
            "domain + 1"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "domain"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "value[j]"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "item[j]"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "item"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"invalid uid range '%s' - skipped\"",
            "domain"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_uid_range",
          "args": [
            "pamh",
            "domain",
            "&min_uid",
            "&max_uid"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uid_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "208-251",
          "snippet": "static enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "ltype[j]"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ltype"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"scanned line[%d]: domain[%s], ltype[%s], item[%s], value[%s]\",\n\t   i, domain, ltype, item, value)"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%s%s%s%s\"",
            "domain",
            "ltype",
            "item",
            "value"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'#'"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*line"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "LINE_LENGTH",
            "fil"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"cannot read settings from %s: %s\"",
            "CONF_FILE",
            "strerror(err)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "err"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "VENDOR_SCONFIGDIR \"/limits.conf\"",
            "\"r\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "CONF_FILE",
            "\"r\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"reading settings from '%s'\"",
            "CONF_FILE"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x0001\n#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */\n#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */\n#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/\n#define LIMIT_RANGE_NONE    0 /* no range specified */\n#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */\n#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */\n#define LIMITS_DEF_USER     0 /* limit was set by a user entry */\n#define LINE_LENGTH 1024\n\nstatic int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n\t\t\t     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH];\n\n    /* check for the CONF_FILE */\n    if (ctrl & PAM_DEBUG_ARG)\n        pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);\n    fil = fopen(CONF_FILE, \"r\");\n    if (fil == NULL) {\n      int err = errno;\n\n#ifdef VENDOR_SCONFIGDIR\n      /* if the specified file does not exist, and it is not provided by\n         the user, try the vendor file as fallback. */\n      if (pl->conf_file == NULL && err == ENOENT)\n        fil = fopen(VENDOR_SCONFIGDIR \"/limits.conf\", \"r\");\n\n      if (fil == NULL)\n#endif\n        {\n          if (err == ENOENT)\n            return PAM_SUCCESS;\n\n          pam_syslog (pamh, LOG_WARNING,\n                      \"cannot read settings from %s: %s\", CONF_FILE,\n                      strerror(err));\n          return PAM_SERVICE_ERR;\n        }\n    }\n\n    /* start the show */\n    while (fgets(buf, LINE_LENGTH, fil) != NULL) {\n        char domain[LINE_LENGTH];\n        char ltype[LINE_LENGTH];\n        char item[LINE_LENGTH];\n        char value[LINE_LENGTH];\n        int i;\n        int rngtype;\n        size_t j;\n        char *tptr,*line;\n        uid_t min_uid = (uid_t)-1, max_uid = (uid_t)-1;\n\n        line = buf;\n        /* skip the leading white space */\n        while (*line && isspace(*line))\n            line++;\n\n        /* Rip off the comments */\n        tptr = strchr(line,'#');\n        if (tptr)\n            *tptr = '\\0';\n        /* Rip off the newline char */\n        tptr = strchr(line,'\\n');\n        if (tptr)\n            *tptr = '\\0';\n        /* Anything left ? */\n        if (!strlen(line))\n            continue;\n\n\tdomain[0] = ltype[0] = item[0] = value[0] = '\\0';\n\n\ti = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value);\n\tD((\"scanned line[%d]: domain[%s], ltype[%s], item[%s], value[%s]\",\n\t   i, domain, ltype, item, value));\n\n        for(j=0; j < strlen(ltype); j++)\n            ltype[j]=tolower(ltype[j]);\n\n\tif ((rngtype=parse_uid_range(pamh, domain, &min_uid, &max_uid)) < 0) {\n\t    pam_syslog(pamh, LOG_WARNING, \"invalid uid range '%s' - skipped\", domain);\n\t    continue;\n\t}\n\n        if (i == 4) { /* a complete line */\n\t    for(j=0; j < strlen(item); j++)\n\t\titem[j]=tolower(item[j]);\n\t    for(j=0; j < strlen(value); j++)\n\t\tvalue[j]=tolower(value[j]);\n\n            if (strcmp(uname, domain) == 0) /* this user have a limit */\n                process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n            else if (domain[0]=='@') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid >= (gid_t)min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_GROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t}\n            } else if (domain[0]=='%') {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"checking if %s is in group %s\",\n\t\t\t\t   uname, domain + 1);\n\t\t}\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain,\"%\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALL, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\telse if (pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1)) {\n\t\t\t    strcpy(pl->login_group, domain+1);\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid)) {\n\t\t\t    struct group *grp;\n\t\t\t    grp = pam_modutil_getgrgid(pamh, (gid_t)max_uid);\n\t\t\t    strncpy(pl->login_group, grp->gr_name, sizeof(pl->login_group));\n\t\t\t    pl->login_group[sizeof(pl->login_group)-1] = '\\0';\n\t\t\t    process_limit(pamh, LIMITS_DEF_ALLGROUP, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MIN:\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tpam_syslog(pamh, LOG_WARNING, \"range unsupported for %%group matching - ignored\");\n\t\t}\n            } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (strcmp(domain, \"*\") == 0)\n\t\t\t    process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl,\n\t\t\t\t\t  pl);\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    break;\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n\t\t}\n\t    }\n\t} else if (i == 2 && ltype[0] == '-') { /* Probably a no-limit line */\n\t    if (strcmp(uname, domain) == 0) {\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    } else if (domain[0] == '@') {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_nam(pamh, uname, domain+1))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (!pam_modutil_user_in_group_nam_gid(pamh, uname, (gid_t)max_uid))\n\t\t\t    continue; /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (gid > (gid_t)max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (gid < (gid_t)min_uid)\n\t\t\t    continue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"no limits for '%s' in group '%s'\",\n\t\t\t       uname, domain+1);\n\t\t}\n\t    } else {\n\t\tswitch(rngtype) {\n\t\t    case LIMIT_RANGE_NONE:\n\t\t\tcontinue;  /* next line */\n\t\t    case LIMIT_RANGE_ONE:\n\t\t\tif (uid != max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\tbreak;\n\t\t    case LIMIT_RANGE_MM:\n\t\t\tif (uid > max_uid)\n\t\t\t    continue;  /* next line */\n\t\t\t/* fallthrough */\n\t\t    case LIMIT_RANGE_MIN:\n\t\t\tif (uid >= min_uid)\n\t\t\t    break;\n\t\t\tcontinue;  /* next line */\n\t\t}\n\t\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG, \"no limits for '%s'\", uname);\n\t\t}\n\t    }\n\t    fclose(fil);\n\t    return PAM_IGNORE;\n        } else {\n            pam_syslog(pamh, LOG_WARNING, \"invalid line '%s' - skipped\", line);\n\t}\n    }\n    fclose(fil);\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "process_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "530-810",
    "snippet": "static void\nprocess_limit (const pam_handle_t *pamh, int source, const char *lim_type,\n\t       const char *lim_item, const char *lim_value,\n\t       int ctrl, struct pam_limit_s *pl)\n{\n    int limit_item;\n    int limit_type = 0;\n    int int_value = 0;\n    rlim_t rlimit_value = 0;\n    char *endptr;\n    const char *value_orig = lim_value;\n\n    if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_DEBUG, \"%s: processing %s %s %s for %s\",\n\t\t    __FUNCTION__, lim_type, lim_item, lim_value,\n\t\t    limits_def_names[source]);\n\n    if (strcmp(lim_item, \"cpu\") == 0)\n        limit_item = RLIMIT_CPU;\n    else if (strcmp(lim_item, \"fsize\") == 0)\n        limit_item = RLIMIT_FSIZE;\n    else if (strcmp(lim_item, \"data\") == 0)\n\tlimit_item = RLIMIT_DATA;\n    else if (strcmp(lim_item, \"stack\") == 0)\n\tlimit_item = RLIMIT_STACK;\n    else if (strcmp(lim_item, \"core\") == 0)\n\tlimit_item = RLIMIT_CORE;\n    else if (strcmp(lim_item, \"rss\") == 0)\n\tlimit_item = RLIMIT_RSS;\n    else if (strcmp(lim_item, \"nproc\") == 0)\n\tlimit_item = RLIMIT_NPROC;\n    else if (strcmp(lim_item, \"nofile\") == 0)\n\tlimit_item = RLIMIT_NOFILE;\n    else if (strcmp(lim_item, \"memlock\") == 0)\n\tlimit_item = RLIMIT_MEMLOCK;\n#ifdef RLIMIT_AS\n    else if (strcmp(lim_item, \"as\") == 0)\n\tlimit_item = RLIMIT_AS;\n#endif /*RLIMIT_AS*/\n#ifdef RLIMIT_LOCKS\n    else if (strcmp(lim_item, \"locks\") == 0)\n\tlimit_item = RLIMIT_LOCKS;\n#endif\n#ifdef RLIMIT_SIGPENDING\n    else if (strcmp(lim_item, \"sigpending\") == 0)\n\tlimit_item = RLIMIT_SIGPENDING;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n    else if (strcmp(lim_item, \"msgqueue\") == 0)\n\tlimit_item = RLIMIT_MSGQUEUE;\n#endif\n#ifdef RLIMIT_NICE\n    else if (strcmp(lim_item, \"nice\") == 0)\n\tlimit_item = RLIMIT_NICE;\n#endif\n#ifdef RLIMIT_RTPRIO\n    else if (strcmp(lim_item, \"rtprio\") == 0)\n\tlimit_item = RLIMIT_RTPRIO;\n#endif\n    else if (strcmp(lim_item, \"maxlogins\") == 0) {\n\tlimit_item = LIMIT_LOGIN;\n\tpl->flag_numsyslogins = 0;\n    } else if (strcmp(lim_item, \"maxsyslogins\") == 0) {\n\tlimit_item = LIMIT_NUMSYSLOGINS;\n\tpl->flag_numsyslogins = 1;\n    } else if (strcmp(lim_item, \"priority\") == 0) {\n\tlimit_item = LIMIT_PRI;\n    } else if (strcmp(lim_item, \"nonewprivs\") == 0) {\n\tlimit_item = LIMIT_NONEWPRIVS;\n    } else {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit item '%s'\", lim_item);\n        return;\n    }\n\n    if (strcmp(lim_type,\"soft\")==0)\n\tlimit_type=LIMIT_SOFT;\n    else if (strcmp(lim_type, \"hard\")==0)\n\tlimit_type=LIMIT_HARD;\n    else if (strcmp(lim_type,\"-\")==0)\n\tlimit_type=LIMIT_SOFT | LIMIT_HARD;\n    else if (limit_item != LIMIT_LOGIN && limit_item != LIMIT_NUMSYSLOGINS\n\t\t&& limit_item != LIMIT_NONEWPRIVS) {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit type '%s'\", lim_type);\n        return;\n    }\n\tif (limit_item == LIMIT_NONEWPRIVS) {\n\t\t/* just require a bool-style 0 or 1 */\n\t\tif (strcmp(lim_value, \"0\") == 0) {\n\t\t\tint_value = 0;\n\t\t} else if (strcmp(lim_value, \"1\") == 0) {\n\t\t\tint_value = 1;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t}\n\t} else if (limit_item != LIMIT_PRI\n#ifdef RLIMIT_NICE\n\t    && limit_item != RLIMIT_NICE\n#endif\n\t    && (strcmp(lim_value, \"-1\") == 0\n\t\t|| strcmp(lim_value, \"-\") == 0 || strcmp(lim_value, \"unlimited\") == 0\n\t\t|| strcmp(lim_value, \"infinity\") == 0)) {\n\t\tint_value = -1;\n\t\trlimit_value = RLIM_INFINITY;\n\t} else if (limit_item == LIMIT_PRI || limit_item == LIMIT_LOGIN ||\n#ifdef RLIMIT_NICE\n\t\tlimit_item == RLIMIT_NICE ||\n#endif\n\t\tlimit_item == LIMIT_NUMSYSLOGINS) {\n\t\tlong temp;\n\t\ttemp = strtol (lim_value, &endptr, 10);\n\t\ttemp = temp < INT_MAX ? temp : INT_MAX;\n\t\tint_value = temp > INT_MIN ? temp : INT_MIN;\n\t\tif (int_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n            return;\n\t\t}\n\t} else {\n#ifdef __USE_FILE_OFFSET64\n\t\trlimit_value = strtoull (lim_value, &endptr, 10);\n#else\n\t\trlimit_value = strtoul (lim_value, &endptr, 10);\n#endif\n\t\tif (rlimit_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t\treturn;\n\t\t}\n\t}\n\n    /* one more special case when limiting logins */\n    if ((source == LIMITS_DEF_ALL || source == LIMITS_DEF_ALLGROUP)\n\t\t&& (limit_item != LIMIT_LOGIN)) {\n\tif (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"'%%' domain valid for maxlogins type only\");\n\treturn;\n    }\n\n    switch(limit_item) {\n        case RLIMIT_CPU:\n\t  if (rlimit_value != RLIM_INFINITY)\n\t    {\n\t      if (rlimit_value >= RLIM_INFINITY/60)\n\t\trlimit_value = RLIM_INFINITY;\n\t      else\n\t\trlimit_value *= 60;\n\t    }\n         break;\n        case RLIMIT_FSIZE:\n        case RLIMIT_DATA:\n        case RLIMIT_STACK:\n        case RLIMIT_CORE:\n        case RLIMIT_RSS:\n        case RLIMIT_MEMLOCK:\n#ifdef RLIMIT_AS\n        case RLIMIT_AS:\n#endif\n         if (rlimit_value != RLIM_INFINITY)\n\t   {\n\t     if (rlimit_value >= RLIM_INFINITY/1024)\n\t       rlimit_value = RLIM_INFINITY;\n\t     else\n\t       rlimit_value *= 1024;\n\t   }\n\t break;\n#ifdef RLIMIT_NICE\n\tcase RLIMIT_NICE:\n\t if (int_value > 19)\n\t    int_value = 19;\n\t if (int_value < -20)\n\t   int_value = -20;\n\t rlimit_value = 20 - int_value;\n         break;\n#endif\n\tcase RLIMIT_NOFILE:\n\t/*\n\t * If nofile is to be set to \"unlimited\", try to set it to\n\t * the value in /proc/sys/fs/nr_open instead.\n\t */\n\tif (rlimit_value == RLIM_INFINITY) {\n\t    if (!value_from_file(\"/proc/sys/fs/nr_open\", &rlimit_value))\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t   \"Cannot set \\\"nofile\\\" to a sensible value\");\n\t    else if (ctrl & PAM_DEBUG_ARG)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Setting \\\"nofile\\\" limit to %llu\",\n\t\t\t   (unsigned long long) rlimit_value);\n\t}\n\tbreak;\n    }\n\n    if ( (limit_item != LIMIT_LOGIN)\n\t && (limit_item != LIMIT_NUMSYSLOGINS)\n\t && (limit_item != LIMIT_PRI)\n\t && (limit_item != LIMIT_NONEWPRIVS) ) {\n        if (limit_type & LIMIT_SOFT) {\n\t    if (pl->limits[limit_item].src_soft < source) {\n                return;\n\t    } else {\n                pl->limits[limit_item].limit.rlim_cur = rlimit_value;\n                pl->limits[limit_item].src_soft = source;\n            }\n\t}\n        if (limit_type & LIMIT_HARD) {\n\t    if (pl->limits[limit_item].src_hard < source) {\n                return;\n            } else {\n                pl->limits[limit_item].limit.rlim_max = rlimit_value;\n                pl->limits[limit_item].src_hard = source;\n            }\n\t}\n    } else {\n\t/* recent kernels support negative priority limits (=raise priority) */\n\n\tif (limit_item == LIMIT_PRI) {\n\t    pl->priority = int_value;\n\t} else if (limit_item == LIMIT_NONEWPRIVS) {\n\t    pl->nonewprivs = int_value;\n\t} else {\n\t    if (pl->login_limit_def < source) {\n\t\treturn;\n\t    } else {\n\t\tpl->login_limit = int_value;\n\t\tpl->login_limit_def = source;\n\t    }\n\t}\n    }\n    return;\n}\n\nstatic int\nparse_uid_range(pam_handle_t *pamh, const char *domain,\n\t\tuid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = domain;\n    char *pmax;\n    char *endptr;\n    int rv = LIMIT_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n\treturn LIMIT_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == '@' || range[0] == '%')\n\t++range;\n\n    if (range[0] == ':')\n\trv = LIMIT_RANGE_ONE;\n    else {\n\t    errno = 0;\n\t    *min_uid = strtoul (range, &endptr, 10);\n\t    if (errno != 0 || (range == endptr) || *endptr != ':') {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"wrong min_uid/gid value in '%s'\", domain);\n\t\treturn LIMIT_RANGE_ERR;\n\t    }\n    }\n\n    if (*pmax == '\\0') {\n\tif (rv == LIMIT_RANGE_ONE)\n\t    return LIMIT_RANGE_ERR;\n\telse\n\t    return LIMIT_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t   \"wrong max_uid/gid value in '%s'\", domain);\n\treturn LIMIT_RANGE_ERR;\n    }\n\n    if (rv == LIMIT_RANGE_ONE)\n\t*min_uid = *max_uid;\n    return rv;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x0001",
      "#define LIMIT_HARD  2",
      "#define LIMIT_SOFT  1",
      "#define LIMIT_NONEWPRIVS RLIM_NLIMITS+4",
      "#define LIMIT_PRI RLIM_NLIMITS+3",
      "#define LIMIT_NUMSYSLOGINS RLIM_NLIMITS+2",
      "#define LIMIT_LOGIN RLIM_NLIMITS+1",
      "#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */",
      "#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */",
      "#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/",
      "#define LIMIT_RANGE_NONE    0 /* no range specified */",
      "#define LIMIT_RANGE_ERR    -1 /* error in specified uid/gid range */",
      "#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */",
      "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */"
    ],
    "globals_used": [
      "static const char *limits_def_names[] = {\n       \"USER\",\n       \"GROUP\",\n       \"ALLGROUP\",\n       \"ALL\",\n       \"DEFAULT\",\n       \"KERNEL\",\n       \"NONE\",\n       NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong max_uid/gid value in '%s'\"",
            "domain"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "pmax",
            "&endptr",
            "10"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong min_uid/gid value in '%s'\"",
            "domain"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "range",
            "&endptr",
            "10"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_uid_range",
          "args": [
            "pam_handle_t *pamh",
            "const char *domain",
            "uid_t *min_uid",
            "uid_t *max_uid"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uid_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "208-251",
          "snippet": "static enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Setting \\\"nofile\\\" limitto %llu\"",
            "(unsigned long long)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Cannot set \\\"nofile\\\"to"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLIMIT_NOFILE",
          "args": [
            "rlimit_value == RLIM_INFINITY"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLIMIT_NICE",
          "args": [
            "int_value > 19"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLIMIT_AS",
          "args": [
            "rlimit_value != RLIM_INFINITY"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLIMIT_CPU",
          "args": [
            "rlimit_value != RLIM_INFINITY"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"'%%'"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong limit value'%s'"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "lim_value",
            "&endptr",
            "10"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "lim_value",
            "&endptr",
            "10"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong limit value'%s'"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "lim_value",
            "&endptr",
            "10"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"unknown limit type'%s'\"",
            "lim_type"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"unknown limit item '%s'\"",
            "lim_item"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"memlock\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"nofile\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"nproc\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"rss\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"core\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"stack\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"data\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"fsize\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lim_item",
            "\"cpu\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s: processing %s %s %s for %s\"",
            "__FUNCTION__",
            "lim_type",
            "lim_item",
            "lim_value",
            "limits_def_names[source]"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x0001\n#define LIMIT_HARD  2\n#define LIMIT_SOFT  1\n#define LIMIT_NONEWPRIVS RLIM_NLIMITS+4\n#define LIMIT_PRI RLIM_NLIMITS+3\n#define LIMIT_NUMSYSLOGINS RLIM_NLIMITS+2\n#define LIMIT_LOGIN RLIM_NLIMITS+1\n#define LIMIT_RANGE_MM      3 /* both min and max uid/gid specified (min_uid:max_uid) */\n#define LIMIT_RANGE_MIN     2 /* only minimum uid/gid specified (min_uid:) */\n#define LIMIT_RANGE_ONE     1 /* exact uid/gid specified (:max_uid)*/\n#define LIMIT_RANGE_NONE    0 /* no range specified */\n#define LIMIT_RANGE_ERR    -1 /* error in specified uid/gid range */\n#define LIMITS_DEF_ALL      3 /* limit was set by an all entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n\nstatic const char *limits_def_names[] = {\n       \"USER\",\n       \"GROUP\",\n       \"ALLGROUP\",\n       \"ALL\",\n       \"DEFAULT\",\n       \"KERNEL\",\n       \"NONE\",\n       NULL\n};\n\nstatic void\nprocess_limit (const pam_handle_t *pamh, int source, const char *lim_type,\n\t       const char *lim_item, const char *lim_value,\n\t       int ctrl, struct pam_limit_s *pl)\n{\n    int limit_item;\n    int limit_type = 0;\n    int int_value = 0;\n    rlim_t rlimit_value = 0;\n    char *endptr;\n    const char *value_orig = lim_value;\n\n    if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_DEBUG, \"%s: processing %s %s %s for %s\",\n\t\t    __FUNCTION__, lim_type, lim_item, lim_value,\n\t\t    limits_def_names[source]);\n\n    if (strcmp(lim_item, \"cpu\") == 0)\n        limit_item = RLIMIT_CPU;\n    else if (strcmp(lim_item, \"fsize\") == 0)\n        limit_item = RLIMIT_FSIZE;\n    else if (strcmp(lim_item, \"data\") == 0)\n\tlimit_item = RLIMIT_DATA;\n    else if (strcmp(lim_item, \"stack\") == 0)\n\tlimit_item = RLIMIT_STACK;\n    else if (strcmp(lim_item, \"core\") == 0)\n\tlimit_item = RLIMIT_CORE;\n    else if (strcmp(lim_item, \"rss\") == 0)\n\tlimit_item = RLIMIT_RSS;\n    else if (strcmp(lim_item, \"nproc\") == 0)\n\tlimit_item = RLIMIT_NPROC;\n    else if (strcmp(lim_item, \"nofile\") == 0)\n\tlimit_item = RLIMIT_NOFILE;\n    else if (strcmp(lim_item, \"memlock\") == 0)\n\tlimit_item = RLIMIT_MEMLOCK;\n#ifdef RLIMIT_AS\n    else if (strcmp(lim_item, \"as\") == 0)\n\tlimit_item = RLIMIT_AS;\n#endif /*RLIMIT_AS*/\n#ifdef RLIMIT_LOCKS\n    else if (strcmp(lim_item, \"locks\") == 0)\n\tlimit_item = RLIMIT_LOCKS;\n#endif\n#ifdef RLIMIT_SIGPENDING\n    else if (strcmp(lim_item, \"sigpending\") == 0)\n\tlimit_item = RLIMIT_SIGPENDING;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n    else if (strcmp(lim_item, \"msgqueue\") == 0)\n\tlimit_item = RLIMIT_MSGQUEUE;\n#endif\n#ifdef RLIMIT_NICE\n    else if (strcmp(lim_item, \"nice\") == 0)\n\tlimit_item = RLIMIT_NICE;\n#endif\n#ifdef RLIMIT_RTPRIO\n    else if (strcmp(lim_item, \"rtprio\") == 0)\n\tlimit_item = RLIMIT_RTPRIO;\n#endif\n    else if (strcmp(lim_item, \"maxlogins\") == 0) {\n\tlimit_item = LIMIT_LOGIN;\n\tpl->flag_numsyslogins = 0;\n    } else if (strcmp(lim_item, \"maxsyslogins\") == 0) {\n\tlimit_item = LIMIT_NUMSYSLOGINS;\n\tpl->flag_numsyslogins = 1;\n    } else if (strcmp(lim_item, \"priority\") == 0) {\n\tlimit_item = LIMIT_PRI;\n    } else if (strcmp(lim_item, \"nonewprivs\") == 0) {\n\tlimit_item = LIMIT_NONEWPRIVS;\n    } else {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit item '%s'\", lim_item);\n        return;\n    }\n\n    if (strcmp(lim_type,\"soft\")==0)\n\tlimit_type=LIMIT_SOFT;\n    else if (strcmp(lim_type, \"hard\")==0)\n\tlimit_type=LIMIT_HARD;\n    else if (strcmp(lim_type,\"-\")==0)\n\tlimit_type=LIMIT_SOFT | LIMIT_HARD;\n    else if (limit_item != LIMIT_LOGIN && limit_item != LIMIT_NUMSYSLOGINS\n\t\t&& limit_item != LIMIT_NONEWPRIVS) {\n        pam_syslog(pamh, LOG_DEBUG, \"unknown limit type '%s'\", lim_type);\n        return;\n    }\n\tif (limit_item == LIMIT_NONEWPRIVS) {\n\t\t/* just require a bool-style 0 or 1 */\n\t\tif (strcmp(lim_value, \"0\") == 0) {\n\t\t\tint_value = 0;\n\t\t} else if (strcmp(lim_value, \"1\") == 0) {\n\t\t\tint_value = 1;\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t}\n\t} else if (limit_item != LIMIT_PRI\n#ifdef RLIMIT_NICE\n\t    && limit_item != RLIMIT_NICE\n#endif\n\t    && (strcmp(lim_value, \"-1\") == 0\n\t\t|| strcmp(lim_value, \"-\") == 0 || strcmp(lim_value, \"unlimited\") == 0\n\t\t|| strcmp(lim_value, \"infinity\") == 0)) {\n\t\tint_value = -1;\n\t\trlimit_value = RLIM_INFINITY;\n\t} else if (limit_item == LIMIT_PRI || limit_item == LIMIT_LOGIN ||\n#ifdef RLIMIT_NICE\n\t\tlimit_item == RLIMIT_NICE ||\n#endif\n\t\tlimit_item == LIMIT_NUMSYSLOGINS) {\n\t\tlong temp;\n\t\ttemp = strtol (lim_value, &endptr, 10);\n\t\ttemp = temp < INT_MAX ? temp : INT_MAX;\n\t\tint_value = temp > INT_MIN ? temp : INT_MIN;\n\t\tif (int_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n            return;\n\t\t}\n\t} else {\n#ifdef __USE_FILE_OFFSET64\n\t\trlimit_value = strtoull (lim_value, &endptr, 10);\n#else\n\t\trlimit_value = strtoul (lim_value, &endptr, 10);\n#endif\n\t\tif (rlimit_value == 0 && value_orig == endptr) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"wrong limit value '%s' for limit type '%s'\",\n\t\t\t\t   lim_value, lim_type);\n\t\t\treturn;\n\t\t}\n\t}\n\n    /* one more special case when limiting logins */\n    if ((source == LIMITS_DEF_ALL || source == LIMITS_DEF_ALLGROUP)\n\t\t&& (limit_item != LIMIT_LOGIN)) {\n\tif (ctrl & PAM_DEBUG_ARG)\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"'%%' domain valid for maxlogins type only\");\n\treturn;\n    }\n\n    switch(limit_item) {\n        case RLIMIT_CPU:\n\t  if (rlimit_value != RLIM_INFINITY)\n\t    {\n\t      if (rlimit_value >= RLIM_INFINITY/60)\n\t\trlimit_value = RLIM_INFINITY;\n\t      else\n\t\trlimit_value *= 60;\n\t    }\n         break;\n        case RLIMIT_FSIZE:\n        case RLIMIT_DATA:\n        case RLIMIT_STACK:\n        case RLIMIT_CORE:\n        case RLIMIT_RSS:\n        case RLIMIT_MEMLOCK:\n#ifdef RLIMIT_AS\n        case RLIMIT_AS:\n#endif\n         if (rlimit_value != RLIM_INFINITY)\n\t   {\n\t     if (rlimit_value >= RLIM_INFINITY/1024)\n\t       rlimit_value = RLIM_INFINITY;\n\t     else\n\t       rlimit_value *= 1024;\n\t   }\n\t break;\n#ifdef RLIMIT_NICE\n\tcase RLIMIT_NICE:\n\t if (int_value > 19)\n\t    int_value = 19;\n\t if (int_value < -20)\n\t   int_value = -20;\n\t rlimit_value = 20 - int_value;\n         break;\n#endif\n\tcase RLIMIT_NOFILE:\n\t/*\n\t * If nofile is to be set to \"unlimited\", try to set it to\n\t * the value in /proc/sys/fs/nr_open instead.\n\t */\n\tif (rlimit_value == RLIM_INFINITY) {\n\t    if (!value_from_file(\"/proc/sys/fs/nr_open\", &rlimit_value))\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t   \"Cannot set \\\"nofile\\\" to a sensible value\");\n\t    else if (ctrl & PAM_DEBUG_ARG)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Setting \\\"nofile\\\" limit to %llu\",\n\t\t\t   (unsigned long long) rlimit_value);\n\t}\n\tbreak;\n    }\n\n    if ( (limit_item != LIMIT_LOGIN)\n\t && (limit_item != LIMIT_NUMSYSLOGINS)\n\t && (limit_item != LIMIT_PRI)\n\t && (limit_item != LIMIT_NONEWPRIVS) ) {\n        if (limit_type & LIMIT_SOFT) {\n\t    if (pl->limits[limit_item].src_soft < source) {\n                return;\n\t    } else {\n                pl->limits[limit_item].limit.rlim_cur = rlimit_value;\n                pl->limits[limit_item].src_soft = source;\n            }\n\t}\n        if (limit_type & LIMIT_HARD) {\n\t    if (pl->limits[limit_item].src_hard < source) {\n                return;\n            } else {\n                pl->limits[limit_item].limit.rlim_max = rlimit_value;\n                pl->limits[limit_item].src_hard = source;\n            }\n\t}\n    } else {\n\t/* recent kernels support negative priority limits (=raise priority) */\n\n\tif (limit_item == LIMIT_PRI) {\n\t    pl->priority = int_value;\n\t} else if (limit_item == LIMIT_NONEWPRIVS) {\n\t    pl->nonewprivs = int_value;\n\t} else {\n\t    if (pl->login_limit_def < source) {\n\t\treturn;\n\t    } else {\n\t\tpl->login_limit = int_value;\n\t\tpl->login_limit_def = source;\n\t    }\n\t}\n    }\n    return;\n}\n\nstatic int\nparse_uid_range(pam_handle_t *pamh, const char *domain,\n\t\tuid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = domain;\n    char *pmax;\n    char *endptr;\n    int rv = LIMIT_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n\treturn LIMIT_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == '@' || range[0] == '%')\n\t++range;\n\n    if (range[0] == ':')\n\trv = LIMIT_RANGE_ONE;\n    else {\n\t    errno = 0;\n\t    *min_uid = strtoul (range, &endptr, 10);\n\t    if (errno != 0 || (range == endptr) || *endptr != ':') {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"wrong min_uid/gid value in '%s'\", domain);\n\t\treturn LIMIT_RANGE_ERR;\n\t    }\n    }\n\n    if (*pmax == '\\0') {\n\tif (rv == LIMIT_RANGE_ONE)\n\t    return LIMIT_RANGE_ERR;\n\telse\n\t    return LIMIT_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t   \"wrong max_uid/gid value in '%s'\", domain);\n\treturn LIMIT_RANGE_ERR;\n    }\n\n    if (rv == LIMIT_RANGE_ONE)\n\t*min_uid = *max_uid;\n    return rv;\n}"
  },
  {
    "function_name": "value_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "500-528",
    "snippet": "static int\nvalue_from_file(const char *pathname, rlim_t *valuep)\n{\n    char buf[128];\n    FILE *fp;\n    int retval;\n\n    retval = 0;\n\n    if ((fp = fopen(pathname, \"r\")) != NULL) {\n\tif (fgets(buf, sizeof(buf), fp) != NULL) {\n\t    char *endptr;\n\t    unsigned long long value;\n\n\t    errno = 0;\n\t    value = strtoull(buf, &endptr, 10);\n\t    if (endptr != buf &&\n\t\t(value != ULLONG_MAX || errno == 0) &&\n                (unsigned long long) (rlim_t) value == value) {\n\t\t*valuep = (rlim_t) value;\n\t\tretval = 1;\n\t    }\n\t}\n\n\tfclose(fp);\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "buf",
            "&endptr",
            "10"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "fp"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pathname",
            "\"r\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nvalue_from_file(const char *pathname, rlim_t *valuep)\n{\n    char buf[128];\n    FILE *fp;\n    int retval;\n\n    retval = 0;\n\n    if ((fp = fopen(pathname, \"r\")) != NULL) {\n\tif (fgets(buf, sizeof(buf), fp) != NULL) {\n\t    char *endptr;\n\t    unsigned long long value;\n\n\t    errno = 0;\n\t    value = strtoull(buf, &endptr, 10);\n\t    if (endptr != buf &&\n\t\t(value != ULLONG_MAX || errno == 0) &&\n                (unsigned long long) (rlim_t) value == value) {\n\t\t*valuep = (rlim_t) value;\n\t\tretval = 1;\n\t    }\n\t}\n\n\tfclose(fp);\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "init_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "450-493",
    "snippet": "static int init_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i;\n    int retval = PAM_SUCCESS;\n\n    D((\"called.\"));\n\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n\tint r = getrlimit(i, &pl->limits[i].limit);\n\tif (r == -1) {\n\t    pl->limits[i].supported = 0;\n\t    if (errno != EINVAL) {\n\t\tretval = !PAM_SUCCESS;\n\t    }\n\t} else {\n\t    pl->limits[i].supported = 1;\n\t    pl->limits[i].src_soft = LIMITS_DEF_NONE;\n\t    pl->limits[i].src_hard = LIMITS_DEF_NONE;\n\t}\n    }\n\n#ifdef __linux__\n    if (ctrl & PAM_SET_ALL) {\n      parse_kernel_limits(pamh, pl, ctrl);\n\n      for(i = 0; i < RLIM_NLIMITS; i++) {\n\tif (pl->limits[i].supported &&\n\t    (pl->limits[i].src_soft == LIMITS_DEF_NONE ||\n\t     pl->limits[i].src_hard == LIMITS_DEF_NONE)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"Did not find kernel RLIMIT for %s, using PAM default\", rlimit2str(i));\n\t}\n      }\n    }\n#endif\n\n    errno = 0;\n    pl->priority = getpriority (PRIO_PROCESS, 0);\n    if (pl->priority == -1 && errno != 0)\n      retval = !PAM_SUCCESS;\n    pl->login_limit = -2;\n    pl->login_limit_def = LIMITS_DEF_NONE;\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_SET_ALL         0x0010",
      "#define LIMITS_DEF_NONE     6 /* this limit was not set yet */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getpriority",
          "args": [
            "PRIO_PROCESS",
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Did not find kernel RLIMIT for %s, using PAM default\"",
            "rlimit2str(i)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit2str",
          "args": [
            "i"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rlimit2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "161-226",
          "snippet": "static const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_kernel_limits",
          "args": [
            "pamh",
            "pl",
            "ctrl"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "parse_kernel_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "389-448",
          "snippet": "static void parse_kernel_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i, maxlen = 0;\n    FILE *limitsfile;\n    const char *proclimits = \"/proc/1/limits\";\n    char line[256];\n    char *hard, *soft, *name;\n\n    if (!(limitsfile = fopen(proclimits, \"r\"))) {\n        pam_syslog(pamh, LOG_WARNING, \"Could not read %s (%s), using PAM defaults\", proclimits, strerror(errno));\n        return;\n    }\n\n    while (fgets(line, 256, limitsfile)) {\n        int pos = strlen(line);\n        if (pos < 2) continue;\n\n        /* drop trailing newline */\n        if (line[pos-1] == '\\n') {\n            pos--;\n            line[pos] = '\\0';\n        }\n\n        /* determine formatting boundary of limits report */\n        if (!maxlen && pam_str_skip_prefix(line, \"Limit\") != NULL) {\n            maxlen = pos;\n            continue;\n        }\n\n        if (pos == maxlen) {\n            /* step backwards over \"Units\" name */\n            LIMITS_SKIP_WHITESPACE;\n            LIMITS_MARK_ITEM(hard); /* not a typo, units unused */\n        }\n\n        /* step backwards over \"Hard Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(hard);\n\n        /* step backwards over \"Soft Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(soft);\n\n        /* step backwards over name of limit */\n        LIMITS_SKIP_WHITESPACE;\n        name = line;\n\n        i = str2rlimit(name);\n        if (i < 0 || i >= RLIM_NLIMITS) {\n            if (ctrl & PAM_DEBUG_ARG)\n                pam_syslog(pamh, LOG_DEBUG, \"Unknown kernel rlimit '%s' ignored\", name);\n            continue;\n        }\n        pl->limits[i].limit.rlim_cur = str2rlim_t(soft);\n        pl->limits[i].limit.rlim_max = str2rlim_t(hard);\n        pl->limits[i].src_soft = LIMITS_DEF_KERNEL;\n        pl->limits[i].src_hard = LIMITS_DEF_KERNEL;\n    }\n    fclose(limitsfile);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LIMITS_MARK_ITEM(item) { \\\n        /* step backwards over non-spaces */ \\\n        pos--; \\\n        while (pos && line[pos] != ' ') pos--; \\\n        if (!pos) continue; \\\n        item = line + pos + 1; \\\n}",
            "#define LIMITS_SKIP_WHITESPACE { \\\n        /* step backwards over spaces */ \\\n        pos--; \\\n        while (pos && line[pos] == ' ') pos--; \\\n        if (!pos) continue; \\\n        line[pos+1] = '\\0'; \\\n}",
            "#define PAM_DEBUG_ARG       0x0001",
            "#define LIMITS_DEF_KERNEL   5 /* limit was set from /proc/1/limits */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LIMITS_MARK_ITEM(item) { \\\n        /* step backwards over non-spaces */ \\\n        pos--; \\\n        while (pos && line[pos] != ' ') pos--; \\\n        if (!pos) continue; \\\n        item = line + pos + 1; \\\n}\n#define LIMITS_SKIP_WHITESPACE { \\\n        /* step backwards over spaces */ \\\n        pos--; \\\n        while (pos && line[pos] == ' ') pos--; \\\n        if (!pos) continue; \\\n        line[pos+1] = '\\0'; \\\n}\n#define PAM_DEBUG_ARG       0x0001\n#define LIMITS_DEF_KERNEL   5 /* limit was set from /proc/1/limits */\n\nstatic void parse_kernel_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i, maxlen = 0;\n    FILE *limitsfile;\n    const char *proclimits = \"/proc/1/limits\";\n    char line[256];\n    char *hard, *soft, *name;\n\n    if (!(limitsfile = fopen(proclimits, \"r\"))) {\n        pam_syslog(pamh, LOG_WARNING, \"Could not read %s (%s), using PAM defaults\", proclimits, strerror(errno));\n        return;\n    }\n\n    while (fgets(line, 256, limitsfile)) {\n        int pos = strlen(line);\n        if (pos < 2) continue;\n\n        /* drop trailing newline */\n        if (line[pos-1] == '\\n') {\n            pos--;\n            line[pos] = '\\0';\n        }\n\n        /* determine formatting boundary of limits report */\n        if (!maxlen && pam_str_skip_prefix(line, \"Limit\") != NULL) {\n            maxlen = pos;\n            continue;\n        }\n\n        if (pos == maxlen) {\n            /* step backwards over \"Units\" name */\n            LIMITS_SKIP_WHITESPACE;\n            LIMITS_MARK_ITEM(hard); /* not a typo, units unused */\n        }\n\n        /* step backwards over \"Hard Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(hard);\n\n        /* step backwards over \"Soft Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(soft);\n\n        /* step backwards over name of limit */\n        LIMITS_SKIP_WHITESPACE;\n        name = line;\n\n        i = str2rlimit(name);\n        if (i < 0 || i >= RLIM_NLIMITS) {\n            if (ctrl & PAM_DEBUG_ARG)\n                pam_syslog(pamh, LOG_DEBUG, \"Unknown kernel rlimit '%s' ignored\", name);\n            continue;\n        }\n        pl->limits[i].limit.rlim_cur = str2rlim_t(soft);\n        pl->limits[i].limit.rlim_max = str2rlim_t(hard);\n        pl->limits[i].src_soft = LIMITS_DEF_KERNEL;\n        pl->limits[i].src_hard = LIMITS_DEF_KERNEL;\n    }\n    fclose(limitsfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "i",
            "&pl->limits[i].limit"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called.\")"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_SET_ALL         0x0010\n#define LIMITS_DEF_NONE     6 /* this limit was not set yet */\n\nstatic int init_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i;\n    int retval = PAM_SUCCESS;\n\n    D((\"called.\"));\n\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n\tint r = getrlimit(i, &pl->limits[i].limit);\n\tif (r == -1) {\n\t    pl->limits[i].supported = 0;\n\t    if (errno != EINVAL) {\n\t\tretval = !PAM_SUCCESS;\n\t    }\n\t} else {\n\t    pl->limits[i].supported = 1;\n\t    pl->limits[i].src_soft = LIMITS_DEF_NONE;\n\t    pl->limits[i].src_hard = LIMITS_DEF_NONE;\n\t}\n    }\n\n#ifdef __linux__\n    if (ctrl & PAM_SET_ALL) {\n      parse_kernel_limits(pamh, pl, ctrl);\n\n      for(i = 0; i < RLIM_NLIMITS; i++) {\n\tif (pl->limits[i].supported &&\n\t    (pl->limits[i].src_soft == LIMITS_DEF_NONE ||\n\t     pl->limits[i].src_hard == LIMITS_DEF_NONE)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"Did not find kernel RLIMIT for %s, using PAM default\", rlimit2str(i));\n\t}\n      }\n    }\n#endif\n\n    errno = 0;\n    pl->priority = getpriority (PRIO_PROCESS, 0);\n    if (pl->priority == -1 && errno != 0)\n      retval = !PAM_SUCCESS;\n    pl->login_limit = -2;\n    pl->login_limit_def = LIMITS_DEF_NONE;\n\n    return retval;\n}"
  },
  {
    "function_name": "parse_kernel_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "389-448",
    "snippet": "static void parse_kernel_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i, maxlen = 0;\n    FILE *limitsfile;\n    const char *proclimits = \"/proc/1/limits\";\n    char line[256];\n    char *hard, *soft, *name;\n\n    if (!(limitsfile = fopen(proclimits, \"r\"))) {\n        pam_syslog(pamh, LOG_WARNING, \"Could not read %s (%s), using PAM defaults\", proclimits, strerror(errno));\n        return;\n    }\n\n    while (fgets(line, 256, limitsfile)) {\n        int pos = strlen(line);\n        if (pos < 2) continue;\n\n        /* drop trailing newline */\n        if (line[pos-1] == '\\n') {\n            pos--;\n            line[pos] = '\\0';\n        }\n\n        /* determine formatting boundary of limits report */\n        if (!maxlen && pam_str_skip_prefix(line, \"Limit\") != NULL) {\n            maxlen = pos;\n            continue;\n        }\n\n        if (pos == maxlen) {\n            /* step backwards over \"Units\" name */\n            LIMITS_SKIP_WHITESPACE;\n            LIMITS_MARK_ITEM(hard); /* not a typo, units unused */\n        }\n\n        /* step backwards over \"Hard Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(hard);\n\n        /* step backwards over \"Soft Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(soft);\n\n        /* step backwards over name of limit */\n        LIMITS_SKIP_WHITESPACE;\n        name = line;\n\n        i = str2rlimit(name);\n        if (i < 0 || i >= RLIM_NLIMITS) {\n            if (ctrl & PAM_DEBUG_ARG)\n                pam_syslog(pamh, LOG_DEBUG, \"Unknown kernel rlimit '%s' ignored\", name);\n            continue;\n        }\n        pl->limits[i].limit.rlim_cur = str2rlim_t(soft);\n        pl->limits[i].limit.rlim_max = str2rlim_t(hard);\n        pl->limits[i].src_soft = LIMITS_DEF_KERNEL;\n        pl->limits[i].src_hard = LIMITS_DEF_KERNEL;\n    }\n    fclose(limitsfile);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LIMITS_MARK_ITEM(item) { \\\n        /* step backwards over non-spaces */ \\\n        pos--; \\\n        while (pos && line[pos] != ' ') pos--; \\\n        if (!pos) continue; \\\n        item = line + pos + 1; \\\n}",
      "#define LIMITS_SKIP_WHITESPACE { \\\n        /* step backwards over spaces */ \\\n        pos--; \\\n        while (pos && line[pos] == ' ') pos--; \\\n        if (!pos) continue; \\\n        line[pos+1] = '\\0'; \\\n}",
      "#define PAM_DEBUG_ARG       0x0001",
      "#define LIMITS_DEF_KERNEL   5 /* limit was set from /proc/1/limits */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "limitsfile"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str2rlim_t",
          "args": [
            "hard"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "str2rlim_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "363-372",
          "snippet": "static rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Unknown kernel rlimit '%s' ignored\"",
            "name"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str2rlimit",
          "args": [
            "name"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "str2rlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
          "lines": "353-361",
          "snippet": "static int str2rlimit(char *name) {\n    int i;\n    if (!name || *name == '\\0')\n        return -1;\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n        if (strcmp(name, lnames[i]) == 0) return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <locale.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <utmp.h>",
            "#include <glob.h>",
            "#include <limits.h>",
            "#include <sys/resource.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *lnames[RLIM_NLIMITS] = {\n        [RLIMIT_CPU] = \"Max cpu time\",\n        [RLIMIT_FSIZE] = \"Max file size\",\n        [RLIMIT_DATA] = \"Max data size\",\n        [RLIMIT_STACK] = \"Max stack size\",\n        [RLIMIT_CORE] = \"Max core file size\",\n        [RLIMIT_RSS] = \"Max resident set\",\n        [RLIMIT_NPROC] = \"Max processes\",\n        [RLIMIT_NOFILE] = \"Max open files\",\n        [RLIMIT_MEMLOCK] = \"Max locked memory\",\n#ifdef RLIMIT_AS\n        [RLIMIT_AS] = \"Max address space\",\n#endif\n#ifdef RLIMIT_LOCKS\n        [RLIMIT_LOCKS] = \"Max file locks\",\n#endif\n#ifdef RLIMIT_SIGPENDING\n        [RLIMIT_SIGPENDING] = \"Max pending signals\",\n#endif\n#ifdef RLIMIT_MSGQUEUE\n        [RLIMIT_MSGQUEUE] = \"Max msgqueue size\",\n#endif\n#ifdef RLIMIT_NICE\n        [RLIMIT_NICE] = \"Max nice priority\",\n#endif\n#ifdef RLIMIT_RTPRIO\n        [RLIMIT_RTPRIO] = \"Max realtime priority\",\n#endif\n#ifdef RLIMIT_RTTIME\n        [RLIMIT_RTTIME] = \"Max realtime timeout\",\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *lnames[RLIM_NLIMITS] = {\n        [RLIMIT_CPU] = \"Max cpu time\",\n        [RLIMIT_FSIZE] = \"Max file size\",\n        [RLIMIT_DATA] = \"Max data size\",\n        [RLIMIT_STACK] = \"Max stack size\",\n        [RLIMIT_CORE] = \"Max core file size\",\n        [RLIMIT_RSS] = \"Max resident set\",\n        [RLIMIT_NPROC] = \"Max processes\",\n        [RLIMIT_NOFILE] = \"Max open files\",\n        [RLIMIT_MEMLOCK] = \"Max locked memory\",\n#ifdef RLIMIT_AS\n        [RLIMIT_AS] = \"Max address space\",\n#endif\n#ifdef RLIMIT_LOCKS\n        [RLIMIT_LOCKS] = \"Max file locks\",\n#endif\n#ifdef RLIMIT_SIGPENDING\n        [RLIMIT_SIGPENDING] = \"Max pending signals\",\n#endif\n#ifdef RLIMIT_MSGQUEUE\n        [RLIMIT_MSGQUEUE] = \"Max msgqueue size\",\n#endif\n#ifdef RLIMIT_NICE\n        [RLIMIT_NICE] = \"Max nice priority\",\n#endif\n#ifdef RLIMIT_RTPRIO\n        [RLIMIT_RTPRIO] = \"Max realtime priority\",\n#endif\n#ifdef RLIMIT_RTTIME\n        [RLIMIT_RTTIME] = \"Max realtime timeout\",\n#endif\n};\n\nstatic int str2rlimit(char *name) {\n    int i;\n    if (!name || *name == '\\0')\n        return -1;\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n        if (strcmp(name, lnames[i]) == 0) return i;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIMITS_MARK_ITEM",
          "args": [
            "soft"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIMITS_MARK_ITEM",
          "args": [
            "hard"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIMITS_MARK_ITEM",
          "args": [
            "hard"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "line",
            "\"Limit\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "256",
            "limitsfile"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Could not read %s (%s), using PAM defaults\"",
            "proclimits",
            "strerror(errno)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "proclimits",
            "\"r\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LIMITS_MARK_ITEM(item) { \\\n        /* step backwards over non-spaces */ \\\n        pos--; \\\n        while (pos && line[pos] != ' ') pos--; \\\n        if (!pos) continue; \\\n        item = line + pos + 1; \\\n}\n#define LIMITS_SKIP_WHITESPACE { \\\n        /* step backwards over spaces */ \\\n        pos--; \\\n        while (pos && line[pos] == ' ') pos--; \\\n        if (!pos) continue; \\\n        line[pos+1] = '\\0'; \\\n}\n#define PAM_DEBUG_ARG       0x0001\n#define LIMITS_DEF_KERNEL   5 /* limit was set from /proc/1/limits */\n\nstatic void parse_kernel_limits(pam_handle_t *pamh, struct pam_limit_s *pl, int ctrl)\n{\n    int i, maxlen = 0;\n    FILE *limitsfile;\n    const char *proclimits = \"/proc/1/limits\";\n    char line[256];\n    char *hard, *soft, *name;\n\n    if (!(limitsfile = fopen(proclimits, \"r\"))) {\n        pam_syslog(pamh, LOG_WARNING, \"Could not read %s (%s), using PAM defaults\", proclimits, strerror(errno));\n        return;\n    }\n\n    while (fgets(line, 256, limitsfile)) {\n        int pos = strlen(line);\n        if (pos < 2) continue;\n\n        /* drop trailing newline */\n        if (line[pos-1] == '\\n') {\n            pos--;\n            line[pos] = '\\0';\n        }\n\n        /* determine formatting boundary of limits report */\n        if (!maxlen && pam_str_skip_prefix(line, \"Limit\") != NULL) {\n            maxlen = pos;\n            continue;\n        }\n\n        if (pos == maxlen) {\n            /* step backwards over \"Units\" name */\n            LIMITS_SKIP_WHITESPACE;\n            LIMITS_MARK_ITEM(hard); /* not a typo, units unused */\n        }\n\n        /* step backwards over \"Hard Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(hard);\n\n        /* step backwards over \"Soft Limit\" value */\n        LIMITS_SKIP_WHITESPACE;\n        LIMITS_MARK_ITEM(soft);\n\n        /* step backwards over name of limit */\n        LIMITS_SKIP_WHITESPACE;\n        name = line;\n\n        i = str2rlimit(name);\n        if (i < 0 || i >= RLIM_NLIMITS) {\n            if (ctrl & PAM_DEBUG_ARG)\n                pam_syslog(pamh, LOG_DEBUG, \"Unknown kernel rlimit '%s' ignored\", name);\n            continue;\n        }\n        pl->limits[i].limit.rlim_cur = str2rlim_t(soft);\n        pl->limits[i].limit.rlim_max = str2rlim_t(hard);\n        pl->limits[i].src_soft = LIMITS_DEF_KERNEL;\n        pl->limits[i].src_hard = LIMITS_DEF_KERNEL;\n    }\n    fclose(limitsfile);\n}"
  },
  {
    "function_name": "str2rlim_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "363-372",
    "snippet": "static rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "NULL",
            "10"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"unlimited\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic rlim_t str2rlim_t(char *value) {\n    unsigned long long rlimit = 0;\n\n    if (!value) return (rlim_t)rlimit;\n    if (strcmp(value, \"unlimited\") == 0) {\n        return RLIM_INFINITY;\n    }\n    rlimit = strtoull(value, NULL, 10);\n    return (rlim_t)rlimit;\n}"
  },
  {
    "function_name": "str2rlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "353-361",
    "snippet": "static int str2rlimit(char *name) {\n    int i;\n    if (!name || *name == '\\0')\n        return -1;\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n        if (strcmp(name, lnames[i]) == 0) return i;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *lnames[RLIM_NLIMITS] = {\n        [RLIMIT_CPU] = \"Max cpu time\",\n        [RLIMIT_FSIZE] = \"Max file size\",\n        [RLIMIT_DATA] = \"Max data size\",\n        [RLIMIT_STACK] = \"Max stack size\",\n        [RLIMIT_CORE] = \"Max core file size\",\n        [RLIMIT_RSS] = \"Max resident set\",\n        [RLIMIT_NPROC] = \"Max processes\",\n        [RLIMIT_NOFILE] = \"Max open files\",\n        [RLIMIT_MEMLOCK] = \"Max locked memory\",\n#ifdef RLIMIT_AS\n        [RLIMIT_AS] = \"Max address space\",\n#endif\n#ifdef RLIMIT_LOCKS\n        [RLIMIT_LOCKS] = \"Max file locks\",\n#endif\n#ifdef RLIMIT_SIGPENDING\n        [RLIMIT_SIGPENDING] = \"Max pending signals\",\n#endif\n#ifdef RLIMIT_MSGQUEUE\n        [RLIMIT_MSGQUEUE] = \"Max msgqueue size\",\n#endif\n#ifdef RLIMIT_NICE\n        [RLIMIT_NICE] = \"Max nice priority\",\n#endif\n#ifdef RLIMIT_RTPRIO\n        [RLIMIT_RTPRIO] = \"Max realtime priority\",\n#endif\n#ifdef RLIMIT_RTTIME\n        [RLIMIT_RTTIME] = \"Max realtime timeout\",\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "lnames[i]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *lnames[RLIM_NLIMITS] = {\n        [RLIMIT_CPU] = \"Max cpu time\",\n        [RLIMIT_FSIZE] = \"Max file size\",\n        [RLIMIT_DATA] = \"Max data size\",\n        [RLIMIT_STACK] = \"Max stack size\",\n        [RLIMIT_CORE] = \"Max core file size\",\n        [RLIMIT_RSS] = \"Max resident set\",\n        [RLIMIT_NPROC] = \"Max processes\",\n        [RLIMIT_NOFILE] = \"Max open files\",\n        [RLIMIT_MEMLOCK] = \"Max locked memory\",\n#ifdef RLIMIT_AS\n        [RLIMIT_AS] = \"Max address space\",\n#endif\n#ifdef RLIMIT_LOCKS\n        [RLIMIT_LOCKS] = \"Max file locks\",\n#endif\n#ifdef RLIMIT_SIGPENDING\n        [RLIMIT_SIGPENDING] = \"Max pending signals\",\n#endif\n#ifdef RLIMIT_MSGQUEUE\n        [RLIMIT_MSGQUEUE] = \"Max msgqueue size\",\n#endif\n#ifdef RLIMIT_NICE\n        [RLIMIT_NICE] = \"Max nice priority\",\n#endif\n#ifdef RLIMIT_RTPRIO\n        [RLIMIT_RTPRIO] = \"Max realtime priority\",\n#endif\n#ifdef RLIMIT_RTTIME\n        [RLIMIT_RTTIME] = \"Max realtime timeout\",\n#endif\n};\n\nstatic int str2rlimit(char *name) {\n    int i;\n    if (!name || *name == '\\0')\n        return -1;\n    for(i = 0; i < RLIM_NLIMITS; i++) {\n        if (strcmp(name, lnames[i]) == 0) return i;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "check_logins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "234-318",
    "snippet": "static int\ncheck_logins (pam_handle_t *pamh, const char *name, int limit, int ctrl,\n              struct pam_limit_s *pl)\n{\n    struct utmp *ut;\n    int count;\n\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG,\n\t\t   \"checking logins for '%s' (maximum of %d)\", name, limit);\n    }\n\n    if (limit < 0)\n        return 0; /* no limits imposed */\n    if (limit == 0) /* maximum 0 logins ? */ {\n        pam_syslog(pamh, LOG_WARNING, \"No logins allowed for '%s'\", name);\n        return LOGIN_ERR;\n    }\n\n    setutent();\n\n    /* Because there is no definition about when an application\n       actually adds a utmp entry, some applications bizarrely do the\n       utmp call before the have PAM authenticate them to the system:\n       you're logged it, sort of...? Anyway, you can use the\n       \"utmp_early\" module argument in your PAM config file to make\n       allowances for this sort of problem. (There should be a PAM\n       standard for this, since if a module wants to actually map a\n       username then any early utmp entry will be for the unmapped\n       name = broken.) */\n\n    if (ctrl & PAM_UTMP_EARLY) {\n\tcount = 0;\n    } else {\n\tcount = 1;\n    }\n\n    while((ut = getutent())) {\n#ifdef USER_PROCESS\n        if (ut->ut_type != USER_PROCESS) {\n            continue;\n\t}\n#endif\n        if (ut->UT_USER[0] == '\\0') {\n            continue;\n\t}\n        if (!pl->flag_numsyslogins) {\n\t    char user[sizeof(ut->UT_USER) + 1];\n\t    user[0] = '\\0';\n\t    strncat(user, ut->UT_USER, sizeof(ut->UT_USER));\n\n\t    if (((pl->login_limit_def == LIMITS_DEF_USER)\n\t         || (pl->login_limit_def == LIMITS_DEF_GROUP)\n\t\t || (pl->login_limit_def == LIMITS_DEF_DEFAULT))\n\t\t&& strcmp(name, user) != 0) {\n                continue;\n\t    }\n\t    if ((pl->login_limit_def == LIMITS_DEF_ALLGROUP)\n\t\t&& !pam_modutil_user_in_group_nam_nam(pamh, user, pl->login_group)) {\n                continue;\n\t    }\n\t    if (kill(ut->ut_pid, 0) == -1 && errno == ESRCH) {\n\t\t/* process does not exist anymore */\n\t\tpam_syslog(pamh, LOG_INFO,\n\t\t\t   \"Stale utmp entry (pid %d) for '%s' ignored\",\n\t\t\t   ut->ut_pid, user);\n\t\tcontinue;\n\t    }\n\t}\n\tif (++count > limit) {\n\t    break;\n\t}\n    }\n    endutent();\n    if (count > limit) {\n\tif (name) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Too many logins (max %d) for %s\", limit, name);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Too many system logins (max %d)\", limit);\n\t}\n        return LOGIN_ERR;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LOGIN_ERR  2 /* too many logins err */",
      "#define PAM_UTMP_EARLY      0x0004",
      "#define PAM_DEBUG_ARG       0x0001",
      "#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */",
      "#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */",
      "#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */",
      "#define LIMITS_DEF_USER     0 /* limit was set by a user entry */",
      "#define UT_USER ut_user"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Too many system logins (max %d)\"",
            "limit"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Too many logins (max %d) for %s\"",
            "limit",
            "name"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endutent",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Stale utmp entry (pid %d) for '%s' ignored\"",
            "ut->ut_pid",
            "user"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "ut->ut_pid",
            "0"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "kill_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "154-201",
          "snippet": "static int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */"
          ],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\n\nstatic int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "user",
            "pl->login_group"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "user"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "user",
            "ut->UT_USER",
            "sizeof(ut->UT_USER)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getutent",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setutent",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"No logins allowed for '%s'\"",
            "name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"checking logins for '%s' (maximum of %d)\"",
            "name",
            "limit"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define LOGIN_ERR  2 /* too many logins err */\n#define PAM_UTMP_EARLY      0x0004\n#define PAM_DEBUG_ARG       0x0001\n#define LIMITS_DEF_DEFAULT  4 /* limit was set by a default entry */\n#define LIMITS_DEF_ALLGROUP 2 /* limit was set by a group entry */\n#define LIMITS_DEF_GROUP    1 /* limit was set by a group entry */\n#define LIMITS_DEF_USER     0 /* limit was set by a user entry */\n#define UT_USER ut_user\n\nstatic int\ncheck_logins (pam_handle_t *pamh, const char *name, int limit, int ctrl,\n              struct pam_limit_s *pl)\n{\n    struct utmp *ut;\n    int count;\n\n    if (ctrl & PAM_DEBUG_ARG) {\n        pam_syslog(pamh, LOG_DEBUG,\n\t\t   \"checking logins for '%s' (maximum of %d)\", name, limit);\n    }\n\n    if (limit < 0)\n        return 0; /* no limits imposed */\n    if (limit == 0) /* maximum 0 logins ? */ {\n        pam_syslog(pamh, LOG_WARNING, \"No logins allowed for '%s'\", name);\n        return LOGIN_ERR;\n    }\n\n    setutent();\n\n    /* Because there is no definition about when an application\n       actually adds a utmp entry, some applications bizarrely do the\n       utmp call before the have PAM authenticate them to the system:\n       you're logged it, sort of...? Anyway, you can use the\n       \"utmp_early\" module argument in your PAM config file to make\n       allowances for this sort of problem. (There should be a PAM\n       standard for this, since if a module wants to actually map a\n       username then any early utmp entry will be for the unmapped\n       name = broken.) */\n\n    if (ctrl & PAM_UTMP_EARLY) {\n\tcount = 0;\n    } else {\n\tcount = 1;\n    }\n\n    while((ut = getutent())) {\n#ifdef USER_PROCESS\n        if (ut->ut_type != USER_PROCESS) {\n            continue;\n\t}\n#endif\n        if (ut->UT_USER[0] == '\\0') {\n            continue;\n\t}\n        if (!pl->flag_numsyslogins) {\n\t    char user[sizeof(ut->UT_USER) + 1];\n\t    user[0] = '\\0';\n\t    strncat(user, ut->UT_USER, sizeof(ut->UT_USER));\n\n\t    if (((pl->login_limit_def == LIMITS_DEF_USER)\n\t         || (pl->login_limit_def == LIMITS_DEF_GROUP)\n\t\t || (pl->login_limit_def == LIMITS_DEF_DEFAULT))\n\t\t&& strcmp(name, user) != 0) {\n                continue;\n\t    }\n\t    if ((pl->login_limit_def == LIMITS_DEF_ALLGROUP)\n\t\t&& !pam_modutil_user_in_group_nam_nam(pamh, user, pl->login_group)) {\n                continue;\n\t    }\n\t    if (kill(ut->ut_pid, 0) == -1 && errno == ESRCH) {\n\t\t/* process does not exist anymore */\n\t\tpam_syslog(pamh, LOG_INFO,\n\t\t\t   \"Stale utmp entry (pid %d) for '%s' ignored\",\n\t\t\t   ut->ut_pid, user);\n\t\tcontinue;\n\t    }\n\t}\n\tif (++count > limit) {\n\t    break;\n\t}\n    }\n    endutent();\n    if (count > limit) {\n\tif (name) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Too many logins (max %d) for %s\", limit, name);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Too many system logins (max %d)\", limit);\n\t}\n        return LOGIN_ERR;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "rlimit2str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_limits/pam_limits.c",
    "lines": "161-226",
    "snippet": "static const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <locale.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <utmp.h>",
      "#include <glob.h>",
      "#include <limits.h>",
      "#include <sys/resource.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <signal.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <locale.h>\n#include <pwd.h>\n#include <grp.h>\n#include <utmp.h>\n#include <glob.h>\n#include <limits.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char *\nrlimit2str (int i)\n{\n  switch (i) {\n  case RLIMIT_CPU:\n    return \"cpu\";\n    break;\n  case RLIMIT_FSIZE:\n    return \"fsize\";\n    break;\n  case RLIMIT_DATA:\n    return \"data\";\n    break;\n  case RLIMIT_STACK:\n    return \"stack\";\n    break;\n  case RLIMIT_CORE:\n    return \"core\";\n    break;\n  case RLIMIT_RSS:\n    return \"rss\";\n    break;\n  case RLIMIT_NPROC:\n    return \"nproc\";\n    break;\n  case RLIMIT_NOFILE:\n    return \"nofile\";\n    break;\n  case RLIMIT_MEMLOCK:\n    return \"memlock\";\n    break;\n#ifdef RLIMIT_AS\n  case RLIMIT_AS:\n    return \"as\";\n    break;\n#endif\n#ifdef RLIMIT_LOCKS\n  case RLIMIT_LOCKS:\n    return \"locks\";\n    break;\n#endif\n#ifdef RLIMIT_SIGPENDING\n  case RLIMIT_SIGPENDING:\n    return \"sigpending\";\n    break;\n#endif\n#ifdef RLIMIT_MSGQUEUE\n  case RLIMIT_MSGQUEUE:\n    return \"msgqueue\";\n    break;\n#endif\n#ifdef RLIMIT_NICE\n  case RLIMIT_NICE:\n    return \"nice\";\n    break;\n#endif\n#ifdef RLIMIT_RTPRIO\n  case RLIMIT_RTPRIO:\n    return \"rtprio\";\n    break;\n#endif\n  default:\n    return \"UNKNOWN\";\n    break;\n  }\n}"
  }
]