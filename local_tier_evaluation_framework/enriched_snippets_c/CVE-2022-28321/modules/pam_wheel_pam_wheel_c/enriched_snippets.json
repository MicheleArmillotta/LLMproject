[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
    "lines": "255-265",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags UNUSED,\n\t\t  int argc, const char **argv)\n{\n    char use_group[BUFSIZ];\n    int ctrl;\n\n    ctrl = _pam_parse(pamh, argc, argv, use_group, sizeof(use_group));\n\n    return perform_check(pamh, ctrl, use_group);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh",
            "ctrl",
            "use_group"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
          "lines": "89-232",
          "snippet": "static int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ROOT_ONLY_ARG   0x0020",
            "#define PAM_DENY_ARG        0x0010",
            "#define PAM_TRUST_ARG       0x0004",
            "#define PAM_USE_UID_ARG     0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "use_group",
            "sizeof(use_group)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
          "lines": "55-87",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ROOT_ONLY_ARG   0x0020",
            "#define PAM_DENY_ARG        0x0010",
            "#define PAM_TRUST_ARG       0x0004",
            "#define PAM_USE_UID_ARG     0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags UNUSED,\n\t\t  int argc, const char **argv)\n{\n    char use_group[BUFSIZ];\n    int ctrl;\n\n    ctrl = _pam_parse(pamh, argc, argv, use_group, sizeof(use_group));\n\n    return perform_check(pamh, ctrl, use_group);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
    "lines": "248-253",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
    "lines": "236-246",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    char use_group[BUFSIZ];\n    int ctrl;\n\n    ctrl = _pam_parse(pamh, argc, argv, use_group, sizeof(use_group));\n\n    return perform_check(pamh, ctrl, use_group);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh",
            "ctrl",
            "use_group"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
          "lines": "89-232",
          "snippet": "static int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ROOT_ONLY_ARG   0x0020",
            "#define PAM_DENY_ARG        0x0010",
            "#define PAM_TRUST_ARG       0x0004",
            "#define PAM_USE_UID_ARG     0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "use_group",
            "sizeof(use_group)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
          "lines": "55-87",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ROOT_ONLY_ARG   0x0020",
            "#define PAM_DENY_ARG        0x0010",
            "#define PAM_TRUST_ARG       0x0004",
            "#define PAM_USE_UID_ARG     0x0002",
            "#define PAM_DEBUG_ARG       0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    char use_group[BUFSIZ];\n    int ctrl;\n\n    ctrl = _pam_parse(pamh, argc, argv, use_group, sizeof(use_group));\n\n    return perform_check(pamh, ctrl, use_group);\n}"
  },
  {
    "function_name": "perform_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
    "lines": "89-232",
    "snippet": "static int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ROOT_ONLY_ARG   0x0020",
      "#define PAM_DENY_ARG        0x0010",
      "#define PAM_TRUST_ARG       0x0004",
      "#define PAM_USE_UID_ARG     0x0002",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Access %s to '%s' for '%s'\"",
            "(retval != PAM_SUCCESS) ? \"denied\":\"granted\"",
            "fromsu",
            "username"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Ignoring access request '%s' for '%s'\"",
            "fromsu",
            "username"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_uid_gid",
          "args": [
            "pamh",
            "tpwd->pw_uid",
            "grp->gr_gid"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"no members in '%s' group\"",
            "use_group"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"no members in a GID 0 group\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getgrnam",
          "args": [
            "pamh",
            "use_group"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getgrgid",
          "args": [
            "pamh",
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getgrnam",
          "args": [
            "pamh",
            "\"wheel\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"who is running me ?!\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "fromsu"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RUSER",
            "(const void **)&fromsu"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "(const void **)&rhostname"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getlogin",
          "args": [
            "pamh"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"who is running me ?!\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwuid",
          "args": [
            "pamh",
            "getuid()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"unknown user %s\"",
            "username"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\nperform_check (pam_handle_t *pamh, int ctrl, const char *use_group)\n{\n    const char *username = NULL;\n    const char *fromsu;\n    struct passwd *pwd, *tpwd = NULL;\n    struct group *grp;\n    int retval = PAM_AUTH_ERR;\n\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"cannot determine user name: %s\",\n\t\t       pam_strerror(pamh, retval));\n\t}\n        return PAM_SERVICE_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam (pamh, username);\n    if (!pwd) {\n        if (ctrl & PAM_DEBUG_ARG) {\n            pam_syslog(pamh, LOG_NOTICE, \"unknown user %s\", username);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    if (ctrl & PAM_ROOT_ONLY_ARG) {\n\t/* su to a non uid 0 account ? */\n        if (pwd->pw_uid != 0) {\n            return PAM_IGNORE;\n        }\n    }\n\n    if (ctrl & PAM_USE_UID_ARG) {\n        tpwd = pam_modutil_getpwuid (pamh, getuid());\n        if (tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n        fromsu = tpwd->pw_name;\n    } else {\n        fromsu = pam_modutil_getlogin(pamh);\n\n        /* if getlogin fails try a fallback to PAM_RUSER */\n        if (fromsu == NULL) {\n            const char *rhostname;\n\n            retval = pam_get_item(pamh, PAM_RHOST, (const void **)&rhostname);\n            if (retval != PAM_SUCCESS || rhostname == NULL) {\n                retval = pam_get_item(pamh, PAM_RUSER, (const void **)&fromsu);\n            }\n        }\n\n        if (fromsu != NULL) {\n            tpwd = pam_modutil_getpwnam (pamh, fromsu);\n        }\n\n        if (fromsu == NULL || tpwd == NULL) {\n            if (ctrl & PAM_DEBUG_ARG) {\n                pam_syslog(pamh, LOG_NOTICE, \"who is running me ?!\");\n            }\n            return PAM_SERVICE_ERR;\n        }\n    }\n\n    /*\n     * At this point fromsu = username-of-invoker; tpwd = pwd ptr for fromsu\n     */\n\n    if (!use_group[0]) {\n\tif ((grp = pam_modutil_getgrnam (pamh, \"wheel\")) == NULL) {\n\t    grp = pam_modutil_getgrgid (pamh, 0);\n\t}\n    } else {\n\tgrp = pam_modutil_getgrnam (pamh, use_group);\n    }\n\n    if (grp == NULL) {\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    if (!use_group[0]) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"no members in a GID 0 group\");\n\t    } else {\n                pam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"no members in '%s' group\", use_group);\n\t    }\n\t}\n\tif (ctrl & PAM_DENY_ARG) {\n\t    /* if this was meant to deny access to the members\n\t     * of this group and the group does not exist, allow\n\t     * access\n\t     */\n\t    return PAM_IGNORE;\n\t} else {\n\t    return PAM_AUTH_ERR;\n\t}\n    }\n\n    /*\n     * test if the user is a member of the group, or if the\n     * user has the \"wheel\" (sic) group as its primary group.\n     */\n\n    if (pam_modutil_user_in_group_uid_gid(pamh, tpwd->pw_uid, grp->gr_gid)) {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\t    retval = PAM_PERM_DENIED;\n\n\t} else if (ctrl & PAM_TRUST_ARG) {\n\t    retval = PAM_SUCCESS;        /* this can be a sufficient check */\n\n\t} else {\n\t    retval = PAM_IGNORE;\n\t}\n\n    } else {\n\n\tif (ctrl & PAM_DENY_ARG) {\n\n\t    if (ctrl & PAM_TRUST_ARG) {\n\t\tretval = PAM_SUCCESS;    /* this can be a sufficient check */\n\t    } else {\n\t\tretval = PAM_IGNORE;\n\t    }\n\n\t} else {\n\t    retval = PAM_PERM_DENIED;\n\t}\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tif (retval == PAM_IGNORE) {\n\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t       \"Ignoring access request '%s' for '%s'\",\n\t\t       fromsu, username);\n\t} else {\n\t    pam_syslog(pamh, LOG_NOTICE, \"Access %s to '%s' for '%s'\",\n\t\t       (retval != PAM_SUCCESS) ? \"denied\":\"granted\",\n\t\t       fromsu, username);\n\t}\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_wheel/pam_wheel.c",
    "lines": "55-87",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ROOT_ONLY_ARG   0x0020",
      "#define PAM_DENY_ARG        0x0010",
      "#define PAM_TRUST_ARG       0x0004",
      "#define PAM_USE_UID_ARG     0x0002",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "use_group",
            "str",
            "group_length - 1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"group=\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"root_only\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"deny\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"trust\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"use_uid\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "use_group",
            "'\\0'",
            "group_length"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_ROOT_ONLY_ARG   0x0020\n#define PAM_DENY_ARG        0x0010\n#define PAM_TRUST_ARG       0x0004\n#define PAM_USE_UID_ARG     0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    char *use_group, size_t group_length)\n{\n     int ctrl=0;\n\n     memset(use_group, '\\0', group_length);\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n          const char *str;\n\n          /* generic options */\n\n          if (!strcmp(*argv,\"debug\"))\n               ctrl |= PAM_DEBUG_ARG;\n          else if (!strcmp(*argv,\"use_uid\"))\n               ctrl |= PAM_USE_UID_ARG;\n          else if (!strcmp(*argv,\"trust\"))\n               ctrl |= PAM_TRUST_ARG;\n          else if (!strcmp(*argv,\"deny\"))\n               ctrl |= PAM_DENY_ARG;\n          else if (!strcmp(*argv,\"root_only\"))\n               ctrl |= PAM_ROOT_ONLY_ARG;\n\t  else if ((str = pam_str_skip_prefix(*argv, \"group=\")) != NULL)\n\t       strncpy(use_group, str, group_length - 1);\n          else {\n               pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n          }\n     }\n\n     return ctrl;\n}"
  }
]