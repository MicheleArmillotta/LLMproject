[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "437-481",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    const char *username;\n    const char *database = NULL;\n    const char *cryptmode = NULL;\n    int retval = PAM_AUTH_ERR, ctrl;\n\n    /* parse arguments */\n    ctrl = _pam_parse(pamh, argc, argv, &database, &cryptmode);\n\n    /* Get the username */\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n                   pam_strerror(pamh, retval));\n        return PAM_SERVICE_ERR;\n    }\n\n    /* Now use the username to look up password in the database file */\n    retval = user_lookup(pamh, database, cryptmode, username, \"\", ctrl);\n    switch (retval) {\n        case -2:\n\t    /* some sort of system error. The log was already printed */\n\t    return PAM_SERVICE_ERR;\n\tcase -1:\n\t    /* incorrect password, but we don't care */\n\t    /* FALL THROUGH */\n\tcase 0:\n\t    /* authentication succeeded. dumbest password ever. */\n\t    return PAM_SUCCESS;\n\tcase 1:\n\t    /* the user does not exist in the database */\n\t    return PAM_USER_UNKNOWN;\n        default:\n\t    /* we don't know anything about this return value */\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"internal module error (retval = %d, user = `%s'\",\n\t\t       retval, username);\n            return PAM_SERVICE_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"internal module error (retval = %d, user = `%s'\"",
            "retval",
            "username"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_lookup",
          "args": [
            "pamh",
            "database",
            "cryptmode",
            "username",
            "\"\"",
            "ctrl"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "user_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "142-336",
          "snippet": "static int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#  include <db.h>",
            "# include <ndbm.h>",
            "#include \"pam_userdb.h\"",
            "#include <crypt.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&database",
            "&cryptmode"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "77-130",
          "snippet": "static int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#  include <db.h>",
            "# include <ndbm.h>",
            "#include \"pam_userdb.h\"",
            "#include <crypt.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    const char *username;\n    const char *database = NULL;\n    const char *cryptmode = NULL;\n    int retval = PAM_AUTH_ERR, ctrl;\n\n    /* parse arguments */\n    ctrl = _pam_parse(pamh, argc, argv, &database, &cryptmode);\n\n    /* Get the username */\n    retval = pam_get_user(pamh, &username, NULL);\n    if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n                   pam_strerror(pamh, retval));\n        return PAM_SERVICE_ERR;\n    }\n\n    /* Now use the username to look up password in the database file */\n    retval = user_lookup(pamh, database, cryptmode, username, \"\", ctrl);\n    switch (retval) {\n        case -2:\n\t    /* some sort of system error. The log was already printed */\n\t    return PAM_SERVICE_ERR;\n\tcase -1:\n\t    /* incorrect password, but we don't care */\n\t    /* FALL THROUGH */\n\tcase 0:\n\t    /* authentication succeeded. dumbest password ever. */\n\t    return PAM_SUCCESS;\n\tcase 1:\n\t    /* the user does not exist in the database */\n\t    return PAM_USER_UNKNOWN;\n        default:\n\t    /* we don't know anything about this return value */\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"internal module error (retval = %d, user = `%s'\",\n\t\t       retval, username);\n            return PAM_SERVICE_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "430-435",
    "snippet": "int\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t       int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t       int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "340-428",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n     const char *username;\n     const void *password;\n     const char *database = NULL;\n     const char *cryptmode = NULL;\n     int retval = PAM_AUTH_ERR, ctrl;\n\n     /* parse arguments */\n     ctrl = _pam_parse(pamh, argc, argv, &database, &cryptmode);\n     if (database == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"can not get the database name\");\n        return PAM_SERVICE_ERR;\n     }\n\n     /* Get the username */\n     retval = pam_get_user(pamh, &username, NULL);\n     if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n                   pam_strerror(pamh, retval));\n        return PAM_SERVICE_ERR;\n     }\n\n     if ((ctrl & PAM_USE_FPASS_ARG) == 0 && (ctrl & PAM_TRY_FPASS_ARG) == 0) {\n        /* Converse to obtain a password */\n        retval = obtain_authtok(pamh);\n        if (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"can not obtain password from user\");\n\t    return retval;\n        }\n     }\n\n     /* Check if we got a password */\n     retval = pam_get_item(pamh, PAM_AUTHTOK, &password);\n     if (retval != PAM_SUCCESS || password == NULL) {\n        if ((ctrl & PAM_TRY_FPASS_ARG) != 0) {\n\t    /* Converse to obtain a password */\n\t    retval = obtain_authtok(pamh);\n\t    if (retval != PAM_SUCCESS) {\n\t        pam_syslog(pamh, LOG_ERR, \"can not obtain password from user\");\n\t\treturn retval;\n\t    }\n\t    retval = pam_get_item(pamh, PAM_AUTHTOK, &password);\n\t}\n\tif (retval != PAM_SUCCESS || password == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"can not recover user password\");\n\t    return PAM_AUTHTOK_RECOVERY_ERR;\n\t}\n     }\n\n     if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_INFO, \"Verify user `%s' with a password\",\n\t\t    username);\n\n     /* Now use the username to look up password in the database file */\n     retval = user_lookup(pamh, database, cryptmode, username, password, ctrl);\n     switch (retval) {\n\t case -2:\n\t     /* some sort of system error. The log was already printed */\n\t     return PAM_SERVICE_ERR;\n\t case -1:\n\t     /* incorrect password */\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"user `%s' denied access (incorrect password)\",\n\t\t\tusername);\n\t     return PAM_AUTH_ERR;\n\t case 1:\n\t     /* the user does not exist in the database */\n\t     if (ctrl & PAM_DEBUG_ARG)\n\t\t pam_syslog(pamh, LOG_NOTICE,\n\t\t\t    \"user `%s' not found in the database\", username);\n\t     return PAM_USER_UNKNOWN;\n\t case 0:\n\t     /* Otherwise, the authentication looked good */\n\t     pam_syslog(pamh, LOG_NOTICE, \"user '%s' granted access\", username);\n\t     return PAM_SUCCESS;\n\t default:\n\t     /* we don't know anything about this return value */\n\t     pam_syslog(pamh, LOG_ERR,\n\t\t      \"internal module error (retval = %d, user = `%s'\",\n\t\t      retval, username);\n\t     return PAM_SERVICE_ERR;\n     }\n\n     /* should not be reached */\n     return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"internal module error (retval = %d, user = `%s'\"",
            "retval",
            "username"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user '%s' granted access\"",
            "username"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user `%s' not found in the database\"",
            "username"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user `%s' denied access (incorrect password)\"",
            "username"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_lookup",
          "args": [
            "pamh",
            "database",
            "cryptmode",
            "username",
            "password",
            "ctrl"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "user_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "142-336",
          "snippet": "static int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#  include <db.h>",
            "# include <ndbm.h>",
            "#include \"pam_userdb.h\"",
            "#include <crypt.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Verify user `%s' with a password\"",
            "username"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can not recover user password\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&password"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can not obtain password from user\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obtain_authtok",
          "args": [
            "pamh"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "obtain_authtok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "46-75",
          "snippet": "static int\nobtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n\n    /* set the auth token */\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n    /* clean it up */\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#  include <db.h>",
            "# include <ndbm.h>",
            "#include \"pam_userdb.h\"",
            "#include <crypt.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nobtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n\n    /* set the auth token */\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n    /* clean it up */\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&password"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can not obtain password from user\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can not get the database name\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&database",
            "&cryptmode"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "77-130",
          "snippet": "static int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#  include <db.h>",
            "# include <ndbm.h>",
            "#include \"pam_userdb.h\"",
            "#include <crypt.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n     const char *username;\n     const void *password;\n     const char *database = NULL;\n     const char *cryptmode = NULL;\n     int retval = PAM_AUTH_ERR, ctrl;\n\n     /* parse arguments */\n     ctrl = _pam_parse(pamh, argc, argv, &database, &cryptmode);\n     if (database == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"can not get the database name\");\n        return PAM_SERVICE_ERR;\n     }\n\n     /* Get the username */\n     retval = pam_get_user(pamh, &username, NULL);\n     if (retval != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n                   pam_strerror(pamh, retval));\n        return PAM_SERVICE_ERR;\n     }\n\n     if ((ctrl & PAM_USE_FPASS_ARG) == 0 && (ctrl & PAM_TRY_FPASS_ARG) == 0) {\n        /* Converse to obtain a password */\n        retval = obtain_authtok(pamh);\n        if (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"can not obtain password from user\");\n\t    return retval;\n        }\n     }\n\n     /* Check if we got a password */\n     retval = pam_get_item(pamh, PAM_AUTHTOK, &password);\n     if (retval != PAM_SUCCESS || password == NULL) {\n        if ((ctrl & PAM_TRY_FPASS_ARG) != 0) {\n\t    /* Converse to obtain a password */\n\t    retval = obtain_authtok(pamh);\n\t    if (retval != PAM_SUCCESS) {\n\t        pam_syslog(pamh, LOG_ERR, \"can not obtain password from user\");\n\t\treturn retval;\n\t    }\n\t    retval = pam_get_item(pamh, PAM_AUTHTOK, &password);\n\t}\n\tif (retval != PAM_SUCCESS || password == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"can not recover user password\");\n\t    return PAM_AUTHTOK_RECOVERY_ERR;\n\t}\n     }\n\n     if (ctrl & PAM_DEBUG_ARG)\n\t pam_syslog(pamh, LOG_INFO, \"Verify user `%s' with a password\",\n\t\t    username);\n\n     /* Now use the username to look up password in the database file */\n     retval = user_lookup(pamh, database, cryptmode, username, password, ctrl);\n     switch (retval) {\n\t case -2:\n\t     /* some sort of system error. The log was already printed */\n\t     return PAM_SERVICE_ERR;\n\t case -1:\n\t     /* incorrect password */\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"user `%s' denied access (incorrect password)\",\n\t\t\tusername);\n\t     return PAM_AUTH_ERR;\n\t case 1:\n\t     /* the user does not exist in the database */\n\t     if (ctrl & PAM_DEBUG_ARG)\n\t\t pam_syslog(pamh, LOG_NOTICE,\n\t\t\t    \"user `%s' not found in the database\", username);\n\t     return PAM_USER_UNKNOWN;\n\t case 0:\n\t     /* Otherwise, the authentication looked good */\n\t     pam_syslog(pamh, LOG_NOTICE, \"user '%s' granted access\", username);\n\t     return PAM_SUCCESS;\n\t default:\n\t     /* we don't know anything about this return value */\n\t     pam_syslog(pamh, LOG_ERR,\n\t\t      \"internal module error (retval = %d, user = `%s'\",\n\t\t      retval, username);\n\t     return PAM_SERVICE_ERR;\n     }\n\n     /* should not be reached */\n     return PAM_IGNORE;\n}"
  },
  {
    "function_name": "user_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "142-336",
    "snippet": "static int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbm_close",
          "args": [
            "dbm"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_close",
          "args": [
            "dbm"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "key.dptr + strlen(user) + 1",
            "pass",
            "strlen(pass)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "key.dptr + strlen(user) + 1",
            "pass",
            "strlen(pass)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "key.dptr",
            "user",
            "strlen(user)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_nextkey",
          "args": [
            "dbm"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_firstkey",
          "args": [
            "dbm"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_close",
          "args": [
            "dbm"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"error returned by dbm_fetch: %m\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_close",
          "args": [
            "dbm"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"defaulting to plaintext password mode\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"invalid value for crypt parameter: %s\"",
            "cryptmode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "cryptmode",
            "\"none\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "data.dptr",
            "pass",
            "data.dsize"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "data.dptr",
            "pass",
            "data.dsize"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pwhash"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"crypt() returned NULL\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"computed hash: %s\"",
            "cryptpw"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"lengths of computed and stored hashes differ\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data.dptr",
            "cryptpw",
            "data.dsize"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cryptpw"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt",
          "args": [
            "pass",
            "pwhash"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "bigcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt.c",
          "lines": "51-163",
          "snippet": "char *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}",
          "includes": [
            "#include \"bigcrypt.h\"",
            "#include <crypt.h>",
            "#include <security/_pam_macros.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)",
            "#define ESEGMENT_SIZE      11",
            "#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)",
            "#define SALT_SIZE          2",
            "#define SEGMENT_SIZE       8",
            "#define MAX_PASS_LEN       16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bigcrypt.h\"\n#include <crypt.h>\n#include <security/_pam_macros.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)\n#define ESEGMENT_SIZE      11\n#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)\n#define SALT_SIZE          2\n#define SEGMENT_SIZE       8\n#define MAX_PASS_LEN       16\n\nchar *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypt_r",
          "args": [
            "pass",
            "pwhash",
            "cdata"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"malloc failed: struct crypt_data\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*cdata)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"strndup failed: data.dptr\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup",
          "args": [
            "data.dptr",
            "data.dsize"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"case-insensitive comparison only works with plaintext passwords\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"password hash in database is too short\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "cryptmode",
            "\"crypt\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_close",
          "args": [
            "dbm"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"password in database is [%p]`%.*s', len is %d\"",
            "data.dptr",
            "data.dsize",
            "(char *) data.dptr",
            "data.dsize"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key.dptr",
            "0",
            "key.dsize"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_fetch",
          "args": [
            "dbm",
            "key"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key.dptr"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&key.dptr",
            "\"%s-%s\"",
            "user",
            "pass"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&key",
            "0",
            "sizeof(key)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"key[len=%d] = `%s', data[len=%d] = `%s'\"",
            "key.dsize",
            "key.dptr",
            "data.dsize",
            "data.dptr"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_fetch",
          "args": [
            "dbm",
            "key"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_nextkey",
          "args": [
            "dbm"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_firstkey",
          "args": [
            "dbm"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Database dump:\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"user_lookup: could not open database `%s': %m\"",
            "database"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbm_open",
          "args": [
            "database",
            "O_RDONLY",
            "0644"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nuser_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = -2;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"crypt\") != NULL) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw = NULL;\n\n\t  if (data.dsize < 13) {\n\t    /* hash is too short */\n\t    pam_syslog(pamh, LOG_INFO, \"password hash in database is too short\");\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    pam_syslog(pamh, LOG_INFO,\n\t       \"case-insensitive comparison only works with plaintext passwords\");\n\t  } else {\n\t    /* libdb is not guaranteed to produce null terminated strings */\n\t    char *pwhash = strndup(data.dptr, data.dsize);\n\n\t    if (pwhash == NULL) {\n\t      pam_syslog(pamh, LOG_CRIT, \"strndup failed: data.dptr\");\n\t    } else {\n#ifdef HAVE_CRYPT_R\n\t      struct crypt_data *cdata = NULL;\n\t      cdata = malloc(sizeof(*cdata));\n\t      if (cdata == NULL) {\n\t        pam_syslog(pamh, LOG_CRIT, \"malloc failed: struct crypt_data\");\n\t      } else {\n\t        cdata->initialized = 0;\n\t        cryptpw = crypt_r(pass, pwhash, cdata);\n\t      }\n#else\n\t      cryptpw = crypt (pass, pwhash);\n#endif\n\t      if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n\t        compare = memcmp(data.dptr, cryptpw, data.dsize);\n\t      } else {\n\t        if (ctrl & PAM_DEBUG_ARG) {\n\t          if (cryptpw) {\n\t            pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n\t            pam_syslog(pamh, LOG_INFO, \"computed hash: %s\", cryptpw);\n\t          } else {\n\t            pam_syslog(pamh, LOG_ERR, \"crypt() returned NULL\");\n\t          }\n\t        }\n\t      }\n#ifdef HAVE_CRYPT_R\n\t      free(cdata);\n#endif\n\t    }\n\t    free(pwhash);\n\t  }\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && pam_str_skip_icase_prefix(cryptmode, \"none\") == NULL\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "77-130",
    "snippet": "static int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"crypt= specification missing argument - ignored\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "*argv",
            "\"crypt=\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"db= specification missing argument - ignored\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "*argv",
            "\"db=\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"try_first_pass\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"use_first_pass\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"key_only\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"unknown_ok\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"dump\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*argv",
            "\"icase\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\n_pam_parse (pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **database, const char **cryptmode)\n{\n  int ctrl;\n\n  *database = NULL;\n  *cryptmode = NULL;\n\n  /* step through arguments */\n  for (ctrl = 0; argc-- > 0; ++argv)\n    {\n      const char *str;\n\n      /* generic options */\n\n      if (!strcmp(*argv,\"debug\"))\n\tctrl |= PAM_DEBUG_ARG;\n      else if (!strcasecmp(*argv, \"icase\"))\n\tctrl |= PAM_ICASE_ARG;\n      else if (!strcasecmp(*argv, \"dump\"))\n\tctrl |= PAM_DUMP_ARG;\n      else if (!strcasecmp(*argv, \"unknown_ok\"))\n\tctrl |= PAM_UNKNOWN_OK_ARG;\n      else if (!strcasecmp(*argv, \"key_only\"))\n\tctrl |= PAM_KEY_ONLY_ARG;\n      else if (!strcasecmp(*argv, \"use_first_pass\"))\n\tctrl |= PAM_USE_FPASS_ARG;\n      else if (!strcasecmp(*argv, \"try_first_pass\"))\n\tctrl |= PAM_TRY_FPASS_ARG;\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"db=\")) != NULL)\n\t{\n\t  *database = str;\n\t  if (**database == '\\0') {\n\t    *database = NULL;\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"db= specification missing argument - ignored\");\n\t  }\n\t}\n      else if ((str = pam_str_skip_icase_prefix(*argv, \"crypt=\")) != NULL)\n\t{\n\t  *cryptmode = str;\n\t  if (**cryptmode == '\\0')\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"crypt= specification missing argument - ignored\");\n\t}\n      else\n\t{\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n  return ctrl;\n}"
  },
  {
    "function_name": "obtain_authtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
    "lines": "46-75",
    "snippet": "static int\nobtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n\n    /* set the auth token */\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n    /* clean it up */\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#  include <db.h>",
      "# include <ndbm.h>",
      "#include \"pam_userdb.h\"",
      "#include <crypt.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&item"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "resp"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "resp"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "resp"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "PAM_PROMPT_ECHO_OFF",
            "&resp",
            "_(\"Password: \")"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Password: \""
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "obtain_authtok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_userdb/pam_userdb.c",
          "lines": "46-75",
          "snippet": "static int\nobtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n\n    /* set the auth token */\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n    /* clean it up */\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n\n    return retval;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#  include <db.h>\n# include <ndbm.h>\n#include \"pam_userdb.h\"\n#include <crypt.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nobtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n\n    /* set the auth token */\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n    /* clean it up */\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n\n    return retval;\n}"
  }
]