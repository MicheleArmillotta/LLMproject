[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
    "lines": "221-236",
    "snippet": "int\nmain (int argc, char *argv[])\n{\n\tstruct options opts;\n\n\tif (args_parse(argc, argv, &opts)) {\n\t\tusage(argv[0]);\n\t\treturn 1;\n\t}\n\n\tif (opts.user == NULL) {\n\t\treturn do_allusers(&opts);\n\t}\n\n\treturn do_user(&opts, opts.user);\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_user",
          "args": [
            "&opts",
            "opts.user"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "do_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "107-191",
          "snippet": "static int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define AUDIT_NO_ID     ((unsigned int) -1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define AUDIT_NO_ID     ((unsigned int) -1)\n\nstatic int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_allusers",
          "args": [
            "&opts"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "do_allusers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "193-217",
          "snippet": "static int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "argv[0]"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "100-105",
          "snippet": "static void\nusage(const char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\"),\n\t\tprogname);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nusage(const char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\"),\n\t\tprogname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "args_parse",
          "args": [
            "argc",
            "argv",
            "&opts"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "args_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "63-98",
          "snippet": "static int\nargs_parse(int argc, char **argv, struct options *opts)\n{\n\tint i;\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = FAILLOCK_DEFAULT_TALLYDIR;\n\topts->progname = argv[0];\n\n\tfor (i = 1; i < argc; ++i) {\n\t\tif (strcmp(argv[i], \"--dir\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No directory supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->dir = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--user\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No user name supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->user = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--reset\") == 0) {\n\t\t\topts->reset = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Unknown option: %s\\n\", argv[0], argv[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nargs_parse(int argc, char **argv, struct options *opts)\n{\n\tint i;\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = FAILLOCK_DEFAULT_TALLYDIR;\n\topts->progname = argv[0];\n\n\tfor (i = 1; i < argc; ++i) {\n\t\tif (strcmp(argv[i], \"--dir\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No directory supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->dir = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--user\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No user name supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->user = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--reset\") == 0) {\n\t\t\topts->reset = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Unknown option: %s\\n\", argv[0], argv[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\nmain (int argc, char *argv[])\n{\n\tstruct options opts;\n\n\tif (args_parse(argc, argv, &opts)) {\n\t\tusage(argv[0]);\n\t\treturn 1;\n\t}\n\n\tif (opts.user == NULL) {\n\t\treturn do_allusers(&opts);\n\t}\n\n\treturn do_user(&opts, opts.user);\n}"
  },
  {
    "function_name": "do_allusers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
    "lines": "193-217",
    "snippet": "static int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "userlist"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_user",
          "args": [
            "opts",
            "userlist[i]->d_name"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "do_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "107-191",
          "snippet": "static int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define AUDIT_NO_ID     ((unsigned int) -1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define AUDIT_NO_ID     ((unsigned int) -1)\n\nstatic int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Error reading tally directory: %m\\n\"",
            "opts->progname"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "opts->dir",
            "&userlist",
            "NULL",
            "alphasort"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
    "lines": "107-191",
    "snippet": "static int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define AUDIT_NO_ID     ((unsigned int) -1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tallies.records"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-19s %-5s %-52.52s %s\\n\"",
            "timebuf",
            "status & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\")",
            "tallies.records[i].source",
            "status & TALLY_STATUS_VALID ? \"V\":\"I\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "timebuf",
            "sizeof(timebuf)",
            "\"%Y-%m-%d %H:%M:%S\"",
            "tm"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Invalid timestamp in the tally record\\n\"",
            "opts->progname"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&when"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-19s %-5s %-48s %-5s\\n\"",
            "\"When\"",
            "\"Type\"",
            "\"Source\"",
            "\"Valid\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:\\n\"",
            "user"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "NULL"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Error reading the tally file for %s:\"",
            "opts->progname",
            "user"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_tally",
          "args": [
            "fd",
            "&tallies"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "read_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "115-148",
          "snippet": "int\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_RECORDS 1024",
            "#define CHUNK_SIZE (64 * sizeof(struct tally))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define MAX_RECORDS 1024\n#define CHUNK_SIZE (64 * sizeof(struct tally))\n\nint\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tallies",
            "0",
            "sizeof(tallies)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "audit_fd"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_acct_message",
          "args": [
            "audit_fd",
            "AUDIT_USER_MGMT",
            "NULL",
            "\"faillock-reset\"",
            "user",
            "pwd != NULL ? pwd->pw_uid : AUDIT_NO_ID",
            "NULL",
            "NULL",
            "NULL",
            "rv == 0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_open",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Error clearing the tally file for %s:\"",
            "opts->progname",
            "user"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "NULL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Error opening the tally file for %s:\"",
            "opts->progname",
            "user"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_tally",
          "args": [
            "opts->dir",
            "user",
            "pwd != NULL ? pwd->pw_uid : 0",
            "0"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "open_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "53-110",
          "snippet": "int\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nint\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define AUDIT_NO_ID     ((unsigned int) -1)\n\nstatic int\ndo_user(struct options *opts, const char *user)\n{\n\tint fd;\n\tint rv;\n\tstruct tally_data tallies;\n\tstruct passwd *pwd;\n\n\tpwd = getpwnam(user);\n\n\tfd = open_tally(opts->dir, user, pwd != NULL ? pwd->pw_uid : 0, 0);\n\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Error opening the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\treturn 3;\n\t\t}\n\t}\n\tif (opts->reset) {\n#ifdef HAVE_LIBAUDIT\n\t\tint audit_fd;\n#endif\n\n\t\twhile ((rv=ftruncate(fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"%s: Error clearing the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n#ifdef HAVE_LIBAUDIT\n\t\t}\n\t\tif ((audit_fd=audit_open()) >= 0) {\n\t\t\taudit_log_acct_message(audit_fd, AUDIT_USER_MGMT, NULL,\n\t\t\t\t\"faillock-reset\", user,\n\t\t\t\tpwd != NULL ? pwd->pw_uid : AUDIT_NO_ID,\n\t\t\t\tNULL, NULL, NULL, rv == 0);\n\t\t\tclose(audit_fd);\n\t\t}\n\t\tif (rv == -1) {\n#endif\n\t\t\tclose(fd);\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse {\n\t\tunsigned int i;\n\n\t\tmemset(&tallies, 0, sizeof(tallies));\n\t\tif (read_tally(fd, &tallies) == -1) {\n\t\t\tfprintf(stderr, \"%s: Error reading the tally file for %s:\",\n\t\t\t\topts->progname, user);\n\t\t\tperror(NULL);\n\t\t\tclose(fd);\n\t\t\treturn 5;\n\t\t}\n\n\t\tprintf(\"%s:\\n\", user);\n\t\tprintf(\"%-19s %-5s %-48s %-5s\\n\", \"When\", \"Type\", \"Source\", \"Valid\");\n\n\t\tfor (i = 0; i < tallies.count; i++) {\n\t\t\tstruct tm *tm;\n\t\t\tchar timebuf[80];\n\t\t\tuint16_t status = tallies.records[i].status;\n\t\t\ttime_t when = tallies.records[i].time;\n\n\t\t\ttm = localtime(&when);\n\t\t\tif(tm == NULL) {\n\t\t\t\tfprintf(stderr, \"%s: Invalid timestamp in the tally record\\n\",\n\t\t\t\t\topts->progname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n\t\t\tprintf(\"%-19s %-5s %-52.52s %s\\n\", timebuf,\n\t\t\t\tstatus & TALLY_STATUS_RHOST ? \"RHOST\" : (status & TALLY_STATUS_TTY ? \"TTY\" : \"SVC\"),\n\t\t\t\ttallies.records[i].source, status & TALLY_STATUS_VALID ? \"V\":\"I\");\n\t\t}\n\t\tfree(tallies.records);\n\t}\n\tclose(fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
    "lines": "100-105",
    "snippet": "static void\nusage(const char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\"),\n\t\tprogname);\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\")",
            "progname"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\""
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "do_allusers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
          "lines": "193-217",
          "snippet": "static int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ndo_allusers(struct options *opts)\n{\n\tstruct dirent **userlist;\n\tint rv, i;\n\n\trv = scandir(opts->dir, &userlist, NULL, alphasort);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"%s: Error reading tally directory: %m\\n\", opts->progname);\n\t\treturn 2;\n\t}\n\n\tfor (i = 0; i < rv; i++) {\n\t\tif (userlist[i]->d_name[0] == '.') {\n\t\t\tif ((userlist[i]->d_name[1] == '.' && userlist[i]->d_name[2] == '\\0') ||\n\t\t\t    userlist[i]->d_name[1] == '\\0')\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo_user(opts, userlist[i]->d_name);\n\t\tfree(userlist[i]);\n\t}\n\tfree(userlist);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nusage(const char *progname)\n{\n\tfprintf(stderr, _(\"Usage: %s [--dir /path/to/tally-directory] [--user username] [--reset]\\n\"),\n\t\tprogname);\n}"
  },
  {
    "function_name": "args_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/main.c",
    "lines": "63-98",
    "snippet": "static int\nargs_parse(int argc, char **argv, struct options *opts)\n{\n\tint i;\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = FAILLOCK_DEFAULT_TALLYDIR;\n\topts->progname = argv[0];\n\n\tfor (i = 1; i < argc; ++i) {\n\t\tif (strcmp(argv[i], \"--dir\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No directory supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->dir = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--user\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No user name supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->user = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--reset\") == 0) {\n\t\t\topts->reset = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Unknown option: %s\\n\", argv[0], argv[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <time.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Unknown option: %s\\n\"",
            "argv[0]",
            "argv[i]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--reset\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: No user name supplied.\\n\"",
            "argv[0]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--user\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: No directory supplied.\\n\"",
            "argv[0]"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--dir\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "opts",
            "0",
            "sizeof(*opts)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <pwd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\nargs_parse(int argc, char **argv, struct options *opts)\n{\n\tint i;\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = FAILLOCK_DEFAULT_TALLYDIR;\n\topts->progname = argv[0];\n\n\tfor (i = 1; i < argc; ++i) {\n\t\tif (strcmp(argv[i], \"--dir\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No directory supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->dir = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--user\") == 0) {\n\t\t\t++i;\n\t\t\tif (i >= argc || strlen(argv[i]) == 0) {\n\t\t\t\tfprintf(stderr, \"%s: No user name supplied.\\n\", argv[0]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->user = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"--reset\") == 0) {\n\t\t\topts->reset = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"%s: Unknown option: %s\\n\", argv[0], argv[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
  }
]