[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "514-519",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  return call_exec (\"close_session\", pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_exec",
          "args": [
            "\"close_session\"",
            "pamh",
            "argc",
            "argv"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "call_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "89-473",
          "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  return call_exec (\"close_session\", pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "507-512",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n  return call_exec (\"open_session\", pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_exec",
          "args": [
            "\"open_session\"",
            "pamh",
            "argc",
            "argv"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "call_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "89-473",
          "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n  return call_exec (\"open_session\", pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "500-505",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n  return call_exec (\"account\", pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_exec",
          "args": [
            "\"account\"",
            "pamh",
            "argc",
            "argv"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "call_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "89-473",
          "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n  return call_exec (\"account\", pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "491-498",
    "snippet": "int\npam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n  if (flags & PAM_PRELIM_CHECK)\n    return PAM_SUCCESS;\n  return call_exec (\"password\", pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_exec",
          "args": [
            "\"password\"",
            "pamh",
            "argc",
            "argv"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "call_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "89-473",
          "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n  if (flags & PAM_PRELIM_CHECK)\n    return PAM_SUCCESS;\n  return call_exec (\"password\", pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "482-487",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "475-480",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  return call_exec (\"auth\", pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_exec",
          "args": [
            "\"auth\"",
            "pamh",
            "argc",
            "argv"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "call_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "89-473",
          "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  return call_exec (\"auth\", pamh, argc, argv);\n}"
  },
  {
    "function_name": "call_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "89-473",
    "snippet": "static int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "i"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"execve(%s,...) failed: %m\"",
            "arggv[0]"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "arggv[0]",
            "(char **) arggv",
            "envlist"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Calling %s ...\"",
            "arggv[0]"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ENOMEM"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"prepare environment failed: %m\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&envstr",
            "\"PAM_TYPE=%s\"",
            "pam_type"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ENOMEM"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"prepare environment failed: %m\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&envstr",
            "\"%s=%s\"",
            "env_items[i].name",
            "(const char *)item"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "env_items[i].item",
            "&item"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ENOMEM"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"realloc environment failed: %m\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "envlist",
            "(envlen + nitems + 2) * sizeof(*envlist)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_ARRAY_SIZE",
          "args": [
            "env_items"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_getenvlist",
          "args": [
            "pamh"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ENOMEM"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "argc + 4",
            "sizeof (char *)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setsid failed: %m\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setuid(%lu) failed: %m\"",
            "(unsigned long) geteuid ()"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "geteuid ()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "redirect_stdin",
            "redirect_stdout",
            "redirect_stdout"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 failed: %m\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDOUT_FILENO",
            "STDERR_FILENO"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "STDOUT_FILENO",
            "buffer",
            "strlen (buffer)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&buffer",
            "\"*** %s\"",
            "ctime (&tm)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&tm"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 failed: %m\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "i",
            "STDOUT_FILENO"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"open of %s failed: %m\"",
            "logfile"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "logfile",
            "O_CREAT|O_APPEND|O_WRONLY",
            "S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 to stdout failed: %m\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdout_fds[1]",
            "STDOUT_FILENO"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of STDIN failed: %m\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fds[0]",
            "STDIN_FILENO"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "stdout_fds[0]"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_fd_to_non_stdio",
          "args": [
            "pamh",
            "stdout_fds[1]"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "move_fd_to_non_stdio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
          "lines": "73-87",
          "snippet": "static int\nmove_fd_to_non_stdio (pam_handle_t *pamh, int fd)\n{\n  while (fd < 3)\n    {\n      fd = dup(fd);\n      if (fd == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup failed: %m\");\n\t  _exit (err);\n\t}\n    }\n  return fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic int\nmove_fd_to_non_stdio (pam_handle_t *pamh, int fd)\n{\n  while (fd < 3)\n    {\n      fd = dup(fd);\n      if (fd == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup failed: %m\");\n\t  _exit (err);\n\t}\n    }\n  return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"%s failed: unknown status 0x%x\")",
            "argv[optargc]",
            "status"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s failed: unknown status 0x%x\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "406-412",
          "snippet": "static const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DATANAME \"pam_selinux_context\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_selinux_context\"\n\nstatic const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s failed: unknown status 0x%x\"",
            "argv[optargc]",
            "status"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"%s failed: caught signal %d%s\")",
            "argv[optargc]",
            "WTERMSIG(status)",
            "WCOREDUMP(status) ? \" (core dumped)\" : \"\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WCOREDUMP",
          "args": [
            "status"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s failed: caught signal %d%s\"",
            "argv[optargc]",
            "WTERMSIG(status)",
            "WCOREDUMP(status) ? \" (core dumped)\" : \"\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WCOREDUMP",
          "args": [
            "status"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"%s failed: exit code %d\")",
            "argv[optargc]",
            "WEXITSTATUS(status)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s failed: exit code %d\"",
            "argv[optargc]",
            "WEXITSTATUS(status)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"waitpid returns with -1: %m\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stdout_file"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "buf"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "stdout_file"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "stdout_fds[1]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"sending password to child failed: %m\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds[1]",
            "authtok",
            "strlen(authtok)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "authtok"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"send password to child\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"No path given as argument\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not fdopen pipe: %m\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "stdout_fds[0]",
            "\"r\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not create pipe: %m\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "stdout_fds"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not create pipe: %m\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "authtok",
            "void_pass",
            "sizeof(authtok) - 1"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "resp"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "authtok",
            "resp",
            "sizeof(authtok) - 1"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "resp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "resp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "PAM_PROMPT_ECHO_OFF",
            "&resp",
            "_(\"Password: \")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_get_item (PAM_AUTHTOK) failed, return %d\"",
            "retval"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&void_pass"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"expose_authtok not supported for type %s\"",
            "pam_type"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pam_type",
            "\"auth\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&name",
            "NULL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"expose_authtok\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"quiet_log\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"quiet\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"seteuid\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pam_type",
            "str"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv[optargc]",
            "\"type=\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv[optargc]",
            "\"log=\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"stdout\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[optargc]",
            "\"debug\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"This module needs at least one argument\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic struct {\n  int item;\n  const char *name;\n} env_items[] = {\n  ENV_ITEM(PAM_SERVICE),\n  ENV_ITEM(PAM_USER),\n  ENV_ITEM(PAM_TTY),\n  ENV_ITEM(PAM_RHOST),\n  ENV_ITEM(PAM_RUSER),\n};\n\nstatic int\ncall_exec (const char *pam_type, pam_handle_t *pamh,\n\t   int argc, const char **argv)\n{\n  int debug = 0;\n  int call_setuid = 0;\n  int quiet = 0;\n  int quiet_log = 0;\n  int expose_authtok = 0;\n  int use_stdout = 0;\n  int optargc;\n  const char *logfile = NULL;\n  char authtok[PAM_MAX_RESP_SIZE] = {};\n  pid_t pid;\n  int fds[2];\n  int stdout_fds[2];\n  FILE *stdout_file = NULL;\n  int retval;\n  const char *name;\n\n  if (argc < 1) {\n    pam_syslog (pamh, LOG_ERR,\n\t\t\"This module needs at least one argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  for (optargc = 0; optargc < argc; optargc++)\n    {\n      const char *str;\n\n      if (argv[optargc][0] == '/') /* paths starts with / */\n\tbreak;\n\n      if (strcasecmp (argv[optargc], \"debug\") == 0)\n\tdebug = 1;\n      else if (strcasecmp (argv[optargc], \"stdout\") == 0)\n\tuse_stdout = 1;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"log=\")) != NULL)\n\tlogfile = str;\n      else if ((str = pam_str_skip_icase_prefix (argv[optargc], \"type=\")) != NULL)\n\t{\n\t  if (strcmp (pam_type, str) != 0)\n\t    return PAM_IGNORE;\n\t}\n      else if (strcasecmp (argv[optargc], \"seteuid\") == 0)\n\tcall_setuid = 1;\n      else if (strcasecmp (argv[optargc], \"quiet\") == 0)\n\tquiet = 1;\n      else if (strcasecmp (argv[optargc], \"quiet_log\") == 0)\n\tquiet_log = 1;\n      else if (strcasecmp (argv[optargc], \"expose_authtok\") == 0)\n\texpose_authtok = 1;\n      else\n\tbreak; /* Unknown option, assume program to execute. */\n    }\n\n  /* Request user name to be available. */\n\n  retval = pam_get_user(pamh, &name, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      if (retval == PAM_CONV_AGAIN)\n        retval = PAM_INCOMPLETE;\n      return retval;\n    }\n\n  if (expose_authtok == 1)\n    {\n      if (strcmp (pam_type, \"auth\") != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"expose_authtok not supported for type %s\", pam_type);\n\t  expose_authtok = 0;\n\t}\n      else\n\t{\n\t  const void *void_pass;\n\n\t  retval = pam_get_item (pamh, PAM_AUTHTOK, &void_pass);\n\t  if (retval != PAM_SUCCESS)\n\t    {\n\t      if (debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"pam_get_item (PAM_AUTHTOK) failed, return %d\",\n\t\t\t    retval);\n\t      return retval;\n\t    }\n\t  else if (void_pass == NULL)\n\t    {\n\t      char *resp = NULL;\n\n\t      retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t   &resp, _(\"Password: \"));\n\n\t      if (retval != PAM_SUCCESS)\n\t\t{\n\t\t  _pam_drop (resp);\n\t\t  if (retval == PAM_CONV_AGAIN)\n\t\t    retval = PAM_INCOMPLETE;\n\t\t  return retval;\n\t\t}\n\n\t      if (resp)\n\t\t{\n\t\t  pam_set_item (pamh, PAM_AUTHTOK, resp);\n\t\t  strncpy (authtok, resp, sizeof(authtok) - 1);\n\t\t  _pam_drop (resp);\n\t\t}\n\t    }\n\t  else\n\t    strncpy (authtok, void_pass, sizeof(authtok) - 1);\n\n\t  if (pipe(fds) != 0)\n\t    {\n\t      pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t      return PAM_SYSTEM_ERR;\n\t    }\n\t}\n    }\n\n  if (use_stdout)\n    {\n      if (pipe(stdout_fds) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      stdout_file = fdopen(stdout_fds[0], \"r\");\n      if (!stdout_file)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Could not fdopen pipe: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n    }\n\n  if (optargc >= argc) {\n    pam_syslog (pamh, LOG_ERR, \"No path given as argument\");\n    return PAM_SERVICE_ERR;\n  }\n\n  pid = fork();\n  if (pid == -1)\n    return PAM_SYSTEM_ERR;\n  if (pid > 0) /* parent */\n    {\n      int status = 0;\n      pid_t rc;\n\n      if (expose_authtok) /* send the password to the child */\n\t{\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"send password to child\");\n\t  if (write(fds[1], authtok, strlen(authtok)) == -1)\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t      \"sending password to child failed: %m\");\n\n          close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n          close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  char buf[4096];\n\t  close(stdout_fds[1]);\n\t  while (fgets(buf, sizeof(buf), stdout_file) != NULL)\n\t    {\n\t      size_t len;\n\t      len = strlen(buf);\n\t      if (buf[len-1] == '\\n')\n\t\tbuf[len-1] = '\\0';\n\t      pam_info(pamh, \"%s\", buf);\n\t    }\n\t  fclose(stdout_file);\n\t}\n\n      while ((rc = waitpid (pid, &status, 0)) == -1 &&\n\t     errno == EINTR);\n      if (rc == (pid_t)-1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"waitpid returns with -1: %m\");\n\t  return PAM_SYSTEM_ERR;\n\t}\n      else if (status != 0)\n\t{\n\t  if (WIFEXITED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: exit code %d\",\n\t\t\t  argv[optargc], WEXITSTATUS(status));\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: exit code %d\"),\n\t\t\t argv[optargc], WEXITSTATUS(status));\n\t    }\n\t  else if (WIFSIGNALED(status))\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: caught signal %d%s\",\n\t\t\t  argv[optargc], WTERMSIG(status),\n\t\t\t  WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: caught signal %d%s\"),\n\t\t\t argv[optargc], WTERMSIG(status),\n\t\t\t WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n\t    }\n\t  else\n\t    {\n\t\tif (!quiet_log)\n\t      pam_syslog (pamh, LOG_ERR, \"%s failed: unknown status 0x%x\",\n\t\t\t  argv[optargc], status);\n\t\tif (!quiet)\n\t      pam_error (pamh, _(\"%s failed: unknown status 0x%x\"),\n\t\t\t argv[optargc], status);\n\t    }\n\t  return PAM_SYSTEM_ERR;\n\t}\n      return PAM_SUCCESS;\n    }\n  else /* child */\n    {\n      const char **arggv;\n      int i;\n      char **envlist;\n      int envlen, nitems;\n      char *envstr;\n      enum pam_modutil_redirect_fd redirect_stdin =\n\t      expose_authtok ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_PIPE_FD;\n      enum pam_modutil_redirect_fd redirect_stdout =\n\t      (use_stdout || logfile) ? PAM_MODUTIL_IGNORE_FD : PAM_MODUTIL_NULL_FD;\n\n      /* First, move all the pipes off of stdin, stdout, and stderr, to ensure\n       * that calls to dup2 won't close them. */\n\n      if (expose_authtok)\n\t{\n\t  fds[0] = move_fd_to_non_stdio(pamh, fds[0]);\n\t  close(fds[1]);\n\t}\n\n      if (use_stdout)\n\t{\n\t  stdout_fds[1] = move_fd_to_non_stdio(pamh, stdout_fds[1]);\n\t  close(stdout_fds[0]);\n\t}\n\n      /* Set up stdin. */\n\n      if (expose_authtok)\n\t{\n\t  /* reopen stdin as pipe */\n\t  if (dup2(fds[0], STDIN_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 of STDIN failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n\n      /* Set up stdout. */\n\n      if (use_stdout)\n\t{\n\t  if (dup2(stdout_fds[1], STDOUT_FILENO) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"dup2 to stdout failed: %m\");\n\t      _exit (err);\n\t    }\n\t}\n      else if (logfile)\n\t{\n\t  time_t tm = time (NULL);\n\t  char *buffer = NULL;\n\n\t  close (STDOUT_FILENO);\n\t  if ((i = open (logfile, O_CREAT|O_APPEND|O_WRONLY,\n\t\t\t S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)\n\t    {\n\t      int err = errno;\n\t      pam_syslog (pamh, LOG_ERR, \"open of %s failed: %m\",\n\t\t\t  logfile);\n\t      _exit (err);\n\t    }\n\t  if (i != STDOUT_FILENO)\n\t    {\n\t      if (dup2 (i, STDOUT_FILENO) == -1)\n\t\t{\n\t\t  int err = errno;\n\t\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t\t  _exit (err);\n\t\t}\n\t      close (i);\n\t    }\n\t  if (asprintf (&buffer, \"*** %s\", ctime (&tm)) > 0)\n\t    {\n\t      pam_modutil_write (STDOUT_FILENO, buffer, strlen (buffer));\n\t      free (buffer);\n\t    }\n\t}\n\n      if ((use_stdout || logfile) &&\n\t  dup2 (STDOUT_FILENO, STDERR_FILENO) == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup2 failed: %m\");\n\t  _exit (err);\n\t}\n\n      if (pam_modutil_sanitize_helper_fds(pamh, redirect_stdin,\n\t\t\t\t\t  redirect_stdout, redirect_stdout) < 0)\n\t_exit(1);\n\n      if (call_setuid)\n\tif (setuid (geteuid ()) == -1)\n\t  {\n\t    int err = errno;\n\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t(unsigned long) geteuid ());\n\t    _exit (err);\n\t  }\n\n      if (setsid () == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"setsid failed: %m\");\n\t  _exit (err);\n\t}\n\n      arggv = calloc (argc + 4, sizeof (char *));\n      if (arggv == NULL)\n\t_exit (ENOMEM);\n\n      for (i = 0; i < (argc - optargc); i++)\n        arggv[i] = argv[i+optargc];\n      arggv[i] = NULL;\n\n      /*\n       * Set up the child's environment list.  It consists of the PAM\n       * environment, plus a few hand-picked PAM items.\n       */\n      envlist = pam_getenvlist(pamh);\n      for (envlen = 0; envlist[envlen] != NULL; ++envlen)\n        /* nothing */ ;\n      nitems = PAM_ARRAY_SIZE(env_items);\n      /* + 2 because of PAM_TYPE and NULL entry */\n      envlist = realloc(envlist, (envlen + nitems + 2) * sizeof(*envlist));\n      if (envlist == NULL)\n      {\n        pam_syslog (pamh, LOG_CRIT, \"realloc environment failed: %m\");\n        _exit (ENOMEM);\n      }\n      for (i = 0; i < nitems; ++i)\n      {\n        const void *item;\n\n        if (pam_get_item(pamh, env_items[i].item, &item) != PAM_SUCCESS || item == NULL)\n          continue;\n        if (asprintf(&envstr, \"%s=%s\", env_items[i].name, (const char *)item) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n        envlist[envlen++] = envstr;\n        envlist[envlen] = NULL;\n      }\n\n      if (asprintf(&envstr, \"PAM_TYPE=%s\", pam_type) < 0)\n        {\n          pam_syslog (pamh, LOG_CRIT, \"prepare environment failed: %m\");\n          _exit (ENOMEM);\n        }\n      envlist[envlen++] = envstr;\n      envlist[envlen] = NULL;\n\n      if (debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Calling %s ...\", arggv[0]);\n\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      execve (arggv[0], (char **) arggv, envlist);\n      DIAG_POP_IGNORE_CAST_QUAL;\n      i = errno;\n      pam_syslog (pamh, LOG_ERR, \"execve(%s,...) failed: %m\", arggv[0]);\n      _exit (i);\n    }\n  return PAM_SYSTEM_ERR; /* will never be reached. */\n}"
  },
  {
    "function_name": "move_fd_to_non_stdio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_exec/pam_exec.c",
    "lines": "73-87",
    "snippet": "static int\nmove_fd_to_non_stdio (pam_handle_t *pamh, int fd)\n{\n  while (fd < 3)\n    {\n      fd = dup(fd);\n      if (fd == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup failed: %m\");\n\t  _exit (err);\n\t}\n    }\n  return fd;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup failed: %m\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "fd"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <time.h>\n#include \"config.h\"\n\nstatic int\nmove_fd_to_non_stdio (pam_handle_t *pamh, int fd)\n{\n  while (fd < 3)\n    {\n      fd = dup(fd);\n      if (fd == -1)\n\t{\n\t  int err = errno;\n\t  pam_syslog (pamh, LOG_ERR, \"dup failed: %m\");\n\t  _exit (err);\n\t}\n    }\n  return fd;\n}"
  }
]