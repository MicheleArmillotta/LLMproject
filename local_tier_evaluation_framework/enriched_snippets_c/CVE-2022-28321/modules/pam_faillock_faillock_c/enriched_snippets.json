[
  {
    "function_name": "update_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
    "lines": "150-176",
    "snippet": "int\nupdate_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = tallies->records;\n\tunsigned int count = tallies->count;\n\tssize_t chunk;\n\n\tif (tallies->count > MAX_RECORDS) {\n\t\tdata = tallies->records + (count - MAX_RECORDS);\n\t\tcount = MAX_RECORDS;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n\t\treturn -1;\n\t}\n\n\tchunk = pam_modutil_write(fd, data, count * sizeof(struct tally));\n\n\tif (chunk != (ssize_t)(count * sizeof(struct tally))) {\n\t\treturn -1;\n\t}\n\n\tif (ftruncate(fd, count * sizeof(struct tally)) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <security/pam_modutil.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_RECORDS 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "count * sizeof(struct tally)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fd",
            "data",
            "count * sizeof(struct tally)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define MAX_RECORDS 1024\n\nint\nupdate_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = tallies->records;\n\tunsigned int count = tallies->count;\n\tssize_t chunk;\n\n\tif (tallies->count > MAX_RECORDS) {\n\t\tdata = tallies->records + (count - MAX_RECORDS);\n\t\tcount = MAX_RECORDS;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n\t\treturn -1;\n\t}\n\n\tchunk = pam_modutil_write(fd, data, count * sizeof(struct tally));\n\n\tif (chunk != (ssize_t)(count * sizeof(struct tally))) {\n\t\treturn -1;\n\t}\n\n\tif (ftruncate(fd, count * sizeof(struct tally)) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
    "lines": "115-148",
    "snippet": "int\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <security/pam_modutil.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_RECORDS 1024",
      "#define CHUNK_SIZE (64 * sizeof(struct tally))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "(char *)data + count * sizeof(struct tally)",
            "CHUNK_SIZE"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "data",
            "count * sizeof(struct tally) + CHUNK_SIZE"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define MAX_RECORDS 1024\n#define CHUNK_SIZE (64 * sizeof(struct tally))\n\nint\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "open_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
    "lines": "53-110",
    "snippet": "int\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include <security/pam_modutil.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_return",
          "args": [
            "fchmod(fd, 0660)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "0660"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_return",
          "args": [
            "fchown(fd, uid, -1)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "uid",
            "-1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_EX"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "flags",
            "0660"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "0755"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "dir",
            "F_OK"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "login_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "325-425",
          "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "path",
            "user"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "path",
            "\"/\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "path",
            "dir"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(dir) + strlen(user) + 2"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"../\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nint\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}"
  }
]