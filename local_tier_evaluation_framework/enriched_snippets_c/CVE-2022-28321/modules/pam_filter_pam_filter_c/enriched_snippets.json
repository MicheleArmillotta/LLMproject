[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "699-714",
    "snippet": "int pam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n    int runN;\n\n    if (flags & PAM_PRELIM_CHECK)\n\trunN = FILTER_RUN1;\n    else if (flags & PAM_UPDATE_AUTHTOK)\n\trunN = FILTER_RUN2;\n    else {\n\tpam_syslog(pamh, LOG_ERR, \"unknown flags for chauthtok (0x%X)\", flags);\n\treturn PAM_TRY_AGAIN;\n    }\n\n    return need_a_filter(pamh, flags, argc, argv, \"chauthtok\", runN);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN2      04",
      "#define FILTER_RUN1      02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"chauthtok\"",
            "runN"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown flags for chauthtok (0x%X)\"",
            "flags"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN2      04\n#define FILTER_RUN1      02\n\nint pam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n    int runN;\n\n    if (flags & PAM_PRELIM_CHECK)\n\trunN = FILTER_RUN1;\n    else if (flags & PAM_UPDATE_AUTHTOK)\n\trunN = FILTER_RUN2;\n    else {\n\tpam_syslog(pamh, LOG_ERR, \"unknown flags for chauthtok (0x%X)\", flags);\n\treturn PAM_TRY_AGAIN;\n    }\n\n    return need_a_filter(pamh, flags, argc, argv, \"chauthtok\", runN);\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "689-694",
    "snippet": "int pam_sm_close_session(pam_handle_t *pamh, int flags,\n                         int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"close_session\", FILTER_RUN2);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN2      04"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"close_session\"",
            "FILTER_RUN2"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN2      04\n\nint pam_sm_close_session(pam_handle_t *pamh, int flags,\n                         int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"close_session\", FILTER_RUN2);\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "682-687",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"open_session\", FILTER_RUN1);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN1      02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"open_session\"",
            "FILTER_RUN1"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN1      02\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"open_session\", FILTER_RUN1);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "673-678",
    "snippet": "int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc,\n                     const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"setcred\", FILTER_RUN1|FILTER_RUN2 );\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN2      04",
      "#define FILTER_RUN1      02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"setcred\"",
            "FILTER_RUN1|FILTER_RUN2"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN2      04\n#define FILTER_RUN1      02\n\nint pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc,\n                     const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"setcred\", FILTER_RUN1|FILTER_RUN2 );\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "665-669",
    "snippet": "int pam_sm_setcred(pam_handle_t *pamh, int flags,\n\t\t   int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv, \"setcred\", FILTER_RUN2);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN2      04"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"setcred\"",
            "FILTER_RUN2"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN2      04\n\nint pam_sm_setcred(pam_handle_t *pamh, int flags,\n\t\t   int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv, \"setcred\", FILTER_RUN2);\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "658-663",
    "snippet": "int pam_sm_authenticate(pam_handle_t *pamh,\n\t\t\tint flags, int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"authenticate\", FILTER_RUN1);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_RUN1      02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_a_filter",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "\"authenticate\"",
            "FILTER_RUN1"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "need_a_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "602-648",
          "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_RUN1      02\n\nint pam_sm_authenticate(pam_handle_t *pamh,\n\t\t\tint flags, int argc, const char **argv)\n{\n    return need_a_filter(pamh, flags, argc, argv\n\t\t\t , \"authenticate\", FILTER_RUN1);\n}"
  },
  {
    "function_name": "need_a_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "602-648",
    "snippet": "static int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NON_TERM        020",
      "#define NEW_TERM        010",
      "#define FILTER_DEBUG     01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"[%s]\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"filter/%s, returning %d\"",
            "name",
            "retval"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_evp",
          "args": [
            "evp"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "free_evp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "235-245",
          "snippet": "static void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"tried and failed to set new terminal as PAM_TTY\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_the_terminal",
          "args": [
            "pamh"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "set_the_terminal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "583-600",
          "snippet": "static int set_the_terminal(pam_handle_t *pamh)\n{\n    const void *tty;\n\n    if (pam_get_item(pamh, PAM_TTY, &tty) != PAM_SUCCESS\n\t|| tty == NULL) {\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't get the tty name\");\n\t    return PAM_ABORT;\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int set_the_terminal(pam_handle_t *pamh)\n{\n    const void *tty;\n\n    if (pam_get_item(pamh, PAM_TTY, &tty) != PAM_SUCCESS\n\t|| tty == NULL) {\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't get the tty name\");\n\t    return PAM_ABORT;\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_filter",
          "args": [
            "pamh",
            "flags",
            "ctrl",
            "evp",
            "filterfile"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "247-581",
          "snippet": "static int\nset_filter (pam_handle_t *pamh, int flags UNUSED, int ctrl,\n\t    char * const evp[], const char *filtername)\n{\n    int status=-1;\n    char* terminal = NULL;\n    struct termios stored_mode;           /* initial terminal mode settings */\n    int fd[2], child=0, child2=0, aterminal;\n\n    if (filtername == NULL || *filtername != '/') {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"filtername not permitted; full pathname required\");\n\treturn PAM_ABORT;\n    }\n\n    if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO)) {\n\taterminal = 0;\n    } else {\n\taterminal = 1;\n    }\n\n    if (aterminal) {\n\n\t/* open the master pseudo terminal */\n\n\tfd[0] = master();\n\tif (fd[0] < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no master terminal\");\n\t    return PAM_AUTH_ERR;\n\t}\n\n\t/* set terminal into raw mode.. remember old mode so that we can\n\t   revert to it after the child has quit. */\n\n\t/* this is termios terminal handling... */\n\n\tif ( tcgetattr(STDIN_FILENO, &stored_mode) < 0 ) {\n\t    pam_syslog(pamh, LOG_CRIT, \"couldn't copy terminal mode: %m\");\n\t    /* in trouble, so close down */\n\t    close(fd[0]);\n\t    return PAM_ABORT;\n\t} else {\n\t    struct termios t_mode = stored_mode;\n\n\t    t_mode.c_iflag = 0;            /* no input control */\n\t    t_mode.c_oflag &= ~OPOST;      /* no output post processing */\n\n\t    /* no signals, canonical input, echoing, upper/lower output */\n#ifdef XCASE\n\t    t_mode.c_lflag &= ~(XCASE);\n#endif\n\t    t_mode.c_lflag &= ~(ISIG|ICANON|ECHO);\n\t    t_mode.c_cflag &= ~(CSIZE|PARENB);  /* no parity */\n\t    t_mode.c_cflag |= CS8;              /* 8 bit chars */\n\n\t    t_mode.c_cc[VMIN] = 1; /* number of chars to satisfy a read */\n\t    t_mode.c_cc[VTIME] = 0;          /* 0/10th second for chars */\n\n\t    if ( tcsetattr(STDIN_FILENO, TCSAFLUSH, &t_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"couldn't put terminal in RAW mode: %m\");\n\t\tclose(fd[0]);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /*\n\t     * NOTE: Unlike the stream socket case here the child\n\t     * opens the slave terminal as fd[1] *after* the fork...\n\t     */\n\t}\n    } else {\n\n\t/*\n\t * not a terminal line so just open a stream socket fd[0-1]\n\t * both set...\n\t */\n\n\tif ( socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0 ) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't open a stream pipe: %m\");\n\t    return PAM_ABORT;\n\t}\n    }\n\n    /* start child process */\n\n    if ( (child = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"first fork failed: %m\");\n\tif (aterminal) {\n\t\t(void) tcsetattr(STDIN_FILENO, TCSAFLUSH, &stored_mode);\n\t\tclose(fd[0]);\n\t} else {\n\t\t/* Socket pair */\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t}\n\n\treturn PAM_AUTH_ERR;\n    }\n\n    if ( child == 0 ) {                  /* child process *is* application */\n\n\tif (aterminal) {\n\n\t    /* close the controlling tty */\n\n#if defined(__hpux) && defined(O_NOCTTY)\n\t    int t = open(\"/dev/tty\", O_RDWR|O_NOCTTY);\n#else\n\t    int t = open(\"/dev/tty\",O_RDWR);\n\t    if (t >= 0) {\n\t\t(void) ioctl(t, TIOCNOTTY, NULL);\n\t\tclose(t);\n\t    }\n#endif /* defined(__hpux) && defined(O_NOCTTY) */\n\n\t    /* make this process it's own process leader */\n\t    if (setsid() == -1) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"child cannot become new session: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* grant slave terminal */\n\t    if (grantpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot grant access to slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* unlock slave terminal */\n\t    if (unlockpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot unlock slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* find slave's name */\n\t    terminal = ptsname(fd[0]); /* returned value should not be freed */\n\n\t    if (terminal == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"Cannot get the name of the slave terminal: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    fd[1] = open(terminal, O_RDWR);\n\t    close(fd[0]);      /* process is the child -- uses line fd[1] */\n\n\t    if (fd[1] < 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot open slave terminal: %s: %m\", terminal);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* initialize the child's terminal to be the way the\n\t       parent's was before we set it into RAW mode */\n\n\t    if ( tcsetattr(fd[1], TCSANOW, &stored_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot set slave terminal mode: %s: %m\", terminal);\n\t\tclose(fd[1]);\n\t\treturn PAM_ABORT;\n\t    }\n\t} else {\n\n\t    /* nothing to do for a simple stream socket */\n\n\t}\n\n\t/* re-assign the stdin/out to fd[1] <- (talks to filter). */\n\n\tif ( dup2(fd[1],STDIN_FILENO) != STDIN_FILENO ||\n\t     dup2(fd[1],STDOUT_FILENO) != STDOUT_FILENO ||\n\t     dup2(fd[1],STDERR_FILENO) != STDERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    close(fd[1]);\n\t    return PAM_ABORT;\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(STDIN_FILENO, F_SETFD, 0) ||\n\t     fcntl(STDOUT_FILENO,F_SETFD, 0) ||\n\t     fcntl(STDERR_FILENO,F_SETFD, 0) ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    return PAM_ABORT;\n\t}\n\n\t/* now the user input is read from the parent/filter: forget fd */\n\n\tclose(fd[1]);\n\n\t/* the current process is now apparently working with filtered\n\t   stdio/stdout/stderr --- success! */\n\n\treturn PAM_SUCCESS;\n    }\n\n    /* Clear out passwords... there is a security problem here in\n     * that this process never executes pam_end.  Consequently, any\n     * other sensitive data in this process is *not* explicitly\n     * overwritten, before the process terminates */\n\n    (void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n    (void) pam_set_item(pamh, PAM_OLDAUTHTOK, NULL);\n\n    /* fork a copy of process to run the actual filter executable */\n\n    if ( (child2 = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"filter fork failed: %m\");\n\tchild2 = 0;\n\n    } else if ( child2 == 0 ) {              /* exec the child filter */\n\n\tif ( dup2(fd[0],APPIN_FILENO) != APPIN_FILENO ||\n\t     dup2(fd[0],APPOUT_FILENO) != APPOUT_FILENO ||\n\t     dup2(fd[0],APPERR_FILENO) != APPERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign APPIN/OUT/ERR: %m\");\n\t    close(fd[0]);\n\t    _exit(1);\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(APPIN_FILENO, F_SETFD, 0) == -1 ||\n\t     fcntl(APPOUT_FILENO,F_SETFD, 0) == -1 ||\n\t     fcntl(APPERR_FILENO,F_SETFD, 0) == -1 ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to retain APPIN/OUT/ERR: %m\");\n\t    close(APPIN_FILENO);\n\t    close(APPOUT_FILENO);\n\t    close(APPERR_FILENO);\n\t    _exit(1);\n\t}\n\n\t/* now the user input is read from the parent through filter */\n\n\texecle(filtername, \"<pam_filter>\", NULL, evp);\n\n\t/* getting to here is an error */\n\n\tpam_syslog(pamh, LOG_ERR, \"filter: %s: %m\", filtername);\n\t_exit(1);\n\n    } else {           /* wait for either of the two children to exit */\n\n\twhile (child && child2) {    /* loop if there are two children */\n\t    int lstatus=0;\n\t    int chid;\n\n\t    chid = wait(&lstatus);\n\t    if (chid == child) {\n\n\t\tif (WIFEXITED(lstatus)) {            /* exited ? */\n\t\t    status = WEXITSTATUS(lstatus);\n\t\t} else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\t    status = -1;\n\t\t} else\n\t\t    continue;             /* just stopped etc.. */\n\t\tchild = 0;        /* the child has exited */\n\n\t    } else if (chid == child2) {\n\t\t/*\n\t\t * if the filter has exited. Let the child die\n\t\t * naturally below\n\t\t */\n\t\tif (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\t    child2 = 0;\n\t    } else {\n\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"programming error <chid=%d,lstatus=%x> \"\n\t\t\t   \"in file %s at line %d\",\n\t\t\t   chid, lstatus, __FILE__, __LINE__);\n\t\tchild = child2 = 0;\n\t\tstatus = -1;\n\n\t    }\n\t}\n    }\n\n    close(fd[0]);\n\n    /* if there is something running, wait for it to exit */\n\n    while (child || child2) {\n\tint lstatus=0;\n\tint chid;\n\n\tchid = wait(&lstatus);\n\n\tif (child && chid == child) {\n\n\t    if (WIFEXITED(lstatus)) {            /* exited ? */\n\t\tstatus = WEXITSTATUS(lstatus);\n\t    } else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\tstatus = -1;\n\t    } else\n\t\tcontinue;             /* just stopped etc.. */\n\t    child = 0;        /* the child has exited */\n\n\t} else if (child2 && chid == child2) {\n\n\t    if (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\tchild2 = 0;\n\n\t} else {\n\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"programming error <chid=%d,lstatus=%x> \"\n\t\t       \"in file %s at line %d\",\n\t\t       chid, lstatus, __FILE__, __LINE__);\n\t    child = child2 = 0;\n\t    status = -1;\n\n\t}\n    }\n\n    if (aterminal) {\n\t/* reset to initial terminal mode */\n\t    (void) tcsetattr(STDIN_FILENO, TCSANOW, &stored_mode);\n    }\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"parent process exited\");      /* clock off */\n    }\n\n    /* quit the parent process, returning the child's exit status */\n\n    exit(status);\n    return status; /* never reached, to make gcc happy */\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_DEBUG     01\n\nstatic int\nset_filter (pam_handle_t *pamh, int flags UNUSED, int ctrl,\n\t    char * const evp[], const char *filtername)\n{\n    int status=-1;\n    char* terminal = NULL;\n    struct termios stored_mode;           /* initial terminal mode settings */\n    int fd[2], child=0, child2=0, aterminal;\n\n    if (filtername == NULL || *filtername != '/') {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"filtername not permitted; full pathname required\");\n\treturn PAM_ABORT;\n    }\n\n    if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO)) {\n\taterminal = 0;\n    } else {\n\taterminal = 1;\n    }\n\n    if (aterminal) {\n\n\t/* open the master pseudo terminal */\n\n\tfd[0] = master();\n\tif (fd[0] < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no master terminal\");\n\t    return PAM_AUTH_ERR;\n\t}\n\n\t/* set terminal into raw mode.. remember old mode so that we can\n\t   revert to it after the child has quit. */\n\n\t/* this is termios terminal handling... */\n\n\tif ( tcgetattr(STDIN_FILENO, &stored_mode) < 0 ) {\n\t    pam_syslog(pamh, LOG_CRIT, \"couldn't copy terminal mode: %m\");\n\t    /* in trouble, so close down */\n\t    close(fd[0]);\n\t    return PAM_ABORT;\n\t} else {\n\t    struct termios t_mode = stored_mode;\n\n\t    t_mode.c_iflag = 0;            /* no input control */\n\t    t_mode.c_oflag &= ~OPOST;      /* no output post processing */\n\n\t    /* no signals, canonical input, echoing, upper/lower output */\n#ifdef XCASE\n\t    t_mode.c_lflag &= ~(XCASE);\n#endif\n\t    t_mode.c_lflag &= ~(ISIG|ICANON|ECHO);\n\t    t_mode.c_cflag &= ~(CSIZE|PARENB);  /* no parity */\n\t    t_mode.c_cflag |= CS8;              /* 8 bit chars */\n\n\t    t_mode.c_cc[VMIN] = 1; /* number of chars to satisfy a read */\n\t    t_mode.c_cc[VTIME] = 0;          /* 0/10th second for chars */\n\n\t    if ( tcsetattr(STDIN_FILENO, TCSAFLUSH, &t_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"couldn't put terminal in RAW mode: %m\");\n\t\tclose(fd[0]);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /*\n\t     * NOTE: Unlike the stream socket case here the child\n\t     * opens the slave terminal as fd[1] *after* the fork...\n\t     */\n\t}\n    } else {\n\n\t/*\n\t * not a terminal line so just open a stream socket fd[0-1]\n\t * both set...\n\t */\n\n\tif ( socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0 ) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't open a stream pipe: %m\");\n\t    return PAM_ABORT;\n\t}\n    }\n\n    /* start child process */\n\n    if ( (child = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"first fork failed: %m\");\n\tif (aterminal) {\n\t\t(void) tcsetattr(STDIN_FILENO, TCSAFLUSH, &stored_mode);\n\t\tclose(fd[0]);\n\t} else {\n\t\t/* Socket pair */\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t}\n\n\treturn PAM_AUTH_ERR;\n    }\n\n    if ( child == 0 ) {                  /* child process *is* application */\n\n\tif (aterminal) {\n\n\t    /* close the controlling tty */\n\n#if defined(__hpux) && defined(O_NOCTTY)\n\t    int t = open(\"/dev/tty\", O_RDWR|O_NOCTTY);\n#else\n\t    int t = open(\"/dev/tty\",O_RDWR);\n\t    if (t >= 0) {\n\t\t(void) ioctl(t, TIOCNOTTY, NULL);\n\t\tclose(t);\n\t    }\n#endif /* defined(__hpux) && defined(O_NOCTTY) */\n\n\t    /* make this process it's own process leader */\n\t    if (setsid() == -1) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"child cannot become new session: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* grant slave terminal */\n\t    if (grantpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot grant access to slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* unlock slave terminal */\n\t    if (unlockpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot unlock slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* find slave's name */\n\t    terminal = ptsname(fd[0]); /* returned value should not be freed */\n\n\t    if (terminal == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"Cannot get the name of the slave terminal: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    fd[1] = open(terminal, O_RDWR);\n\t    close(fd[0]);      /* process is the child -- uses line fd[1] */\n\n\t    if (fd[1] < 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot open slave terminal: %s: %m\", terminal);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* initialize the child's terminal to be the way the\n\t       parent's was before we set it into RAW mode */\n\n\t    if ( tcsetattr(fd[1], TCSANOW, &stored_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot set slave terminal mode: %s: %m\", terminal);\n\t\tclose(fd[1]);\n\t\treturn PAM_ABORT;\n\t    }\n\t} else {\n\n\t    /* nothing to do for a simple stream socket */\n\n\t}\n\n\t/* re-assign the stdin/out to fd[1] <- (talks to filter). */\n\n\tif ( dup2(fd[1],STDIN_FILENO) != STDIN_FILENO ||\n\t     dup2(fd[1],STDOUT_FILENO) != STDOUT_FILENO ||\n\t     dup2(fd[1],STDERR_FILENO) != STDERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    close(fd[1]);\n\t    return PAM_ABORT;\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(STDIN_FILENO, F_SETFD, 0) ||\n\t     fcntl(STDOUT_FILENO,F_SETFD, 0) ||\n\t     fcntl(STDERR_FILENO,F_SETFD, 0) ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    return PAM_ABORT;\n\t}\n\n\t/* now the user input is read from the parent/filter: forget fd */\n\n\tclose(fd[1]);\n\n\t/* the current process is now apparently working with filtered\n\t   stdio/stdout/stderr --- success! */\n\n\treturn PAM_SUCCESS;\n    }\n\n    /* Clear out passwords... there is a security problem here in\n     * that this process never executes pam_end.  Consequently, any\n     * other sensitive data in this process is *not* explicitly\n     * overwritten, before the process terminates */\n\n    (void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n    (void) pam_set_item(pamh, PAM_OLDAUTHTOK, NULL);\n\n    /* fork a copy of process to run the actual filter executable */\n\n    if ( (child2 = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"filter fork failed: %m\");\n\tchild2 = 0;\n\n    } else if ( child2 == 0 ) {              /* exec the child filter */\n\n\tif ( dup2(fd[0],APPIN_FILENO) != APPIN_FILENO ||\n\t     dup2(fd[0],APPOUT_FILENO) != APPOUT_FILENO ||\n\t     dup2(fd[0],APPERR_FILENO) != APPERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign APPIN/OUT/ERR: %m\");\n\t    close(fd[0]);\n\t    _exit(1);\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(APPIN_FILENO, F_SETFD, 0) == -1 ||\n\t     fcntl(APPOUT_FILENO,F_SETFD, 0) == -1 ||\n\t     fcntl(APPERR_FILENO,F_SETFD, 0) == -1 ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to retain APPIN/OUT/ERR: %m\");\n\t    close(APPIN_FILENO);\n\t    close(APPOUT_FILENO);\n\t    close(APPERR_FILENO);\n\t    _exit(1);\n\t}\n\n\t/* now the user input is read from the parent through filter */\n\n\texecle(filtername, \"<pam_filter>\", NULL, evp);\n\n\t/* getting to here is an error */\n\n\tpam_syslog(pamh, LOG_ERR, \"filter: %s: %m\", filtername);\n\t_exit(1);\n\n    } else {           /* wait for either of the two children to exit */\n\n\twhile (child && child2) {    /* loop if there are two children */\n\t    int lstatus=0;\n\t    int chid;\n\n\t    chid = wait(&lstatus);\n\t    if (chid == child) {\n\n\t\tif (WIFEXITED(lstatus)) {            /* exited ? */\n\t\t    status = WEXITSTATUS(lstatus);\n\t\t} else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\t    status = -1;\n\t\t} else\n\t\t    continue;             /* just stopped etc.. */\n\t\tchild = 0;        /* the child has exited */\n\n\t    } else if (chid == child2) {\n\t\t/*\n\t\t * if the filter has exited. Let the child die\n\t\t * naturally below\n\t\t */\n\t\tif (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\t    child2 = 0;\n\t    } else {\n\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"programming error <chid=%d,lstatus=%x> \"\n\t\t\t   \"in file %s at line %d\",\n\t\t\t   chid, lstatus, __FILE__, __LINE__);\n\t\tchild = child2 = 0;\n\t\tstatus = -1;\n\n\t    }\n\t}\n    }\n\n    close(fd[0]);\n\n    /* if there is something running, wait for it to exit */\n\n    while (child || child2) {\n\tint lstatus=0;\n\tint chid;\n\n\tchid = wait(&lstatus);\n\n\tif (child && chid == child) {\n\n\t    if (WIFEXITED(lstatus)) {            /* exited ? */\n\t\tstatus = WEXITSTATUS(lstatus);\n\t    } else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\tstatus = -1;\n\t    } else\n\t\tcontinue;             /* just stopped etc.. */\n\t    child = 0;        /* the child has exited */\n\n\t} else if (child2 && chid == child2) {\n\n\t    if (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\tchild2 = 0;\n\n\t} else {\n\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"programming error <chid=%d,lstatus=%x> \"\n\t\t       \"in file %s at line %d\",\n\t\t       chid, lstatus, __FILE__, __LINE__);\n\t    child = child2 = 0;\n\t    status = -1;\n\n\t}\n    }\n\n    if (aterminal) {\n\t/* reset to initial terminal mode */\n\t    (void) tcsetattr(STDIN_FILENO, TCSANOW, &stored_mode);\n    }\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"parent process exited\");      /* clock off */\n    }\n\n    /* quit the parent process, returning the child's exit status */\n\n    exit(status);\n    return status; /* never reached, to make gcc happy */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"tried and failed to set PAM_TTY\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_args",
          "args": [
            "pamh",
            "argc",
            "argv",
            "name",
            "&evp",
            "&filterfile"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "process_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "60-233",
          "snippet": "static int process_args(pam_handle_t *pamh\n\t\t\t, int argc, const char **argv, const char *type\n\t\t\t, char ***evp, const char **filtername)\n{\n    int ctrl=0;\n\n    while (argc-- > 0) {\n\tif (strcmp(\"debug\",*argv) == 0) {\n\t    ctrl |= FILTER_DEBUG;\n\t} else if (strcmp(\"new_term\",*argv) == 0) {\n\t    ctrl |= NEW_TERM;\n\t} else if (strcmp(\"non_term\",*argv) == 0) {\n\t    ctrl |= NON_TERM;\n\t} else if (strcmp(\"run1\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN1;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else if (strcmp(\"run2\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN2;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option: %s\", *argv);\n\t}\n\t++argv;                   /* step along list */\n    }\n\n    if (argc < 0) {\n\t/* there was no reference to a filter */\n\t*filtername = NULL;\n\t*evp = NULL;\n    } else {\n\tchar **levp;\n\tconst char *user = NULL;\n\tconst void *tmp;\n\tint i,size, retval;\n\n\t*filtername = *++argv;\n\tif (ctrl & FILTER_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"will run filter %s\", *filtername);\n\t}\n\n\tlevp = (char **) malloc(5*sizeof(char *));\n\tif (levp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for environment of filter\");\n\t    return -1;\n\t}\n\n\t/* the \"ARGS\" variable */\n\n#define ARGS_NAME      \"ARGS=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n\n\tsize = sizeof(ARGS_NAME);\n\n\tfor (i=0; i<argc; ++i) {\n\t    size += strlen(argv[i]) + (i != 0);\n\t}\n\n\tlevp[0] = malloc(size);\n\tif (levp[0] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for filter arguments\");\n\t    free(levp);\n\t    return -1;\n\t}\n\n\tstrcpy(levp[0], ARGS_NAME);\n\tsize = ARGS_OFFSET;\n\tfor (i=0; i<argc; ++i) {\n\t    if (i)\n\t\tlevp[0][size++] = ' ';\n\t    strcpy(levp[0]+size, argv[i]);\n\t    size += strlen(argv[i]);\n\t}\n\n\t/* the \"SERVICE\" variable */\n\n#define SERVICE_NAME      \"SERVICE=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n\n\tretval = pam_get_item(pamh, PAM_SERVICE, &tmp);\n\tif (retval != PAM_SUCCESS || tmp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"service name not found\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\tsize = SERVICE_OFFSET+strlen(tmp);\n\n\tlevp[1] = (char *) malloc(size+1);\n\tif (levp[1] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for service name\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[1], SERVICE_NAME);\n\tstrcpy(levp[1]+SERVICE_OFFSET, tmp);\n\tlevp[1][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define USER_NAME      \"USER=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t    user = \"<unknown>\";\n\t}\n\tsize = USER_OFFSET+strlen(user);\n\n\tlevp[2] = (char *) malloc(size+1);\n\tif (levp[2] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for user's name\");\n\t    if (levp) {\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[2], USER_NAME);\n\tstrcpy(levp[2]+USER_OFFSET, user);\n\tlevp[2][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define TYPE_NAME      \"TYPE=\"\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n\n\tsize = TYPE_OFFSET+strlen(type);\n\n\tlevp[3] = (char *) malloc(size+1);\n\tif (levp[3] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for type\");\n\t    if (levp) {\n\t\tfree(levp[2]);\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[3], TYPE_NAME);\n\tstrcpy(levp[3]+TYPE_OFFSET, type);\n\tlevp[3][size] = '\\0';                      /* <NUL> terminate */\n\n\tlevp[4] = NULL;\t                     /* end list */\n\n\t*evp = levp;\n    }\n\n    if ((ctrl & FILTER_DEBUG) && *filtername) {\n\tchar **e;\n\n\tpam_syslog(pamh, LOG_DEBUG, \"filter[%s]: %s\", type, *filtername);\n\tpam_syslog(pamh, LOG_DEBUG, \"environment:\");\n\tfor (e=*evp; e && *e; ++e) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"  %s\", *e);\n\t}\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)",
            "#define TYPE_NAME      \"TYPE=\"",
            "#define USER_OFFSET    (sizeof(USER_NAME) - 1)",
            "#define USER_NAME      \"USER=\"",
            "#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)",
            "#define SERVICE_NAME      \"SERVICE=\"",
            "#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)",
            "#define ARGS_NAME      \"ARGS=\"",
            "#define NON_TERM        020",
            "#define NEW_TERM        010",
            "#define FILTER_RUN2      04",
            "#define FILTER_RUN1      02",
            "#define FILTER_DEBUG     01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n#define TYPE_NAME      \"TYPE=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n#define USER_NAME      \"USER=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n#define SERVICE_NAME      \"SERVICE=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n#define ARGS_NAME      \"ARGS=\"\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_RUN2      04\n#define FILTER_RUN1      02\n#define FILTER_DEBUG     01\n\nstatic int process_args(pam_handle_t *pamh\n\t\t\t, int argc, const char **argv, const char *type\n\t\t\t, char ***evp, const char **filtername)\n{\n    int ctrl=0;\n\n    while (argc-- > 0) {\n\tif (strcmp(\"debug\",*argv) == 0) {\n\t    ctrl |= FILTER_DEBUG;\n\t} else if (strcmp(\"new_term\",*argv) == 0) {\n\t    ctrl |= NEW_TERM;\n\t} else if (strcmp(\"non_term\",*argv) == 0) {\n\t    ctrl |= NON_TERM;\n\t} else if (strcmp(\"run1\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN1;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else if (strcmp(\"run2\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN2;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option: %s\", *argv);\n\t}\n\t++argv;                   /* step along list */\n    }\n\n    if (argc < 0) {\n\t/* there was no reference to a filter */\n\t*filtername = NULL;\n\t*evp = NULL;\n    } else {\n\tchar **levp;\n\tconst char *user = NULL;\n\tconst void *tmp;\n\tint i,size, retval;\n\n\t*filtername = *++argv;\n\tif (ctrl & FILTER_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"will run filter %s\", *filtername);\n\t}\n\n\tlevp = (char **) malloc(5*sizeof(char *));\n\tif (levp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for environment of filter\");\n\t    return -1;\n\t}\n\n\t/* the \"ARGS\" variable */\n\n#define ARGS_NAME      \"ARGS=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n\n\tsize = sizeof(ARGS_NAME);\n\n\tfor (i=0; i<argc; ++i) {\n\t    size += strlen(argv[i]) + (i != 0);\n\t}\n\n\tlevp[0] = malloc(size);\n\tif (levp[0] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for filter arguments\");\n\t    free(levp);\n\t    return -1;\n\t}\n\n\tstrcpy(levp[0], ARGS_NAME);\n\tsize = ARGS_OFFSET;\n\tfor (i=0; i<argc; ++i) {\n\t    if (i)\n\t\tlevp[0][size++] = ' ';\n\t    strcpy(levp[0]+size, argv[i]);\n\t    size += strlen(argv[i]);\n\t}\n\n\t/* the \"SERVICE\" variable */\n\n#define SERVICE_NAME      \"SERVICE=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n\n\tretval = pam_get_item(pamh, PAM_SERVICE, &tmp);\n\tif (retval != PAM_SUCCESS || tmp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"service name not found\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\tsize = SERVICE_OFFSET+strlen(tmp);\n\n\tlevp[1] = (char *) malloc(size+1);\n\tif (levp[1] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for service name\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[1], SERVICE_NAME);\n\tstrcpy(levp[1]+SERVICE_OFFSET, tmp);\n\tlevp[1][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define USER_NAME      \"USER=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t    user = \"<unknown>\";\n\t}\n\tsize = USER_OFFSET+strlen(user);\n\n\tlevp[2] = (char *) malloc(size+1);\n\tif (levp[2] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for user's name\");\n\t    if (levp) {\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[2], USER_NAME);\n\tstrcpy(levp[2]+USER_OFFSET, user);\n\tlevp[2][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define TYPE_NAME      \"TYPE=\"\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n\n\tsize = TYPE_OFFSET+strlen(type);\n\n\tlevp[3] = (char *) malloc(size+1);\n\tif (levp[3] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for type\");\n\t    if (levp) {\n\t\tfree(levp[2]);\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[3], TYPE_NAME);\n\tstrcpy(levp[3]+TYPE_OFFSET, type);\n\tlevp[3][size] = '\\0';                      /* <NUL> terminate */\n\n\tlevp[4] = NULL;\t                     /* end list */\n\n\t*evp = levp;\n    }\n\n    if ((ctrl & FILTER_DEBUG) && *filtername) {\n\tchar **e;\n\n\tpam_syslog(pamh, LOG_DEBUG, \"filter[%s]: %s\", type, *filtername);\n\tpam_syslog(pamh, LOG_DEBUG, \"environment:\");\n\tfor (e=*evp; e && *e; ++e) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"  %s\", *e);\n\t}\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_DEBUG     01\n\nstatic int need_a_filter(pam_handle_t *pamh\n\t\t\t , int flags, int argc, const char **argv\n\t\t\t , const char *name, int which_run)\n{\n    int ctrl;\n    char **evp;\n    const char *filterfile;\n    int retval;\n\n    ctrl = process_args(pamh, argc, argv, name, &evp, &filterfile);\n    if (ctrl == -1) {\n\treturn PAM_AUTHINFO_UNAVAIL;\n    }\n\n    /* set the tty to the old or the new one? */\n\n    if (!(ctrl & NON_TERM) && !(ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"tried and failed to set PAM_TTY\");\n\t}\n    } else {\n\tretval = PAM_SUCCESS;  /* nothing to do which is always a success */\n    }\n\n    if (retval == PAM_SUCCESS && (ctrl & which_run)) {\n\tretval = set_filter(pamh, flags, ctrl, evp, filterfile);\n    }\n\n    if (retval == PAM_SUCCESS\n\t&& !(ctrl & NON_TERM) && (ctrl & NEW_TERM)) {\n\tretval = set_the_terminal(pamh);\n\tif (retval != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"tried and failed to set new terminal as PAM_TTY\");\n\t}\n    }\n\n    free_evp(evp);\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"filter/%s, returning %d\", name, retval);\n\tpam_syslog(pamh, LOG_DEBUG, \"[%s]\", pam_strerror(pamh, retval));\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "set_the_terminal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "583-600",
    "snippet": "static int set_the_terminal(pam_handle_t *pamh)\n{\n    const void *tty;\n\n    if (pam_get_item(pamh, PAM_TTY, &tty) != PAM_SUCCESS\n\t|| tty == NULL) {\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't get the tty name\");\n\t    return PAM_ABORT;\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"couldn't set tty name\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "tty"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"couldn't get the tty name\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&tty"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int set_the_terminal(pam_handle_t *pamh)\n{\n    const void *tty;\n\n    if (pam_get_item(pamh, PAM_TTY, &tty) != PAM_SUCCESS\n\t|| tty == NULL) {\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't get the tty name\");\n\t    return PAM_ABORT;\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "247-581",
    "snippet": "static int\nset_filter (pam_handle_t *pamh, int flags UNUSED, int ctrl,\n\t    char * const evp[], const char *filtername)\n{\n    int status=-1;\n    char* terminal = NULL;\n    struct termios stored_mode;           /* initial terminal mode settings */\n    int fd[2], child=0, child2=0, aterminal;\n\n    if (filtername == NULL || *filtername != '/') {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"filtername not permitted; full pathname required\");\n\treturn PAM_ABORT;\n    }\n\n    if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO)) {\n\taterminal = 0;\n    } else {\n\taterminal = 1;\n    }\n\n    if (aterminal) {\n\n\t/* open the master pseudo terminal */\n\n\tfd[0] = master();\n\tif (fd[0] < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no master terminal\");\n\t    return PAM_AUTH_ERR;\n\t}\n\n\t/* set terminal into raw mode.. remember old mode so that we can\n\t   revert to it after the child has quit. */\n\n\t/* this is termios terminal handling... */\n\n\tif ( tcgetattr(STDIN_FILENO, &stored_mode) < 0 ) {\n\t    pam_syslog(pamh, LOG_CRIT, \"couldn't copy terminal mode: %m\");\n\t    /* in trouble, so close down */\n\t    close(fd[0]);\n\t    return PAM_ABORT;\n\t} else {\n\t    struct termios t_mode = stored_mode;\n\n\t    t_mode.c_iflag = 0;            /* no input control */\n\t    t_mode.c_oflag &= ~OPOST;      /* no output post processing */\n\n\t    /* no signals, canonical input, echoing, upper/lower output */\n#ifdef XCASE\n\t    t_mode.c_lflag &= ~(XCASE);\n#endif\n\t    t_mode.c_lflag &= ~(ISIG|ICANON|ECHO);\n\t    t_mode.c_cflag &= ~(CSIZE|PARENB);  /* no parity */\n\t    t_mode.c_cflag |= CS8;              /* 8 bit chars */\n\n\t    t_mode.c_cc[VMIN] = 1; /* number of chars to satisfy a read */\n\t    t_mode.c_cc[VTIME] = 0;          /* 0/10th second for chars */\n\n\t    if ( tcsetattr(STDIN_FILENO, TCSAFLUSH, &t_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"couldn't put terminal in RAW mode: %m\");\n\t\tclose(fd[0]);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /*\n\t     * NOTE: Unlike the stream socket case here the child\n\t     * opens the slave terminal as fd[1] *after* the fork...\n\t     */\n\t}\n    } else {\n\n\t/*\n\t * not a terminal line so just open a stream socket fd[0-1]\n\t * both set...\n\t */\n\n\tif ( socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0 ) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't open a stream pipe: %m\");\n\t    return PAM_ABORT;\n\t}\n    }\n\n    /* start child process */\n\n    if ( (child = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"first fork failed: %m\");\n\tif (aterminal) {\n\t\t(void) tcsetattr(STDIN_FILENO, TCSAFLUSH, &stored_mode);\n\t\tclose(fd[0]);\n\t} else {\n\t\t/* Socket pair */\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t}\n\n\treturn PAM_AUTH_ERR;\n    }\n\n    if ( child == 0 ) {                  /* child process *is* application */\n\n\tif (aterminal) {\n\n\t    /* close the controlling tty */\n\n#if defined(__hpux) && defined(O_NOCTTY)\n\t    int t = open(\"/dev/tty\", O_RDWR|O_NOCTTY);\n#else\n\t    int t = open(\"/dev/tty\",O_RDWR);\n\t    if (t >= 0) {\n\t\t(void) ioctl(t, TIOCNOTTY, NULL);\n\t\tclose(t);\n\t    }\n#endif /* defined(__hpux) && defined(O_NOCTTY) */\n\n\t    /* make this process it's own process leader */\n\t    if (setsid() == -1) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"child cannot become new session: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* grant slave terminal */\n\t    if (grantpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot grant access to slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* unlock slave terminal */\n\t    if (unlockpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot unlock slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* find slave's name */\n\t    terminal = ptsname(fd[0]); /* returned value should not be freed */\n\n\t    if (terminal == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"Cannot get the name of the slave terminal: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    fd[1] = open(terminal, O_RDWR);\n\t    close(fd[0]);      /* process is the child -- uses line fd[1] */\n\n\t    if (fd[1] < 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot open slave terminal: %s: %m\", terminal);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* initialize the child's terminal to be the way the\n\t       parent's was before we set it into RAW mode */\n\n\t    if ( tcsetattr(fd[1], TCSANOW, &stored_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot set slave terminal mode: %s: %m\", terminal);\n\t\tclose(fd[1]);\n\t\treturn PAM_ABORT;\n\t    }\n\t} else {\n\n\t    /* nothing to do for a simple stream socket */\n\n\t}\n\n\t/* re-assign the stdin/out to fd[1] <- (talks to filter). */\n\n\tif ( dup2(fd[1],STDIN_FILENO) != STDIN_FILENO ||\n\t     dup2(fd[1],STDOUT_FILENO) != STDOUT_FILENO ||\n\t     dup2(fd[1],STDERR_FILENO) != STDERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    close(fd[1]);\n\t    return PAM_ABORT;\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(STDIN_FILENO, F_SETFD, 0) ||\n\t     fcntl(STDOUT_FILENO,F_SETFD, 0) ||\n\t     fcntl(STDERR_FILENO,F_SETFD, 0) ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    return PAM_ABORT;\n\t}\n\n\t/* now the user input is read from the parent/filter: forget fd */\n\n\tclose(fd[1]);\n\n\t/* the current process is now apparently working with filtered\n\t   stdio/stdout/stderr --- success! */\n\n\treturn PAM_SUCCESS;\n    }\n\n    /* Clear out passwords... there is a security problem here in\n     * that this process never executes pam_end.  Consequently, any\n     * other sensitive data in this process is *not* explicitly\n     * overwritten, before the process terminates */\n\n    (void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n    (void) pam_set_item(pamh, PAM_OLDAUTHTOK, NULL);\n\n    /* fork a copy of process to run the actual filter executable */\n\n    if ( (child2 = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"filter fork failed: %m\");\n\tchild2 = 0;\n\n    } else if ( child2 == 0 ) {              /* exec the child filter */\n\n\tif ( dup2(fd[0],APPIN_FILENO) != APPIN_FILENO ||\n\t     dup2(fd[0],APPOUT_FILENO) != APPOUT_FILENO ||\n\t     dup2(fd[0],APPERR_FILENO) != APPERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign APPIN/OUT/ERR: %m\");\n\t    close(fd[0]);\n\t    _exit(1);\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(APPIN_FILENO, F_SETFD, 0) == -1 ||\n\t     fcntl(APPOUT_FILENO,F_SETFD, 0) == -1 ||\n\t     fcntl(APPERR_FILENO,F_SETFD, 0) == -1 ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to retain APPIN/OUT/ERR: %m\");\n\t    close(APPIN_FILENO);\n\t    close(APPOUT_FILENO);\n\t    close(APPERR_FILENO);\n\t    _exit(1);\n\t}\n\n\t/* now the user input is read from the parent through filter */\n\n\texecle(filtername, \"<pam_filter>\", NULL, evp);\n\n\t/* getting to here is an error */\n\n\tpam_syslog(pamh, LOG_ERR, \"filter: %s: %m\", filtername);\n\t_exit(1);\n\n    } else {           /* wait for either of the two children to exit */\n\n\twhile (child && child2) {    /* loop if there are two children */\n\t    int lstatus=0;\n\t    int chid;\n\n\t    chid = wait(&lstatus);\n\t    if (chid == child) {\n\n\t\tif (WIFEXITED(lstatus)) {            /* exited ? */\n\t\t    status = WEXITSTATUS(lstatus);\n\t\t} else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\t    status = -1;\n\t\t} else\n\t\t    continue;             /* just stopped etc.. */\n\t\tchild = 0;        /* the child has exited */\n\n\t    } else if (chid == child2) {\n\t\t/*\n\t\t * if the filter has exited. Let the child die\n\t\t * naturally below\n\t\t */\n\t\tif (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\t    child2 = 0;\n\t    } else {\n\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"programming error <chid=%d,lstatus=%x> \"\n\t\t\t   \"in file %s at line %d\",\n\t\t\t   chid, lstatus, __FILE__, __LINE__);\n\t\tchild = child2 = 0;\n\t\tstatus = -1;\n\n\t    }\n\t}\n    }\n\n    close(fd[0]);\n\n    /* if there is something running, wait for it to exit */\n\n    while (child || child2) {\n\tint lstatus=0;\n\tint chid;\n\n\tchid = wait(&lstatus);\n\n\tif (child && chid == child) {\n\n\t    if (WIFEXITED(lstatus)) {            /* exited ? */\n\t\tstatus = WEXITSTATUS(lstatus);\n\t    } else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\tstatus = -1;\n\t    } else\n\t\tcontinue;             /* just stopped etc.. */\n\t    child = 0;        /* the child has exited */\n\n\t} else if (child2 && chid == child2) {\n\n\t    if (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\tchild2 = 0;\n\n\t} else {\n\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"programming error <chid=%d,lstatus=%x> \"\n\t\t       \"in file %s at line %d\",\n\t\t       chid, lstatus, __FILE__, __LINE__);\n\t    child = child2 = 0;\n\t    status = -1;\n\n\t}\n    }\n\n    if (aterminal) {\n\t/* reset to initial terminal mode */\n\t    (void) tcsetattr(STDIN_FILENO, TCSANOW, &stored_mode);\n    }\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"parent process exited\");      /* clock off */\n    }\n\n    /* quit the parent process, returning the child's exit status */\n\n    exit(status);\n    return status; /* never reached, to make gcc happy */\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FILTER_DEBUG     01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "status"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"parent process exited\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "STDIN_FILENO",
            "TCSANOW",
            "&stored_mode"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"programming error <chid=%d,lstatus=%x> \"\n\t\t       \"in file %s at line %d\"",
            "chid",
            "lstatus",
            "__FILE__",
            "__LINE__"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "lstatus"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "lstatus"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "lstatus"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "lstatus"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "lstatus"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&lstatus"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"programming error <chid=%d,lstatus=%x> \"\n\t\t\t   \"in file %s at line %d\"",
            "chid",
            "lstatus",
            "__FILE__",
            "__LINE__"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "lstatus"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "lstatus"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "lstatus"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "lstatus"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "lstatus"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&lstatus"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"filter: %s: %m\"",
            "filtername"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execle",
          "args": [
            "filtername",
            "\"<pam_filter>\"",
            "NULL",
            "evp"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "APPERR_FILENO"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "APPOUT_FILENO"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "APPIN_FILENO"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to retain APPIN/OUT/ERR: %m\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "APPERR_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "APPOUT_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "APPIN_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to re-assign APPIN/OUT/ERR: %m\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[0]",
            "APPERR_FILENO"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[0]",
            "APPOUT_FILENO"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[0]",
            "APPIN_FILENO"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"filter fork failed: %m\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_OLDAUTHTOK",
            "NULL"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "NULL"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[1]"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to re-assign STDIN/OUT/ERR: %m\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "STDERR_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "STDOUT_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "STDIN_FILENO",
            "F_SETFD",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[1]"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to re-assign STDIN/OUT/ERR: %m\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[1]",
            "STDERR_FILENO"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[1]",
            "STDOUT_FILENO"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd[1]",
            "STDIN_FILENO"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[1]"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot set slave terminal mode: %s: %m\"",
            "terminal"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fd[1]",
            "TCSANOW",
            "&stored_mode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot open slave terminal: %s: %m\"",
            "terminal"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "terminal",
            "O_RDWR"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot get the name of the slave terminal: %m\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptsname",
          "args": [
            "fd[0]"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot unlock slave terminal\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlockpt",
          "args": [
            "fd[0]"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot grant access to slave terminal\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grantpt",
          "args": [
            "fd[0]"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"child cannot become new session: %m\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "t"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "t",
            "TIOCNOTTY",
            "NULL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/tty\"",
            "O_RDWR"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/tty\"",
            "O_RDWR|O_NOCTTY"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[1]"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "STDIN_FILENO",
            "TCSAFLUSH",
            "&stored_mode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"first fork failed: %m\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"couldn't open a stream pipe: %m\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "fd"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"couldn't put terminal in RAW mode: %m\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "STDIN_FILENO",
            "TCSAFLUSH",
            "&t_mode"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd[0]"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"couldn't copy terminal mode: %m\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "STDIN_FILENO",
            "&stored_mode"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no master terminal\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "master",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "48-58",
          "snippet": "static int\nmaster (void)\n{\n    int fd;\n\n    if ((fd = open(DEV_PTMX, O_RDWR)) >= 0) {\n\treturn fd;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEV_PTMX \"/dev/ptmx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define DEV_PTMX \"/dev/ptmx\"\n\nstatic int\nmaster (void)\n{\n    int fd;\n\n    if ((fd = open(DEV_PTMX, O_RDWR)) >= 0) {\n\treturn fd;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"filtername not permitted; full pathname required\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define FILTER_DEBUG     01\n\nstatic int\nset_filter (pam_handle_t *pamh, int flags UNUSED, int ctrl,\n\t    char * const evp[], const char *filtername)\n{\n    int status=-1;\n    char* terminal = NULL;\n    struct termios stored_mode;           /* initial terminal mode settings */\n    int fd[2], child=0, child2=0, aterminal;\n\n    if (filtername == NULL || *filtername != '/') {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"filtername not permitted; full pathname required\");\n\treturn PAM_ABORT;\n    }\n\n    if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO)) {\n\taterminal = 0;\n    } else {\n\taterminal = 1;\n    }\n\n    if (aterminal) {\n\n\t/* open the master pseudo terminal */\n\n\tfd[0] = master();\n\tif (fd[0] < 0) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no master terminal\");\n\t    return PAM_AUTH_ERR;\n\t}\n\n\t/* set terminal into raw mode.. remember old mode so that we can\n\t   revert to it after the child has quit. */\n\n\t/* this is termios terminal handling... */\n\n\tif ( tcgetattr(STDIN_FILENO, &stored_mode) < 0 ) {\n\t    pam_syslog(pamh, LOG_CRIT, \"couldn't copy terminal mode: %m\");\n\t    /* in trouble, so close down */\n\t    close(fd[0]);\n\t    return PAM_ABORT;\n\t} else {\n\t    struct termios t_mode = stored_mode;\n\n\t    t_mode.c_iflag = 0;            /* no input control */\n\t    t_mode.c_oflag &= ~OPOST;      /* no output post processing */\n\n\t    /* no signals, canonical input, echoing, upper/lower output */\n#ifdef XCASE\n\t    t_mode.c_lflag &= ~(XCASE);\n#endif\n\t    t_mode.c_lflag &= ~(ISIG|ICANON|ECHO);\n\t    t_mode.c_cflag &= ~(CSIZE|PARENB);  /* no parity */\n\t    t_mode.c_cflag |= CS8;              /* 8 bit chars */\n\n\t    t_mode.c_cc[VMIN] = 1; /* number of chars to satisfy a read */\n\t    t_mode.c_cc[VTIME] = 0;          /* 0/10th second for chars */\n\n\t    if ( tcsetattr(STDIN_FILENO, TCSAFLUSH, &t_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"couldn't put terminal in RAW mode: %m\");\n\t\tclose(fd[0]);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /*\n\t     * NOTE: Unlike the stream socket case here the child\n\t     * opens the slave terminal as fd[1] *after* the fork...\n\t     */\n\t}\n    } else {\n\n\t/*\n\t * not a terminal line so just open a stream socket fd[0-1]\n\t * both set...\n\t */\n\n\tif ( socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0 ) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't open a stream pipe: %m\");\n\t    return PAM_ABORT;\n\t}\n    }\n\n    /* start child process */\n\n    if ( (child = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"first fork failed: %m\");\n\tif (aterminal) {\n\t\t(void) tcsetattr(STDIN_FILENO, TCSAFLUSH, &stored_mode);\n\t\tclose(fd[0]);\n\t} else {\n\t\t/* Socket pair */\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t}\n\n\treturn PAM_AUTH_ERR;\n    }\n\n    if ( child == 0 ) {                  /* child process *is* application */\n\n\tif (aterminal) {\n\n\t    /* close the controlling tty */\n\n#if defined(__hpux) && defined(O_NOCTTY)\n\t    int t = open(\"/dev/tty\", O_RDWR|O_NOCTTY);\n#else\n\t    int t = open(\"/dev/tty\",O_RDWR);\n\t    if (t >= 0) {\n\t\t(void) ioctl(t, TIOCNOTTY, NULL);\n\t\tclose(t);\n\t    }\n#endif /* defined(__hpux) && defined(O_NOCTTY) */\n\n\t    /* make this process it's own process leader */\n\t    if (setsid() == -1) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"child cannot become new session: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* grant slave terminal */\n\t    if (grantpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot grant access to slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* unlock slave terminal */\n\t    if (unlockpt (fd[0]) < 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot unlock slave terminal\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* find slave's name */\n\t    terminal = ptsname(fd[0]); /* returned value should not be freed */\n\n\t    if (terminal == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"Cannot get the name of the slave terminal: %m\");\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    fd[1] = open(terminal, O_RDWR);\n\t    close(fd[0]);      /* process is the child -- uses line fd[1] */\n\n\t    if (fd[1] < 0) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot open slave terminal: %s: %m\", terminal);\n\t\treturn PAM_ABORT;\n\t    }\n\n\t    /* initialize the child's terminal to be the way the\n\t       parent's was before we set it into RAW mode */\n\n\t    if ( tcsetattr(fd[1], TCSANOW, &stored_mode) < 0 ) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"cannot set slave terminal mode: %s: %m\", terminal);\n\t\tclose(fd[1]);\n\t\treturn PAM_ABORT;\n\t    }\n\t} else {\n\n\t    /* nothing to do for a simple stream socket */\n\n\t}\n\n\t/* re-assign the stdin/out to fd[1] <- (talks to filter). */\n\n\tif ( dup2(fd[1],STDIN_FILENO) != STDIN_FILENO ||\n\t     dup2(fd[1],STDOUT_FILENO) != STDOUT_FILENO ||\n\t     dup2(fd[1],STDERR_FILENO) != STDERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    close(fd[1]);\n\t    return PAM_ABORT;\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(STDIN_FILENO, F_SETFD, 0) ||\n\t     fcntl(STDOUT_FILENO,F_SETFD, 0) ||\n\t     fcntl(STDERR_FILENO,F_SETFD, 0) ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign STDIN/OUT/ERR: %m\");\n\t    return PAM_ABORT;\n\t}\n\n\t/* now the user input is read from the parent/filter: forget fd */\n\n\tclose(fd[1]);\n\n\t/* the current process is now apparently working with filtered\n\t   stdio/stdout/stderr --- success! */\n\n\treturn PAM_SUCCESS;\n    }\n\n    /* Clear out passwords... there is a security problem here in\n     * that this process never executes pam_end.  Consequently, any\n     * other sensitive data in this process is *not* explicitly\n     * overwritten, before the process terminates */\n\n    (void) pam_set_item(pamh, PAM_AUTHTOK, NULL);\n    (void) pam_set_item(pamh, PAM_OLDAUTHTOK, NULL);\n\n    /* fork a copy of process to run the actual filter executable */\n\n    if ( (child2 = fork()) < 0 ) {\n\n\tpam_syslog(pamh, LOG_ERR, \"filter fork failed: %m\");\n\tchild2 = 0;\n\n    } else if ( child2 == 0 ) {              /* exec the child filter */\n\n\tif ( dup2(fd[0],APPIN_FILENO) != APPIN_FILENO ||\n\t     dup2(fd[0],APPOUT_FILENO) != APPOUT_FILENO ||\n\t     dup2(fd[0],APPERR_FILENO) != APPERR_FILENO )  {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to re-assign APPIN/OUT/ERR: %m\");\n\t    close(fd[0]);\n\t    _exit(1);\n\t}\n\n\t/* make sure that file descriptors survive 'exec's */\n\n\tif ( fcntl(APPIN_FILENO, F_SETFD, 0) == -1 ||\n\t     fcntl(APPOUT_FILENO,F_SETFD, 0) == -1 ||\n\t     fcntl(APPERR_FILENO,F_SETFD, 0) == -1 ) {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"unable to retain APPIN/OUT/ERR: %m\");\n\t    close(APPIN_FILENO);\n\t    close(APPOUT_FILENO);\n\t    close(APPERR_FILENO);\n\t    _exit(1);\n\t}\n\n\t/* now the user input is read from the parent through filter */\n\n\texecle(filtername, \"<pam_filter>\", NULL, evp);\n\n\t/* getting to here is an error */\n\n\tpam_syslog(pamh, LOG_ERR, \"filter: %s: %m\", filtername);\n\t_exit(1);\n\n    } else {           /* wait for either of the two children to exit */\n\n\twhile (child && child2) {    /* loop if there are two children */\n\t    int lstatus=0;\n\t    int chid;\n\n\t    chid = wait(&lstatus);\n\t    if (chid == child) {\n\n\t\tif (WIFEXITED(lstatus)) {            /* exited ? */\n\t\t    status = WEXITSTATUS(lstatus);\n\t\t} else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\t    status = -1;\n\t\t} else\n\t\t    continue;             /* just stopped etc.. */\n\t\tchild = 0;        /* the child has exited */\n\n\t    } else if (chid == child2) {\n\t\t/*\n\t\t * if the filter has exited. Let the child die\n\t\t * naturally below\n\t\t */\n\t\tif (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\t    child2 = 0;\n\t    } else {\n\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"programming error <chid=%d,lstatus=%x> \"\n\t\t\t   \"in file %s at line %d\",\n\t\t\t   chid, lstatus, __FILE__, __LINE__);\n\t\tchild = child2 = 0;\n\t\tstatus = -1;\n\n\t    }\n\t}\n    }\n\n    close(fd[0]);\n\n    /* if there is something running, wait for it to exit */\n\n    while (child || child2) {\n\tint lstatus=0;\n\tint chid;\n\n\tchid = wait(&lstatus);\n\n\tif (child && chid == child) {\n\n\t    if (WIFEXITED(lstatus)) {            /* exited ? */\n\t\tstatus = WEXITSTATUS(lstatus);\n\t    } else if (WIFSIGNALED(lstatus)) {   /* killed ? */\n\t\tstatus = -1;\n\t    } else\n\t\tcontinue;             /* just stopped etc.. */\n\t    child = 0;        /* the child has exited */\n\n\t} else if (child2 && chid == child2) {\n\n\t    if (WIFEXITED(lstatus) || WIFSIGNALED(lstatus))\n\t\tchild2 = 0;\n\n\t} else {\n\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"programming error <chid=%d,lstatus=%x> \"\n\t\t       \"in file %s at line %d\",\n\t\t       chid, lstatus, __FILE__, __LINE__);\n\t    child = child2 = 0;\n\t    status = -1;\n\n\t}\n    }\n\n    if (aterminal) {\n\t/* reset to initial terminal mode */\n\t    (void) tcsetattr(STDIN_FILENO, TCSANOW, &stored_mode);\n    }\n\n    if (ctrl & FILTER_DEBUG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"parent process exited\");      /* clock off */\n    }\n\n    /* quit the parent process, returning the child's exit status */\n\n    exit(status);\n    return status; /* never reached, to make gcc happy */\n}"
  },
  {
    "function_name": "free_evp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "235-245",
    "snippet": "static void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "evp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "free_evp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "235-245",
          "snippet": "static void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}"
  },
  {
    "function_name": "process_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "60-233",
    "snippet": "static int process_args(pam_handle_t *pamh\n\t\t\t, int argc, const char **argv, const char *type\n\t\t\t, char ***evp, const char **filtername)\n{\n    int ctrl=0;\n\n    while (argc-- > 0) {\n\tif (strcmp(\"debug\",*argv) == 0) {\n\t    ctrl |= FILTER_DEBUG;\n\t} else if (strcmp(\"new_term\",*argv) == 0) {\n\t    ctrl |= NEW_TERM;\n\t} else if (strcmp(\"non_term\",*argv) == 0) {\n\t    ctrl |= NON_TERM;\n\t} else if (strcmp(\"run1\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN1;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else if (strcmp(\"run2\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN2;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option: %s\", *argv);\n\t}\n\t++argv;                   /* step along list */\n    }\n\n    if (argc < 0) {\n\t/* there was no reference to a filter */\n\t*filtername = NULL;\n\t*evp = NULL;\n    } else {\n\tchar **levp;\n\tconst char *user = NULL;\n\tconst void *tmp;\n\tint i,size, retval;\n\n\t*filtername = *++argv;\n\tif (ctrl & FILTER_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"will run filter %s\", *filtername);\n\t}\n\n\tlevp = (char **) malloc(5*sizeof(char *));\n\tif (levp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for environment of filter\");\n\t    return -1;\n\t}\n\n\t/* the \"ARGS\" variable */\n\n#define ARGS_NAME      \"ARGS=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n\n\tsize = sizeof(ARGS_NAME);\n\n\tfor (i=0; i<argc; ++i) {\n\t    size += strlen(argv[i]) + (i != 0);\n\t}\n\n\tlevp[0] = malloc(size);\n\tif (levp[0] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for filter arguments\");\n\t    free(levp);\n\t    return -1;\n\t}\n\n\tstrcpy(levp[0], ARGS_NAME);\n\tsize = ARGS_OFFSET;\n\tfor (i=0; i<argc; ++i) {\n\t    if (i)\n\t\tlevp[0][size++] = ' ';\n\t    strcpy(levp[0]+size, argv[i]);\n\t    size += strlen(argv[i]);\n\t}\n\n\t/* the \"SERVICE\" variable */\n\n#define SERVICE_NAME      \"SERVICE=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n\n\tretval = pam_get_item(pamh, PAM_SERVICE, &tmp);\n\tif (retval != PAM_SUCCESS || tmp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"service name not found\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\tsize = SERVICE_OFFSET+strlen(tmp);\n\n\tlevp[1] = (char *) malloc(size+1);\n\tif (levp[1] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for service name\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[1], SERVICE_NAME);\n\tstrcpy(levp[1]+SERVICE_OFFSET, tmp);\n\tlevp[1][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define USER_NAME      \"USER=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t    user = \"<unknown>\";\n\t}\n\tsize = USER_OFFSET+strlen(user);\n\n\tlevp[2] = (char *) malloc(size+1);\n\tif (levp[2] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for user's name\");\n\t    if (levp) {\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[2], USER_NAME);\n\tstrcpy(levp[2]+USER_OFFSET, user);\n\tlevp[2][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define TYPE_NAME      \"TYPE=\"\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n\n\tsize = TYPE_OFFSET+strlen(type);\n\n\tlevp[3] = (char *) malloc(size+1);\n\tif (levp[3] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for type\");\n\t    if (levp) {\n\t\tfree(levp[2]);\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[3], TYPE_NAME);\n\tstrcpy(levp[3]+TYPE_OFFSET, type);\n\tlevp[3][size] = '\\0';                      /* <NUL> terminate */\n\n\tlevp[4] = NULL;\t                     /* end list */\n\n\t*evp = levp;\n    }\n\n    if ((ctrl & FILTER_DEBUG) && *filtername) {\n\tchar **e;\n\n\tpam_syslog(pamh, LOG_DEBUG, \"filter[%s]: %s\", type, *filtername);\n\tpam_syslog(pamh, LOG_DEBUG, \"environment:\");\n\tfor (e=*evp; e && *e; ++e) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"  %s\", *e);\n\t}\n    }\n\n    return ctrl;\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)",
      "#define TYPE_NAME      \"TYPE=\"",
      "#define USER_OFFSET    (sizeof(USER_NAME) - 1)",
      "#define USER_NAME      \"USER=\"",
      "#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)",
      "#define SERVICE_NAME      \"SERVICE=\"",
      "#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)",
      "#define ARGS_NAME      \"ARGS=\"",
      "#define NON_TERM        020",
      "#define NEW_TERM        010",
      "#define FILTER_RUN2      04",
      "#define FILTER_RUN1      02",
      "#define FILTER_DEBUG     01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"  %s\"",
            "*e"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"environment:\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"filter[%s]: %s\"",
            "type",
            "*filtername"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[3]+TYPE_OFFSET",
            "type"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[3]",
            "TYPE_NAME"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "levp"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "free_evp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
          "lines": "235-245",
          "snippet": "static void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include \"pam_filter.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/time.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic void free_evp(char *evp[])\n{\n    int i;\n\n    if (evp)\n\tfor (i=0; i<4; ++i) {\n\t    if (evp[i])\n\t\tfree(evp[i]);\n\t}\n    free(evp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for type\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size+1"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "type"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[2]+USER_OFFSET",
            "user"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[2]",
            "USER_NAME"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for user's name\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size+1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[1]+SERVICE_OFFSET",
            "tmp"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[1]",
            "SERVICE_NAME"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for service name\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size+1"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"service name not found\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&tmp"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[0]+size",
            "argv[i]"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "levp[0]",
            "ARGS_NAME"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for filter arguments\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for environment of filter\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "5*sizeof(char *)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"will run filter %s\"",
            "*filtername"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unrecognized option: %s\"",
            "*argv"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"no run filter supplied\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"run2\"",
            "*argv"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"no run filter supplied\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"run1\"",
            "*argv"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"non_term\"",
            "*argv"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"new_term\"",
            "*argv"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"debug\"",
            "*argv"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n#define TYPE_NAME      \"TYPE=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n#define USER_NAME      \"USER=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n#define SERVICE_NAME      \"SERVICE=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n#define ARGS_NAME      \"ARGS=\"\n#define NON_TERM        020\n#define NEW_TERM        010\n#define FILTER_RUN2      04\n#define FILTER_RUN1      02\n#define FILTER_DEBUG     01\n\nstatic int process_args(pam_handle_t *pamh\n\t\t\t, int argc, const char **argv, const char *type\n\t\t\t, char ***evp, const char **filtername)\n{\n    int ctrl=0;\n\n    while (argc-- > 0) {\n\tif (strcmp(\"debug\",*argv) == 0) {\n\t    ctrl |= FILTER_DEBUG;\n\t} else if (strcmp(\"new_term\",*argv) == 0) {\n\t    ctrl |= NEW_TERM;\n\t} else if (strcmp(\"non_term\",*argv) == 0) {\n\t    ctrl |= NON_TERM;\n\t} else if (strcmp(\"run1\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN1;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else if (strcmp(\"run2\",*argv) == 0) {\n\t    ctrl |= FILTER_RUN2;\n\t    if (argc <= 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"no run filter supplied\");\n\t    } else\n\t\tbreak;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option: %s\", *argv);\n\t}\n\t++argv;                   /* step along list */\n    }\n\n    if (argc < 0) {\n\t/* there was no reference to a filter */\n\t*filtername = NULL;\n\t*evp = NULL;\n    } else {\n\tchar **levp;\n\tconst char *user = NULL;\n\tconst void *tmp;\n\tint i,size, retval;\n\n\t*filtername = *++argv;\n\tif (ctrl & FILTER_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"will run filter %s\", *filtername);\n\t}\n\n\tlevp = (char **) malloc(5*sizeof(char *));\n\tif (levp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for environment of filter\");\n\t    return -1;\n\t}\n\n\t/* the \"ARGS\" variable */\n\n#define ARGS_NAME      \"ARGS=\"\n#define ARGS_OFFSET    (sizeof(ARGS_NAME) - 1)\n\n\tsize = sizeof(ARGS_NAME);\n\n\tfor (i=0; i<argc; ++i) {\n\t    size += strlen(argv[i]) + (i != 0);\n\t}\n\n\tlevp[0] = malloc(size);\n\tif (levp[0] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for filter arguments\");\n\t    free(levp);\n\t    return -1;\n\t}\n\n\tstrcpy(levp[0], ARGS_NAME);\n\tsize = ARGS_OFFSET;\n\tfor (i=0; i<argc; ++i) {\n\t    if (i)\n\t\tlevp[0][size++] = ' ';\n\t    strcpy(levp[0]+size, argv[i]);\n\t    size += strlen(argv[i]);\n\t}\n\n\t/* the \"SERVICE\" variable */\n\n#define SERVICE_NAME      \"SERVICE=\"\n#define SERVICE_OFFSET    (sizeof(SERVICE_NAME) - 1)\n\n\tretval = pam_get_item(pamh, PAM_SERVICE, &tmp);\n\tif (retval != PAM_SUCCESS || tmp == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"service name not found\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\tsize = SERVICE_OFFSET+strlen(tmp);\n\n\tlevp[1] = (char *) malloc(size+1);\n\tif (levp[1] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for service name\");\n\t    if (levp) {\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[1], SERVICE_NAME);\n\tstrcpy(levp[1]+SERVICE_OFFSET, tmp);\n\tlevp[1][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define USER_NAME      \"USER=\"\n#define USER_OFFSET    (sizeof(USER_NAME) - 1)\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t    user = \"<unknown>\";\n\t}\n\tsize = USER_OFFSET+strlen(user);\n\n\tlevp[2] = (char *) malloc(size+1);\n\tif (levp[2] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for user's name\");\n\t    if (levp) {\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[2], USER_NAME);\n\tstrcpy(levp[2]+USER_OFFSET, user);\n\tlevp[2][size] = '\\0';                      /* <NUL> terminate */\n\n\t/* the \"USER\" variable */\n\n#define TYPE_NAME      \"TYPE=\"\n#define TYPE_OFFSET    (sizeof(TYPE_NAME) - 1)\n\n\tsize = TYPE_OFFSET+strlen(type);\n\n\tlevp[3] = (char *) malloc(size+1);\n\tif (levp[3] == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"no memory for type\");\n\t    if (levp) {\n\t\tfree(levp[2]);\n\t\tfree(levp[1]);\n\t\tfree(levp[0]);\n\t\tfree(levp);\n\t    }\n\t    return -1;\n\t}\n\n\tstrcpy(levp[3], TYPE_NAME);\n\tstrcpy(levp[3]+TYPE_OFFSET, type);\n\tlevp[3][size] = '\\0';                      /* <NUL> terminate */\n\n\tlevp[4] = NULL;\t                     /* end list */\n\n\t*evp = levp;\n    }\n\n    if ((ctrl & FILTER_DEBUG) && *filtername) {\n\tchar **e;\n\n\tpam_syslog(pamh, LOG_DEBUG, \"filter[%s]: %s\", type, *filtername);\n\tpam_syslog(pamh, LOG_DEBUG, \"environment:\");\n\tfor (e=*evp; e && *e; ++e) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"  %s\", *e);\n\t}\n    }\n\n    return ctrl;\n}"
  },
  {
    "function_name": "master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/pam_filter.c",
    "lines": "48-58",
    "snippet": "static int\nmaster (void)\n{\n    int fd;\n\n    if ((fd = open(DEV_PTMX, O_RDWR)) >= 0) {\n\treturn fd;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include <stdarg.h>",
      "#include \"pam_filter.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <signal.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/time.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DEV_PTMX \"/dev/ptmx\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "open",
          "args": [
            "DEV_PTMX",
            "O_RDWR"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdarg.h>\n#include \"pam_filter.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define DEV_PTMX \"/dev/ptmx\"\n\nstatic int\nmaster (void)\n{\n    int fd;\n\n    if ((fd = open(DEV_PTMX, O_RDWR)) >= 0) {\n\treturn fd;\n    }\n\n    return -1;\n}"
  }
]