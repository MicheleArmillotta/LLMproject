[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "981-986",
    "snippet": "int\npam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "821-951",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define MAXHOSTNAMELEN 256",
            "#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */",
            "#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define MAXHOSTNAMELEN 256\n#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */\n#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nint\npam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "974-979",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "821-951",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define MAXHOSTNAMELEN 256",
            "#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */",
            "#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define MAXHOSTNAMELEN 256\n#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */\n#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nint\npam_sm_close_session(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "967-972",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "821-951",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define MAXHOSTNAMELEN 256",
            "#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */",
            "#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define MAXHOSTNAMELEN 256\n#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */\n#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n  return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "960-965",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n  return pam_sm_authenticate (pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "821-951",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define MAXHOSTNAMELEN 256",
            "#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */",
            "#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define MAXHOSTNAMELEN 256\n#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */\n#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n  return pam_sm_authenticate (pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "953-958",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "821-951",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NOMATCH        -1",
      "#define MAXHOSTNAMELEN 256",
      "#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */",
      "#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"access denied for user `%s' from `%s'\"",
            "user",
            "from"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "loginfo.res"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "login_access",
          "args": [
            "pamh",
            "&loginfo"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "login_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "325-425",
          "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "ACCESS_CONF_GLOB",
            "GLOB_ERR",
            "NULL",
            "&globbuf"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"gethostname failed: %m\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "hostname",
            "sizeof(hostname)-1"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "from",
            "'/'"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"cannot determine tty or remote hostname, using service %s\"",
            "from"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot determine remote host, tty or service name\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&void_from"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"couldn't set tty name\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "from"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"PAM_TTY not set, probing stdin\")"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&void_from"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot find the remote host name\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&void_from"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to parse the module arguments\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_args",
          "args": [
            "pamh",
            "&loginfo",
            "argc",
            "argv"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "parse_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "107-155",
          "snippet": "static int\nparse_args(pam_handle_t *pamh, struct login_info *loginfo,\n           int argc, const char **argv)\n{\n    int i;\n\n    loginfo->noaudit = NO;\n    loginfo->debug = NO;\n    loginfo->only_new_group_syntax = NO;\n    loginfo->fs = \":\";\n    loginfo->sep = \", \\t\";\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(argv[i], \"fieldsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default field separators */\n\t    loginfo->fs = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"listsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default list separators */\n\t    loginfo->sep = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"accessfile=\")) != NULL) {\n\t    FILE *fp = fopen(str, \"r\");\n\n\t    if (fp) {\n\t\tloginfo->config_file = str;\n\t\tfclose(fp);\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"failed to open accessfile=[%s]: %m\", str);\n\t\treturn 0;\n\t    }\n\n\t} else if (strcmp (argv[i], \"debug\") == 0) {\n\t    loginfo->debug = YES;\n\t} else if (strcmp (argv[i], \"nodefgroup\") == 0) {\n\t    loginfo->only_new_group_syntax = YES;\n\t} else if (strcmp (argv[i], \"noaudit\") == 0) {\n\t    loginfo->noaudit = YES;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option [%s]\", argv[i]);\n\t}\n    }\n\n    return 1;  /* OK */\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nparse_args(pam_handle_t *pamh, struct login_info *loginfo,\n           int argc, const char **argv)\n{\n    int i;\n\n    loginfo->noaudit = NO;\n    loginfo->debug = NO;\n    loginfo->only_new_group_syntax = NO;\n    loginfo->fs = \":\";\n    loginfo->sep = \", \\t\";\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(argv[i], \"fieldsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default field separators */\n\t    loginfo->fs = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"listsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default list separators */\n\t    loginfo->sep = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"accessfile=\")) != NULL) {\n\t    FILE *fp = fopen(str, \"r\");\n\n\t    if (fp) {\n\t\tloginfo->config_file = str;\n\t\tfclose(fp);\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"failed to open accessfile=[%s]: %m\", str);\n\t\treturn 0;\n\t    }\n\n\t} else if (strcmp (argv[i], \"debug\") == 0) {\n\t    loginfo->debug = YES;\n\t} else if (strcmp (argv[i], \"nodefgroup\") == 0) {\n\t    loginfo->only_new_group_syntax = YES;\n\t} else if (strcmp (argv[i], \"noaudit\") == 0) {\n\t    loginfo->noaudit = YES;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option [%s]\", argv[i]);\n\t}\n    }\n\n    return 1;  /* OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&loginfo",
            "'\\0'",
            "sizeof(loginfo)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define MAXHOSTNAMELEN 256\n#define ACCESS_CONF_GLOB\t(SCONFIGDIR \"/access.d/*.conf\")\n\n/* login_access.c from logdaemon-5.6 with several changes by A.Nogin: */\n#define PAM_ACCESS_CONFIG\t(SCONFIGDIR \"/access.conf\")\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct login_info loginfo;\n    const char *user=NULL;\n    const void *void_from=NULL;\n    const char *from;\n    const char *default_config = PAM_ACCESS_CONFIG;\n    struct passwd *user_pw;\n    char hostname[MAXHOSTNAMELEN + 1];\n    int rv;\n\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if ((user_pw=pam_modutil_getpwnam(pamh, user))==NULL)\n      return (PAM_USER_UNKNOWN);\n\n    /*\n     * Bundle up the arguments to avoid unnecessary clumsiness later on.\n     */\n    memset(&loginfo, '\\0', sizeof(loginfo));\n    loginfo.user = user_pw;\n    loginfo.config_file = default_config;\n\n    /* parse the argument list */\n\n    if (!parse_args(pamh, &loginfo, argc, argv)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to parse the module arguments\");\n\treturn PAM_ABORT;\n    }\n\n    /* remote host name */\n\n    if (pam_get_item(pamh, PAM_RHOST, &void_from)\n\t!= PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the remote host name\");\n\treturn PAM_ABORT;\n    }\n    from = void_from;\n\n    if ((from==NULL) || (*from=='\\0')) {\n\n        /* local login, set tty name */\n\n        loginfo.from_remote_host = 0;\n\n        if (pam_get_item(pamh, PAM_TTY, &void_from) != PAM_SUCCESS\n            || void_from == NULL) {\n            D((\"PAM_TTY not set, probing stdin\"));\n\t    from = ttyname(STDIN_FILENO);\n\t    if (from != NULL) {\n\t        if (pam_set_item(pamh, PAM_TTY, from) != PAM_SUCCESS)\n\t            pam_syslog(pamh, LOG_WARNING, \"couldn't set tty name\");\n\t    } else {\n\t      if (pam_get_item(pamh, PAM_SERVICE, &void_from) != PAM_SUCCESS\n\t\t  || void_from == NULL) {\n\t\tpam_syslog (pamh, LOG_ERR,\n\t\t     \"cannot determine remote host, tty or service name\");\n\t\treturn PAM_ABORT;\n\t      }\n\t      from = void_from;\n\t      if (loginfo.debug)\n\t\tpam_syslog (pamh, LOG_DEBUG,\n\t\t\t    \"cannot determine tty or remote hostname, using service %s\",\n\t\t\t    from);\n\t    }\n        }\n\telse\n\t  from = void_from;\n\n\tif (from[0] == '/') {   /* full path, remove device path.  */\n\t    const char *f;\n\t    from++;\n\t    if ((f = strchr(from, '/')) != NULL) {\n\t\tfrom = f + 1;\n\t    }\n\t}\n    }\n    else\n      loginfo.from_remote_host = 1;\n\n    loginfo.from = from;\n\n    hostname[sizeof(hostname)-1] = '\\0';\n    if (gethostname(hostname, sizeof(hostname)-1) == 0)\n\tloginfo.hostname = hostname;\n    else {\n\tpam_syslog (pamh, LOG_ERR, \"gethostname failed: %m\");\n\tloginfo.hostname = NULL;\n    }\n\n    rv = login_access(pamh, &loginfo);\n\n    if (rv == NOMATCH && loginfo.config_file == default_config) {\n\tglob_t globbuf;\n\tint i, glob_rv;\n\n\t/* We do not manipulate locale as setlocale() is not\n\t * thread safe. We could use uselocale() in future.\n\t */\n\tglob_rv = glob(ACCESS_CONF_GLOB, GLOB_ERR, NULL, &globbuf);\n\tif (!glob_rv) {\n\t    /* Parse the *.conf files. */\n\t    for (i = 0; globbuf.gl_pathv[i] != NULL; i++) {\n\t\tloginfo.config_file = globbuf.gl_pathv[i];\n\t\trv = login_access(pamh, &loginfo);\n\t\tif (rv != NOMATCH)\n\t\t    break;\n\t    }\n\t    globfree(&globbuf);\n\t}\n    }\n\n    if (loginfo.gai_rv == 0 && loginfo.res)\n\tfreeaddrinfo(loginfo.res);\n\n    if (rv) {\n\treturn (PAM_SUCCESS);\n    } else {\n\tpam_syslog(pamh, LOG_ERR,\n                   \"access denied for user `%s' from `%s'\",user,from);\n\treturn (PAM_PERM_DENIED);\n    }\n}"
  },
  {
    "function_name": "network_netmask_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "722-816",
    "snippet": "static int\nnetwork_netmask_match (pam_handle_t *pamh,\n\t\t       const char *tok, const char *string, struct login_info *item)\n{\n    char *netmask_ptr;\n    char netmask_string[MAXHOSTNAMELEN + 1];\n    int addr_type;\n\n    if (item->debug)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"network_netmask_match: tok=%s, item=%s\", tok, string);\n    /* OK, check if tok is of type addr/mask */\n    if ((netmask_ptr = strchr(tok, '/')) != NULL)\n      {\n\tlong netmask = 0;\n\n\t/* YES */\n\t*netmask_ptr = 0;\n\tnetmask_ptr++;\n\n\tif (isipaddr(tok, &addr_type, NULL) == NO)\n\t  { /* no netaddr */\n\t    return NO;\n\t  }\n\n\t/* check netmask */\n\tif (isipaddr(netmask_ptr, NULL, NULL) == NO)\n\t  { /* netmask as integre value */\n\t    char *endptr = NULL;\n\t    netmask = strtol(netmask_ptr, &endptr, 0);\n\t    if ((endptr == netmask_ptr) || (*endptr != '\\0'))\n\t\t{ /* invalid netmask value */\n\t\t  return NO;\n\t\t}\n\t    if ((netmask < 0)\n\t\t|| (addr_type == AF_INET && netmask > 32)\n\t\t|| (addr_type == AF_INET6 && netmask > 128))\n\t\t{ /* netmask value out of range */\n\t\t  return NO;\n\t\t}\n\n\t    netmask_ptr = number_to_netmask(netmask, addr_type,\n\t\tnetmask_string, MAXHOSTNAMELEN);\n\t  }\n\t}\n    else\n\t/* NO, then check if it is only an addr */\n\tif (isipaddr(tok, NULL, NULL) != YES)\n\t  {\n\t    return NO;\n\t  }\n\n    if (isipaddr(string, NULL, NULL) != YES)\n      {\n\t/* Assume network/netmask with a name of a host.  */\n\tstruct addrinfo hint;\n\n\tmemset (&hint, '\\0', sizeof (hint));\n\thint.ai_flags = AI_CANONNAME;\n\thint.ai_family = AF_UNSPEC;\n\n\tif (item->gai_rv != 0)\n\t    return NO;\n\telse if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\t    return NO;\n        else\n\t  {\n\t    struct addrinfo *runp = item->res;\n\n\t    while (runp != NULL)\n\t      {\n\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\tDIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\tinet_ntop (runp->ai_family,\n\t\t\trunp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr,\n\t\t\tbuf, sizeof (buf));\n\t\tDIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\tif (are_addresses_equal(buf, tok, netmask_ptr))\n\t\t  {\n\t\t    return YES;\n\t\t  }\n\t\trunp = runp->ai_next;\n\t      }\n\t  }\n      }\n    else\n      return (are_addresses_equal(string, tok, netmask_ptr));\n\n  return NO;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1",
      "#define MAXHOSTNAMELEN 256"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "are_addresses_equal",
          "args": [
            "string",
            "tok",
            "netmask_ptr"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "are_addresses_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "218-267",
          "snippet": "static int\nare_addresses_equal (const char *ipaddr0, const char *ipaddr1,\n\t\t     const char *netmask)\n{\n  struct sockaddr_storage addr0;\n  struct sockaddr_storage addr1;\n  int addr_type0 = 0;\n  int addr_type1 = 0;\n\n  if (isipaddr (ipaddr0, &addr_type0, &addr0) == NO)\n    return NO;\n\n  if (isipaddr (ipaddr1, &addr_type1, &addr1) == NO)\n    return NO;\n\n  if (addr_type0 != addr_type1)\n    /* different address types */\n    return NO;\n\n  if (netmask != NULL) {\n    /* Got a netmask, so normalize addresses? */\n    struct sockaddr_storage nmask;\n    unsigned char *byte_a, *byte_nm;\n\n    memset(&nmask, 0, sizeof(struct sockaddr_storage));\n    if (inet_pton(addr_type0, netmask, (void *)&nmask) > 0) {\n      unsigned int i;\n      byte_a = (unsigned char *)(&addr0);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n\n      byte_a = (unsigned char *)(&addr1);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n    }\n  }\n\n\n  /* Are the two addresses equal? */\n  if (memcmp((void *)&addr0, (void *)&addr1,\n              sizeof(struct sockaddr_storage)) == 0) {\n    return(YES);\n  }\n\n  return(NO);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int\nare_addresses_equal (const char *ipaddr0, const char *ipaddr1,\n\t\t     const char *netmask)\n{\n  struct sockaddr_storage addr0;\n  struct sockaddr_storage addr1;\n  int addr_type0 = 0;\n  int addr_type1 = 0;\n\n  if (isipaddr (ipaddr0, &addr_type0, &addr0) == NO)\n    return NO;\n\n  if (isipaddr (ipaddr1, &addr_type1, &addr1) == NO)\n    return NO;\n\n  if (addr_type0 != addr_type1)\n    /* different address types */\n    return NO;\n\n  if (netmask != NULL) {\n    /* Got a netmask, so normalize addresses? */\n    struct sockaddr_storage nmask;\n    unsigned char *byte_a, *byte_nm;\n\n    memset(&nmask, 0, sizeof(struct sockaddr_storage));\n    if (inet_pton(addr_type0, netmask, (void *)&nmask) > 0) {\n      unsigned int i;\n      byte_a = (unsigned char *)(&addr0);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n\n      byte_a = (unsigned char *)(&addr1);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n    }\n  }\n\n\n  /* Are the two addresses equal? */\n  if (memcmp((void *)&addr0, (void *)&addr1,\n              sizeof(struct sockaddr_storage)) == 0) {\n    return(YES);\n  }\n\n  return(NO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "runp->ai_family",
            "runp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr",
            "buf",
            "sizeof (buf)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "string",
            "NULL",
            "&hint",
            "&item->res"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hint",
            "'\\0'",
            "sizeof (hint)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isipaddr",
          "args": [
            "string",
            "NULL",
            "NULL"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "isipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "173-210",
          "snippet": "static int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "number_to_netmask",
          "args": [
            "netmask",
            "addr_type",
            "netmask_string",
            "MAXHOSTNAMELEN"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "number_to_netmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "269-321",
          "snippet": "static char *\nnumber_to_netmask (long netmask, int addr_type,\n\t\t   char *ipaddr_buf, size_t ipaddr_buf_len)\n{\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n  struct sockaddr_storage nmask;\n  unsigned char *byte_nm;\n  const char *ipaddr_dst = NULL;\n  int i, ip_bytes;\n\n  if (netmask == 0) {\n    /* mask 0 is the same like no mask */\n    return(NULL);\n  }\n\n  memset(&nmask, 0, sizeof(struct sockaddr_storage));\n  if (addr_type == AF_INET6) {\n    /* ipv6 address mask */\n    ip_bytes = 16;\n  } else {\n    /* default might be an ipv4 address mask */\n    addr_type = AF_INET;\n    ip_bytes = 4;\n  }\n\n  byte_nm = (unsigned char *)(&nmask);\n  /* translate number to mask */\n  for (i=0; i<ip_bytes; i++) {\n    if (netmask >= 8) {\n      byte_nm[i] = 0xff;\n      netmask -= 8;\n    } else\n    if (netmask > 0) {\n      byte_nm[i] = 0xff << (8 - netmask);\n      break;\n    } else\n    if (netmask <= 0) {\n      break;\n    }\n  }\n\n  /* now generate netmask address string */\n  ipaddr_dst = inet_ntop(addr_type, &nmask, ipaddr_buf, ipaddr_buf_len);\n  if (ipaddr_dst == ipaddr_buf) {\n    return (ipaddr_buf);\n  }\n\n  return (NULL);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *\nnumber_to_netmask (long netmask, int addr_type,\n\t\t   char *ipaddr_buf, size_t ipaddr_buf_len)\n{\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n  struct sockaddr_storage nmask;\n  unsigned char *byte_nm;\n  const char *ipaddr_dst = NULL;\n  int i, ip_bytes;\n\n  if (netmask == 0) {\n    /* mask 0 is the same like no mask */\n    return(NULL);\n  }\n\n  memset(&nmask, 0, sizeof(struct sockaddr_storage));\n  if (addr_type == AF_INET6) {\n    /* ipv6 address mask */\n    ip_bytes = 16;\n  } else {\n    /* default might be an ipv4 address mask */\n    addr_type = AF_INET;\n    ip_bytes = 4;\n  }\n\n  byte_nm = (unsigned char *)(&nmask);\n  /* translate number to mask */\n  for (i=0; i<ip_bytes; i++) {\n    if (netmask >= 8) {\n      byte_nm[i] = 0xff;\n      netmask -= 8;\n    } else\n    if (netmask > 0) {\n      byte_nm[i] = 0xff << (8 - netmask);\n      break;\n    } else\n    if (netmask <= 0) {\n      break;\n    }\n  }\n\n  /* now generate netmask address string */\n  ipaddr_dst = inet_ntop(addr_type, &nmask, ipaddr_buf, ipaddr_buf_len);\n  if (ipaddr_dst == ipaddr_buf) {\n    return (ipaddr_buf);\n  }\n\n  return (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "netmask_ptr",
            "&endptr",
            "0"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tok",
            "'/'"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"network_netmask_match: tok=%s, item=%s\"",
            "tok",
            "string"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define MAXHOSTNAMELEN 256\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nnetwork_netmask_match (pam_handle_t *pamh,\n\t\t       const char *tok, const char *string, struct login_info *item)\n{\n    char *netmask_ptr;\n    char netmask_string[MAXHOSTNAMELEN + 1];\n    int addr_type;\n\n    if (item->debug)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"network_netmask_match: tok=%s, item=%s\", tok, string);\n    /* OK, check if tok is of type addr/mask */\n    if ((netmask_ptr = strchr(tok, '/')) != NULL)\n      {\n\tlong netmask = 0;\n\n\t/* YES */\n\t*netmask_ptr = 0;\n\tnetmask_ptr++;\n\n\tif (isipaddr(tok, &addr_type, NULL) == NO)\n\t  { /* no netaddr */\n\t    return NO;\n\t  }\n\n\t/* check netmask */\n\tif (isipaddr(netmask_ptr, NULL, NULL) == NO)\n\t  { /* netmask as integre value */\n\t    char *endptr = NULL;\n\t    netmask = strtol(netmask_ptr, &endptr, 0);\n\t    if ((endptr == netmask_ptr) || (*endptr != '\\0'))\n\t\t{ /* invalid netmask value */\n\t\t  return NO;\n\t\t}\n\t    if ((netmask < 0)\n\t\t|| (addr_type == AF_INET && netmask > 32)\n\t\t|| (addr_type == AF_INET6 && netmask > 128))\n\t\t{ /* netmask value out of range */\n\t\t  return NO;\n\t\t}\n\n\t    netmask_ptr = number_to_netmask(netmask, addr_type,\n\t\tnetmask_string, MAXHOSTNAMELEN);\n\t  }\n\t}\n    else\n\t/* NO, then check if it is only an addr */\n\tif (isipaddr(tok, NULL, NULL) != YES)\n\t  {\n\t    return NO;\n\t  }\n\n    if (isipaddr(string, NULL, NULL) != YES)\n      {\n\t/* Assume network/netmask with a name of a host.  */\n\tstruct addrinfo hint;\n\n\tmemset (&hint, '\\0', sizeof (hint));\n\thint.ai_flags = AI_CANONNAME;\n\thint.ai_family = AF_UNSPEC;\n\n\tif (item->gai_rv != 0)\n\t    return NO;\n\telse if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\t    return NO;\n        else\n\t  {\n\t    struct addrinfo *runp = item->res;\n\n\t    while (runp != NULL)\n\t      {\n\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\tDIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\tinet_ntop (runp->ai_family,\n\t\t\trunp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr,\n\t\t\tbuf, sizeof (buf));\n\t\tDIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\tif (are_addresses_equal(buf, tok, netmask_ptr))\n\t\t  {\n\t\t    return YES;\n\t\t  }\n\t\trunp = runp->ai_next;\n\t      }\n\t  }\n      }\n    else\n      return (are_addresses_equal(string, tok, netmask_ptr));\n\n  return NO;\n}"
  },
  {
    "function_name": "string_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "690-715",
    "snippet": "static int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1",
      "#define ALL             2"
    ],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "\"NONE\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "string"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "\"ALL\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"string_match: tok=%s, item=%s\"",
            "tok",
            "string"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}"
  },
  {
    "function_name": "remote_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "632-686",
    "snippet": "static int\nremote_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    size_t tok_len = strlen(tok);\n    size_t str_len;\n\n    if (tok[0] == '.') {\t\t\t/* domain: match last fields */\n      if ((str_len = strlen(string)) > tok_len\n\t  && strcasecmp(tok, string + str_len - tok_len) == 0)\n\treturn YES;\n    } else if (tok[tok_len - 1] == '.') {\n      struct addrinfo hint;\n\n      memset (&hint, '\\0', sizeof (hint));\n      hint.ai_flags = AI_CANONNAME;\n      hint.ai_family = AF_INET;\n\n      if (item->gai_rv != 0)\n\treturn NO;\n      else if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\treturn NO;\n      else\n\t{\n\t  struct addrinfo *runp = item->res;\n\n          while (runp != NULL)\n\t    {\n\t      char buf[INET_ADDRSTRLEN+2];\n\n\t      if (runp->ai_family == AF_INET)\n\t\t{\n\t\t  DIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\t  inet_ntop (runp->ai_family,\n\t\t\t     &((struct sockaddr_in *) runp->ai_addr)->sin_addr,\n\t\t\t     buf, sizeof (buf));\n\t\t  DIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\t  strcat (buf, \".\");\n\n\t\t  if (strncmp(tok, buf, tok_len) == 0)\n\t\t    {\n\t\t      return YES;\n\t\t    }\n\t\t}\n\t      runp = runp->ai_next;\n\t    }\n\t}\n      return NO;\n    }\n\n    /* Assume network/netmask with an IP of a host.  */\n    return network_netmask_match(pamh, tok, string, item);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "network_netmask_match",
          "args": [
            "pamh",
            "tok",
            "string",
            "item"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "network_netmask_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "722-816",
          "snippet": "static int\nnetwork_netmask_match (pam_handle_t *pamh,\n\t\t       const char *tok, const char *string, struct login_info *item)\n{\n    char *netmask_ptr;\n    char netmask_string[MAXHOSTNAMELEN + 1];\n    int addr_type;\n\n    if (item->debug)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"network_netmask_match: tok=%s, item=%s\", tok, string);\n    /* OK, check if tok is of type addr/mask */\n    if ((netmask_ptr = strchr(tok, '/')) != NULL)\n      {\n\tlong netmask = 0;\n\n\t/* YES */\n\t*netmask_ptr = 0;\n\tnetmask_ptr++;\n\n\tif (isipaddr(tok, &addr_type, NULL) == NO)\n\t  { /* no netaddr */\n\t    return NO;\n\t  }\n\n\t/* check netmask */\n\tif (isipaddr(netmask_ptr, NULL, NULL) == NO)\n\t  { /* netmask as integre value */\n\t    char *endptr = NULL;\n\t    netmask = strtol(netmask_ptr, &endptr, 0);\n\t    if ((endptr == netmask_ptr) || (*endptr != '\\0'))\n\t\t{ /* invalid netmask value */\n\t\t  return NO;\n\t\t}\n\t    if ((netmask < 0)\n\t\t|| (addr_type == AF_INET && netmask > 32)\n\t\t|| (addr_type == AF_INET6 && netmask > 128))\n\t\t{ /* netmask value out of range */\n\t\t  return NO;\n\t\t}\n\n\t    netmask_ptr = number_to_netmask(netmask, addr_type,\n\t\tnetmask_string, MAXHOSTNAMELEN);\n\t  }\n\t}\n    else\n\t/* NO, then check if it is only an addr */\n\tif (isipaddr(tok, NULL, NULL) != YES)\n\t  {\n\t    return NO;\n\t  }\n\n    if (isipaddr(string, NULL, NULL) != YES)\n      {\n\t/* Assume network/netmask with a name of a host.  */\n\tstruct addrinfo hint;\n\n\tmemset (&hint, '\\0', sizeof (hint));\n\thint.ai_flags = AI_CANONNAME;\n\thint.ai_family = AF_UNSPEC;\n\n\tif (item->gai_rv != 0)\n\t    return NO;\n\telse if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\t    return NO;\n        else\n\t  {\n\t    struct addrinfo *runp = item->res;\n\n\t    while (runp != NULL)\n\t      {\n\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\tDIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\tinet_ntop (runp->ai_family,\n\t\t\trunp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr,\n\t\t\tbuf, sizeof (buf));\n\t\tDIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\tif (are_addresses_equal(buf, tok, netmask_ptr))\n\t\t  {\n\t\t    return YES;\n\t\t  }\n\t\trunp = runp->ai_next;\n\t      }\n\t  }\n      }\n    else\n      return (are_addresses_equal(string, tok, netmask_ptr));\n\n  return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1",
            "#define MAXHOSTNAMELEN 256"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define MAXHOSTNAMELEN 256\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nnetwork_netmask_match (pam_handle_t *pamh,\n\t\t       const char *tok, const char *string, struct login_info *item)\n{\n    char *netmask_ptr;\n    char netmask_string[MAXHOSTNAMELEN + 1];\n    int addr_type;\n\n    if (item->debug)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"network_netmask_match: tok=%s, item=%s\", tok, string);\n    /* OK, check if tok is of type addr/mask */\n    if ((netmask_ptr = strchr(tok, '/')) != NULL)\n      {\n\tlong netmask = 0;\n\n\t/* YES */\n\t*netmask_ptr = 0;\n\tnetmask_ptr++;\n\n\tif (isipaddr(tok, &addr_type, NULL) == NO)\n\t  { /* no netaddr */\n\t    return NO;\n\t  }\n\n\t/* check netmask */\n\tif (isipaddr(netmask_ptr, NULL, NULL) == NO)\n\t  { /* netmask as integre value */\n\t    char *endptr = NULL;\n\t    netmask = strtol(netmask_ptr, &endptr, 0);\n\t    if ((endptr == netmask_ptr) || (*endptr != '\\0'))\n\t\t{ /* invalid netmask value */\n\t\t  return NO;\n\t\t}\n\t    if ((netmask < 0)\n\t\t|| (addr_type == AF_INET && netmask > 32)\n\t\t|| (addr_type == AF_INET6 && netmask > 128))\n\t\t{ /* netmask value out of range */\n\t\t  return NO;\n\t\t}\n\n\t    netmask_ptr = number_to_netmask(netmask, addr_type,\n\t\tnetmask_string, MAXHOSTNAMELEN);\n\t  }\n\t}\n    else\n\t/* NO, then check if it is only an addr */\n\tif (isipaddr(tok, NULL, NULL) != YES)\n\t  {\n\t    return NO;\n\t  }\n\n    if (isipaddr(string, NULL, NULL) != YES)\n      {\n\t/* Assume network/netmask with a name of a host.  */\n\tstruct addrinfo hint;\n\n\tmemset (&hint, '\\0', sizeof (hint));\n\thint.ai_flags = AI_CANONNAME;\n\thint.ai_family = AF_UNSPEC;\n\n\tif (item->gai_rv != 0)\n\t    return NO;\n\telse if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\t    return NO;\n        else\n\t  {\n\t    struct addrinfo *runp = item->res;\n\n\t    while (runp != NULL)\n\t      {\n\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\tDIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\tinet_ntop (runp->ai_family,\n\t\t\trunp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr,\n\t\t\tbuf, sizeof (buf));\n\t\tDIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\tif (are_addresses_equal(buf, tok, netmask_ptr))\n\t\t  {\n\t\t    return YES;\n\t\t  }\n\t\trunp = runp->ai_next;\n\t      }\n\t  }\n      }\n    else\n      return (are_addresses_equal(string, tok, netmask_ptr));\n\n  return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tok",
            "buf",
            "tok_len"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\".\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "runp->ai_family",
            "&((struct sockaddr_in *) runp->ai_addr)->sin_addr",
            "buf",
            "sizeof (buf)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "string",
            "NULL",
            "&hint",
            "&item->res"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hint",
            "'\\0'",
            "sizeof (hint)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "string + str_len - tok_len"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tok"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nremote_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    size_t tok_len = strlen(tok);\n    size_t str_len;\n\n    if (tok[0] == '.') {\t\t\t/* domain: match last fields */\n      if ((str_len = strlen(string)) > tok_len\n\t  && strcasecmp(tok, string + str_len - tok_len) == 0)\n\treturn YES;\n    } else if (tok[tok_len - 1] == '.') {\n      struct addrinfo hint;\n\n      memset (&hint, '\\0', sizeof (hint));\n      hint.ai_flags = AI_CANONNAME;\n      hint.ai_family = AF_INET;\n\n      if (item->gai_rv != 0)\n\treturn NO;\n      else if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\treturn NO;\n      else\n\t{\n\t  struct addrinfo *runp = item->res;\n\n          while (runp != NULL)\n\t    {\n\t      char buf[INET_ADDRSTRLEN+2];\n\n\t      if (runp->ai_family == AF_INET)\n\t\t{\n\t\t  DIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\t  inet_ntop (runp->ai_family,\n\t\t\t     &((struct sockaddr_in *) runp->ai_addr)->sin_addr,\n\t\t\t     buf, sizeof (buf));\n\t\t  DIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\t  strcat (buf, \".\");\n\n\t\t  if (strncmp(tok, buf, tok_len) == 0)\n\t\t    {\n\t\t      return YES;\n\t\t    }\n\t\t}\n\t      runp = runp->ai_next;\n\t    }\n\t}\n      return NO;\n    }\n\n    /* Assume network/netmask with an IP of a host.  */\n    return network_netmask_match(pamh, tok, string, item);\n}"
  },
  {
    "function_name": "from_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "595-630",
    "snippet": "static int\nfrom_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    int        rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"from_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds. Return\n     * YES if the token fully matches the string. If the token is a domain\n     * name, return YES if it matches the last fields of the string. If the\n     * token has the magic value \"LOCAL\", return YES if the from field was\n     * not taken by PAM_RHOST. If the token is a network number, return YES\n     * if it matches the head of the string.\n     */\n\n    if (string == NULL) {\n\treturn NO;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n        return (netgroup_match (pamh, tok + 1, string, (char *) 0, item->debug));\n    } else if ((rv = string_match(pamh, tok, string, item->debug)) != NO) {\n        /* ALL or exact match */\n\treturn rv;\n    } else if (strcasecmp(tok, \"LOCAL\") == 0) {\n\t    /* LOCAL matches only local accesses */\n\t    if (!item->from_remote_host)\n\t        return YES;\n\t    return NO;\n    } else if (item->from_remote_host) {\n        return remote_match(pamh, tok, item);\n    }\n    return NO;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1",
      "#define ALL             2"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote_match",
          "args": [
            "pamh",
            "tok",
            "item"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "remote_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "632-686",
          "snippet": "static int\nremote_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    size_t tok_len = strlen(tok);\n    size_t str_len;\n\n    if (tok[0] == '.') {\t\t\t/* domain: match last fields */\n      if ((str_len = strlen(string)) > tok_len\n\t  && strcasecmp(tok, string + str_len - tok_len) == 0)\n\treturn YES;\n    } else if (tok[tok_len - 1] == '.') {\n      struct addrinfo hint;\n\n      memset (&hint, '\\0', sizeof (hint));\n      hint.ai_flags = AI_CANONNAME;\n      hint.ai_family = AF_INET;\n\n      if (item->gai_rv != 0)\n\treturn NO;\n      else if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\treturn NO;\n      else\n\t{\n\t  struct addrinfo *runp = item->res;\n\n          while (runp != NULL)\n\t    {\n\t      char buf[INET_ADDRSTRLEN+2];\n\n\t      if (runp->ai_family == AF_INET)\n\t\t{\n\t\t  DIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\t  inet_ntop (runp->ai_family,\n\t\t\t     &((struct sockaddr_in *) runp->ai_addr)->sin_addr,\n\t\t\t     buf, sizeof (buf));\n\t\t  DIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\t  strcat (buf, \".\");\n\n\t\t  if (strncmp(tok, buf, tok_len) == 0)\n\t\t    {\n\t\t      return YES;\n\t\t    }\n\t\t}\n\t      runp = runp->ai_next;\n\t    }\n\t}\n      return NO;\n    }\n\n    /* Assume network/netmask with an IP of a host.  */\n    return network_netmask_match(pamh, tok, string, item);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nremote_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    size_t tok_len = strlen(tok);\n    size_t str_len;\n\n    if (tok[0] == '.') {\t\t\t/* domain: match last fields */\n      if ((str_len = strlen(string)) > tok_len\n\t  && strcasecmp(tok, string + str_len - tok_len) == 0)\n\treturn YES;\n    } else if (tok[tok_len - 1] == '.') {\n      struct addrinfo hint;\n\n      memset (&hint, '\\0', sizeof (hint));\n      hint.ai_flags = AI_CANONNAME;\n      hint.ai_family = AF_INET;\n\n      if (item->gai_rv != 0)\n\treturn NO;\n      else if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\treturn NO;\n      else\n\t{\n\t  struct addrinfo *runp = item->res;\n\n          while (runp != NULL)\n\t    {\n\t      char buf[INET_ADDRSTRLEN+2];\n\n\t      if (runp->ai_family == AF_INET)\n\t\t{\n\t\t  DIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\t  inet_ntop (runp->ai_family,\n\t\t\t     &((struct sockaddr_in *) runp->ai_addr)->sin_addr,\n\t\t\t     buf, sizeof (buf));\n\t\t  DIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\t  strcat (buf, \".\");\n\n\t\t  if (strncmp(tok, buf, tok_len) == 0)\n\t\t    {\n\t\t      return YES;\n\t\t    }\n\t\t}\n\t      runp = runp->ai_next;\n\t    }\n\t}\n      return NO;\n    }\n\n    /* Assume network/netmask with an IP of a host.  */\n    return network_netmask_match(pamh, tok, string, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "\"LOCAL\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_match",
          "args": [
            "pamh",
            "tok",
            "string",
            "item->debug"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "string_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "690-715",
          "snippet": "static int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netgroup_match",
          "args": [
            "pamh",
            "tok + 1",
            "string",
            "(char *) 0",
            "item->debug"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "netgroup_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "470-502",
          "snippet": "static int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define YES             1"
          ],
          "globals_used": [
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define YES             1\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"from_match: tok=%s, item=%s\"",
            "tok",
            "string"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nfrom_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    int        rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"from_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds. Return\n     * YES if the token fully matches the string. If the token is a domain\n     * name, return YES if it matches the last fields of the string. If the\n     * token has the magic value \"LOCAL\", return YES if the from field was\n     * not taken by PAM_RHOST. If the token is a network number, return YES\n     * if it matches the head of the string.\n     */\n\n    if (string == NULL) {\n\treturn NO;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n        return (netgroup_match (pamh, tok + 1, string, (char *) 0, item->debug));\n    } else if ((rv = string_match(pamh, tok, string, item->debug)) != NO) {\n        /* ALL or exact match */\n\treturn rv;\n    } else if (strcasecmp(tok, \"LOCAL\") == 0) {\n\t    /* LOCAL matches only local accesses */\n\t    if (!item->from_remote_host)\n\t        return YES;\n\t    return NO;\n    } else if (item->from_remote_host) {\n        return remote_match(pamh, tok, item);\n    }\n    return NO;\n}"
  },
  {
    "function_name": "group_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "569-590",
    "snippet": "static int\ngroup_match (pam_handle_t *pamh, const char *tok, const char* usr,\n    int debug)\n{\n    char grptok[BUFSIZ];\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"group_match: grp=%s, user=%s\", tok, usr);\n\n    if (strlen(tok) < 3)\n        return NO;\n\n    /* token is received under the format '(...)' */\n    memset(grptok, 0, BUFSIZ);\n    strncpy(grptok, tok + 1, strlen(tok) - 2);\n\n    if (pam_modutil_user_in_group_nam_nam(pamh, usr, grptok))\n        return YES;\n\n  return NO;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1"
    ],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "usr",
            "grptok"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "grptok",
            "tok + 1",
            "strlen(tok) - 2"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tok"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "grptok",
            "0",
            "BUFSIZ"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tok"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"group_match: grp=%s, user=%s\"",
            "tok",
            "usr"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\ngroup_match (pam_handle_t *pamh, const char *tok, const char* usr,\n    int debug)\n{\n    char grptok[BUFSIZ];\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"group_match: grp=%s, user=%s\", tok, usr);\n\n    if (strlen(tok) < 3)\n        return NO;\n\n    /* token is received under the format '(...)' */\n    memset(grptok, 0, BUFSIZ);\n    strncpy(grptok, tok + 1, strlen(tok) - 2);\n\n    if (pam_modutil_user_in_group_nam_nam(pamh, usr, grptok))\n        return YES;\n\n  return NO;\n}"
  },
  {
    "function_name": "user_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "506-564",
    "snippet": "static int\nuser_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    char   *string = item->user->pw_name;\n    struct login_info fake_item;\n    char   *at;\n    int    rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"user_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the username, if the\n     * token is a group that contains the username, or if the token is the\n     * name of the user's primary group.\n     */\n\n    /* Try to split on a pattern (@*[^@]+)(@+.*) */\n    for (at = tok; *at == '@'; ++at);\n\n    if (tok[0] == '(' && tok[strlen(tok) - 1] == ')') {\n      return (group_match (pamh, tok, string, item->debug));\n    } else if ((at = strchr(at, '@')) != NULL) {\n        /* split user@host pattern */\n\tif (item->hostname == NULL)\n\t    return NO;\n\tmemcpy (&fake_item, item, sizeof(fake_item));\n\tfake_item.from = item->hostname;\n\tfake_item.gai_rv = 0;\n\tfake_item.res = NULL;\n\tfake_item.from_remote_host = 1; /* hostname should be resolvable */\n\t*at = 0;\n\tif (!user_match (pamh, tok, item))\n\t\treturn NO;\n\trv = from_match (pamh, at + 1, &fake_item);\n\tif (fake_item.gai_rv == 0 && fake_item.res)\n\t\tfreeaddrinfo(fake_item.res);\n\treturn rv;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n\tconst char *hostname = NULL;\n\tif (tok[1] == '@') {\t\t\t/* add hostname to netgroup match */\n\t\tif (item->hostname == NULL)\n\t\t    return NO;\n\t\t++tok;\n\t\thostname = item->hostname;\n\t}\n        return (netgroup_match (pamh, tok + 1, hostname, string, item->debug));\n    } else if ((rv=string_match (pamh, tok, string, item->debug)) != NO) /* ALL or exact match */\n      return rv;\n    else if (item->only_new_group_syntax == NO &&\n\t     pam_modutil_user_in_group_nam_nam (pamh,\n\t\t\t\t\t\titem->user->pw_name, tok))\n      /* try group membership */\n      return YES;\n\n    return NO;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1",
      "#define ALL             2"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "item->user->pw_name",
            "tok"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_match",
          "args": [
            "pamh",
            "tok",
            "string",
            "item->debug"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "string_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "690-715",
          "snippet": "static int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nstring_match (pam_handle_t *pamh, const char *tok, const char *string,\n    int debug)\n{\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"string_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If the token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the string.\n\t * \"NONE\" token matches NULL string.\n     */\n\n    if (strcasecmp(tok, \"ALL\") == 0) {\t\t/* all: always matches */\n\treturn (ALL);\n    } else if (string != NULL) {\n\tif (strcasecmp(tok, string) == 0) {\t/* try exact match */\n\t    return (YES);\n\t}\n    } else if (strcasecmp(tok, \"NONE\") == 0) {\n\treturn (YES);\n    }\n    return (NO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netgroup_match",
          "args": [
            "pamh",
            "tok + 1",
            "hostname",
            "string",
            "item->debug"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "netgroup_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "470-502",
          "snippet": "static int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define YES             1"
          ],
          "globals_used": [
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define YES             1\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "fake_item.res"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_match",
          "args": [
            "pamh",
            "at + 1",
            "&fake_item"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "from_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "595-630",
          "snippet": "static int\nfrom_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    int        rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"from_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds. Return\n     * YES if the token fully matches the string. If the token is a domain\n     * name, return YES if it matches the last fields of the string. If the\n     * token has the magic value \"LOCAL\", return YES if the from field was\n     * not taken by PAM_RHOST. If the token is a network number, return YES\n     * if it matches the head of the string.\n     */\n\n    if (string == NULL) {\n\treturn NO;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n        return (netgroup_match (pamh, tok + 1, string, (char *) 0, item->debug));\n    } else if ((rv = string_match(pamh, tok, string, item->debug)) != NO) {\n        /* ALL or exact match */\n\treturn rv;\n    } else if (strcasecmp(tok, \"LOCAL\") == 0) {\n\t    /* LOCAL matches only local accesses */\n\t    if (!item->from_remote_host)\n\t        return YES;\n\t    return NO;\n    } else if (item->from_remote_host) {\n        return remote_match(pamh, tok, item);\n    }\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nfrom_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    const char *string = item->from;\n    int        rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"from_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds. Return\n     * YES if the token fully matches the string. If the token is a domain\n     * name, return YES if it matches the last fields of the string. If the\n     * token has the magic value \"LOCAL\", return YES if the from field was\n     * not taken by PAM_RHOST. If the token is a network number, return YES\n     * if it matches the head of the string.\n     */\n\n    if (string == NULL) {\n\treturn NO;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n        return (netgroup_match (pamh, tok + 1, string, (char *) 0, item->debug));\n    } else if ((rv = string_match(pamh, tok, string, item->debug)) != NO) {\n        /* ALL or exact match */\n\treturn rv;\n    } else if (strcasecmp(tok, \"LOCAL\") == 0) {\n\t    /* LOCAL matches only local accesses */\n\t    if (!item->from_remote_host)\n\t        return YES;\n\t    return NO;\n    } else if (item->from_remote_host) {\n        return remote_match(pamh, tok, item);\n    }\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_match",
          "args": [
            "pamh",
            "tok",
            "item"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "user_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "506-564",
          "snippet": "static int\nuser_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    char   *string = item->user->pw_name;\n    struct login_info fake_item;\n    char   *at;\n    int    rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"user_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the username, if the\n     * token is a group that contains the username, or if the token is the\n     * name of the user's primary group.\n     */\n\n    /* Try to split on a pattern (@*[^@]+)(@+.*) */\n    for (at = tok; *at == '@'; ++at);\n\n    if (tok[0] == '(' && tok[strlen(tok) - 1] == ')') {\n      return (group_match (pamh, tok, string, item->debug));\n    } else if ((at = strchr(at, '@')) != NULL) {\n        /* split user@host pattern */\n\tif (item->hostname == NULL)\n\t    return NO;\n\tmemcpy (&fake_item, item, sizeof(fake_item));\n\tfake_item.from = item->hostname;\n\tfake_item.gai_rv = 0;\n\tfake_item.res = NULL;\n\tfake_item.from_remote_host = 1; /* hostname should be resolvable */\n\t*at = 0;\n\tif (!user_match (pamh, tok, item))\n\t\treturn NO;\n\trv = from_match (pamh, at + 1, &fake_item);\n\tif (fake_item.gai_rv == 0 && fake_item.res)\n\t\tfreeaddrinfo(fake_item.res);\n\treturn rv;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n\tconst char *hostname = NULL;\n\tif (tok[1] == '@') {\t\t\t/* add hostname to netgroup match */\n\t\tif (item->hostname == NULL)\n\t\t    return NO;\n\t\t++tok;\n\t\thostname = item->hostname;\n\t}\n        return (netgroup_match (pamh, tok + 1, hostname, string, item->debug));\n    } else if ((rv=string_match (pamh, tok, string, item->debug)) != NO) /* ALL or exact match */\n      return rv;\n    else if (item->only_new_group_syntax == NO &&\n\t     pam_modutil_user_in_group_nam_nam (pamh,\n\t\t\t\t\t\titem->user->pw_name, tok))\n      /* try group membership */\n      return YES;\n\n    return NO;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fake_item",
            "item",
            "sizeof(fake_item)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "at",
            "'@'"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_match",
          "args": [
            "pamh",
            "tok",
            "string",
            "item->debug"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "group_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "569-590",
          "snippet": "static int\ngroup_match (pam_handle_t *pamh, const char *tok, const char* usr,\n    int debug)\n{\n    char grptok[BUFSIZ];\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"group_match: grp=%s, user=%s\", tok, usr);\n\n    if (strlen(tok) < 3)\n        return NO;\n\n    /* token is received under the format '(...)' */\n    memset(grptok, 0, BUFSIZ);\n    strncpy(grptok, tok + 1, strlen(tok) - 2);\n\n    if (pam_modutil_user_in_group_nam_nam(pamh, usr, grptok))\n        return YES;\n\n  return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\ngroup_match (pam_handle_t *pamh, const char *tok, const char* usr,\n    int debug)\n{\n    char grptok[BUFSIZ];\n\n    if (debug)\n        pam_syslog (pamh, LOG_DEBUG,\n\t\t    \"group_match: grp=%s, user=%s\", tok, usr);\n\n    if (strlen(tok) < 3)\n        return NO;\n\n    /* token is received under the format '(...)' */\n    memset(grptok, 0, BUFSIZ);\n    strncpy(grptok, tok + 1, strlen(tok) - 2);\n\n    if (pam_modutil_user_in_group_nam_nam(pamh, usr, grptok))\n        return YES;\n\n  return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tok"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user_match: tok=%s, item=%s\"",
            "tok",
            "string"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nuser_match (pam_handle_t *pamh, char *tok, struct login_info *item)\n{\n    char   *string = item->user->pw_name;\n    struct login_info fake_item;\n    char   *at;\n    int    rv;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"user_match: tok=%s, item=%s\", tok, string);\n\n    /*\n     * If a token has the magic value \"ALL\" the match always succeeds.\n     * Otherwise, return YES if the token fully matches the username, if the\n     * token is a group that contains the username, or if the token is the\n     * name of the user's primary group.\n     */\n\n    /* Try to split on a pattern (@*[^@]+)(@+.*) */\n    for (at = tok; *at == '@'; ++at);\n\n    if (tok[0] == '(' && tok[strlen(tok) - 1] == ')') {\n      return (group_match (pamh, tok, string, item->debug));\n    } else if ((at = strchr(at, '@')) != NULL) {\n        /* split user@host pattern */\n\tif (item->hostname == NULL)\n\t    return NO;\n\tmemcpy (&fake_item, item, sizeof(fake_item));\n\tfake_item.from = item->hostname;\n\tfake_item.gai_rv = 0;\n\tfake_item.res = NULL;\n\tfake_item.from_remote_host = 1; /* hostname should be resolvable */\n\t*at = 0;\n\tif (!user_match (pamh, tok, item))\n\t\treturn NO;\n\trv = from_match (pamh, at + 1, &fake_item);\n\tif (fake_item.gai_rv == 0 && fake_item.res)\n\t\tfreeaddrinfo(fake_item.res);\n\treturn rv;\n    } else if (tok[0] == '@') {\t\t\t/* netgroup */\n\tconst char *hostname = NULL;\n\tif (tok[1] == '@') {\t\t\t/* add hostname to netgroup match */\n\t\tif (item->hostname == NULL)\n\t\t    return NO;\n\t\t++tok;\n\t\thostname = item->hostname;\n\t}\n        return (netgroup_match (pamh, tok + 1, hostname, string, item->debug));\n    } else if ((rv=string_match (pamh, tok, string, item->debug)) != NO) /* ALL or exact match */\n      return rv;\n    else if (item->only_new_group_syntax == NO &&\n\t     pam_modutil_user_in_group_nam_nam (pamh,\n\t\t\t\t\t\titem->user->pw_name, tok))\n      /* try group membership */\n      return YES;\n\n    return NO;\n}"
  },
  {
    "function_name": "netgroup_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "470-502",
    "snippet": "static int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define YES             1"
    ],
    "globals_used": [
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\"",
            "retval",
            "netgroup ? netgroup : \"NULL\"",
            "machine ? machine : \"NULL\"",
            "user ? user : \"NULL\"",
            "mydomain ? mydomain : \"NULL\""
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_access does not have netgroup support\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "innetgr",
          "args": [
            "netgroup",
            "machine",
            "user",
            "mydomain"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate_notinnetgr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_succeed_if/pam_succeed_if.c",
          "lines": "277-287",
          "snippet": "static int\nevaluate_notinnetgr(const pam_handle_t* pamh SOMETIMES_UNUSED, const char *host, const char *user, const char *group)\n{\n#ifdef HAVE_INNETGR\n\tif (innetgr(group, host, user, NULL) == 0)\n\t\treturn PAM_SUCCESS;\n#else\n\tpam_syslog (pamh, LOG_ERR, \"pam_succeed_if does not have netgroup support\");\n#endif\n\treturn PAM_AUTH_ERR;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <fnmatch.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <netdb.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <fnmatch.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic int\nevaluate_notinnetgr(const pam_handle_t* pamh SOMETIMES_UNUSED, const char *host, const char *user, const char *group)\n{\n#ifdef HAVE_INNETGR\n\tif (innetgr(group, host, user, NULL) == 0)\n\t\treturn PAM_SUCCESS;\n#else\n\tpam_syslog (pamh, LOG_ERR, \"pam_succeed_if does not have netgroup support\");\n#endif\n\treturn PAM_AUTH_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname_res",
            "\"(none)\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdomainname",
          "args": [
            "domainname_res",
            "sizeof (domainname_res)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define YES             1\n\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\n\nstatic int\nnetgroup_match (pam_handle_t *pamh, const char *netgroup,\n\t\tconst char *machine, const char *user, int debug)\n{\n  int retval;\n  char *mydomain = NULL;\n\n#ifdef HAVE_GETDOMAINNAME\n  char domainname_res[256];\n\n  if (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n    {\n      if (domainname_res[0] != '\\0' && strcmp (domainname_res, \"(none)\") != 0)\n        {\n          mydomain = domainname_res;\n        }\n    }\n#endif\n\n#ifdef HAVE_INNETGR\n  retval = innetgr (netgroup, machine, user, mydomain);\n#else\n  retval = 0;\n  pam_syslog (pamh, LOG_ERR, \"pam_access does not have netgroup support\");\n#endif\n  if (debug == YES)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"netgroup_match: %d (netgroup=%s, machine=%s, user=%s, domain=%s)\",\n\t\tretval, netgroup ? netgroup : \"NULL\",\n\t\tmachine ? machine : \"NULL\",\n\t\tuser ? user : \"NULL\", mydomain ? mydomain : \"NULL\");\n  return retval;\n}"
  },
  {
    "function_name": "list_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "430-466",
    "snippet": "static int\nlist_match(pam_handle_t *pamh, char *list, char *sptr,\n\t   struct login_info *item, match_func *match_fn)\n{\n    char   *tok;\n    int     match = NO;\n\n    if (item->debug && list != NULL)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"list_match: list=%s, item=%s\", list, item->user->pw_name);\n\n    /*\n     * Process tokens one at a time. We have exhausted all possible matches\n     * when we reach an \"EXCEPT\" token or the end of the list. If we do find\n     * a match, look for an \"EXCEPT\" list and recurse to determine whether\n     * the match is affected by any exceptions.\n     */\n\n    for (tok = strtok_r(list, item->sep, &sptr); tok != 0;\n\t tok = strtok_r(NULL, item->sep, &sptr)) {\n\tif (strcasecmp(tok, \"EXCEPT\") == 0)\t/* EXCEPT: give up */\n\t    break;\n\tif ((match = (*match_fn) (pamh, tok, item)))\t/* YES */\n\t    break;\n    }\n    /* Process exceptions to matches. */\n\n    if (match != NO) {\n\twhile ((tok = strtok_r(NULL, item->sep, &sptr)) && strcasecmp(tok, \"EXCEPT\"))\n\t     /* VOID */ ;\n\tif (tok == 0)\n\t    return match;\n\tif (list_match(pamh, NULL, sptr, item, match_fn) == NO)\n\t    return YES; /* drop special meaning of ALL */\n    }\n    return (NO);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1",
      "#define ALL             2"
    ],
    "globals_used": [
      "static int list_match (pam_handle_t *, char *, char *, struct login_info *,\n\t\t       match_func *);",
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_match",
          "args": [
            "pamh",
            "NULL",
            "sptr",
            "item",
            "match_fn"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "430-466",
          "snippet": "static int\nlist_match(pam_handle_t *pamh, char *list, char *sptr,\n\t   struct login_info *item, match_func *match_fn)\n{\n    char   *tok;\n    int     match = NO;\n\n    if (item->debug && list != NULL)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"list_match: list=%s, item=%s\", list, item->user->pw_name);\n\n    /*\n     * Process tokens one at a time. We have exhausted all possible matches\n     * when we reach an \"EXCEPT\" token or the end of the list. If we do find\n     * a match, look for an \"EXCEPT\" list and recurse to determine whether\n     * the match is affected by any exceptions.\n     */\n\n    for (tok = strtok_r(list, item->sep, &sptr); tok != 0;\n\t tok = strtok_r(NULL, item->sep, &sptr)) {\n\tif (strcasecmp(tok, \"EXCEPT\") == 0)\t/* EXCEPT: give up */\n\t    break;\n\tif ((match = (*match_fn) (pamh, tok, item)))\t/* YES */\n\t    break;\n    }\n    /* Process exceptions to matches. */\n\n    if (match != NO) {\n\twhile ((tok = strtok_r(NULL, item->sep, &sptr)) && strcasecmp(tok, \"EXCEPT\"))\n\t     /* VOID */ ;\n\tif (tok == 0)\n\t    return match;\n\tif (list_match(pamh, NULL, sptr, item, match_fn) == NO)\n\t    return YES; /* drop special meaning of ALL */\n    }\n    return (NO);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "\"EXCEPT\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "item->sep",
            "&sptr"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pamh",
            "tok",
            "item"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tok",
            "\"EXCEPT\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "item->sep",
            "&sptr"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "list",
            "item->sep",
            "&sptr"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"list_match: list=%s, item=%s\"",
            "list",
            "item->user->pw_name"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int list_match (pam_handle_t *, char *, char *, struct login_info *,\n\t\t       match_func *);\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlist_match(pam_handle_t *pamh, char *list, char *sptr,\n\t   struct login_info *item, match_func *match_fn)\n{\n    char   *tok;\n    int     match = NO;\n\n    if (item->debug && list != NULL)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"list_match: list=%s, item=%s\", list, item->user->pw_name);\n\n    /*\n     * Process tokens one at a time. We have exhausted all possible matches\n     * when we reach an \"EXCEPT\" token or the end of the list. If we do find\n     * a match, look for an \"EXCEPT\" list and recurse to determine whether\n     * the match is affected by any exceptions.\n     */\n\n    for (tok = strtok_r(list, item->sep, &sptr); tok != 0;\n\t tok = strtok_r(NULL, item->sep, &sptr)) {\n\tif (strcasecmp(tok, \"EXCEPT\") == 0)\t/* EXCEPT: give up */\n\t    break;\n\tif ((match = (*match_fn) (pamh, tok, item)))\t/* YES */\n\t    break;\n    }\n    /* Process exceptions to matches. */\n\n    if (match != NO) {\n\twhile ((tok = strtok_r(NULL, item->sep, &sptr)) && strcasecmp(tok, \"EXCEPT\"))\n\t     /* VOID */ ;\n\tif (tok == 0)\n\t    return match;\n\tif (list_match(pamh, NULL, sptr, item, match_fn) == NO)\n\t    return YES; /* drop special meaning of ALL */\n    }\n    return (NO);\n}"
  },
  {
    "function_name": "login_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "325-425",
    "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NOMATCH        -1",
      "#define NO              0",
      "#define YES             1",
      "#define ALL             2"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_audit_write",
          "args": [
            "pamh",
            "AUDIT_ANOM_LOGIN_LOCATION",
            "\"pam_access\"",
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot open %s: %m\"",
            "item->config_file"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"warning: cannot open %s: %m\"",
            "item->config_file"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"from_match=%d, \\\"%s\\\"\"",
            "match",
            "item->from"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_match",
          "args": [
            "pamh",
            "froms",
            "NULL",
            "item",
            "from_match"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "430-466",
          "snippet": "static int\nlist_match(pam_handle_t *pamh, char *list, char *sptr,\n\t   struct login_info *item, match_func *match_fn)\n{\n    char   *tok;\n    int     match = NO;\n\n    if (item->debug && list != NULL)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"list_match: list=%s, item=%s\", list, item->user->pw_name);\n\n    /*\n     * Process tokens one at a time. We have exhausted all possible matches\n     * when we reach an \"EXCEPT\" token or the end of the list. If we do find\n     * a match, look for an \"EXCEPT\" list and recurse to determine whether\n     * the match is affected by any exceptions.\n     */\n\n    for (tok = strtok_r(list, item->sep, &sptr); tok != 0;\n\t tok = strtok_r(NULL, item->sep, &sptr)) {\n\tif (strcasecmp(tok, \"EXCEPT\") == 0)\t/* EXCEPT: give up */\n\t    break;\n\tif ((match = (*match_fn) (pamh, tok, item)))\t/* YES */\n\t    break;\n    }\n    /* Process exceptions to matches. */\n\n    if (match != NO) {\n\twhile ((tok = strtok_r(NULL, item->sep, &sptr)) && strcasecmp(tok, \"EXCEPT\"))\n\t     /* VOID */ ;\n\tif (tok == 0)\n\t    return match;\n\tif (list_match(pamh, NULL, sptr, item, match_fn) == NO)\n\t    return YES; /* drop special meaning of ALL */\n    }\n    return (NO);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int list_match (pam_handle_t *, char *, char *, struct login_info *,\n\t\t       match_func *);",
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int list_match (pam_handle_t *, char *, char *, struct login_info *,\n\t\t       match_func *);\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlist_match(pam_handle_t *pamh, char *list, char *sptr,\n\t   struct login_info *item, match_func *match_fn)\n{\n    char   *tok;\n    int     match = NO;\n\n    if (item->debug && list != NULL)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"list_match: list=%s, item=%s\", list, item->user->pw_name);\n\n    /*\n     * Process tokens one at a time. We have exhausted all possible matches\n     * when we reach an \"EXCEPT\" token or the end of the list. If we do find\n     * a match, look for an \"EXCEPT\" list and recurse to determine whether\n     * the match is affected by any exceptions.\n     */\n\n    for (tok = strtok_r(list, item->sep, &sptr); tok != 0;\n\t tok = strtok_r(NULL, item->sep, &sptr)) {\n\tif (strcasecmp(tok, \"EXCEPT\") == 0)\t/* EXCEPT: give up */\n\t    break;\n\tif ((match = (*match_fn) (pamh, tok, item)))\t/* YES */\n\t    break;\n    }\n    /* Process exceptions to matches. */\n\n    if (match != NO) {\n\twhile ((tok = strtok_r(NULL, item->sep, &sptr)) && strcasecmp(tok, \"EXCEPT\"))\n\t     /* VOID */ ;\n\tif (tok == 0)\n\t    return match;\n\tif (list_match(pamh, NULL, sptr, item, match_fn) == NO)\n\t    return YES; /* drop special meaning of ALL */\n    }\n    return (NO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user_match=%d, \\\"%s\\\"\"",
            "match",
            "item->user->pw_name"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"line %d: %s : %s : %s\"",
            "lineno",
            "perm",
            "users",
            "froms"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: line %d: bad first field\"",
            "item->config_file",
            "lineno"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: line %d: bad field count\"",
            "item->config_file",
            "lineno"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"\\n\"",
            "&sptr"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "item->fs",
            "&sptr"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "line",
            "item->fs",
            "&sptr"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "line[end - 1]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: line %d: missing newline or line too long\"",
            "item->config_file",
            "lineno"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "fp"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "item->config_file",
            "\"r\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"login_access: user=%s, from=%s, file=%s\"",
            "item->user->pw_name",
            "item->from",
            "item->config_file"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
  },
  {
    "function_name": "number_to_netmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "269-321",
    "snippet": "static char *\nnumber_to_netmask (long netmask, int addr_type,\n\t\t   char *ipaddr_buf, size_t ipaddr_buf_len)\n{\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n  struct sockaddr_storage nmask;\n  unsigned char *byte_nm;\n  const char *ipaddr_dst = NULL;\n  int i, ip_bytes;\n\n  if (netmask == 0) {\n    /* mask 0 is the same like no mask */\n    return(NULL);\n  }\n\n  memset(&nmask, 0, sizeof(struct sockaddr_storage));\n  if (addr_type == AF_INET6) {\n    /* ipv6 address mask */\n    ip_bytes = 16;\n  } else {\n    /* default might be an ipv4 address mask */\n    addr_type = AF_INET;\n    ip_bytes = 4;\n  }\n\n  byte_nm = (unsigned char *)(&nmask);\n  /* translate number to mask */\n  for (i=0; i<ip_bytes; i++) {\n    if (netmask >= 8) {\n      byte_nm[i] = 0xff;\n      netmask -= 8;\n    } else\n    if (netmask > 0) {\n      byte_nm[i] = 0xff << (8 - netmask);\n      break;\n    } else\n    if (netmask <= 0) {\n      break;\n    }\n  }\n\n  /* now generate netmask address string */\n  ipaddr_dst = inet_ntop(addr_type, &nmask, ipaddr_buf, ipaddr_buf_len);\n  if (ipaddr_dst == ipaddr_buf) {\n    return (ipaddr_buf);\n  }\n\n  return (NULL);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "addr_type",
            "&nmask",
            "ipaddr_buf",
            "ipaddr_buf_len"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nmask",
            "0",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *\nnumber_to_netmask (long netmask, int addr_type,\n\t\t   char *ipaddr_buf, size_t ipaddr_buf_len)\n{\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n  struct sockaddr_storage nmask;\n  unsigned char *byte_nm;\n  const char *ipaddr_dst = NULL;\n  int i, ip_bytes;\n\n  if (netmask == 0) {\n    /* mask 0 is the same like no mask */\n    return(NULL);\n  }\n\n  memset(&nmask, 0, sizeof(struct sockaddr_storage));\n  if (addr_type == AF_INET6) {\n    /* ipv6 address mask */\n    ip_bytes = 16;\n  } else {\n    /* default might be an ipv4 address mask */\n    addr_type = AF_INET;\n    ip_bytes = 4;\n  }\n\n  byte_nm = (unsigned char *)(&nmask);\n  /* translate number to mask */\n  for (i=0; i<ip_bytes; i++) {\n    if (netmask >= 8) {\n      byte_nm[i] = 0xff;\n      netmask -= 8;\n    } else\n    if (netmask > 0) {\n      byte_nm[i] = 0xff << (8 - netmask);\n      break;\n    } else\n    if (netmask <= 0) {\n      break;\n    }\n  }\n\n  /* now generate netmask address string */\n  ipaddr_dst = inet_ntop(addr_type, &nmask, ipaddr_buf, ipaddr_buf_len);\n  if (ipaddr_dst == ipaddr_buf) {\n    return (ipaddr_buf);\n  }\n\n  return (NULL);\n}"
  },
  {
    "function_name": "are_addresses_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "218-267",
    "snippet": "static int\nare_addresses_equal (const char *ipaddr0, const char *ipaddr1,\n\t\t     const char *netmask)\n{\n  struct sockaddr_storage addr0;\n  struct sockaddr_storage addr1;\n  int addr_type0 = 0;\n  int addr_type1 = 0;\n\n  if (isipaddr (ipaddr0, &addr_type0, &addr0) == NO)\n    return NO;\n\n  if (isipaddr (ipaddr1, &addr_type1, &addr1) == NO)\n    return NO;\n\n  if (addr_type0 != addr_type1)\n    /* different address types */\n    return NO;\n\n  if (netmask != NULL) {\n    /* Got a netmask, so normalize addresses? */\n    struct sockaddr_storage nmask;\n    unsigned char *byte_a, *byte_nm;\n\n    memset(&nmask, 0, sizeof(struct sockaddr_storage));\n    if (inet_pton(addr_type0, netmask, (void *)&nmask) > 0) {\n      unsigned int i;\n      byte_a = (unsigned char *)(&addr0);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n\n      byte_a = (unsigned char *)(&addr1);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n    }\n  }\n\n\n  /* Are the two addresses equal? */\n  if (memcmp((void *)&addr0, (void *)&addr1,\n              sizeof(struct sockaddr_storage)) == 0) {\n    return(YES);\n  }\n\n  return(NO);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(void *)&addr0",
            "(void *)&addr1",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "addr_type0",
            "netmask",
            "(void *)&nmask"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nmask",
            "0",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isipaddr",
          "args": [
            "ipaddr1",
            "&addr_type1",
            "&addr1"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "isipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "173-210",
          "snippet": "static int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NO              0",
            "#define YES             1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int\nare_addresses_equal (const char *ipaddr0, const char *ipaddr1,\n\t\t     const char *netmask)\n{\n  struct sockaddr_storage addr0;\n  struct sockaddr_storage addr1;\n  int addr_type0 = 0;\n  int addr_type1 = 0;\n\n  if (isipaddr (ipaddr0, &addr_type0, &addr0) == NO)\n    return NO;\n\n  if (isipaddr (ipaddr1, &addr_type1, &addr1) == NO)\n    return NO;\n\n  if (addr_type0 != addr_type1)\n    /* different address types */\n    return NO;\n\n  if (netmask != NULL) {\n    /* Got a netmask, so normalize addresses? */\n    struct sockaddr_storage nmask;\n    unsigned char *byte_a, *byte_nm;\n\n    memset(&nmask, 0, sizeof(struct sockaddr_storage));\n    if (inet_pton(addr_type0, netmask, (void *)&nmask) > 0) {\n      unsigned int i;\n      byte_a = (unsigned char *)(&addr0);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n\n      byte_a = (unsigned char *)(&addr1);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n    }\n  }\n\n\n  /* Are the two addresses equal? */\n  if (memcmp((void *)&addr0, (void *)&addr1,\n              sizeof(struct sockaddr_storage)) == 0) {\n    return(YES);\n  }\n\n  return(NO);\n}"
  },
  {
    "function_name": "isipaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "173-210",
    "snippet": "static int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "string",
            "addr"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET",
            "string",
            "addr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "0",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}"
  },
  {
    "function_name": "parse_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
    "lines": "107-155",
    "snippet": "static int\nparse_args(pam_handle_t *pamh, struct login_info *loginfo,\n           int argc, const char **argv)\n{\n    int i;\n\n    loginfo->noaudit = NO;\n    loginfo->debug = NO;\n    loginfo->only_new_group_syntax = NO;\n    loginfo->fs = \":\";\n    loginfo->sep = \", \\t\";\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(argv[i], \"fieldsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default field separators */\n\t    loginfo->fs = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"listsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default list separators */\n\t    loginfo->sep = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"accessfile=\")) != NULL) {\n\t    FILE *fp = fopen(str, \"r\");\n\n\t    if (fp) {\n\t\tloginfo->config_file = str;\n\t\tfclose(fp);\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"failed to open accessfile=[%s]: %m\", str);\n\t\treturn 0;\n\t    }\n\n\t} else if (strcmp (argv[i], \"debug\") == 0) {\n\t    loginfo->debug = YES;\n\t} else if (strcmp (argv[i], \"nodefgroup\") == 0) {\n\t    loginfo->only_new_group_syntax = YES;\n\t} else if (strcmp (argv[i], \"noaudit\") == 0) {\n\t    loginfo->noaudit = YES;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option [%s]\", argv[i]);\n\t}\n    }\n\n    return 1;  /* OK */\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <libaudit.h>",
      "#include <glob.h>",
      "#include <sys/socket.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <sys/utsname.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NO              0",
      "#define YES             1"
    ],
    "globals_used": [
      "static int user_match (pam_handle_t *, char *, struct login_info *);",
      "static int group_match (pam_handle_t *, const char *, const char *, int);",
      "static int from_match (pam_handle_t *, char *, struct login_info *);",
      "static int remote_match (pam_handle_t *, char *, struct login_info *);",
      "static int string_match (pam_handle_t *, const char *, const char *, int);",
      "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unrecognized option [%s]\"",
            "argv[i]"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"noaudit\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"nodefgroup\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to open accessfile=[%s]: %m\"",
            "str"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "str",
            "\"r\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"accessfile=\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"listsep=\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"fieldsep=\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nparse_args(pam_handle_t *pamh, struct login_info *loginfo,\n           int argc, const char **argv)\n{\n    int i;\n\n    loginfo->noaudit = NO;\n    loginfo->debug = NO;\n    loginfo->only_new_group_syntax = NO;\n    loginfo->fs = \":\";\n    loginfo->sep = \", \\t\";\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(argv[i], \"fieldsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default field separators */\n\t    loginfo->fs = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"listsep=\")) != NULL) {\n\n\t    /* the admin wants to override the default list separators */\n\t    loginfo->sep = str;\n\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"accessfile=\")) != NULL) {\n\t    FILE *fp = fopen(str, \"r\");\n\n\t    if (fp) {\n\t\tloginfo->config_file = str;\n\t\tfclose(fp);\n\t    } else {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"failed to open accessfile=[%s]: %m\", str);\n\t\treturn 0;\n\t    }\n\n\t} else if (strcmp (argv[i], \"debug\") == 0) {\n\t    loginfo->debug = YES;\n\t} else if (strcmp (argv[i], \"nodefgroup\") == 0) {\n\t    loginfo->only_new_group_syntax = YES;\n\t} else if (strcmp (argv[i], \"noaudit\") == 0) {\n\t    loginfo->noaudit = YES;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unrecognized option [%s]\", argv[i]);\n\t}\n    }\n\n    return 1;  /* OK */\n}"
  }
]