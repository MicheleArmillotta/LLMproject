[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux_check.c",
    "lines": "118-161",
    "snippet": "int\nmain (int argc, char **argv)\n{\n  pam_handle_t *pamh;\n  int childPid;\n\n  if (argc < 1)\n    exit (-1);\n\n  if (!authenticate_via_pam(argv[1],&pamh))\n    exit(-1);\n\n  childPid = fork();\n  if (childPid < 0) {\n    /* error in fork() */\n    fprintf(stderr, _(\"login: failure forking: %m\"));\n    pam_close_session(pamh, 0);\n    /* We're done with PAM.  Free `pam_handle'. */\n    pam_end( pamh, PAM_SUCCESS );\n    exit(0);\n  }\n  if (childPid) {\n    close(0); close(1); close(2);\n    struct sigaction sa;\n    memset(&sa,0,sizeof(sa));\n    sa.sa_handler = SIG_IGN;\n    sigaction(SIGQUIT, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n    while(wait(NULL) == -1 && errno == EINTR) /**/ ;\n    openlog(\"login\", LOG_ODELAY, LOG_AUTHPRIV);\n    pam_close_session(pamh, 0);\n    /* We're done with PAM.  Free `pam_handle'. */\n    pam_end( pamh, PAM_SUCCESS );\n    exit(0);\n  }\n  argv[0]=strdup (\"/bin/sh\");\n  argv[1]=NULL;\n\n  /* NOTE: The environment has not been sanitized. LD_PRELOAD and other fun\n   * things could be set. */\n  execv(\"/bin/sh\",argv);\n  fprintf(stderr,\"Failure\\n\");\n  return 0;\n}",
    "includes": [
      "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */",
      "#include <security/pam_appl.h>    /* for PAM functions */",
      "#include <sys/wait.h>\t\t  /* for wait() */",
      "#include <signal.h>",
      "#include <unistd.h>               /* for getuid(), exit(), getopt() */",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int authenticate_via_pam( const char *user ,   pam_handle_t **pamh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failure\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "\"/bin/sh\"",
            "argv"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/bin/sh\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_end",
          "args": [
            "pamh",
            "PAM_SUCCESS"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_close_session",
          "args": [
            "pamh",
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"login\"",
            "LOG_ODELAY",
            "LOG_AUTHPRIV"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sa",
            "NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&sa",
            "NULL"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof(sa)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "2"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_end",
          "args": [
            "pamh",
            "PAM_SUCCESS"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_close_session",
          "args": [
            "pamh",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"login: failure forking: %m\")"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"login: failure forking: %m\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "get_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "406-412",
          "snippet": "static const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DATANAME \"pam_selinux_context\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_selinux_context\"\n\nstatic const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authenticate_via_pam",
          "args": [
            "argv[1]",
            "&pamh"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "authenticate_via_pam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux_check.c",
          "lines": "78-116",
          "snippet": "int authenticate_via_pam( const char *user ,   pam_handle_t **pamh) {\n\n  struct pam_conv *conv;\n  int result = 0;    /* our result, set to 0 (not authenticated) by default */\n\n  /* this is a jump table of functions for pam to use when it wants to *\n   * communicate with the user.  we'll be using misc_conv(), which is  *\n   * provided for us via pam_misc.h.                                   */\n  struct pam_conv pam_conversation = {\n    misc_conv,\n    NULL\n  };\n  conv = &pam_conversation;\n\n\n  /* make `p_pam_handle' a valid pam handle so we can use it when *\n   * calling pam functions.                                       */\n  if( PAM_SUCCESS != pam_start( SERVICE_NAME,\n\t\t\t\tuser,\n\t\t\t\tconv,\n\t\t\t\tpamh ) ) {\n    fprintf( stderr, _(\"failed to initialize PAM\\n\") );\n    exit( -1 );\n  }\n\n  if( PAM_SUCCESS != pam_set_item(*pamh, PAM_RUSER, user))\n  {\n      fprintf( stderr, _(\"failed to pam_set_item()\\n\") );\n      exit( -1 );\n  }\n\n  /* Ask PAM to authenticate the user running this program */\n  if( PAM_SUCCESS == pam_authenticate(*pamh,0) ) {\n    if ( PAM_SUCCESS == pam_open_session(*pamh, 0) )\n      result = 1;  /* user authenticated OK! */\n  }\n  return( result );\n\n}",
          "includes": [
            "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */",
            "#include <security/pam_appl.h>    /* for PAM functions */",
            "#include <sys/wait.h>\t\t  /* for wait() */",
            "#include <signal.h>",
            "#include <unistd.h>               /* for getuid(), exit(), getopt() */",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SERVICE_NAME \"pam_selinux_check\"   /* the name of this program for PAM */"
          ],
          "globals_used": [
            "int authenticate_via_pam( const char *user ,   pam_handle_t **pamh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */\n#include <security/pam_appl.h>    /* for PAM functions */\n#include <sys/wait.h>\t\t  /* for wait() */\n#include <signal.h>\n#include <unistd.h>               /* for getuid(), exit(), getopt() */\n#include <syslog.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define SERVICE_NAME \"pam_selinux_check\"   /* the name of this program for PAM */\n\nint authenticate_via_pam( const char *user ,   pam_handle_t **pamh);\n\nint authenticate_via_pam( const char *user ,   pam_handle_t **pamh) {\n\n  struct pam_conv *conv;\n  int result = 0;    /* our result, set to 0 (not authenticated) by default */\n\n  /* this is a jump table of functions for pam to use when it wants to *\n   * communicate with the user.  we'll be using misc_conv(), which is  *\n   * provided for us via pam_misc.h.                                   */\n  struct pam_conv pam_conversation = {\n    misc_conv,\n    NULL\n  };\n  conv = &pam_conversation;\n\n\n  /* make `p_pam_handle' a valid pam handle so we can use it when *\n   * calling pam functions.                                       */\n  if( PAM_SUCCESS != pam_start( SERVICE_NAME,\n\t\t\t\tuser,\n\t\t\t\tconv,\n\t\t\t\tpamh ) ) {\n    fprintf( stderr, _(\"failed to initialize PAM\\n\") );\n    exit( -1 );\n  }\n\n  if( PAM_SUCCESS != pam_set_item(*pamh, PAM_RUSER, user))\n  {\n      fprintf( stderr, _(\"failed to pam_set_item()\\n\") );\n      exit( -1 );\n  }\n\n  /* Ask PAM to authenticate the user running this program */\n  if( PAM_SUCCESS == pam_authenticate(*pamh,0) ) {\n    if ( PAM_SUCCESS == pam_open_session(*pamh, 0) )\n      result = 1;  /* user authenticated OK! */\n  }\n  return( result );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */\n#include <security/pam_appl.h>    /* for PAM functions */\n#include <sys/wait.h>\t\t  /* for wait() */\n#include <signal.h>\n#include <unistd.h>               /* for getuid(), exit(), getopt() */\n#include <syslog.h>\n#include <errno.h>\n#include \"config.h\"\n\nint authenticate_via_pam( const char *user ,   pam_handle_t **pamh);\n\nint\nmain (int argc, char **argv)\n{\n  pam_handle_t *pamh;\n  int childPid;\n\n  if (argc < 1)\n    exit (-1);\n\n  if (!authenticate_via_pam(argv[1],&pamh))\n    exit(-1);\n\n  childPid = fork();\n  if (childPid < 0) {\n    /* error in fork() */\n    fprintf(stderr, _(\"login: failure forking: %m\"));\n    pam_close_session(pamh, 0);\n    /* We're done with PAM.  Free `pam_handle'. */\n    pam_end( pamh, PAM_SUCCESS );\n    exit(0);\n  }\n  if (childPid) {\n    close(0); close(1); close(2);\n    struct sigaction sa;\n    memset(&sa,0,sizeof(sa));\n    sa.sa_handler = SIG_IGN;\n    sigaction(SIGQUIT, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n    while(wait(NULL) == -1 && errno == EINTR) /**/ ;\n    openlog(\"login\", LOG_ODELAY, LOG_AUTHPRIV);\n    pam_close_session(pamh, 0);\n    /* We're done with PAM.  Free `pam_handle'. */\n    pam_end( pamh, PAM_SUCCESS );\n    exit(0);\n  }\n  argv[0]=strdup (\"/bin/sh\");\n  argv[1]=NULL;\n\n  /* NOTE: The environment has not been sanitized. LD_PRELOAD and other fun\n   * things could be set. */\n  execv(\"/bin/sh\",argv);\n  fprintf(stderr,\"Failure\\n\");\n  return 0;\n}"
  },
  {
    "function_name": "authenticate_via_pam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux_check.c",
    "lines": "78-116",
    "snippet": "int authenticate_via_pam( const char *user ,   pam_handle_t **pamh) {\n\n  struct pam_conv *conv;\n  int result = 0;    /* our result, set to 0 (not authenticated) by default */\n\n  /* this is a jump table of functions for pam to use when it wants to *\n   * communicate with the user.  we'll be using misc_conv(), which is  *\n   * provided for us via pam_misc.h.                                   */\n  struct pam_conv pam_conversation = {\n    misc_conv,\n    NULL\n  };\n  conv = &pam_conversation;\n\n\n  /* make `p_pam_handle' a valid pam handle so we can use it when *\n   * calling pam functions.                                       */\n  if( PAM_SUCCESS != pam_start( SERVICE_NAME,\n\t\t\t\tuser,\n\t\t\t\tconv,\n\t\t\t\tpamh ) ) {\n    fprintf( stderr, _(\"failed to initialize PAM\\n\") );\n    exit( -1 );\n  }\n\n  if( PAM_SUCCESS != pam_set_item(*pamh, PAM_RUSER, user))\n  {\n      fprintf( stderr, _(\"failed to pam_set_item()\\n\") );\n      exit( -1 );\n  }\n\n  /* Ask PAM to authenticate the user running this program */\n  if( PAM_SUCCESS == pam_authenticate(*pamh,0) ) {\n    if ( PAM_SUCCESS == pam_open_session(*pamh, 0) )\n      result = 1;  /* user authenticated OK! */\n  }\n  return( result );\n\n}",
    "includes": [
      "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */",
      "#include <security/pam_appl.h>    /* for PAM functions */",
      "#include <sys/wait.h>\t\t  /* for wait() */",
      "#include <signal.h>",
      "#include <unistd.h>               /* for getuid(), exit(), getopt() */",
      "#include <syslog.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SERVICE_NAME \"pam_selinux_check\"   /* the name of this program for PAM */"
    ],
    "globals_used": [
      "int authenticate_via_pam( const char *user ,   pam_handle_t **pamh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_open_session",
          "args": [
            "*pamh",
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_authenticate",
          "args": [
            "*pamh",
            "0"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"failed to pam_set_item()\\n\")"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to pam_set_item()\\n\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "get_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "406-412",
          "snippet": "static const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DATANAME \"pam_selinux_context\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_selinux_context\"\n\nstatic const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "*pamh",
            "PAM_RUSER",
            "user"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "-1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"failed to initialize PAM\\n\")"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_start",
          "args": [
            "SERVICE_NAME",
            "user",
            "conv",
            "pamh"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_misc.h>    /* for misc_conv PAM utility function */\n#include <security/pam_appl.h>    /* for PAM functions */\n#include <sys/wait.h>\t\t  /* for wait() */\n#include <signal.h>\n#include <unistd.h>               /* for getuid(), exit(), getopt() */\n#include <syslog.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define SERVICE_NAME \"pam_selinux_check\"   /* the name of this program for PAM */\n\nint authenticate_via_pam( const char *user ,   pam_handle_t **pamh);\n\nint authenticate_via_pam( const char *user ,   pam_handle_t **pamh) {\n\n  struct pam_conv *conv;\n  int result = 0;    /* our result, set to 0 (not authenticated) by default */\n\n  /* this is a jump table of functions for pam to use when it wants to *\n   * communicate with the user.  we'll be using misc_conv(), which is  *\n   * provided for us via pam_misc.h.                                   */\n  struct pam_conv pam_conversation = {\n    misc_conv,\n    NULL\n  };\n  conv = &pam_conversation;\n\n\n  /* make `p_pam_handle' a valid pam handle so we can use it when *\n   * calling pam functions.                                       */\n  if( PAM_SUCCESS != pam_start( SERVICE_NAME,\n\t\t\t\tuser,\n\t\t\t\tconv,\n\t\t\t\tpamh ) ) {\n    fprintf( stderr, _(\"failed to initialize PAM\\n\") );\n    exit( -1 );\n  }\n\n  if( PAM_SUCCESS != pam_set_item(*pamh, PAM_RUSER, user))\n  {\n      fprintf( stderr, _(\"failed to pam_set_item()\\n\") );\n      exit( -1 );\n  }\n\n  /* Ask PAM to authenticate the user running this program */\n  if( PAM_SUCCESS == pam_authenticate(*pamh,0) ) {\n    if ( PAM_SUCCESS == pam_open_session(*pamh, 0) )\n      result = 1;  /* user authenticated OK! */\n  }\n  return( result );\n\n}"
  }
]