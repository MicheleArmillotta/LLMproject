[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_update.c",
    "lines": "113-156",
    "snippet": "int main(int argc, char *argv[])\n{\n\tchar *option;\n\n\t/*\n\t * Catch or ignore as many signal as possible.\n\t */\n\tsetup_signals();\n\n\t/*\n\t * we establish that this program is running with non-tty stdin.\n\t * this is to discourage casual use. It does *NOT* prevent an\n\t * intruder from repeatadly running this program to determine the\n\t * password of the current user (brute force attack, but one for\n\t * which the attacker must already have gained access to the user's\n\t * account).\n\t */\n\n\tif (isatty(STDIN_FILENO) || argc != 5 ) {\n\t\thelper_log_err(LOG_NOTICE\n\t\t      ,\"inappropriate use of Unix helper binary [UID=%d]\"\n\t\t\t ,getuid());\n\t\tfprintf(stderr\n\t\t ,\"This binary is not designed for running in this way\\n\"\n\t\t      \"-- the system administrator has been informed\\n\");\n\t\tsleep(10);\t/* this should discourage/annoy the user */\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\t/* We must be root to read/update shadow.\n\t */\n\tif (geteuid() != 0) {\n\t    return PAM_CRED_INSUFFICIENT;\n\t}\n\n\toption = argv[2];\n\n\tif (strcmp(option, \"update\") == 0) {\n\t    /* Attempting to change the password */\n\t    return set_password(argv[1], argv[3], argv[4]);\n\t}\n\n\treturn PAM_SYSTEM_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"passverify.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/_pam_types.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_password",
          "args": [
            "argv[1]",
            "argv[3]",
            "argv[4]"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "set_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_update.c",
          "lines": "37-111",
          "snippet": "static int\nset_password(const char *forwho, const char *shadow, const char *remember)\n{\n    struct passwd *pwd = NULL;\n    int retval;\n    char pass[PAM_MAX_RESP_SIZE + 1];\n    char towhat[PAM_MAX_RESP_SIZE + 1];\n    int npass = 0;\n    /* we don't care about number format errors because the helper\n       should be called internally only */\n    int doshadow = atoi(shadow);\n    int nremember = atoi(remember);\n    char *passwords[] = { pass, towhat };\n\n    /* read the password from stdin (a pipe from the pam_unix module) */\n\n    npass = pam_read_passwords(STDIN_FILENO, 2, passwords);\n\n    if (npass != 2) {\t/* is it a valid password? */\n      if (npass == 1) {\n        helper_log_err(LOG_DEBUG, \"no new password supplied\");\n\tmemset(pass, '\\0', PAM_MAX_RESP_SIZE);\n      } else {\n        helper_log_err(LOG_DEBUG, \"no valid passwords supplied\");\n      }\n      return PAM_AUTHTOK_ERR;\n    }\n\n    if (lock_pwdf() != PAM_SUCCESS)\n\treturn PAM_AUTHTOK_LOCK_BUSY;\n\n    pwd = getpwnam(forwho);\n\n    if (pwd == NULL) {\n        retval = PAM_USER_UNKNOWN;\n        goto done;\n    }\n\n    /* If real caller uid is not root we must verify that\n       received old pass agrees with the current one.\n       We always allow change from null pass. */\n    if (getuid()) {\n\tretval = helper_verify_password(forwho, pass, 1);\n\tif (retval != PAM_SUCCESS) {\n\t    goto done;\n\t}\n    }\n\n    /* first, save old password */\n    if (save_old_password(forwho, pass, nremember)) {\n\tretval = PAM_AUTHTOK_ERR;\n\tgoto done;\n    }\n\n    if (doshadow || is_pwd_shadowed(pwd)) {\n\tretval = unix_update_shadow(forwho, towhat);\n\tif (retval == PAM_SUCCESS)\n\t    if (!is_pwd_shadowed(pwd))\n\t\tretval = unix_update_passwd(forwho, \"x\");\n    } else {\n\tretval = unix_update_passwd(forwho, towhat);\n    }\n\ndone:\n    memset(pass, '\\0', PAM_MAX_RESP_SIZE);\n    memset(towhat, '\\0', PAM_MAX_RESP_SIZE);\n\n    unlock_pwdf();\n\n    if (retval == PAM_SUCCESS) {\n\treturn PAM_SUCCESS;\n    } else {\n\treturn PAM_AUTHTOK_ERR;\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"passverify.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int\nset_password(const char *forwho, const char *shadow, const char *remember)\n{\n    struct passwd *pwd = NULL;\n    int retval;\n    char pass[PAM_MAX_RESP_SIZE + 1];\n    char towhat[PAM_MAX_RESP_SIZE + 1];\n    int npass = 0;\n    /* we don't care about number format errors because the helper\n       should be called internally only */\n    int doshadow = atoi(shadow);\n    int nremember = atoi(remember);\n    char *passwords[] = { pass, towhat };\n\n    /* read the password from stdin (a pipe from the pam_unix module) */\n\n    npass = pam_read_passwords(STDIN_FILENO, 2, passwords);\n\n    if (npass != 2) {\t/* is it a valid password? */\n      if (npass == 1) {\n        helper_log_err(LOG_DEBUG, \"no new password supplied\");\n\tmemset(pass, '\\0', PAM_MAX_RESP_SIZE);\n      } else {\n        helper_log_err(LOG_DEBUG, \"no valid passwords supplied\");\n      }\n      return PAM_AUTHTOK_ERR;\n    }\n\n    if (lock_pwdf() != PAM_SUCCESS)\n\treturn PAM_AUTHTOK_LOCK_BUSY;\n\n    pwd = getpwnam(forwho);\n\n    if (pwd == NULL) {\n        retval = PAM_USER_UNKNOWN;\n        goto done;\n    }\n\n    /* If real caller uid is not root we must verify that\n       received old pass agrees with the current one.\n       We always allow change from null pass. */\n    if (getuid()) {\n\tretval = helper_verify_password(forwho, pass, 1);\n\tif (retval != PAM_SUCCESS) {\n\t    goto done;\n\t}\n    }\n\n    /* first, save old password */\n    if (save_old_password(forwho, pass, nremember)) {\n\tretval = PAM_AUTHTOK_ERR;\n\tgoto done;\n    }\n\n    if (doshadow || is_pwd_shadowed(pwd)) {\n\tretval = unix_update_shadow(forwho, towhat);\n\tif (retval == PAM_SUCCESS)\n\t    if (!is_pwd_shadowed(pwd))\n\t\tretval = unix_update_passwd(forwho, \"x\");\n    } else {\n\tretval = unix_update_passwd(forwho, towhat);\n    }\n\ndone:\n    memset(pass, '\\0', PAM_MAX_RESP_SIZE);\n    memset(towhat, '\\0', PAM_MAX_RESP_SIZE);\n\n    unlock_pwdf();\n\n    if (retval == PAM_SUCCESS) {\n\treturn PAM_SUCCESS;\n    } else {\n\treturn PAM_AUTHTOK_ERR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "option",
            "\"update\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "10"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This binary is not designed for running in this way\\n\"\n\t\t      \"-- the system administrator has been informed\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "helper_log_err",
          "args": [
            "LOG_NOTICE",
            "\"inappropriate use of Unix helper binary [UID=%d]\"",
            "getuid()"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "helper_log_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
          "lines": "91-101",
          "snippet": "void\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}",
          "includes": [
            "#include \"opasswd.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <crypt.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <time.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nvoid\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_signals",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "setup_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "1132-1155",
          "snippet": "void\nsetup_signals(void)\n{\n        struct sigaction action;        /* posix signal structure */\n\n        /*\n         * Setup signal handlers\n         */\n        (void) memset((void *) &action, 0, sizeof(action));\n        action.sa_handler = su_sighandler;\n#ifdef SA_RESETHAND\n        action.sa_flags = SA_RESETHAND;\n#endif\n        (void) sigaction(SIGILL, &action, NULL);\n        (void) sigaction(SIGTRAP, &action, NULL);\n        (void) sigaction(SIGBUS, &action, NULL);\n        (void) sigaction(SIGSEGV, &action, NULL);\n        action.sa_handler = SIG_IGN;\n        action.sa_flags = 0;\n        (void) sigaction(SIGTERM, &action, NULL);\n        (void) sigaction(SIGHUP, &action, NULL);\n        (void) sigaction(SIGINT, &action, NULL);\n        (void) sigaction(SIGQUIT, &action, NULL);\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nvoid\nsetup_signals(void)\n{\n        struct sigaction action;        /* posix signal structure */\n\n        /*\n         * Setup signal handlers\n         */\n        (void) memset((void *) &action, 0, sizeof(action));\n        action.sa_handler = su_sighandler;\n#ifdef SA_RESETHAND\n        action.sa_flags = SA_RESETHAND;\n#endif\n        (void) sigaction(SIGILL, &action, NULL);\n        (void) sigaction(SIGTRAP, &action, NULL);\n        (void) sigaction(SIGBUS, &action, NULL);\n        (void) sigaction(SIGSEGV, &action, NULL);\n        action.sa_handler = SIG_IGN;\n        action.sa_flags = 0;\n        (void) sigaction(SIGTERM, &action, NULL);\n        (void) sigaction(SIGHUP, &action, NULL);\n        (void) sigaction(SIGINT, &action, NULL);\n        (void) sigaction(SIGQUIT, &action, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nint main(int argc, char *argv[])\n{\n\tchar *option;\n\n\t/*\n\t * Catch or ignore as many signal as possible.\n\t */\n\tsetup_signals();\n\n\t/*\n\t * we establish that this program is running with non-tty stdin.\n\t * this is to discourage casual use. It does *NOT* prevent an\n\t * intruder from repeatadly running this program to determine the\n\t * password of the current user (brute force attack, but one for\n\t * which the attacker must already have gained access to the user's\n\t * account).\n\t */\n\n\tif (isatty(STDIN_FILENO) || argc != 5 ) {\n\t\thelper_log_err(LOG_NOTICE\n\t\t      ,\"inappropriate use of Unix helper binary [UID=%d]\"\n\t\t\t ,getuid());\n\t\tfprintf(stderr\n\t\t ,\"This binary is not designed for running in this way\\n\"\n\t\t      \"-- the system administrator has been informed\\n\");\n\t\tsleep(10);\t/* this should discourage/annoy the user */\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\t/* We must be root to read/update shadow.\n\t */\n\tif (geteuid() != 0) {\n\t    return PAM_CRED_INSUFFICIENT;\n\t}\n\n\toption = argv[2];\n\n\tif (strcmp(option, \"update\") == 0) {\n\t    /* Attempting to change the password */\n\t    return set_password(argv[1], argv[3], argv[4]);\n\t}\n\n\treturn PAM_SYSTEM_ERR;\n}"
  },
  {
    "function_name": "set_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_update.c",
    "lines": "37-111",
    "snippet": "static int\nset_password(const char *forwho, const char *shadow, const char *remember)\n{\n    struct passwd *pwd = NULL;\n    int retval;\n    char pass[PAM_MAX_RESP_SIZE + 1];\n    char towhat[PAM_MAX_RESP_SIZE + 1];\n    int npass = 0;\n    /* we don't care about number format errors because the helper\n       should be called internally only */\n    int doshadow = atoi(shadow);\n    int nremember = atoi(remember);\n    char *passwords[] = { pass, towhat };\n\n    /* read the password from stdin (a pipe from the pam_unix module) */\n\n    npass = pam_read_passwords(STDIN_FILENO, 2, passwords);\n\n    if (npass != 2) {\t/* is it a valid password? */\n      if (npass == 1) {\n        helper_log_err(LOG_DEBUG, \"no new password supplied\");\n\tmemset(pass, '\\0', PAM_MAX_RESP_SIZE);\n      } else {\n        helper_log_err(LOG_DEBUG, \"no valid passwords supplied\");\n      }\n      return PAM_AUTHTOK_ERR;\n    }\n\n    if (lock_pwdf() != PAM_SUCCESS)\n\treturn PAM_AUTHTOK_LOCK_BUSY;\n\n    pwd = getpwnam(forwho);\n\n    if (pwd == NULL) {\n        retval = PAM_USER_UNKNOWN;\n        goto done;\n    }\n\n    /* If real caller uid is not root we must verify that\n       received old pass agrees with the current one.\n       We always allow change from null pass. */\n    if (getuid()) {\n\tretval = helper_verify_password(forwho, pass, 1);\n\tif (retval != PAM_SUCCESS) {\n\t    goto done;\n\t}\n    }\n\n    /* first, save old password */\n    if (save_old_password(forwho, pass, nremember)) {\n\tretval = PAM_AUTHTOK_ERR;\n\tgoto done;\n    }\n\n    if (doshadow || is_pwd_shadowed(pwd)) {\n\tretval = unix_update_shadow(forwho, towhat);\n\tif (retval == PAM_SUCCESS)\n\t    if (!is_pwd_shadowed(pwd))\n\t\tretval = unix_update_passwd(forwho, \"x\");\n    } else {\n\tretval = unix_update_passwd(forwho, towhat);\n    }\n\ndone:\n    memset(pass, '\\0', PAM_MAX_RESP_SIZE);\n    memset(towhat, '\\0', PAM_MAX_RESP_SIZE);\n\n    unlock_pwdf();\n\n    if (retval == PAM_SUCCESS) {\n\treturn PAM_SUCCESS;\n    } else {\n\treturn PAM_AUTHTOK_ERR;\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"passverify.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/_pam_types.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_pwdf",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_pwdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "607-611",
          "snippet": "void\nunlock_pwdf(void)\n{\n\treturn;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nvoid\nunlock_pwdf(void)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "towhat",
            "'\\0'",
            "PAM_MAX_RESP_SIZE"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pass",
            "'\\0'",
            "PAM_MAX_RESP_SIZE"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_update_passwd",
          "args": [
            "forwho",
            "towhat"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_update_passwd",
          "args": [
            "forwho",
            "\"x\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pwd_shadowed",
          "args": [
            "pwd"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "is_pwd_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "176-190",
          "snippet": "int\nis_pwd_shadowed(const struct passwd *pwd)\n{\n\tif (pwd != NULL) {\n\t\tif (strcmp(pwd->pw_passwd, \"x\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pwd->pw_passwd[0] == '#') &&\n\t\t    (pwd->pw_passwd[1] == '#') &&\n\t\t    (strcmp(pwd->pw_name, pwd->pw_passwd + 2) == 0)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "PAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nPAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);\n\nint\nis_pwd_shadowed(const struct passwd *pwd)\n{\n\tif (pwd != NULL) {\n\t\tif (strcmp(pwd->pw_passwd, \"x\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pwd->pw_passwd[0] == '#') &&\n\t\t    (pwd->pw_passwd[1] == '#') &&\n\t\t    (strcmp(pwd->pw_name, pwd->pw_passwd + 2) == 0)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_update_shadow",
          "args": [
            "forwho",
            "towhat"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_old_password",
          "args": [
            "forwho",
            "pass",
            "nremember"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "helper_verify_password",
          "args": [
            "forwho",
            "pass",
            "1"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "helper_verify_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "1070-1100",
          "snippet": "int\nhelper_verify_password(const char *name, const char *p, int nullok)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *hash = NULL;\n\tint retval;\n\n\tretval = get_pwd_hash(name, &pwd, &hash);\n\n\tif (pwd == NULL || hash == NULL) {\n\t\thelper_log_err(LOG_NOTICE, \"check pass; user unknown\");\n\t\tretval = PAM_USER_UNKNOWN;\n\t} else if (p[0] == '\\0' && nullok) {\n\t\tif (hash[0] == '\\0') {\n\t\t\tretval = PAM_SUCCESS;\n\t\t} else {\n\t\t\tretval = PAM_AUTH_ERR;\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(p, hash, nullok);\n\t}\n\n\tif (hash) {\n\t\t_pam_overwrite(hash);\n\t\t_pam_drop(hash);\n\t}\n\n\tp = NULL;\t\t/* no longer needed here */\n\n\treturn retval;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int retval;",
            "PAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);",
            "PAMH_ARG_DECL(int get_pwd_hash,\n\tconst char *name, struct passwd **pwd, char **hash)\n{\n\tint retval;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nint retval;\nPAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);\nPAMH_ARG_DECL(int get_pwd_hash,\n\tconst char *name, struct passwd **pwd, char **hash)\n{\n\tint retval;\n\nint\nhelper_verify_password(const char *name, const char *p, int nullok)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *hash = NULL;\n\tint retval;\n\n\tretval = get_pwd_hash(name, &pwd, &hash);\n\n\tif (pwd == NULL || hash == NULL) {\n\t\thelper_log_err(LOG_NOTICE, \"check pass; user unknown\");\n\t\tretval = PAM_USER_UNKNOWN;\n\t} else if (p[0] == '\\0' && nullok) {\n\t\tif (hash[0] == '\\0') {\n\t\t\tretval = PAM_SUCCESS;\n\t\t} else {\n\t\t\tretval = PAM_AUTH_ERR;\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(p, hash, nullok);\n\t}\n\n\tif (hash) {\n\t\t_pam_overwrite(hash);\n\t\t_pam_drop(hash);\n\t}\n\n\tp = NULL;\t\t/* no longer needed here */\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "forwho"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "helper_log_err",
          "args": [
            "LOG_DEBUG",
            "\"no valid passwords supplied\""
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "helper_log_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
          "lines": "91-101",
          "snippet": "void\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}",
          "includes": [
            "#include \"opasswd.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <crypt.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <time.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nvoid\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pass",
            "'\\0'",
            "PAM_MAX_RESP_SIZE"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_read_passwords",
          "args": [
            "STDIN_FILENO",
            "2",
            "passwords"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "remember"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "shadow"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int\nset_password(const char *forwho, const char *shadow, const char *remember)\n{\n    struct passwd *pwd = NULL;\n    int retval;\n    char pass[PAM_MAX_RESP_SIZE + 1];\n    char towhat[PAM_MAX_RESP_SIZE + 1];\n    int npass = 0;\n    /* we don't care about number format errors because the helper\n       should be called internally only */\n    int doshadow = atoi(shadow);\n    int nremember = atoi(remember);\n    char *passwords[] = { pass, towhat };\n\n    /* read the password from stdin (a pipe from the pam_unix module) */\n\n    npass = pam_read_passwords(STDIN_FILENO, 2, passwords);\n\n    if (npass != 2) {\t/* is it a valid password? */\n      if (npass == 1) {\n        helper_log_err(LOG_DEBUG, \"no new password supplied\");\n\tmemset(pass, '\\0', PAM_MAX_RESP_SIZE);\n      } else {\n        helper_log_err(LOG_DEBUG, \"no valid passwords supplied\");\n      }\n      return PAM_AUTHTOK_ERR;\n    }\n\n    if (lock_pwdf() != PAM_SUCCESS)\n\treturn PAM_AUTHTOK_LOCK_BUSY;\n\n    pwd = getpwnam(forwho);\n\n    if (pwd == NULL) {\n        retval = PAM_USER_UNKNOWN;\n        goto done;\n    }\n\n    /* If real caller uid is not root we must verify that\n       received old pass agrees with the current one.\n       We always allow change from null pass. */\n    if (getuid()) {\n\tretval = helper_verify_password(forwho, pass, 1);\n\tif (retval != PAM_SUCCESS) {\n\t    goto done;\n\t}\n    }\n\n    /* first, save old password */\n    if (save_old_password(forwho, pass, nremember)) {\n\tretval = PAM_AUTHTOK_ERR;\n\tgoto done;\n    }\n\n    if (doshadow || is_pwd_shadowed(pwd)) {\n\tretval = unix_update_shadow(forwho, towhat);\n\tif (retval == PAM_SUCCESS)\n\t    if (!is_pwd_shadowed(pwd))\n\t\tretval = unix_update_passwd(forwho, \"x\");\n    } else {\n\tretval = unix_update_passwd(forwho, towhat);\n    }\n\ndone:\n    memset(pass, '\\0', PAM_MAX_RESP_SIZE);\n    memset(towhat, '\\0', PAM_MAX_RESP_SIZE);\n\n    unlock_pwdf();\n\n    if (retval == PAM_SUCCESS) {\n\treturn PAM_SUCCESS;\n    } else {\n\treturn PAM_AUTHTOK_ERR;\n    }\n}"
  }
]