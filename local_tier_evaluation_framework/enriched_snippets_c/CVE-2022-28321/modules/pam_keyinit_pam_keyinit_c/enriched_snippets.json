[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "314-326",
    "snippet": "int pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t\t int argc UNUSED, const char **argv UNUSED)\n{\n\tdebug(pamh, \"CLOSE %d,%d,%d\",\n\t      session_counter, my_session_keyring, do_revoke);\n\n\tsession_counter--;\n\n\tif (session_counter <= 0 && my_session_keyring > 0 && do_revoke)\n\t\tkill_keyrings(pamh, PAM_SESSION_ERR);\n\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static _Thread_local int my_session_keyring = 0;",
      "static _Atomic int session_counter = 0;",
      "static _Thread_local int do_revoke = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_keyrings",
          "args": [
            "pamh",
            "PAM_SESSION_ERR"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "kill_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "154-201",
          "snippet": "static int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */"
          ],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\n\nstatic int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"CLOSE %d,%d,%d\"",
            "session_counter",
            "my_session_keyring",
            "do_revoke"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Atomic int session_counter = 0;\nstatic _Thread_local int do_revoke = 0;\n\nint pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t\t int argc UNUSED, const char **argv UNUSED)\n{\n\tdebug(pamh, \"CLOSE %d,%d,%d\",\n\t      session_counter, my_session_keyring, do_revoke);\n\n\tsession_counter--;\n\n\tif (session_counter <= 0 && my_session_keyring > 0 && do_revoke)\n\t\tkill_keyrings(pamh, PAM_SESSION_ERR);\n\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "301-309",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t\tint argc, const char **argv)\n{\n\tsession_counter++;\n\n\tdebug(pamh, \"OPEN %d\", session_counter);\n\n\treturn do_keyinit(pamh, argc, argv, PAM_SESSION_ERR);\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static _Atomic int session_counter = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_keyinit",
          "args": [
            "pamh",
            "argc",
            "argv",
            "PAM_SESSION_ERR"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "do_keyinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "203-272",
          "snippet": "static int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local int do_revoke = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;",
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local int do_revoke = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\nstatic _Thread_local int xdebug = 0;\n\nstatic int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"OPEN %d\"",
            "session_counter"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Atomic int session_counter = 0;\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t\tint argc, const char **argv)\n{\n\tsession_counter++;\n\n\tdebug(pamh, \"OPEN %d\", session_counter);\n\n\treturn do_keyinit(pamh, argc, argv, PAM_SESSION_ERR);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "287-299",
    "snippet": "int pam_sm_setcred(pam_handle_t *pamh, int flags,\n                   int argc, const char **argv)\n{\n\tif (flags & PAM_ESTABLISH_CRED) {\n\t\tdebug(pamh, \"ESTABLISH_CRED\");\n\t\treturn do_keyinit(pamh, argc, argv, PAM_CRED_ERR);\n\t}\n\tif (flags & PAM_DELETE_CRED && my_session_keyring > 0 && do_revoke) {\n\t\tdebug(pamh, \"DELETE_CRED\");\n\t\treturn kill_keyrings(pamh, PAM_CRED_ERR);\n\t}\n\treturn PAM_IGNORE;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static _Thread_local int my_session_keyring = 0;",
      "static _Thread_local int do_revoke = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_keyrings",
          "args": [
            "pamh",
            "PAM_CRED_ERR"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "kill_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "154-201",
          "snippet": "static int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */"
          ],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\n\nstatic int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"DELETE_CRED\""
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_keyinit",
          "args": [
            "pamh",
            "argc",
            "argv",
            "PAM_CRED_ERR"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "do_keyinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "203-272",
          "snippet": "static int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;",
            "static _Thread_local int do_revoke = 0;",
            "static _Thread_local uid_t revoke_as_uid;",
            "static _Thread_local gid_t revoke_as_gid;",
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local int do_revoke = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\nstatic _Thread_local int xdebug = 0;\n\nstatic int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local int do_revoke = 0;\n\nint pam_sm_setcred(pam_handle_t *pamh, int flags,\n                   int argc, const char **argv)\n{\n\tif (flags & PAM_ESTABLISH_CRED) {\n\t\tdebug(pamh, \"ESTABLISH_CRED\");\n\t\treturn do_keyinit(pamh, argc, argv, PAM_CRED_ERR);\n\t}\n\tif (flags & PAM_DELETE_CRED && my_session_keyring > 0 && do_revoke) {\n\t\tdebug(pamh, \"DELETE_CRED\");\n\t\treturn kill_keyrings(pamh, PAM_CRED_ERR);\n\t}\n\treturn PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "277-281",
    "snippet": "int pam_sm_authenticate(pam_handle_t *pamh UNUSED, int flags UNUSED,\n                   int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nint pam_sm_authenticate(pam_handle_t *pamh UNUSED, int flags UNUSED,\n                   int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "do_keyinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "203-272",
    "snippet": "static int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static _Thread_local int my_session_keyring = 0;",
      "static _Thread_local int do_revoke = 0;",
      "static _Thread_local uid_t revoke_as_uid;",
      "static _Thread_local gid_t revoke_as_gid;",
      "static _Thread_local int xdebug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "pamh",
            "\"Unable to change GID back to %d\\n\"",
            "old_gid"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "59-66",
          "snippet": "static void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_setregid",
          "args": [
            "old_gid",
            "-1"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "pam_setregid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "77-84",
          "snippet": "static int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_setreuid",
          "args": [
            "old_uid",
            "-1"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "pam_setreuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "68-75",
          "snippet": "static int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_keyrings",
          "args": [
            "pamh",
            "force",
            "error_ret"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "init_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "98-149",
          "snippet": "static int init_keyrings(pam_handle_t *pamh, int force, int error_ret)\n{\n\tint session, usession, ret;\n\n\tif (!force) {\n\t\t/* get the IDs of the session keyring and the user session\n\t\t * keyring */\n\t\tsession = syscall(__NR_keyctl,\n\t\t\t\t  KEYCTL_GET_KEYRING_ID,\n\t\t\t\t  KEY_SPEC_SESSION_KEYRING,\n\t\t\t\t  0);\n\t\tdebug(pamh, \"GET SESSION = %d\", session);\n\t\tif (session < 0) {\n\t\t\t/* don't worry about keyrings if facility not\n\t\t\t * installed */\n\t\t\tif (errno == ENOSYS)\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tusession = syscall(__NR_keyctl,\n\t\t\t\t   KEYCTL_GET_KEYRING_ID,\n\t\t\t\t   KEY_SPEC_USER_SESSION_KEYRING,\n\t\t\t\t   0);\n\t\tdebug(pamh, \"GET SESSION = %d\", usession);\n\t\tif (usession < 0)\n\t\t\treturn error_ret;\n\n\t\t/* if the user session keyring is our keyring, then we don't\n\t\t * need to do anything if we're not forcing */\n\t\tif (session != usession)\n\t\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* create a session keyring, discarding the old one */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_JOIN_SESSION_KEYRING,\n\t\t      NULL);\n\tdebug(pamh, \"JOIN = %d\", ret);\n\tif (ret < 0)\n\t\treturn error_ret;\n\n\tmy_session_keyring = ret;\n\n\t/* make a link from the session keyring to the user keyring */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_LINK,\n\t\t      KEY_SPEC_USER_KEYRING,\n\t\t      KEY_SPEC_SESSION_KEYRING);\n\n\treturn ret < 0 ? error_ret : PAM_SUCCESS;\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define KEYCTL_LINK\t\t\t8 /* link a key into a keyring */",
            "#define KEYCTL_JOIN_SESSION_KEYRING\t1 /* start named session keyring */",
            "#define KEYCTL_GET_KEYRING_ID\t\t0 /* ask for a keyring's ID */",
            "#define KEY_SPEC_USER_SESSION_KEYRING\t-5 /* - key ID for UID-session keyring */",
            "#define KEY_SPEC_USER_KEYRING\t\t-4 /* ID for UID-specific keyring */",
            "#define KEY_SPEC_SESSION_KEYRING\t-3 /* ID for session keyring */"
          ],
          "globals_used": [
            "static _Thread_local int my_session_keyring = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_LINK\t\t\t8 /* link a key into a keyring */\n#define KEYCTL_JOIN_SESSION_KEYRING\t1 /* start named session keyring */\n#define KEYCTL_GET_KEYRING_ID\t\t0 /* ask for a keyring's ID */\n#define KEY_SPEC_USER_SESSION_KEYRING\t-5 /* - key ID for UID-session keyring */\n#define KEY_SPEC_USER_KEYRING\t\t-4 /* ID for UID-specific keyring */\n#define KEY_SPEC_SESSION_KEYRING\t-3 /* ID for session keyring */\n\nstatic _Thread_local int my_session_keyring = 0;\n\nstatic int init_keyrings(pam_handle_t *pamh, int force, int error_ret)\n{\n\tint session, usession, ret;\n\n\tif (!force) {\n\t\t/* get the IDs of the session keyring and the user session\n\t\t * keyring */\n\t\tsession = syscall(__NR_keyctl,\n\t\t\t\t  KEYCTL_GET_KEYRING_ID,\n\t\t\t\t  KEY_SPEC_SESSION_KEYRING,\n\t\t\t\t  0);\n\t\tdebug(pamh, \"GET SESSION = %d\", session);\n\t\tif (session < 0) {\n\t\t\t/* don't worry about keyrings if facility not\n\t\t\t * installed */\n\t\t\tif (errno == ENOSYS)\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tusession = syscall(__NR_keyctl,\n\t\t\t\t   KEYCTL_GET_KEYRING_ID,\n\t\t\t\t   KEY_SPEC_USER_SESSION_KEYRING,\n\t\t\t\t   0);\n\t\tdebug(pamh, \"GET SESSION = %d\", usession);\n\t\tif (usession < 0)\n\t\t\treturn error_ret;\n\n\t\t/* if the user session keyring is our keyring, then we don't\n\t\t * need to do anything if we're not forcing */\n\t\tif (session != usession)\n\t\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* create a session keyring, discarding the old one */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_JOIN_SESSION_KEYRING,\n\t\t      NULL);\n\tdebug(pamh, \"JOIN = %d\", ret);\n\tif (ret < 0)\n\t\treturn error_ret;\n\n\tmy_session_keyring = ret;\n\n\t/* make a link from the session keyring to the user keyring */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_LINK,\n\t\t      KEY_SPEC_USER_KEYRING,\n\t\t      KEY_SPEC_SESSION_KEYRING);\n\n\treturn ret < 0 ? error_ret : PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"UID:%d [%d]  GID:%d [%d]\"",
            "uid",
            "old_uid",
            "gid",
            "old_gid"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Unable to look up user \\\"%s\\\"\\n\"",
            "username"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "\"key user\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[loop]",
            "\"revoke\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[loop]",
            "\"debug\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[loop]",
            "\"force\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local int do_revoke = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\nstatic _Thread_local int xdebug = 0;\n\nstatic int do_keyinit(pam_handle_t *pamh, int argc, const char **argv, int error_ret)\n{\n\tstruct passwd *pw;\n\tconst char *username;\n\tint ret, loop, force = 0;\n\tuid_t old_uid, uid;\n\tgid_t old_gid, gid;\n\n\tfor (loop = 0; loop < argc; loop++) {\n\t\tif (strcmp(argv[loop], \"force\") == 0)\n\t\t\tforce = 1;\n\t\telse if (strcmp(argv[loop], \"debug\") == 0)\n\t\t\txdebug = 1;\n\t\telse if (strcmp(argv[loop], \"revoke\") == 0)\n\t\t\tdo_revoke = 1;\n\t}\n\n\t/* don't do anything if already created a keyring (will be called\n\t * multiple times if mentioned more than once in a pam script)\n\t */\n\tif (my_session_keyring > 0)\n\t\treturn PAM_SUCCESS;\n\n\t/* look up the target UID */\n\tret = pam_get_user(pamh, &username, \"key user\");\n\tif (ret != PAM_SUCCESS)\n\t\treturn ret;\n\n\tpw = pam_modutil_getpwnam(pamh, username);\n\tif (!pw) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"Unable to look up user \\\"%s\\\"\\n\",\n\t\t\t   username);\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\trevoke_as_uid = uid = pw->pw_uid;\n\told_uid = getuid();\n\trevoke_as_gid = gid = pw->pw_gid;\n\told_gid = getgid();\n\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\", uid, old_uid, gid, old_gid);\n\n\t/* switch to the real UID and GID so that the keyring ends up owned by\n\t * the right user */\n\tif (gid != old_gid && pam_setregid(gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", gid);\n\t\treturn error_ret;\n\t}\n\n\tif (uid != old_uid && pam_setreuid(uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", uid);\n\t\tif (pam_setregid(old_gid, -1) < 0)\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\treturn error_ret;\n\t}\n\n\tret = init_keyrings(pamh, force, error_ret);\n\n\t/* return to the original UID and GID (probably root) */\n\tif (uid != old_uid && pam_setreuid(old_uid, -1) < 0) {\n\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\tret = error_ret;\n\t}\n\n\tif (gid != old_gid && pam_setregid(old_gid, -1) < 0) {\n\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\tret = error_ret;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_keyrings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "154-201",
    "snippet": "static int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */"
    ],
    "globals_used": [
      "static _Thread_local int my_session_keyring = 0;",
      "static _Thread_local uid_t revoke_as_uid;",
      "static _Thread_local gid_t revoke_as_gid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "pamh",
            "\"Unable to change GID back to %d\\n\"",
            "old_gid"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "59-66",
          "snippet": "static void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_setregid",
          "args": [
            "-1",
            "old_gid"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "pam_setregid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "77-84",
          "snippet": "static int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_setreuid",
          "args": [
            "-1",
            "old_uid"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pam_setreuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "68-75",
          "snippet": "static int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_keyctl",
            "KEYCTL_REVOKE",
            "my_session_keyring"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_setresuid",
          "args": [
            "-1",
            "revoke_as_uid",
            "old_uid"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "pam_setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "86-93",
          "snippet": "static int pam_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n#if defined(SYS_setresuid32)\n    return syscall(SYS_setresuid32, ruid, euid, suid);\n#else\n    return syscall(SYS_setresuid, ruid, euid, suid);\n#endif\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n#if defined(SYS_setresuid32)\n    return syscall(SYS_setresuid32, ruid, euid, suid);\n#else\n    return syscall(SYS_setresuid, ruid, euid, suid);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"UID:%d [%d]  GID:%d [%d]\"",
            "revoke_as_uid",
            "old_uid",
            "revoke_as_gid",
            "old_gid"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_REVOKE\t\t\t3 /* revoke a key */\n\nstatic _Thread_local int my_session_keyring = 0;\nstatic _Thread_local uid_t revoke_as_uid;\nstatic _Thread_local gid_t revoke_as_gid;\n\nstatic int kill_keyrings(pam_handle_t *pamh, int error_ret)\n{\n\tuid_t old_uid;\n\tgid_t old_gid;\n\tint ret = PAM_SUCCESS;\n\n\t/* revoke the session keyring we created earlier */\n\tif (my_session_keyring > 0) {\n\t\tdebug(pamh, \"REVOKE %d\", my_session_keyring);\n\n\t\told_uid = geteuid();\n\t\told_gid = getegid();\n\t\tdebug(pamh, \"UID:%d [%d]  GID:%d [%d]\",\n\t\t      revoke_as_uid, old_uid, revoke_as_gid, old_gid);\n\n\t\t/* switch to the real UID and GID so that we have permission to\n\t\t * revoke the key */\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, revoke_as_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID to %d temporarily\\n\", revoke_as_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (revoke_as_uid != old_uid && pam_setresuid(-1, revoke_as_uid, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID to %d temporarily\\n\", revoke_as_uid);\n\t\t\tif (getegid() != old_gid && pam_setregid(-1, old_gid) < 0)\n\t\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tif (syscall(__NR_keyctl, KEYCTL_REVOKE, my_session_keyring) < 0) {\n\t\t\tret = error_ret;\n\t\t}\n\n\t\t/* return to the original UID and GID (probably root) */\n\t\tif (revoke_as_uid != old_uid && pam_setreuid(-1, old_uid) < 0) {\n\t\t\terror(pamh, \"Unable to change UID back to %d\\n\", old_uid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tif (revoke_as_gid != old_gid && pam_setregid(-1, old_gid) < 0) {\n\t\t\terror(pamh, \"Unable to change GID back to %d\\n\", old_gid);\n\t\t\tret = error_ret;\n\t\t}\n\n\t\tmy_session_keyring = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "init_keyrings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "98-149",
    "snippet": "static int init_keyrings(pam_handle_t *pamh, int force, int error_ret)\n{\n\tint session, usession, ret;\n\n\tif (!force) {\n\t\t/* get the IDs of the session keyring and the user session\n\t\t * keyring */\n\t\tsession = syscall(__NR_keyctl,\n\t\t\t\t  KEYCTL_GET_KEYRING_ID,\n\t\t\t\t  KEY_SPEC_SESSION_KEYRING,\n\t\t\t\t  0);\n\t\tdebug(pamh, \"GET SESSION = %d\", session);\n\t\tif (session < 0) {\n\t\t\t/* don't worry about keyrings if facility not\n\t\t\t * installed */\n\t\t\tif (errno == ENOSYS)\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tusession = syscall(__NR_keyctl,\n\t\t\t\t   KEYCTL_GET_KEYRING_ID,\n\t\t\t\t   KEY_SPEC_USER_SESSION_KEYRING,\n\t\t\t\t   0);\n\t\tdebug(pamh, \"GET SESSION = %d\", usession);\n\t\tif (usession < 0)\n\t\t\treturn error_ret;\n\n\t\t/* if the user session keyring is our keyring, then we don't\n\t\t * need to do anything if we're not forcing */\n\t\tif (session != usession)\n\t\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* create a session keyring, discarding the old one */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_JOIN_SESSION_KEYRING,\n\t\t      NULL);\n\tdebug(pamh, \"JOIN = %d\", ret);\n\tif (ret < 0)\n\t\treturn error_ret;\n\n\tmy_session_keyring = ret;\n\n\t/* make a link from the session keyring to the user keyring */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_LINK,\n\t\t      KEY_SPEC_USER_KEYRING,\n\t\t      KEY_SPEC_SESSION_KEYRING);\n\n\treturn ret < 0 ? error_ret : PAM_SUCCESS;\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define KEYCTL_LINK\t\t\t8 /* link a key into a keyring */",
      "#define KEYCTL_JOIN_SESSION_KEYRING\t1 /* start named session keyring */",
      "#define KEYCTL_GET_KEYRING_ID\t\t0 /* ask for a keyring's ID */",
      "#define KEY_SPEC_USER_SESSION_KEYRING\t-5 /* - key ID for UID-session keyring */",
      "#define KEY_SPEC_USER_KEYRING\t\t-4 /* ID for UID-specific keyring */",
      "#define KEY_SPEC_SESSION_KEYRING\t-3 /* ID for session keyring */"
    ],
    "globals_used": [
      "static _Thread_local int my_session_keyring = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_keyctl",
            "KEYCTL_LINK",
            "KEY_SPEC_USER_KEYRING",
            "KEY_SPEC_SESSION_KEYRING"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "\"JOIN = %d\"",
            "ret"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
          "lines": "45-54",
          "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
          "includes": [
            "#include <stdatomic.h>",
            "#include <sys/syscall.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static _Thread_local int xdebug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_keyctl",
            "KEYCTL_JOIN_SESSION_KEYRING",
            "NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_keyctl",
            "KEYCTL_GET_KEYRING_ID",
            "KEY_SPEC_USER_SESSION_KEYRING",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_keyctl",
            "KEYCTL_GET_KEYRING_ID",
            "KEY_SPEC_SESSION_KEYRING",
            "0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\n#define KEYCTL_LINK\t\t\t8 /* link a key into a keyring */\n#define KEYCTL_JOIN_SESSION_KEYRING\t1 /* start named session keyring */\n#define KEYCTL_GET_KEYRING_ID\t\t0 /* ask for a keyring's ID */\n#define KEY_SPEC_USER_SESSION_KEYRING\t-5 /* - key ID for UID-session keyring */\n#define KEY_SPEC_USER_KEYRING\t\t-4 /* ID for UID-specific keyring */\n#define KEY_SPEC_SESSION_KEYRING\t-3 /* ID for session keyring */\n\nstatic _Thread_local int my_session_keyring = 0;\n\nstatic int init_keyrings(pam_handle_t *pamh, int force, int error_ret)\n{\n\tint session, usession, ret;\n\n\tif (!force) {\n\t\t/* get the IDs of the session keyring and the user session\n\t\t * keyring */\n\t\tsession = syscall(__NR_keyctl,\n\t\t\t\t  KEYCTL_GET_KEYRING_ID,\n\t\t\t\t  KEY_SPEC_SESSION_KEYRING,\n\t\t\t\t  0);\n\t\tdebug(pamh, \"GET SESSION = %d\", session);\n\t\tif (session < 0) {\n\t\t\t/* don't worry about keyrings if facility not\n\t\t\t * installed */\n\t\t\tif (errno == ENOSYS)\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\treturn error_ret;\n\t\t}\n\n\t\tusession = syscall(__NR_keyctl,\n\t\t\t\t   KEYCTL_GET_KEYRING_ID,\n\t\t\t\t   KEY_SPEC_USER_SESSION_KEYRING,\n\t\t\t\t   0);\n\t\tdebug(pamh, \"GET SESSION = %d\", usession);\n\t\tif (usession < 0)\n\t\t\treturn error_ret;\n\n\t\t/* if the user session keyring is our keyring, then we don't\n\t\t * need to do anything if we're not forcing */\n\t\tif (session != usession)\n\t\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* create a session keyring, discarding the old one */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_JOIN_SESSION_KEYRING,\n\t\t      NULL);\n\tdebug(pamh, \"JOIN = %d\", ret);\n\tif (ret < 0)\n\t\treturn error_ret;\n\n\tmy_session_keyring = ret;\n\n\t/* make a link from the session keyring to the user keyring */\n\tret = syscall(__NR_keyctl,\n\t\t      KEYCTL_LINK,\n\t\t      KEY_SPEC_USER_KEYRING,\n\t\t      KEY_SPEC_SESSION_KEYRING);\n\n\treturn ret < 0 ? error_ret : PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_setresuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "86-93",
    "snippet": "static int pam_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n#if defined(SYS_setresuid32)\n    return syscall(SYS_setresuid32, ruid, euid, suid);\n#else\n    return syscall(SYS_setresuid, ruid, euid, suid);\n#endif\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setresuid",
            "ruid",
            "euid",
            "suid"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setresuid32",
            "ruid",
            "euid",
            "suid"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n#if defined(SYS_setresuid32)\n    return syscall(SYS_setresuid32, ruid, euid, suid);\n#else\n    return syscall(SYS_setresuid, ruid, euid, suid);\n#endif\n}"
  },
  {
    "function_name": "pam_setregid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "77-84",
    "snippet": "static int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setregid",
            "rgid",
            "egid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setregid32",
            "rgid",
            "egid"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setregid(gid_t rgid, gid_t egid)\n{\n#if defined(SYS_setregid32)\n    return syscall(SYS_setregid32, rgid, egid);\n#else\n    return syscall(SYS_setregid, rgid, egid);\n#endif\n}"
  },
  {
    "function_name": "pam_setreuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "68-75",
    "snippet": "static int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setreuid",
            "ruid",
            "euid"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_setreuid32",
            "ruid",
            "euid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int pam_setreuid(uid_t ruid, uid_t euid)\n{\n#if defined(SYS_setreuid32)\n    return syscall(SYS_setreuid32, ruid, euid);\n#else\n    return syscall(SYS_setreuid, ruid, euid);\n#endif\n}"
  },
  {
    "function_name": "error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "59-66",
    "snippet": "static void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "va"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_vsyslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "fmt",
            "va"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "va",
            "fmt"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic void error(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tpam_vsyslog(pamh, LOG_ERR, fmt, va);\n\tva_end(va);\n}"
  },
  {
    "function_name": "debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_keyinit/pam_keyinit.c",
    "lines": "45-54",
    "snippet": "static void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}",
    "includes": [
      "#include <stdatomic.h>",
      "#include <sys/syscall.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static _Thread_local int xdebug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "va"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_vsyslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "fmt",
            "va"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "va",
            "fmt"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdatomic.h>\n#include <sys/syscall.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic _Thread_local int xdebug = 0;\n\nstatic void debug(pam_handle_t *pamh, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (xdebug) {\n\t\tva_start(va, fmt);\n\t\tpam_vsyslog(pamh, LOG_DEBUG, fmt, va);\n\t\tva_end(va);\n\t}\n}"
  }
]