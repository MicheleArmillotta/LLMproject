[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/upperLOWER/upperLOWER.c",
    "lines": "37-141",
    "snippet": "int main(int argc, char **argv UNUSED)\n{\n     char buffer[BUFSIZ];\n     fd_set readers;\n     void (*before_user)(char *,int);\n     void (*before_app)(char *,int);\n\n     openlog(\"upperLOWER\", LOG_CONS|LOG_PID, LOG_AUTHPRIV);\n\n#ifdef DEBUG\n     {\n\t  int i;\n\n\t  fprintf(stderr,\"environment :[\\r\\n\");\n\t  for (i=0; environ[i]; ++i) {\n\t       fprintf(stderr,\"-> %s\\r\\n\",environ[i]);\n\t  }\n\t  fprintf(stderr,\"]: end\\r\\n\");\n     }\n#endif\n\n     if (argc != 1) {\n#ifdef DEBUG\n\t  fprintf(stderr,\"filter invoked as conventional executable\\n\");\n#else\n\t  syslog(LOG_ERR, \"filter invoked as conventional executable\");\n#endif\n\t  exit(1);\n     }\n\n     before_user = before_app = do_transpose;   /* assign filter functions */\n\n     /* enter a loop that deals with the input and output of the\n        user.. passing it to and from the application */\n\n     FD_ZERO(&readers);                    /* initialize reading mask */\n\n     for (;;) {\n\n\t  FD_SET(APPOUT_FILENO, &readers);              /* wake for output */\n\t  FD_SET(APPERR_FILENO, &readers);               /* wake for error */\n\t  FD_SET(STDIN_FILENO, &readers);                /* wake for input */\n\n\t  if ( select(APPTOP_FILE,&readers,NULL,NULL,NULL) < 0 ) {\n#ifdef DEBUG\n\t       fprintf(stderr,\"select failed\\n\");\n#else\n\t       syslog(LOG_WARNING,\"select failed\");\n#endif\n\t       break;\n\t  }\n\n\t  /* application errors */\n\n\t  if ( FD_ISSET(APPERR_FILENO,&readers) ) {\n\t       int got = read(APPERR_FILENO, buffer, BUFSIZ);\n\t       if (got <= 0) {\n\t\t    break;\n\t       } else {\n\t\t    /* translate to give to real terminal */\n\t\t    if (before_user != NULL)\n\t\t\t before_user(buffer, got);\n\t\t    if (pam_modutil_write(STDERR_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't write %d bytes?!\",got);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  } else if ( FD_ISSET(APPOUT_FILENO,&readers) ) {    /* app output */\n\t       int got = read(APPOUT_FILENO, buffer, BUFSIZ);\n\t       if (got <= 0) {\n\t\t    break;\n\t       } else {\n\t\t    /* translate to give to real terminal */\n\t\t    if (before_user != NULL)\n\t\t\t before_user(buffer, got);\n\t\t    if (pam_modutil_write(STDOUT_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't write %d bytes!?\",got);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\n\t  if ( FD_ISSET(STDIN_FILENO, &readers) ) {  /* user input */\n\t       int got = read(STDIN_FILENO, buffer, BUFSIZ);\n\t       if (got < 0) {\n\t\t    syslog(LOG_WARNING,\"user input junked\");\n\t\t    break;\n\t       } else if (got) {\n\t\t    /* translate to give to application */\n\t\t    if (before_app != NULL)\n\t\t\t before_app(buffer, got);\n\t\t    if (pam_modutil_write(APPIN_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't pass %d bytes!?\",got);\n\t\t\t break;\n\t\t    }\n\t       } else {\n\t\t    /* nothing received -- an error? */\n\t\t    syslog(LOG_WARNING,\"user input null?\");\n\t\t    break;\n\t       }\n\t  }\n     }\n\n     exit(0);\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include \"pam_filter.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char **environ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"user input null?\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"couldn't pass %d bytes!?\"",
            "got"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "APPIN_FILENO",
            "buffer",
            "got"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "before_app",
          "args": [
            "buffer",
            "got"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"user input junked\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "STDIN_FILENO",
            "buffer",
            "BUFSIZ"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "188-275",
          "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
            "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "STDIN_FILENO",
            "&readers"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"couldn't write %d bytes!?\"",
            "got"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "STDOUT_FILENO",
            "buffer",
            "got"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "before_user",
          "args": [
            "buffer",
            "got"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "APPOUT_FILENO",
            "&readers"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"couldn't write %d bytes?!\"",
            "got"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "STDERR_FILENO",
            "buffer",
            "got"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "before_user",
          "args": [
            "buffer",
            "got"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "APPERR_FILENO",
            "&readers"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_WARNING",
            "\"select failed\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"select failed\\n\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "APPTOP_FILE",
            "&readers",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "STDIN_FILENO",
            "&readers"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "APPERR_FILENO",
            "&readers"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "APPOUT_FILENO",
            "&readers"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&readers"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_ERR",
            "\"filter invoked as conventional executable\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"filter invoked as conventional executable\\n\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"]: end\\r\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-> %s\\r\\n\"",
            "environ[i]"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"environment :[\\r\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"upperLOWER\"",
            "LOG_CONS|LOG_PID",
            "LOG_AUTHPRIV"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include \"pam_filter.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"config.h\"\n\nextern char **environ;\n\nint main(int argc, char **argv UNUSED)\n{\n     char buffer[BUFSIZ];\n     fd_set readers;\n     void (*before_user)(char *,int);\n     void (*before_app)(char *,int);\n\n     openlog(\"upperLOWER\", LOG_CONS|LOG_PID, LOG_AUTHPRIV);\n\n#ifdef DEBUG\n     {\n\t  int i;\n\n\t  fprintf(stderr,\"environment :[\\r\\n\");\n\t  for (i=0; environ[i]; ++i) {\n\t       fprintf(stderr,\"-> %s\\r\\n\",environ[i]);\n\t  }\n\t  fprintf(stderr,\"]: end\\r\\n\");\n     }\n#endif\n\n     if (argc != 1) {\n#ifdef DEBUG\n\t  fprintf(stderr,\"filter invoked as conventional executable\\n\");\n#else\n\t  syslog(LOG_ERR, \"filter invoked as conventional executable\");\n#endif\n\t  exit(1);\n     }\n\n     before_user = before_app = do_transpose;   /* assign filter functions */\n\n     /* enter a loop that deals with the input and output of the\n        user.. passing it to and from the application */\n\n     FD_ZERO(&readers);                    /* initialize reading mask */\n\n     for (;;) {\n\n\t  FD_SET(APPOUT_FILENO, &readers);              /* wake for output */\n\t  FD_SET(APPERR_FILENO, &readers);               /* wake for error */\n\t  FD_SET(STDIN_FILENO, &readers);                /* wake for input */\n\n\t  if ( select(APPTOP_FILE,&readers,NULL,NULL,NULL) < 0 ) {\n#ifdef DEBUG\n\t       fprintf(stderr,\"select failed\\n\");\n#else\n\t       syslog(LOG_WARNING,\"select failed\");\n#endif\n\t       break;\n\t  }\n\n\t  /* application errors */\n\n\t  if ( FD_ISSET(APPERR_FILENO,&readers) ) {\n\t       int got = read(APPERR_FILENO, buffer, BUFSIZ);\n\t       if (got <= 0) {\n\t\t    break;\n\t       } else {\n\t\t    /* translate to give to real terminal */\n\t\t    if (before_user != NULL)\n\t\t\t before_user(buffer, got);\n\t\t    if (pam_modutil_write(STDERR_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't write %d bytes?!\",got);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  } else if ( FD_ISSET(APPOUT_FILENO,&readers) ) {    /* app output */\n\t       int got = read(APPOUT_FILENO, buffer, BUFSIZ);\n\t       if (got <= 0) {\n\t\t    break;\n\t       } else {\n\t\t    /* translate to give to real terminal */\n\t\t    if (before_user != NULL)\n\t\t\t before_user(buffer, got);\n\t\t    if (pam_modutil_write(STDOUT_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't write %d bytes!?\",got);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\n\t  if ( FD_ISSET(STDIN_FILENO, &readers) ) {  /* user input */\n\t       int got = read(STDIN_FILENO, buffer, BUFSIZ);\n\t       if (got < 0) {\n\t\t    syslog(LOG_WARNING,\"user input junked\");\n\t\t    break;\n\t       } else if (got) {\n\t\t    /* translate to give to application */\n\t\t    if (before_app != NULL)\n\t\t\t before_app(buffer, got);\n\t\t    if (pam_modutil_write(APPIN_FILENO, buffer, got) != got ) {\n\t\t\t syslog(LOG_WARNING,\"couldn't pass %d bytes!?\",got);\n\t\t\t break;\n\t\t    }\n\t       } else {\n\t\t    /* nothing received -- an error? */\n\t\t    syslog(LOG_WARNING,\"user input null?\");\n\t\t    break;\n\t       }\n\t  }\n     }\n\n     exit(0);\n}"
  },
  {
    "function_name": "do_transpose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_filter/upperLOWER/upperLOWER.c",
    "lines": "23-33",
    "snippet": "static void do_transpose(char *buffer,int len)\n{\n     int i;\n     for (i=0; i<len; ++i) {\n\t  if (islower(buffer[i])) {\n\t       buffer[i] = toupper(buffer[i]);\n\t  } else {\n\t       buffer[i] = tolower(buffer[i]);\n\t  }\n     }\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include \"pam_filter.h\"",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "buffer[i]"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "buffer[i]"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "buffer[i]"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include \"pam_filter.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void do_transpose(char *buffer,int len)\n{\n     int i;\n     for (i=0; i<len; ++i) {\n\t  if (islower(buffer[i])) {\n\t       buffer[i] = toupper(buffer[i]);\n\t  } else {\n\t       buffer[i] = tolower(buffer[i]);\n\t  }\n     }\n}"
  }
]