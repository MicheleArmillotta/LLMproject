[
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
    "lines": "208-213",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
    "lines": "104-206",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, anon=0, ctrl;\n    const char *user;\n    char *anon_user = NULL;\n    const char *users = NULL;\n\n    /*\n     * this module checks if the user name is ftp or anonymous. If\n     * this is the case, it can set the PAM_RUSER to the entered email\n     * address and SUCCEEDS, otherwise it FAILS.\n     */\n\n    ctrl = _pam_parse(pamh, argc, argv, &users);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (!(ctrl & PAM_NO_ANON)) {\n\tanon = lookup(user, users, &anon_user);\n    }\n\n    if (anon) {\n\tretval = pam_set_item(pamh, PAM_USER, (const void *)anon_user);\n\tif (retval != PAM_SUCCESS || anon_user == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"user resetting failed\");\n\t    free(anon_user);\n\n\t    return PAM_USER_UNKNOWN;\n\t}\n\tfree(anon_user);\n    }\n\n    /*\n     * OK. we require an email address for user or the user's password.\n     * - build conversation and get their input.\n     */\n\n    {\n\tchar *resp = NULL;\n\tconst char *token;\n\n\tif (!anon)\n\t  retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &resp,\n\t\t\t       PLEASE_ENTER_PASSWORD, user);\n\telse\n\t  retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &resp,\n\t\t\t       GUEST_LOGIN_PROMPT);\n\n\tif (retval != PAM_SUCCESS) {\n\t    _pam_overwrite (resp);\n\t    _pam_drop (resp);\n\t    return ((retval == PAM_CONV_AGAIN)\n\t\t    ? PAM_INCOMPLETE:PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (anon) {\n\t  /* XXX: Some effort should be made to verify this email address! */\n\n\t    if (!(ctrl & PAM_IGNORE_EMAIL)) {\n\t\tchar *sptr = NULL;\n\t\ttoken = strtok_r(resp, \"@\", &sptr);\n\t\tretval = pam_set_item(pamh, PAM_RUSER, token);\n\n\t\tif ((token) && (retval == PAM_SUCCESS)) {\n\t\t    token = strtok_r(NULL, \"@\", &sptr);\n\t\t    retval = pam_set_item(pamh, PAM_RHOST, token);\n\t\t}\n\t    }\n\n\t    /* we are happy to grant anonymous access to the user */\n\t    retval = PAM_SUCCESS;\n\n\t} else {\n\t    /*\n\t     * we have a password so set AUTHTOK\n\t     */\n\n\t    pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n\t    /*\n\t     * this module failed, but the next one might succeed with\n\t     * this password.\n\t     */\n\n\t    retval = PAM_AUTH_ERR;\n\t}\n\n\t/* clean up */\n\t_pam_overwrite(resp);\n\t_pam_drop(resp);\n\n\t/* success or failure */\n\n\treturn retval;\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_NO_ANON         04",
      "#define PAM_IGNORE_EMAIL    02",
      "#define GUEST_LOGIN_PROMPT \"Guest login ok, \" \\\n\"send your complete e-mail address as password.\"",
      "#define PLEASE_ENTER_PASSWORD \"Password required for %s.\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "resp"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "resp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "resp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "token"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"@\"",
            "&sptr"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_RUSER",
            "token"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "resp",
            "\"@\"",
            "&sptr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "resp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "resp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "PAM_PROMPT_ECHO_OFF",
            "&resp",
            "GUEST_LOGIN_PROMPT"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "PAM_PROMPT_ECHO_OFF",
            "&resp",
            "PLEASE_ENTER_PASSWORD",
            "user"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "anon_user"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"user resetting failed\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_USER",
            "(const void *)anon_user"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup",
          "args": [
            "user",
            "users",
            "&anon_user"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
          "lines": "63-100",
          "snippet": "static int lookup(const char *name, const char *list, char **_user)\n{\n    int anon = 0;\n\n    if (list && *list) {\n\tconst char *l;\n\tchar *list_copy, *x;\n\tchar *sptr = NULL;\n\n\tlist_copy = strdup(list);\n\tx = list_copy;\n\twhile (list_copy && (l = strtok_r(x, \",\", &sptr))) {\n\t    x = NULL;\n\t    if (!strcmp(name, l)) {\n\t\t*_user = list_copy;\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (*_user != list_copy) {\n\t    free(list_copy);\n\t}\n    } else {\n#define MAX_L 2\n\tstatic const char *l[MAX_L] = { \"ftp\", \"anonymous\" };\n\tint i;\n\n\tfor (i=0; i<MAX_L; ++i) {\n\t    if (!strcmp(l[i], name)) {\n\t\t*_user = strdup(l[0]);\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return anon;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_L 2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_L 2\n\nstatic int lookup(const char *name, const char *list, char **_user)\n{\n    int anon = 0;\n\n    if (list && *list) {\n\tconst char *l;\n\tchar *list_copy, *x;\n\tchar *sptr = NULL;\n\n\tlist_copy = strdup(list);\n\tx = list_copy;\n\twhile (list_copy && (l = strtok_r(x, \",\", &sptr))) {\n\t    x = NULL;\n\t    if (!strcmp(name, l)) {\n\t\t*_user = list_copy;\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (*_user != list_copy) {\n\t    free(list_copy);\n\t}\n    } else {\n#define MAX_L 2\n\tstatic const char *l[MAX_L] = { \"ftp\", \"anonymous\" };\n\tint i;\n\n\tfor (i=0; i<MAX_L; ++i) {\n\t    if (!strcmp(l[i], name)) {\n\t\t*_user = strdup(l[0]);\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return anon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&users"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
          "lines": "34-56",
          "snippet": "static int\n_pam_parse(pam_handle_t *pamh, int argc, const char **argv, const char **users)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"ignore\"))\n\t    ctrl |= PAM_IGNORE_EMAIL;\n\telse if ((str = pam_str_skip_prefix(*argv, \"users=\")) != NULL)\n\t    *users = str;\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_IGNORE_EMAIL    02",
            "#define PAM_DEBUG_ARG       01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_IGNORE_EMAIL    02\n#define PAM_DEBUG_ARG       01\n\nstatic int\n_pam_parse(pam_handle_t *pamh, int argc, const char **argv, const char **users)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"ignore\"))\n\t    ctrl |= PAM_IGNORE_EMAIL;\n\telse if ((str = pam_str_skip_prefix(*argv, \"users=\")) != NULL)\n\t    *users = str;\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_NO_ANON         04\n#define PAM_IGNORE_EMAIL    02\n#define GUEST_LOGIN_PROMPT \"Guest login ok, \" \\\n\"send your complete e-mail address as password.\"\n#define PLEASE_ENTER_PASSWORD \"Password required for %s.\"\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, anon=0, ctrl;\n    const char *user;\n    char *anon_user = NULL;\n    const char *users = NULL;\n\n    /*\n     * this module checks if the user name is ftp or anonymous. If\n     * this is the case, it can set the PAM_RUSER to the entered email\n     * address and SUCCEEDS, otherwise it FAILS.\n     */\n\n    ctrl = _pam_parse(pamh, argc, argv, &users);\n\n    retval = pam_get_user(pamh, &user, NULL);\n    if (retval != PAM_SUCCESS) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t   pam_strerror(pamh, retval));\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (!(ctrl & PAM_NO_ANON)) {\n\tanon = lookup(user, users, &anon_user);\n    }\n\n    if (anon) {\n\tretval = pam_set_item(pamh, PAM_USER, (const void *)anon_user);\n\tif (retval != PAM_SUCCESS || anon_user == NULL) {\n\t    pam_syslog(pamh, LOG_ERR, \"user resetting failed\");\n\t    free(anon_user);\n\n\t    return PAM_USER_UNKNOWN;\n\t}\n\tfree(anon_user);\n    }\n\n    /*\n     * OK. we require an email address for user or the user's password.\n     * - build conversation and get their input.\n     */\n\n    {\n\tchar *resp = NULL;\n\tconst char *token;\n\n\tif (!anon)\n\t  retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &resp,\n\t\t\t       PLEASE_ENTER_PASSWORD, user);\n\telse\n\t  retval = pam_prompt (pamh, PAM_PROMPT_ECHO_OFF, &resp,\n\t\t\t       GUEST_LOGIN_PROMPT);\n\n\tif (retval != PAM_SUCCESS) {\n\t    _pam_overwrite (resp);\n\t    _pam_drop (resp);\n\t    return ((retval == PAM_CONV_AGAIN)\n\t\t    ? PAM_INCOMPLETE:PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (anon) {\n\t  /* XXX: Some effort should be made to verify this email address! */\n\n\t    if (!(ctrl & PAM_IGNORE_EMAIL)) {\n\t\tchar *sptr = NULL;\n\t\ttoken = strtok_r(resp, \"@\", &sptr);\n\t\tretval = pam_set_item(pamh, PAM_RUSER, token);\n\n\t\tif ((token) && (retval == PAM_SUCCESS)) {\n\t\t    token = strtok_r(NULL, \"@\", &sptr);\n\t\t    retval = pam_set_item(pamh, PAM_RHOST, token);\n\t\t}\n\t    }\n\n\t    /* we are happy to grant anonymous access to the user */\n\t    retval = PAM_SUCCESS;\n\n\t} else {\n\t    /*\n\t     * we have a password so set AUTHTOK\n\t     */\n\n\t    pam_set_item(pamh, PAM_AUTHTOK, resp);\n\n\t    /*\n\t     * this module failed, but the next one might succeed with\n\t     * this password.\n\t     */\n\n\t    retval = PAM_AUTH_ERR;\n\t}\n\n\t/* clean up */\n\t_pam_overwrite(resp);\n\t_pam_drop(resp);\n\n\t/* success or failure */\n\n\treturn retval;\n    }\n}"
  },
  {
    "function_name": "lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
    "lines": "63-100",
    "snippet": "static int lookup(const char *name, const char *list, char **_user)\n{\n    int anon = 0;\n\n    if (list && *list) {\n\tconst char *l;\n\tchar *list_copy, *x;\n\tchar *sptr = NULL;\n\n\tlist_copy = strdup(list);\n\tx = list_copy;\n\twhile (list_copy && (l = strtok_r(x, \",\", &sptr))) {\n\t    x = NULL;\n\t    if (!strcmp(name, l)) {\n\t\t*_user = list_copy;\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (*_user != list_copy) {\n\t    free(list_copy);\n\t}\n    } else {\n#define MAX_L 2\n\tstatic const char *l[MAX_L] = { \"ftp\", \"anonymous\" };\n\tint i;\n\n\tfor (i=0; i<MAX_L; ++i) {\n\t    if (!strcmp(l[i], name)) {\n\t\t*_user = strdup(l[0]);\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return anon;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_L 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "l[0]"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "l[i]",
            "name"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list_copy"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "l"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "x",
            "\",\"",
            "&sptr"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "list"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_L 2\n\nstatic int lookup(const char *name, const char *list, char **_user)\n{\n    int anon = 0;\n\n    if (list && *list) {\n\tconst char *l;\n\tchar *list_copy, *x;\n\tchar *sptr = NULL;\n\n\tlist_copy = strdup(list);\n\tx = list_copy;\n\twhile (list_copy && (l = strtok_r(x, \",\", &sptr))) {\n\t    x = NULL;\n\t    if (!strcmp(name, l)) {\n\t\t*_user = list_copy;\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (*_user != list_copy) {\n\t    free(list_copy);\n\t}\n    } else {\n#define MAX_L 2\n\tstatic const char *l[MAX_L] = { \"ftp\", \"anonymous\" };\n\tint i;\n\n\tfor (i=0; i<MAX_L; ++i) {\n\t    if (!strcmp(l[i], name)) {\n\t\t*_user = strdup(l[0]);\n\t\tanon = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return anon;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_ftp/pam_ftp.c",
    "lines": "34-56",
    "snippet": "static int\n_pam_parse(pam_handle_t *pamh, int argc, const char **argv, const char **users)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"ignore\"))\n\t    ctrl |= PAM_IGNORE_EMAIL;\n\telse if ((str = pam_str_skip_prefix(*argv, \"users=\")) != NULL)\n\t    *users = str;\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_IGNORE_EMAIL    02",
      "#define PAM_DEBUG_ARG       01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"users=\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"ignore\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define PAM_IGNORE_EMAIL    02\n#define PAM_DEBUG_ARG       01\n\nstatic int\n_pam_parse(pam_handle_t *pamh, int argc, const char **argv, const char **users)\n{\n    int ctrl=0;\n\n    /* step through arguments */\n    for (ctrl=0; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strcmp(*argv,\"ignore\"))\n\t    ctrl |= PAM_IGNORE_EMAIL;\n\telse if ((str = pam_str_skip_prefix(*argv, \"users=\")) != NULL)\n\t    *users = str;\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    return ctrl;\n}"
  }
]