[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
    "lines": "155-164",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return perform_check(pamh, &opts);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh",
            "&opts"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
          "lines": "61-127",
          "snippet": "static int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"",
            "#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"\n#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\"\n\nstatic int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_args",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&opts"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "parse_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
          "lines": "35-55",
          "snippet": "static void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return perform_check(pamh, &opts);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
    "lines": "142-151",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return opts.retval_when_nofile;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_args",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&opts"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "parse_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
          "lines": "35-55",
          "snippet": "static void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return opts.retval_when_nofile;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
    "lines": "131-140",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return perform_check(pamh, &opts);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_check",
          "args": [
            "pamh",
            "&opts"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "perform_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
          "lines": "61-127",
          "snippet": "static int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"",
            "#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"\n#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\"\n\nstatic int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_args",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&opts"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "parse_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
          "lines": "35-55",
          "snippet": "static void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    struct opt_s opts;\n\n    parse_args(pamh, argc, argv, &opts);\n\n    return perform_check(pamh, &opts);\n}"
  },
  {
    "function_name": "perform_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
    "lines": "61-127",
    "snippet": "static int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"",
      "#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mtmp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "msg_style",
            "NULL",
            "\"%s\"",
            "mtmp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "mtmp",
            "st.st_size"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size+1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "opts->nologin_file",
            "O_RDONLY",
            "0"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define COMPAT_NOLOGIN_PATH \"/etc/nologin\"\n#define DEFAULT_NOLOGIN_PATH \"/var/run/nologin\"\n\nstatic int perform_check(pam_handle_t *pamh, struct opt_s *opts)\n{\n    const char *username;\n    int retval = opts->retval_when_nofile;\n    int fd = -1;\n\n    if ((pam_get_user(pamh, &username, NULL) != PAM_SUCCESS)) {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    if (opts->nologin_file == NULL) {\n\tif ((fd = open(DEFAULT_NOLOGIN_PATH, O_RDONLY, 0)) < 0) {\n\t\tfd = open(COMPAT_NOLOGIN_PATH, O_RDONLY, 0);\n\t}\n    } else {\n\tfd = open(opts->nologin_file, O_RDONLY, 0);\n    }\n\n    if (fd >= 0) {\n\n\tint msg_style = PAM_TEXT_INFO;\n\tstruct passwd *user_pwd;\n\tstruct stat st;\n\n\tuser_pwd = pam_modutil_getpwnam(pamh, username);\n\tif (user_pwd == NULL) {\n\t    retval = PAM_USER_UNKNOWN;\n\t    msg_style = PAM_ERROR_MSG;\n\t} else if (user_pwd->pw_uid) {\n\t    retval = PAM_AUTH_ERR;\n\t    msg_style = PAM_ERROR_MSG;\n\t}\n\n\t/* fill in message buffer with contents of /etc/nologin */\n\tif (fstat(fd, &st) < 0)  {\n\t    /* give up trying to display message */\n\t    goto clean_up_fd;\n\t}\n\n\t/* Don't print anything if the message is empty, will only\n\t   disturb the output with empty lines */\n\tif (st.st_size > 0) {\n\t    char *mtmp = malloc(st.st_size+1);\n\t    if (!mtmp) {\n\t        pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t        retval = PAM_BUF_ERR;\n\t        goto clean_up_fd;\n\t    }\n\n\t    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\t        mtmp[st.st_size] = '\\0';\n\t        (void) pam_prompt (pamh, msg_style, NULL, \"%s\", mtmp);\n\t    }\n\t    else\n\t        retval = PAM_SYSTEM_ERR;\n\n\t    free(mtmp);\n\t}\n\n    clean_up_fd:\n\n\tclose(fd);\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "parse_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_nologin/pam_nologin.c",
    "lines": "35-55",
    "snippet": "static void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <pwd.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "argv[i]"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"file=\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"successok\"",
            "argv[i]"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "opts",
            "0",
            "sizeof(*opts)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nparse_args(pam_handle_t *pamh, int argc, const char **argv, struct opt_s *opts)\n{\n    int i;\n\n    memset(opts, 0, sizeof(*opts));\n\n    opts->retval_when_nofile = PAM_IGNORE;\n\n    for (i=0; i<argc; ++i) {\n\tconst char *str;\n\n\tif (!strcmp(\"successok\", argv[i])) {\n\t    opts->retval_when_nofile = PAM_SUCCESS;\n\t} else if ((str = pam_str_skip_prefix(argv[i], \"file=\")) != NULL) {\n\t    opts->nologin_file = str;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", argv[i]);\n\t}\n    }\n}"
  }
]