[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "252-260",
    "snippet": "int\npam_sm_chauthtok (pam_handle_t *pamh, int flags, int argc,\n\t\t  const char **argv)\n{\n  if (flags & PAM_PRELIM_CHECK)\n    return pam_echo (pamh, flags, argc, argv);\n  else\n    return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_echo",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "pam_echo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
          "lines": "135-215",
          "snippet": "static int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_chauthtok (pam_handle_t *pamh, int flags, int argc,\n\t\t  const char **argv)\n{\n  if (flags & PAM_PRELIM_CHECK)\n    return pam_echo (pamh, flags, argc, argv);\n  else\n    return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "245-250",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "238-243",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc,\n\t\t     const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_echo",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "pam_echo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
          "lines": "135-215",
          "snippet": "static int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc,\n\t\t     const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "231-236",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags, int argc,\n\t\t  const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_echo",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "pam_echo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
          "lines": "135-215",
          "snippet": "static int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags, int argc,\n\t\t  const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "224-229",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "217-222",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags, int argc,\n                     const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_echo",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "pam_echo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
          "lines": "135-215",
          "snippet": "static int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags, int argc,\n                     const char **argv)\n{\n  return pam_echo (pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_echo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "135-215",
    "snippet": "static int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open %s: %m\"",
            "file"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mtmp"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_and_print",
          "args": [
            "pamh",
            "mtmp"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "replace_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
          "lines": "61-133",
          "snippet": "static int\nreplace_and_print (pam_handle_t *pamh, const char *mesg)\n{\n  char *output;\n  size_t length = strlen (mesg) + PAM_MAX_MSG_SIZE;\n  char myhostname[HOST_NAME_MAX+1];\n  const void *str = NULL;\n  const char *p, *q;\n  int item;\n  size_t len;\n\n  output = malloc (length);\n  if (output == NULL)\n    {\n      pam_syslog (pamh, LOG_CRIT, \"running out of memory\");\n      return PAM_BUF_ERR;\n    }\n\n  for (p = mesg, len = 0; *p != '\\0' && len < length - 1; ++p)\n    {\n      if (*p != '%' || p[1] == '\\0')\n\t{\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      switch (*++p)\n\t{\n\tcase 'H':\n\t  item = PAM_RHOST;\n\t  break;\n\tcase 'h':\n\t  item = -2; /* aka PAM_LOCALHOST */\n\t  break;\n\tcase 's':\n\t  item = PAM_SERVICE;\n\t  break;\n\tcase 't':\n\t  item = PAM_TTY;\n\t  break;\n\tcase 'U':\n\t  item = PAM_RUSER;\n\t  break;\n\tcase 'u':\n\t  item = PAM_USER;\n\t  break;\n\tdefault:\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      if (item == -2)\n\t{\n\t  if (gethostname (myhostname, sizeof (myhostname)) == -1)\n\t    str = NULL;\n\t  else\n\t    str = &myhostname;\n\t}\n      else\n\t{\n\t  if (pam_get_item (pamh, item, &str) != PAM_SUCCESS)\n\t    str = NULL;\n\t}\n      if (str == NULL)\n\tstr = \"(null)\";\n      for (q = str; *q != '\\0' && len < length - 1; ++q)\n\toutput[len++] = *q;\n    }\n  output[len] = '\\0';\n\n  pam_info (pamh, \"%s\", output);\n  free (output);\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define HOST_NAME_MAX 255"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define HOST_NAME_MAX 255\n\nstatic int\nreplace_and_print (pam_handle_t *pamh, const char *mesg)\n{\n  char *output;\n  size_t length = strlen (mesg) + PAM_MAX_MSG_SIZE;\n  char myhostname[HOST_NAME_MAX+1];\n  const void *str = NULL;\n  const char *p, *q;\n  int item;\n  size_t len;\n\n  output = malloc (length);\n  if (output == NULL)\n    {\n      pam_syslog (pamh, LOG_CRIT, \"running out of memory\");\n      return PAM_BUF_ERR;\n    }\n\n  for (p = mesg, len = 0; *p != '\\0' && len < length - 1; ++p)\n    {\n      if (*p != '%' || p[1] == '\\0')\n\t{\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      switch (*++p)\n\t{\n\tcase 'H':\n\t  item = PAM_RHOST;\n\t  break;\n\tcase 'h':\n\t  item = -2; /* aka PAM_LOCALHOST */\n\t  break;\n\tcase 's':\n\t  item = PAM_SERVICE;\n\t  break;\n\tcase 't':\n\t  item = PAM_TTY;\n\t  break;\n\tcase 'U':\n\t  item = PAM_RUSER;\n\t  break;\n\tcase 'u':\n\t  item = PAM_USER;\n\t  break;\n\tdefault:\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      if (item == -2)\n\t{\n\t  if (gethostname (myhostname, sizeof (myhostname)) == -1)\n\t    str = NULL;\n\t  else\n\t    str = &myhostname;\n\t}\n      else\n\t{\n\t  if (pam_get_item (pamh, item, &str) != PAM_SUCCESS)\n\t    str = NULL;\n\t}\n      if (str == NULL)\n\tstr = \"(null)\";\n      for (q = str; *q != '\\0' && len < length - 1; ++q)\n\toutput[len++] = *q;\n    }\n  output[len] = '\\0';\n\n  pam_info (pamh, \"%s\", output);\n  free (output);\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error while reading %s: %m\"",
            "file"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "mtmp",
            "st.st_size"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size + 1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file",
            "O_RDONLY",
            "0"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"file=\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\npam_echo (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  int fd;\n  int orig_argc = argc;\n  const char **orig_argv = argv;\n  const char *file = NULL;\n  int retval;\n\n  if (flags & PAM_SILENT)\n    return PAM_IGNORE;\n\n  for (; argc-- > 0; ++argv)\n    {\n      const char *str = pam_str_skip_prefix(*argv, \"file=\");\n      if (str != NULL)\n\tfile = str;\n    }\n\n  /* No file= option, use argument for output.  */\n  if (file == NULL || file[0] == '\\0')\n    {\n      char msg[PAM_MAX_MSG_SIZE];\n      const char *p;\n      int i;\n      size_t len;\n\n      for (i = 0, len = 0; i < orig_argc && len < sizeof (msg) - 1; ++i)\n\t{\n\t  if (i > 0)\n\t    msg[len++] = ' ';\n\t  for (p = orig_argv[i]; *p != '\\0' && len < sizeof(msg) - 1; ++p)\n\t    msg[len++] = *p;\n\t}\n      msg[len] = '\\0';\n\n      retval = replace_and_print (pamh, msg);\n    }\n  else if ((fd = open (file, O_RDONLY, 0)) >= 0)\n    {\n      char *mtmp = NULL;\n      struct stat st;\n\n      /* load file into message buffer. */\n      if ((fstat (fd, &st) < 0) || !st.st_size)\n\t{\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      mtmp = malloc (st.st_size + 1);\n      if (!mtmp)\n\t{\n\t  close (fd);\n\t  return PAM_BUF_ERR;\n\t}\n\n      if (pam_modutil_read (fd, mtmp, st.st_size) == -1)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"Error while reading %s: %m\", file);\n\t  free (mtmp);\n\t  close (fd);\n\t  return PAM_IGNORE;\n\t}\n\n      if (mtmp[st.st_size - 1] == '\\n')\n\tmtmp[st.st_size - 1] = '\\0';\n      else\n\tmtmp[st.st_size] = '\\0';\n\n      close (fd);\n      retval = replace_and_print (pamh, mtmp);\n      free (mtmp);\n    }\n  else\n    {\n       pam_syslog (pamh, LOG_ERR, \"Cannot open %s: %m\", file);\n       retval = PAM_IGNORE;\n    }\n  return retval;\n}"
  },
  {
    "function_name": "replace_and_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_echo/pam_echo.c",
    "lines": "61-133",
    "snippet": "static int\nreplace_and_print (pam_handle_t *pamh, const char *mesg)\n{\n  char *output;\n  size_t length = strlen (mesg) + PAM_MAX_MSG_SIZE;\n  char myhostname[HOST_NAME_MAX+1];\n  const void *str = NULL;\n  const char *p, *q;\n  int item;\n  size_t len;\n\n  output = malloc (length);\n  if (output == NULL)\n    {\n      pam_syslog (pamh, LOG_CRIT, \"running out of memory\");\n      return PAM_BUF_ERR;\n    }\n\n  for (p = mesg, len = 0; *p != '\\0' && len < length - 1; ++p)\n    {\n      if (*p != '%' || p[1] == '\\0')\n\t{\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      switch (*++p)\n\t{\n\tcase 'H':\n\t  item = PAM_RHOST;\n\t  break;\n\tcase 'h':\n\t  item = -2; /* aka PAM_LOCALHOST */\n\t  break;\n\tcase 's':\n\t  item = PAM_SERVICE;\n\t  break;\n\tcase 't':\n\t  item = PAM_TTY;\n\t  break;\n\tcase 'U':\n\t  item = PAM_RUSER;\n\t  break;\n\tcase 'u':\n\t  item = PAM_USER;\n\t  break;\n\tdefault:\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      if (item == -2)\n\t{\n\t  if (gethostname (myhostname, sizeof (myhostname)) == -1)\n\t    str = NULL;\n\t  else\n\t    str = &myhostname;\n\t}\n      else\n\t{\n\t  if (pam_get_item (pamh, item, &str) != PAM_SUCCESS)\n\t    str = NULL;\n\t}\n      if (str == NULL)\n\tstr = \"(null)\";\n      for (q = str; *q != '\\0' && len < length - 1; ++q)\n\toutput[len++] = *q;\n    }\n  output[len] = '\\0';\n\n  pam_info (pamh, \"%s\", output);\n  free (output);\n\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define HOST_NAME_MAX 255"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "output"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "output"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "item",
            "&str"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "myhostname",
            "sizeof (myhostname)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"running out of memory\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "length"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mesg"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define HOST_NAME_MAX 255\n\nstatic int\nreplace_and_print (pam_handle_t *pamh, const char *mesg)\n{\n  char *output;\n  size_t length = strlen (mesg) + PAM_MAX_MSG_SIZE;\n  char myhostname[HOST_NAME_MAX+1];\n  const void *str = NULL;\n  const char *p, *q;\n  int item;\n  size_t len;\n\n  output = malloc (length);\n  if (output == NULL)\n    {\n      pam_syslog (pamh, LOG_CRIT, \"running out of memory\");\n      return PAM_BUF_ERR;\n    }\n\n  for (p = mesg, len = 0; *p != '\\0' && len < length - 1; ++p)\n    {\n      if (*p != '%' || p[1] == '\\0')\n\t{\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      switch (*++p)\n\t{\n\tcase 'H':\n\t  item = PAM_RHOST;\n\t  break;\n\tcase 'h':\n\t  item = -2; /* aka PAM_LOCALHOST */\n\t  break;\n\tcase 's':\n\t  item = PAM_SERVICE;\n\t  break;\n\tcase 't':\n\t  item = PAM_TTY;\n\t  break;\n\tcase 'U':\n\t  item = PAM_RUSER;\n\t  break;\n\tcase 'u':\n\t  item = PAM_USER;\n\t  break;\n\tdefault:\n\t  output[len++] = *p;\n\t  continue;\n\t}\n      if (item == -2)\n\t{\n\t  if (gethostname (myhostname, sizeof (myhostname)) == -1)\n\t    str = NULL;\n\t  else\n\t    str = &myhostname;\n\t}\n      else\n\t{\n\t  if (pam_get_item (pamh, item, &str) != PAM_SUCCESS)\n\t    str = NULL;\n\t}\n      if (str == NULL)\n\tstr = \"(null)\";\n      for (q = str; *q != '\\0' && len < length - 1; ++q)\n\toutput[len++] = *q;\n    }\n  output[len] = '\\0';\n\n  pam_info (pamh, \"%s\", output);\n  free (output);\n\n  return PAM_SUCCESS;\n}"
  }
]