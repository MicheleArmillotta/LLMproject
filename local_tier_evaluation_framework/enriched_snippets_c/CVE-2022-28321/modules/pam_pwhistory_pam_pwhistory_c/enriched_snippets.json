[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
    "lines": "301-403",
    "snippet": "int\npam_sm_chauthtok (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  const char *newpass;\n  const char *user;\n    int retval, tries;\n  options_t options;\n\n  memset (&options, 0, sizeof (options));\n\n  /* Set some default values, which could be overwritten later.  */\n  options.remember = 10;\n  options.tries = 1;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, &options);\n\n  if (options.debug)\n    pam_syslog (pamh, LOG_DEBUG, \"pam_sm_chauthtok entered\");\n\n\n  if (options.remember == 0)\n    return PAM_IGNORE;\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    return retval;\n\n  if (flags & PAM_PRELIM_CHECK)\n    {\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG,\n\t\t    \"pam_sm_chauthtok(PAM_PRELIM_CHECK)\");\n\n      return PAM_SUCCESS;\n    }\n\n  retval = save_old_pass (pamh, user, options.remember, options.filename, options.debug);\n\n  if (retval == PAM_PWHISTORY_RUN_HELPER)\n      retval = run_save_helper(pamh, user, options.remember, options.filename, options.debug);\n\n  if (retval != PAM_SUCCESS)\n    return retval;\n\n  newpass = NULL;\n  tries = 0;\n  while ((newpass == NULL) && (tries < options.tries))\n    {\n      retval = pam_get_authtok (pamh, PAM_AUTHTOK, &newpass, NULL);\n      if (retval != PAM_SUCCESS && retval != PAM_TRY_AGAIN)\n\t{\n\t  if (retval == PAM_CONV_AGAIN)\n\t    retval = PAM_INCOMPLETE;\n\t  return retval;\n\t}\n      tries++;\n\n      if (options.debug)\n\t{\n\t  if (newpass)\n\t    pam_syslog (pamh, LOG_DEBUG, \"got new auth token\");\n\t  else\n\t    pam_syslog (pamh, LOG_DEBUG, \"got no auth token\");\n\t}\n\n      if (newpass == NULL || retval == PAM_TRY_AGAIN)\n\tcontinue;\n\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"check against old password file\");\n\n      retval = check_old_pass (pamh, user, newpass, options.filename, options.debug);\n      if (retval == PAM_PWHISTORY_RUN_HELPER)\n\t  retval = run_check_helper(pamh, user, newpass, options.filename, options.debug);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  if (getuid() || options.enforce_for_root ||\n\t      (flags & PAM_CHANGE_EXPIRED_AUTHTOK))\n\t    {\n\t      pam_error (pamh,\n\t\t         _(\"Password has been already used. Choose another.\"));\n\t      newpass = NULL;\n\t      /* Remove password item, else following module will use it */\n\t      pam_set_item (pamh, PAM_AUTHTOK, (void *) NULL);\n\t    }\n\t  else\n\t    pam_info (pamh,\n\t\t       _(\"Password has been already used.\"));\n\t}\n    }\n\n  if (newpass == NULL && tries >= options.tries)\n    {\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Aborted, too many tries\");\n      return PAM_MAXTRIES;\n    }\n\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Aborted, too many tries\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Password has been already used.\")"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Password has been already used.\""
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "get_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "406-412",
          "snippet": "static const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DATANAME \"pam_selinux_context\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_selinux_context\"\n\nstatic const module_data_t *\nget_module_data(const pam_handle_t *pamh)\n{\n  const void *data;\n\n  return (pam_get_data(pamh, DATANAME, &data) == PAM_SUCCESS) ? data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "(void *) NULL"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "_(\"Password has been already used. Choose another.\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_check_helper",
          "args": [
            "pamh",
            "user",
            "newpass",
            "options.filename",
            "options.debug"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "run_check_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
          "lines": "198-296",
          "snippet": "static int\nrun_check_helper(pam_handle_t *pamh, const char *user,\n\t\t const char *newpass, const char *filename, int debug)\n{\n  int retval, child, fds[2];\n  struct sigaction newsa, oldsa;\n\n  /* create a pipe for the password */\n  if (pipe(fds) != 0)\n    return PAM_SYSTEM_ERR;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n      /* reopen stdin as pipe */\n      if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO)\n        {\n          pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"check\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      if (newpass == NULL)\n        newpass = \"\";\n\n      /* send the password to the child */\n      if (write(fds[1], newpass, strlen(newpass)+1) == -1)\n        {\n          pam_syslog(pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      newpass = NULL;\n      close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n      close(fds[1]);\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      close(fds[0]);\n      close(fds[1]);\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"opasswd.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic int\nrun_check_helper(pam_handle_t *pamh, const char *user,\n\t\t const char *newpass, const char *filename, int debug)\n{\n  int retval, child, fds[2];\n  struct sigaction newsa, oldsa;\n\n  /* create a pipe for the password */\n  if (pipe(fds) != 0)\n    return PAM_SYSTEM_ERR;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n      /* reopen stdin as pipe */\n      if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO)\n        {\n          pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"check\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      if (newpass == NULL)\n        newpass = \"\";\n\n      /* send the password to the child */\n      if (write(fds[1], newpass, strlen(newpass)+1) == -1)\n        {\n          pam_syslog(pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      newpass = NULL;\n      close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n      close(fds[1]);\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      close(fds[0]);\n      close(fds[1]);\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_old_pass",
          "args": [
            "pamh",
            "user",
            "newpass",
            "options.filename",
            "options.debug"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"check against old password file\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"got no auth token\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"got new auth token\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_authtok",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&newpass",
            "NULL"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_save_helper",
          "args": [
            "pamh",
            "user",
            "options.remember",
            "options.filename",
            "options.debug"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "run_save_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
          "lines": "122-196",
          "snippet": "static int\nrun_save_helper(pam_handle_t *pamh, const char *user,\n\t\tint howmany, const char *filename, int debug)\n{\n  int retval, child;\n  struct sigaction newsa, oldsa;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"save\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", howmany) < 0 ||\n          asprintf(&args[5], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"opasswd.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic int\nrun_save_helper(pam_handle_t *pamh, const char *user,\n\t\tint howmany, const char *filename, int debug)\n{\n  int retval, child;\n  struct sigaction newsa, oldsa;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"save\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", howmany) < 0 ||\n          asprintf(&args[5], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_old_pass",
          "args": [
            "pamh",
            "user",
            "options.remember",
            "options.filename",
            "options.debug"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok(PAM_PRELIM_CHECK)\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok entered\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_option",
          "args": [
            "pamh",
            "*argv",
            "&options"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "parse_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
          "lines": "77-120",
          "snippet": "static void\nparse_option (pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (strcasecmp (argv, \"try_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_authtok\") == 0)\n    /* ignore, handled by pam_get_authtok */;\n  else if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix(argv, \"remember=\")) != NULL)\n    {\n      options->remember = strtol(str, NULL, 10);\n      if (options->remember < 0)\n        options->remember = 0;\n      if (options->remember > 400)\n        options->remember = 400;\n    }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"retry=\")) != NULL)\n    {\n      options->tries = strtol(str, NULL, 10);\n      if (options->tries < 0)\n        options->tries = 1;\n    }\n  else if (strcasecmp (argv, \"enforce_for_root\") == 0)\n    options->enforce_for_root = 1;\n  else if (pam_str_skip_icase_prefix(argv, \"authtok_type=\") != NULL)\n    { /* ignore, for pam_get_authtok */; }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"file=\")) != NULL)\n    {\n      if (*str != '/')\n        {\n          pam_syslog (pamh, LOG_ERR,\n                      \"pam_pwhistory: file path should be absolute: %s\", argv);\n        }\n      else\n        options->filename = str;\n    }\n  else\n    pam_syslog (pamh, LOG_ERR, \"pam_pwhistory: unknown option: %s\", argv);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"opasswd.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic void\nparse_option (pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (strcasecmp (argv, \"try_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_authtok\") == 0)\n    /* ignore, handled by pam_get_authtok */;\n  else if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix(argv, \"remember=\")) != NULL)\n    {\n      options->remember = strtol(str, NULL, 10);\n      if (options->remember < 0)\n        options->remember = 0;\n      if (options->remember > 400)\n        options->remember = 400;\n    }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"retry=\")) != NULL)\n    {\n      options->tries = strtol(str, NULL, 10);\n      if (options->tries < 0)\n        options->tries = 1;\n    }\n  else if (strcasecmp (argv, \"enforce_for_root\") == 0)\n    options->enforce_for_root = 1;\n  else if (pam_str_skip_icase_prefix(argv, \"authtok_type=\") != NULL)\n    { /* ignore, for pam_get_authtok */; }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"file=\")) != NULL)\n    {\n      if (*str != '/')\n        {\n          pam_syslog (pamh, LOG_ERR,\n                      \"pam_pwhistory: file path should be absolute: %s\", argv);\n        }\n      else\n        options->filename = str;\n    }\n  else\n    pam_syslog (pamh, LOG_ERR, \"pam_pwhistory: unknown option: %s\", argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&options",
            "0",
            "sizeof (options)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nint\npam_sm_chauthtok (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  const char *newpass;\n  const char *user;\n    int retval, tries;\n  options_t options;\n\n  memset (&options, 0, sizeof (options));\n\n  /* Set some default values, which could be overwritten later.  */\n  options.remember = 10;\n  options.tries = 1;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, &options);\n\n  if (options.debug)\n    pam_syslog (pamh, LOG_DEBUG, \"pam_sm_chauthtok entered\");\n\n\n  if (options.remember == 0)\n    return PAM_IGNORE;\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    return retval;\n\n  if (flags & PAM_PRELIM_CHECK)\n    {\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG,\n\t\t    \"pam_sm_chauthtok(PAM_PRELIM_CHECK)\");\n\n      return PAM_SUCCESS;\n    }\n\n  retval = save_old_pass (pamh, user, options.remember, options.filename, options.debug);\n\n  if (retval == PAM_PWHISTORY_RUN_HELPER)\n      retval = run_save_helper(pamh, user, options.remember, options.filename, options.debug);\n\n  if (retval != PAM_SUCCESS)\n    return retval;\n\n  newpass = NULL;\n  tries = 0;\n  while ((newpass == NULL) && (tries < options.tries))\n    {\n      retval = pam_get_authtok (pamh, PAM_AUTHTOK, &newpass, NULL);\n      if (retval != PAM_SUCCESS && retval != PAM_TRY_AGAIN)\n\t{\n\t  if (retval == PAM_CONV_AGAIN)\n\t    retval = PAM_INCOMPLETE;\n\t  return retval;\n\t}\n      tries++;\n\n      if (options.debug)\n\t{\n\t  if (newpass)\n\t    pam_syslog (pamh, LOG_DEBUG, \"got new auth token\");\n\t  else\n\t    pam_syslog (pamh, LOG_DEBUG, \"got no auth token\");\n\t}\n\n      if (newpass == NULL || retval == PAM_TRY_AGAIN)\n\tcontinue;\n\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"check against old password file\");\n\n      retval = check_old_pass (pamh, user, newpass, options.filename, options.debug);\n      if (retval == PAM_PWHISTORY_RUN_HELPER)\n\t  retval = run_check_helper(pamh, user, newpass, options.filename, options.debug);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  if (getuid() || options.enforce_for_root ||\n\t      (flags & PAM_CHANGE_EXPIRED_AUTHTOK))\n\t    {\n\t      pam_error (pamh,\n\t\t         _(\"Password has been already used. Choose another.\"));\n\t      newpass = NULL;\n\t      /* Remove password item, else following module will use it */\n\t      pam_set_item (pamh, PAM_AUTHTOK, (void *) NULL);\n\t    }\n\t  else\n\t    pam_info (pamh,\n\t\t       _(\"Password has been already used.\"));\n\t}\n    }\n\n  if (newpass == NULL && tries >= options.tries)\n    {\n      if (options.debug)\n\tpam_syslog (pamh, LOG_DEBUG, \"Aborted, too many tries\");\n      return PAM_MAXTRIES;\n    }\n\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "run_check_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
    "lines": "198-296",
    "snippet": "static int\nrun_check_helper(pam_handle_t *pamh, const char *user,\n\t\t const char *newpass, const char *filename, int debug)\n{\n  int retval, child, fds[2];\n  struct sigaction newsa, oldsa;\n\n  /* create a pipe for the password */\n  if (pipe(fds) != 0)\n    return PAM_SYSTEM_ERR;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n      /* reopen stdin as pipe */\n      if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO)\n        {\n          pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"check\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      if (newpass == NULL)\n        newpass = \"\";\n\n      /* send the password to the child */\n      if (write(fds[1], newpass, strlen(newpass)+1) == -1)\n        {\n          pam_syslog(pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      newpass = NULL;\n      close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n      close(fds[1]);\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      close(fds[0]);\n      close(fds[1]);\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"fork failed: %m\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pwhistory_helper check abnormal exit: %d\"",
            "retval"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pwhistory_helper check: waitpid: %m\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot send password to helper: %m\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds[1]",
            "newpass",
            "strlen(newpass)+1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newpass"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"helper binary execve failed: %s: %m\"",
            "args[0]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "args[0]",
            "args",
            "envp"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"asprintf: %m\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&args[4]",
            "\"%d\"",
            "debug"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdin\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fds[0]",
            "STDIN_FILENO"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic int\nrun_check_helper(pam_handle_t *pamh, const char *user,\n\t\t const char *newpass, const char *filename, int debug)\n{\n  int retval, child, fds[2];\n  struct sigaction newsa, oldsa;\n\n  /* create a pipe for the password */\n  if (pipe(fds) != 0)\n    return PAM_SYSTEM_ERR;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n\n      /* reopen stdin as pipe */\n      if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO)\n        {\n          pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"check\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      if (newpass == NULL)\n        newpass = \"\";\n\n      /* send the password to the child */\n      if (write(fds[1], newpass, strlen(newpass)+1) == -1)\n        {\n          pam_syslog(pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      newpass = NULL;\n      close(fds[0]);       /* close here to avoid possible SIGPIPE above */\n      close(fds[1]);\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper check abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      close(fds[0]);\n      close(fds[1]);\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}"
  },
  {
    "function_name": "run_save_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
    "lines": "122-196",
    "snippet": "static int\nrun_save_helper(pam_handle_t *pamh, const char *user,\n\t\tint howmany, const char *filename, int debug)\n{\n  int retval, child;\n  struct sigaction newsa, oldsa;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"save\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", howmany) < 0 ||\n          asprintf(&args[5], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"fork failed: %m\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pwhistory_helper save abnormal exit: %d\"",
            "retval"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pwhistory_helper save: waitpid: %m\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"helper binary execve failed: %s: %m\"",
            "args[0]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "args[0]",
            "args",
            "envp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"asprintf: %m\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&args[5]",
            "\"%d\"",
            "debug"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&args[4]",
            "\"%d\"",
            "howmany"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_SYSTEM_ERR"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic int\nrun_save_helper(pam_handle_t *pamh, const char *user,\n\t\tint howmany, const char *filename, int debug)\n{\n  int retval, child;\n  struct sigaction newsa, oldsa;\n\n  memset(&newsa, '\\0', sizeof(newsa));\n  newsa.sa_handler = SIG_DFL;\n  sigaction(SIGCHLD, &newsa, &oldsa);\n\n  child = fork();\n  if (child == 0)\n    {\n      static char *envp[] = { NULL };\n      char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n      if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD,\n          PAM_MODUTIL_PIPE_FD) < 0)\n        {\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      /* exec binary helper */\n      DIAG_PUSH_IGNORE_CAST_QUAL;\n      args[0] = (char *)PWHISTORY_HELPER;\n      args[1] = (char *)\"save\";\n      args[2] = (char *)user;\n      args[3] = (char *)filename;\n      DIAG_POP_IGNORE_CAST_QUAL;\n      if (asprintf(&args[4], \"%d\", howmany) < 0 ||\n          asprintf(&args[5], \"%d\", debug) < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"asprintf: %m\");\n          _exit(PAM_SYSTEM_ERR);\n        }\n\n      execve(args[0], args, envp);\n\n      pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %s: %m\", args[0]);\n\n      _exit(PAM_SYSTEM_ERR);\n    }\n  else if (child > 0)\n    {\n      /* wait for child */\n      int rc = 0;\n      while ((rc = waitpid (child, &retval, 0)) == -1 &&\n              errno == EINTR);\n      if (rc < 0)\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save: waitpid: %m\");\n          retval = PAM_SYSTEM_ERR;\n        }\n      else if (!WIFEXITED(retval))\n        {\n          pam_syslog(pamh, LOG_ERR, \"pwhistory_helper save abnormal exit: %d\", retval);\n          retval = PAM_SYSTEM_ERR;\n        }\n      else\n        {\n          retval = WEXITSTATUS(retval);\n        }\n    }\n  else\n    {\n      pam_syslog(pamh, LOG_ERR, \"fork failed: %m\");\n      retval = PAM_SYSTEM_ERR;\n    }\n\n  sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n\n  return retval;\n}"
  },
  {
    "function_name": "parse_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/pam_pwhistory.c",
    "lines": "77-120",
    "snippet": "static void\nparse_option (pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (strcasecmp (argv, \"try_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_authtok\") == 0)\n    /* ignore, handled by pam_get_authtok */;\n  else if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix(argv, \"remember=\")) != NULL)\n    {\n      options->remember = strtol(str, NULL, 10);\n      if (options->remember < 0)\n        options->remember = 0;\n      if (options->remember > 400)\n        options->remember = 400;\n    }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"retry=\")) != NULL)\n    {\n      options->tries = strtol(str, NULL, 10);\n      if (options->tries < 0)\n        options->tries = 1;\n    }\n  else if (strcasecmp (argv, \"enforce_for_root\") == 0)\n    options->enforce_for_root = 1;\n  else if (pam_str_skip_icase_prefix(argv, \"authtok_type=\") != NULL)\n    { /* ignore, for pam_get_authtok */; }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"file=\")) != NULL)\n    {\n      if (*str != '/')\n        {\n          pam_syslog (pamh, LOG_ERR,\n                      \"pam_pwhistory: file path should be absolute: %s\", argv);\n        }\n      else\n        options->filename = str;\n    }\n  else\n    pam_syslog (pamh, LOG_ERR, \"pam_pwhistory: unknown option: %s\", argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"opasswd.h\"",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_pwhistory: unknown option: %s\"",
            "argv"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_pwhistory: file path should be absolute: %s\"",
            "argv"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv",
            "\"file=\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv",
            "\"authtok_type=\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"enforce_for_root\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv",
            "\"retry=\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv",
            "\"remember=\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"debug\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"use_authtok\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"use_first_pass\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"try_first_pass\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"opasswd.h\"\n#include <security/_pam_macros.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic void\nparse_option (pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (strcasecmp (argv, \"try_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_first_pass\") == 0)\n    /* ignore */;\n  else if (strcasecmp (argv, \"use_authtok\") == 0)\n    /* ignore, handled by pam_get_authtok */;\n  else if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix(argv, \"remember=\")) != NULL)\n    {\n      options->remember = strtol(str, NULL, 10);\n      if (options->remember < 0)\n        options->remember = 0;\n      if (options->remember > 400)\n        options->remember = 400;\n    }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"retry=\")) != NULL)\n    {\n      options->tries = strtol(str, NULL, 10);\n      if (options->tries < 0)\n        options->tries = 1;\n    }\n  else if (strcasecmp (argv, \"enforce_for_root\") == 0)\n    options->enforce_for_root = 1;\n  else if (pam_str_skip_icase_prefix(argv, \"authtok_type=\") != NULL)\n    { /* ignore, for pam_get_authtok */; }\n  else if ((str = pam_str_skip_icase_prefix(argv, \"file=\")) != NULL)\n    {\n      if (*str != '/')\n        {\n          pam_syslog (pamh, LOG_ERR,\n                      \"pam_pwhistory: file path should be absolute: %s\", argv);\n        }\n      else\n        options->filename = str;\n    }\n  else\n    pam_syslog (pamh, LOG_ERR, \"pam_pwhistory: unknown option: %s\", argv);\n}"
  }
]