[
  {
    "function_name": "_unix_verify_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "819-854",
    "snippet": "int\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_shadow_expiry",
          "args": [
            "pamh",
            "spent",
            "daysleft"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_BROKEN_SHADOW",
            "ctrl"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unix_run_verify_binary",
          "args": [
            "pamh",
            "ctrl",
            "name",
            "daysleft"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_run_verify_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_acct.c",
          "lines": "64-179",
          "snippet": "int _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}",
          "includes": [
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"could not identify user (from getpwnam(%s))\"",
            "name"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_account_info",
          "args": [
            "pamh",
            "name",
            "&pwent",
            "&spent"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}"
  },
  {
    "function_name": "_unix_verify_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "661-817",
    "snippet": "int _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define UNIX_MAX_RETRIES              3",
      "#define FAIL_PREFIX                   \"-UN*X-FAIL-\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"done [%d].\", retval)"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "salt"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "data_name"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pw",
            "0",
            "sizeof(pw)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for failure recorder\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "data_name",
            "new",
            "_cleanup_failures"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\"",
            "new->name",
            "new->uid",
            "new->euid",
            "tty ? (const char *)tty : \"\"",
            "ruser ? (const char *)ruser : \"\"",
            "rhost ? (const char *)rhost : \"\"",
            "(new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\"",
            "new->user"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&tty"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&rhost"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RUSER",
            "&ruser"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "data_name",
            "&void_old"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "login_name"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name ? name : \"\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getlogin",
          "args": [
            "pamh"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct _pam_failed_auth)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "data_name",
            "NULL",
            "_cleanup_failures"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_pwd_hash",
          "args": [
            "pamh",
            "p",
            "salt",
            "off(UNIX__NONULL, ctrl)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__NONULL",
            "ctrl"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"check pass; user unknown\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_DEBUG",
            "ctrl"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"check pass; user (%s) unknown\"",
            "name"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_run_helper_binary",
          "args": [
            "pamh",
            "p",
            "ctrl",
            "name"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_run_helper_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "469-588",
          "snippet": "static int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pw",
            "p",
            "sizeof(pw) - 1"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pw",
            "0",
            "sizeof(pw)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "data_name + sizeof(FAIL_PREFIX) - 1",
            "name"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "data_name",
            "FAIL_PREFIX"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"no memory for data-name\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(FAIL_PREFIX) + strlen(name)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwd_hash",
          "args": [
            "pamh",
            "name",
            "&pwd",
            "&salt"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_fail_delay",
          "args": [
            "pamh",
            "2000000"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NODELAY",
            "ctrl"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define UNIX_MAX_RETRIES              3\n#define FAIL_PREFIX                   \"-UN*X-FAIL-\"\n\nint _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}"
  },
  {
    "function_name": "_unix_blankpasswd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "597-659",
    "snippet": "int\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "salt"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "salt"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_run_helper_binary",
          "args": [
            "pamh",
            "NULL",
            "ctrl",
            "name"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_run_helper_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "469-588",
          "snippet": "static int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pwd_hash",
          "args": [
            "pamh",
            "name",
            "&pwd",
            "&salt"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX__NONULL",
            "ctrl"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "UNIX__NULLOK",
            "ctrl"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "set_exec_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "422-430",
          "snippet": "static int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user [%s] has expired blank password, enabling nullok\"",
            "name"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_verify_user",
          "args": [
            "pamh",
            "ctrl",
            "name",
            "&daysleft"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_verify_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "819-854",
          "snippet": "int\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_verify_user(pam_handle_t *pamh,\n                  unsigned long long ctrl,\n                  const char *name,\n                  int *daysleft)\n{\n    int retval;\n    struct spwd *spent;\n    struct passwd *pwent;\n\n    retval = get_account_info(pamh, name, &pwent, &spent);\n    if (retval == PAM_USER_UNKNOWN) {\n        pam_syslog(pamh, LOG_ERR,\n             \"could not identify user (from getpwnam(%s))\",\n             name);\n        return retval;\n    }\n\n    if (retval == PAM_SUCCESS && spent == NULL)\n        return PAM_SUCCESS;\n\n    if (retval == PAM_UNIX_RUN_HELPER) {\n        retval = _unix_run_verify_binary(pamh, ctrl, name, daysleft);\n        if (retval == PAM_AUTHINFO_UNAVAIL &&\n            on(UNIX_BROKEN_SHADOW, ctrl))\n            return PAM_SUCCESS;\n    } else if (retval != PAM_SUCCESS) {\n        if (on(UNIX_BROKEN_SHADOW,ctrl))\n            return PAM_SUCCESS;\n        else\n            return retval;\n    } else\n        retval = check_shadow_expiry(pamh, spent, daysleft);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called\")"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}"
  },
  {
    "function_name": "_unix_run_helper_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "469-588",
    "snippet": "static int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"returning %d\", retval)"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_chkpwd abnormal exit: %d\"",
            "retval"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_chkpwd waitpid returned %d: %m\"",
            "rc"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot send password to helper: %m\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds[1]",
            "\"\"",
            "1"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot send password to helper: %m\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds[1]",
            "\"\"",
            "1"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds[1]",
            "passwd",
            "len"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passwd"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "CHKPWD_HELPER",
            "(char *const *) args",
            "envp"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__NONULL",
            "ctrl"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdin\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fds[0]",
            "STDIN_FILENO"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int _unix_run_helper_binary(pam_handle_t *pamh, const char *passwd,\n\t\t\t\t   unsigned long long ctrl, const char *user)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n\tnewsa.sa_handler = SIG_DFL;\n\tsigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL };\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (geteuid() == 0) {\n          /* must set the real uid to 0 so the helper will not error\n\t     out if pam is called from setuid binary (su, sudo...) */\n\t  if (setuid(0) == -1) {\n             D((\"setuid failed\"));\n\t     _exit(PAM_AUTHINFO_UNAVAIL);\n          }\n\t}\n\n\t/* exec binary helper */\n\targs[0] = CHKPWD_HELPER;\n\targs[1] = user;\n\tif (off(UNIX__NONULL, ctrl)) {\t/* this means we've succeeded */\n\t  args[2]=\"nullok\";\n\t} else {\n\t  args[2]=\"nonull\";\n\t}\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(CHKPWD_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (passwd != NULL) {            /* send the password to the child */\n\t    int len = strlen(passwd);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    if (write(fds[1], passwd, len) == -1 ||\n\t        write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t    passwd = NULL;\n\t} else {                         /* blank password */\n\t    if (write(fds[1], \"\", 1) == -1) {\n\t      pam_syslog (pamh, LOG_ERR, \"Cannot send password to helper: %m\");\n\t      retval = PAM_AUTH_ERR;\n\t    }\n\t}\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\t  retval = PAM_AUTH_ERR;\n\t} else if (!WIFEXITED(retval)) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n\t  retval = PAM_AUTH_ERR;\n\t} else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    D((\"returning %d\", retval));\n    return retval;\n}"
  },
  {
    "function_name": "_unix_comesfromsource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "456-460",
    "snippet": "int _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_unix_getpwnam",
          "args": [
            "pamh",
            "name",
            "files",
            "nis",
            "NULL"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_getpwnam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "308-449",
          "snippet": "int _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}"
  },
  {
    "function_name": "_unix_getpwnam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "308-449",
    "snippet": "int _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*ret"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "buf",
            "*ret",
            "_unix_cleanup"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"_pam_unix_getpwnam_%s\"",
            "name"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "sshell"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "shome"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "sgecos"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "spasswd"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "slogin"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sgid"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "sgid",
            "&p",
            "10"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suid"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "suid",
            "&p",
            "10"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*ret",
            "'\\0'",
            "buflen"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "buflen"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sshell"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "shome"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sgecos"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spasswd"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "slogin"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "shome",
            "':'"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sgecos",
            "':'"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sgid",
            "':'"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "suid",
            "':'"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "spasswd",
            "':'"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "slogin",
            "':'"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "userinfo",
            "sizeof(buf) - 1"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_unbind",
          "args": [
            "domain"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_match",
          "args": [
            "domain",
            "\"passwd.byname\"",
            "name",
            "strlen(name)",
            "&userinfo",
            "&len"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_bind",
          "args": [
            "domain"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_get_default_domain",
          "args": [
            "&domain"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "passwd"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*p"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "buf",
            "userlen"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "passwd"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/passwd\"",
            "\"r\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}"
  },
  {
    "function_name": "_unix_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "303-306",
    "snippet": "static void _unix_cleanup(pam_handle_t *pamh UNUSED, void *data, int error_status UNUSED)\n{\n\tfree(data);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic void _unix_cleanup(pam_handle_t *pamh UNUSED, void *data, int error_status UNUSED)\n{\n\tfree(data);\n}"
  },
  {
    "function_name": "_cleanup_failures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "243-298",
    "snippet": "static void _cleanup_failures(pam_handle_t * pamh, void *fl, int err)\n{\n\tint quiet;\n\tconst void *service = NULL;\n\tconst void *ruser = NULL;\n\tconst void *rhost = NULL;\n\tconst void *tty = NULL;\n\tstruct _pam_failed_auth *failure;\n\n\tD((\"called\"));\n\n\tquiet = err & PAM_DATA_SILENT;\t/* should we log something? */\n\terr &= PAM_DATA_REPLACE;\t/* are we just replacing data? */\n\tfailure = (struct _pam_failed_auth *) fl;\n\n\tif (failure != NULL) {\n\n\t\tif (!quiet && !err) {\t/* under advisement from Sun,may go away */\n\n\t\t\t/* log the number of authentication failures */\n\t\t\tif (failure->count > 1) {\n\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t    &service);\n\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t    &ruser);\n\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t    &rhost);\n\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t    &tty);\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"%d more authentication failure%s; \"\n\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t         \"%s%s\",\n\t\t\t\t         failure->count - 1, failure->count == 2 ? \"\" : \"s\",\n\t\t\t\t         failure->name, failure->uid, failure->euid,\n\t\t\t\t         tty ? (const char *)tty : \"\", ruser ? (const char *)ruser : \"\",\n\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t         (failure->user && failure->user[0] != '\\0')\n\t\t\t\t          ? \" user=\" : \"\", failure->user\n\t\t\t\t);\n\n\t\t\t\tif (failure->count > UNIX_MAX_RETRIES) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t\t \"service(%s) ignoring max retries; %d > %d\",\n\t\t\t\t\t\t service == NULL ? \"**unknown**\" : (const char *)service,\n\t\t\t\t\t\t failure->count,\n\t\t\t\t\t\t UNIX_MAX_RETRIES);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_pam_delete(failure->user);\t/* tidy up */\n\t\t_pam_delete(failure->name);\t/* tidy up */\n\t\tfree(failure);\n\t}\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define UNIX_MAX_RETRIES              3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "failure"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "failure->name"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "failure->user"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"service(%s) ignoring max retries; %d > %d\"",
            "service == NULL ? \"**unknown**\" : (const char *)service",
            "failure->count",
            "UNIX_MAX_RETRIES"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"%d more authentication failure%s; \"\n\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t         \"%s%s\"",
            "failure->count - 1",
            "failure->count == 2 ? \"\" : \"s\"",
            "failure->name",
            "failure->uid",
            "failure->euid",
            "tty ? (const char *)tty : \"\"",
            "ruser ? (const char *)ruser : \"\"",
            "rhost ? (const char *)rhost : \"\"",
            "(failure->user && failure->user[0] != '\\0')\n\t\t\t\t          ? \" user=\" : \"\"",
            "failure->user"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&tty"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&rhost"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RUSER",
            "&ruser"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called\")"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define UNIX_MAX_RETRIES              3\n\nstatic void _cleanup_failures(pam_handle_t * pamh, void *fl, int err)\n{\n\tint quiet;\n\tconst void *service = NULL;\n\tconst void *ruser = NULL;\n\tconst void *rhost = NULL;\n\tconst void *tty = NULL;\n\tstruct _pam_failed_auth *failure;\n\n\tD((\"called\"));\n\n\tquiet = err & PAM_DATA_SILENT;\t/* should we log something? */\n\terr &= PAM_DATA_REPLACE;\t/* are we just replacing data? */\n\tfailure = (struct _pam_failed_auth *) fl;\n\n\tif (failure != NULL) {\n\n\t\tif (!quiet && !err) {\t/* under advisement from Sun,may go away */\n\n\t\t\t/* log the number of authentication failures */\n\t\t\tif (failure->count > 1) {\n\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t    &service);\n\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t    &ruser);\n\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t    &rhost);\n\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t    &tty);\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"%d more authentication failure%s; \"\n\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t         \"%s%s\",\n\t\t\t\t         failure->count - 1, failure->count == 2 ? \"\" : \"s\",\n\t\t\t\t         failure->name, failure->uid, failure->euid,\n\t\t\t\t         tty ? (const char *)tty : \"\", ruser ? (const char *)ruser : \"\",\n\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t         (failure->user && failure->user[0] != '\\0')\n\t\t\t\t          ? \" user=\" : \"\", failure->user\n\t\t\t\t);\n\n\t\t\t\tif (failure->count > UNIX_MAX_RETRIES) {\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t\t \"service(%s) ignoring max retries; %d > %d\",\n\t\t\t\t\t\t service == NULL ? \"**unknown**\" : (const char *)service,\n\t\t\t\t\t\t failure->count,\n\t\t\t\t\t\t UNIX_MAX_RETRIES);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_pam_delete(failure->user);\t/* tidy up */\n\t\t_pam_delete(failure->name);\t/* tidy up */\n\t\tfree(failure);\n\t}\n}"
  },
  {
    "function_name": "_set_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "53-217",
    "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"done.\")"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "UNIX_DEBUG",
            "ctrl"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "set_exec_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "422-430",
          "snippet": "static int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_AUDIT",
            "ctrl"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset",
          "args": [
            "UNIX_ALGO_ROUNDS",
            "ctrl"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_ALGO_ROUNDS",
            "ctrl"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Password minlen reset to 8 characters\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIX_DES_CRYPT",
          "args": [
            "ctrl"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"option rounds not allowed for this module type\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"option minlen not allowed for this module type\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"option remember not allowed for this module type\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unrecognized option [%s]\"",
            "*argv"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix_len",
          "args": [
            "*argv",
            "unix_args[j].token",
            "strlen(unix_args[j].token)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "unix_args[j].token"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "val",
            "NULL",
            "10"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "\"SHA_CRYPT_MAX_ROUNDS\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"unrecognized ENCRYPT_METHOD value [%s]\"",
            "val"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "val",
            "unix_args[j].token",
            "strlen(unix_args[j].token)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "unix_args[j].token"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "\"ENCRYPT_METHOD\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
  },
  {
    "function_name": "_make_remark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
    "lines": "38-47",
    "snippet": "int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <rpcsvc/ypclnt.h>",
      "#include <sys/resource.h>",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <utmp.h>",
      "#include <limits.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_prompt",
          "args": [
            "pamh",
            "type",
            "NULL",
            "\"%s\"",
            "text"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__QUIET",
            "ctrl"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}"
  }
]