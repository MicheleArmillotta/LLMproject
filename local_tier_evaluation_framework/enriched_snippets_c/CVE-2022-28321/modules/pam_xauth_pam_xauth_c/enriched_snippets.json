[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
    "lines": "749-803",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t      int argc, const char **argv)\n{\n\tint i, debug = 0;\n\tconst char *user;\n\tconst void *data;\n\tconst char *cookiefile;\n\tstruct passwd *tpwd;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Try to retrieve the name of a file we created when\n\t * the session was opened. */\n\tif (pam_get_data(pamh, DATANAME, &data) != PAM_SUCCESS)\n\t\treturn PAM_SUCCESS;\n\tcookiefile = data;\n\n\t/* Parse arguments.  We don't understand many, so\n\t * no sense in breaking this into a separate function. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pam_str_skip_prefix(argv[i], \"xauthpath=\") != NULL)\n\t\t\tcontinue;\n\t\tif (pam_str_skip_prefix(argv[i], \"systemuser=\") != NULL)\n\t\t\tcontinue;\n\t\tif (pam_str_skip_prefix(argv[i], \"targetuser=\") != NULL)\n\t\t\tcontinue;\n\t\tpam_syslog(pamh, LOG_WARNING, \"unrecognized option `%s'\",\n\t\t       argv[i]);\n\t}\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (!(tpwd = pam_modutil_getpwnam(pamh, user))) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"error determining target user's UID\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"removing `%s'\", cookiefile);\n\tif (pam_modutil_drop_priv(pamh, &privs, tpwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (unlink(cookiefile) == -1 && errno != ENOENT)\n\t  pam_syslog(pamh, LOG_WARNING, \"Couldn't remove `%s': %m\", cookiefile);\n\tif (pam_modutil_regain_priv(pamh, &privs))\n\t\treturn PAM_SESSION_ERR;\n\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <selinux/label.h>",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <grp.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DATANAME \"pam_xauth_cookie_file\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Couldn't remove `%s': %m\"",
            "cookiefile"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cookiefile"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "&privs",
            "tpwd"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"removing `%s'\"",
            "cookiefile"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"error determining target user's UID\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"unrecognized option `%s'\"",
            "argv[i]"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"targetuser=\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"systemuser=\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"xauthpath=\""
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "DATANAME",
            "&data"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_xauth_cookie_file\"\n\nint\npam_sm_close_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t      int argc, const char **argv)\n{\n\tint i, debug = 0;\n\tconst char *user;\n\tconst void *data;\n\tconst char *cookiefile;\n\tstruct passwd *tpwd;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Try to retrieve the name of a file we created when\n\t * the session was opened. */\n\tif (pam_get_data(pamh, DATANAME, &data) != PAM_SUCCESS)\n\t\treturn PAM_SUCCESS;\n\tcookiefile = data;\n\n\t/* Parse arguments.  We don't understand many, so\n\t * no sense in breaking this into a separate function. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pam_str_skip_prefix(argv[i], \"xauthpath=\") != NULL)\n\t\t\tcontinue;\n\t\tif (pam_str_skip_prefix(argv[i], \"systemuser=\") != NULL)\n\t\t\tcontinue;\n\t\tif (pam_str_skip_prefix(argv[i], \"targetuser=\") != NULL)\n\t\t\tcontinue;\n\t\tpam_syslog(pamh, LOG_WARNING, \"unrecognized option `%s'\",\n\t\t       argv[i]);\n\t}\n\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (!(tpwd = pam_modutil_getpwnam(pamh, user))) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"error determining target user's UID\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (debug)\n\t\tpam_syslog(pamh, LOG_DEBUG, \"removing `%s'\", cookiefile);\n\tif (pam_modutil_drop_priv(pamh, &privs, tpwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (unlink(cookiefile) == -1 && errno != ENOENT)\n\t  pam_syslog(pamh, LOG_WARNING, \"Couldn't remove `%s': %m\", cookiefile);\n\tif (pam_modutil_regain_priv(pamh, &privs))\n\t\treturn PAM_SESSION_ERR;\n\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
    "lines": "351-747",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n\tchar *cookiefile = NULL, *xauthority = NULL,\n\t     *cookie = NULL, *display = NULL, *tmp = NULL,\n\t     *xauthlocalhostname = NULL;\n\tconst char *user, *xauth = NULL;\n\tstruct passwd *tpwd, *rpwd;\n\tint fd, i, debug = 0;\n\tint retval = PAM_SUCCESS;\n\tuid_t systemuser = 499, targetuser = 0;\n\n\t/* Parse arguments.  We don't understand many, so no sense in breaking\n\t * this into a separate function. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"xauthpath=\")) != NULL) {\n\t\t\txauth = str;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"targetuser=\")) != NULL) {\n\t\t\tlong l = strtol(str, &tmp, 10);\n\t\t\tif ((*str != '\\0') && (*tmp == '\\0')) {\n\t\t\t\ttargetuser = l;\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t   \"invalid value for targetuser (`%s')\",\n\t\t\t\t\t   argv[i] + 11);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"systemuser=\")) != NULL) {\n\t\t\tlong l = strtol(str, &tmp, 10);\n\t\t\tif ((*str != '\\0') && (*tmp == '\\0')) {\n\t\t\t\tsystemuser = l;\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t   \"invalid value for systemuser (`%s')\",\n\t\t\t\t\t   argv[i] + 11);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tpam_syslog(pamh, LOG_WARNING, \"unrecognized option `%s'\",\n\t\t\t   argv[i]);\n\t}\n\n\tif (xauth == NULL) {\n\t        size_t j;\n\t\tfor (j = 0; j < PAM_ARRAY_SIZE(xauthpaths); j++) {\n\t\t\tif (access(xauthpaths[j], X_OK) == 0) {\n\t\t\t\txauth = xauthpaths[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (xauth == NULL) {\n\t\t\t/* xauth executable not found - nothing to do */\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t}\n\n\t/* If DISPLAY isn't set, we don't really care, now do we? */\n\tif ((display = getenv(\"DISPLAY\")) == NULL) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"user has no DISPLAY, doing nothing\");\n\t\t}\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* Read the target user's name. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\trpwd = pam_modutil_getpwuid(pamh, getuid());\n\tif (rpwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining invoking user's name\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the target user's UID and primary GID, which we'll need to set\n\t * on the xauthority file we create later on. */\n\ttpwd = pam_modutil_getpwnam(pamh, user);\n\tif (tpwd == NULL) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"error determining target user's UID\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"requesting user %lu/%lu, target user %lu/%lu\",\n\t\t\t   (unsigned long) rpwd->pw_uid,\n\t\t\t   (unsigned long) rpwd->pw_gid,\n\t\t\t   (unsigned long) tpwd->pw_uid,\n\t\t\t   (unsigned long) tpwd->pw_gid);\n\t}\n\n\t/* If the UID is a system account (and not the superuser), forget\n\t * about forwarding keys. */\n\tif ((tpwd->pw_uid != 0) &&\n\t    (tpwd->pw_uid != targetuser) &&\n\t    (tpwd->pw_uid <= systemuser)) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"not forwarding cookies to user ID %lu\",\n\t\t\t\t   (unsigned long) tpwd->pw_uid);\n\t\t}\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\n\t/* If current user and the target user are the same, don't\n\t   check the ACL list, but forward X11 */\n\tif (strcmp (rpwd->pw_name, tpwd->pw_name) != 0) {\n\n\t  /* Check that both users are amenable to this.  By default, this\n\t   * boils down to this policy:\n\t   * export(ruser=root): only if <user> is listed in .xauth/export\n\t   * export(ruser=*) if <user> is listed in .xauth/export, or\n\t   *                 if .xauth/export does not exist\n\t   * import(user=*): if <ruser> is listed in .xauth/import, or\n\t   *                 if .xauth/import does not exist */\n\t  i = (getuid() != 0 || tpwd->pw_uid == 0) ? PAM_SUCCESS : PAM_PERM_DENIED;\n\t  i = check_acl(pamh, \"export\", rpwd->pw_name, user, i, debug);\n\t  if (i != PAM_SUCCESS) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto cleanup;\n\t  }\n\t  i = PAM_SUCCESS;\n\t  i = check_acl(pamh, \"import\", user, rpwd->pw_name, i, debug);\n\t  if (i != PAM_SUCCESS) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto cleanup;\n\t  }\n\t}  else {\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"current and target user are the same, forward X11\");\n\t}\n\n\t/* Figure out where the source user's .Xauthority file is. */\n\tif (getenv(XAUTHENV) != NULL) {\n\t\tcookiefile = strdup(getenv(XAUTHENV));\n\t} else {\n\t\tcookiefile = malloc(strlen(rpwd->pw_dir) + 1 +\n\t\t\t\t    strlen(XAUTHDEF) + 1);\n\t\tif (cookiefile == NULL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tstrcpy(cookiefile, rpwd->pw_dir);\n\t\tstrcat(cookiefile, \"/\");\n\t\tstrcat(cookiefile, XAUTHDEF);\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"reading keys from `%s'\",\n\t\t\t   cookiefile);\n\t}\n\n\t/* Read the user's .Xauthority file.  Because the current UID is\n\t * the original user's UID, this will only fail if something has\n\t * gone wrong, or we have no cookies. */\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"running \\\"%s %s %s %s %s\\\" as %lu/%lu\",\n\t\t\t   xauth, \"-f\", cookiefile, \"nlist\", display,\n\t\t\t   (unsigned long) getuid(), (unsigned long) getgid());\n\t}\n\tif (run_coprocess(pamh, NULL, &cookie,\n\t\t\t  getuid(), getgid(),\n\t\t\t  xauth, \"-f\", cookiefile, \"nlist\", display,\n\t\t\t  NULL) == 0) {\n#ifdef WITH_SELINUX\n\t\tchar *context_raw = NULL;\n#endif\n\t\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t\t/* Check that we got a cookie.  If not, we get creative. */\n\t\tif (((cookie == NULL) || (strlen(cookie) == 0)) &&\n\t\t    (pam_str_skip_prefix(display, \"localhost:\") != NULL ||\n\t\t     pam_str_skip_prefix(display, \"localhost/unix:\") != NULL)) {\n\t\t\tchar *t, *screen;\n\t\t\tsize_t tlen, slen;\n\t\t\t/* Free the useless cookie string. */\n\t\t\tif (cookie != NULL) {\n\t\t\t\tfree(cookie);\n\t\t\t\tcookie = NULL;\n\t\t\t}\n\t\t\t/* Allocate enough space to hold an adjusted name. */\n\t\t\ttlen = strlen(display) + LINE_MAX + 1;\n\t\t\tt = malloc(tlen);\n\t\t\tif (t != NULL) {\n\t\t\t\tmemset(t, 0, tlen);\n\t\t\t\tif (gethostname(t, tlen - 1) != -1) {\n\t\t\t\t\t/* Append the protocol and then the\n\t\t\t\t\t * screen number. */\n\t\t\t\t\tif (strlen(t) < tlen - 6) {\n\t\t\t\t\t\tstrcat(t, \"/unix:\");\n\t\t\t\t\t}\n\t\t\t\t\tscreen = strchr(display, ':');\n\t\t\t\t\tif (screen != NULL) {\n\t\t\t\t\t\tscreen++;\n\t\t\t\t\t\tslen = strlen(screen);\n\t\t\t\t\t\tif (strlen(t) + slen < tlen) {\n\t\t\t\t\t\t\tstrcat(t, screen);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t\t   \"no key for `%s', \"\n\t\t\t\t\t\t\t   \"trying `%s'\",\n\t\t\t\t\t\t\t   display, t);\n\t\t\t\t\t}\n\t\t\t\t\t/* Read the cookie for this display. */\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t       \"running \"\n\t\t\t\t\t\t       \"\\\"%s %s %s %s %s\\\" as \"\n\t\t\t\t\t\t       \"%lu/%lu\",\n\t\t\t\t\t\t       xauth,\n\t\t\t\t\t\t       \"-f\",\n\t\t\t\t\t\t       cookiefile,\n\t\t\t\t\t\t       \"nlist\",\n\t\t\t\t\t\t       t,\n\t\t\t\t\t\t       (unsigned long) getuid(),\n\t\t\t\t\t\t       (unsigned long) getgid());\n\t\t\t\t\t}\n\t\t\t\t\trun_coprocess(pamh, NULL, &cookie,\n\t\t\t\t\t\t      getuid(), getgid(),\n\t\t\t\t\t\t      xauth, \"-f\", cookiefile,\n\t\t\t\t\t\t      \"nlist\", t, NULL);\n\t\t\t\t}\n\t\t\t\tfree(t);\n\t\t\t\tt = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we got a cookie, this time for real. */\n\t\tif ((cookie == NULL) || (strlen(cookie) == 0)) {\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"no key\");\n\t\t\t}\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate the environment variable\n\t\t * \"XAUTHORITY=<homedir>/filename\". */\n\t\tif (asprintf(&xauthority, \"%s=%s/%s\",\n\t\t\t     XAUTHENV, tpwd->pw_dir, XAUTHTMP) < 0) {\n\t\t\txauthority = NULL;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"out of memory\");\n\t\t\t}\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate a new file to hold the data. */\n\t\tif (pam_modutil_drop_priv(pamh, &privs, tpwd)) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n#ifdef WITH_SELINUX\n\t\tif (is_selinux_enabled() > 0) {\n\t\t\tstruct selabel_handle *ctx = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\t\t\tif (ctx != NULL) {\n\t\t\t\tif (selabel_lookup_raw(ctx, &context_raw,\n\t\t\t\t\t\t       xauthority + sizeof(XAUTHENV), S_IFREG) != 0) {\n\t\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t\t   \"could not get SELinux label for '%s'\",\n\t\t\t\t\t\t   xauthority + sizeof(XAUTHENV));\n\t\t\t\t}\n\t\t\t\tselabel_close(ctx);\n\t\t\t\tif (setfscreatecon_raw(context_raw)) {\n\t\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t\t   \"setfscreatecon_raw(%s) failed: %m\", context_raw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* WITH_SELINUX */\n\t\tfd = mkstemp(xauthority + sizeof(XAUTHENV));\n\t\tif (fd < 0)\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"error creating temporary file `%s': %m\",\n\t\t\t\t   xauthority + sizeof(XAUTHENV));\n#ifdef WITH_SELINUX\n\t\tif (context_raw != NULL) {\n\t\t\tfree(context_raw);\n\t\t\tsetfscreatecon_raw(NULL);\n\t\t}\n#endif /* WITH_SELINUX */\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tif (pam_modutil_regain_priv(pamh, &privs) || fd < 0) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Get a copy of the filename to save as a data item for\n\t\t * removal at session-close time. */\n\t\tfree(cookiefile);\n\t\tcookiefile = strdup(xauthority + sizeof(XAUTHENV));\n\n\t\t/* Save the filename. */\n\t\tif (pam_set_data(pamh, DATANAME, cookiefile, cleanup) != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"error saving name of temporary file `%s'\",\n\t\t\t\t   cookiefile);\n\t\t\tunlink(cookiefile);\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Set the new variable in the environment. */\n\t\tif (pam_putenv (pamh, xauthority) != PAM_SUCCESS)\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"can't set environment variable '%s'\",\n\t\t\t\t   xauthority);\n\t\tputenv (xauthority); /* The environment owns this string now. */\n\t\txauthority = NULL; /* Don't free environment variables. */\n\n\t\t/* set $DISPLAY in pam handle to make su - work */\n\t\t{\n\t\t  char *d;\n\n\t\t  if (asprintf(&d, \"DISPLAY=%s\", display) < 0)\n\t\t    {\n\t\t      pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t      cookiefile = NULL;\n\t\t      retval = PAM_SESSION_ERR;\n\t\t      goto cleanup;\n\t\t    }\n\n\t\t  if (pam_putenv (pamh, d) != PAM_SUCCESS)\n\t\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\t\"can't set environment variable '%s'\", d);\n\t\t  free (d);\n\t\t}\n\n\t\t/* set XAUTHLOCALHOSTNAME to make sure that su - work under gnome */\n\t\tif ((xauthlocalhostname = getenv(\"XAUTHLOCALHOSTNAME\")) != NULL) {\n\t\t  char *d;\n\n\t\t  if (asprintf(&d, \"XAUTHLOCALHOSTNAME=%s\", xauthlocalhostname) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_SESSION_ERR;\n\t\t    goto cleanup;\n\t\t  }\n\n\t\t  if (pam_putenv (pamh, d) != PAM_SUCCESS)\n\t\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\t\"can't set environment variable '%s'\", d);\n\t\t  free (d);\n\t\t}\n\n\t\t/* Merge the cookie we read before into the new file. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"writing key `%s' to temporary file `%s'\",\n\t\t\t\t   cookie, cookiefile);\n\t\t}\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t  \"running \\\"%s %s %s %s %s\\\" as %lu/%lu\",\n\t\t\t\t  xauth, \"-f\", cookiefile, \"nmerge\", \"-\",\n\t\t\t\t  (unsigned long) tpwd->pw_uid,\n\t\t\t\t  (unsigned long) tpwd->pw_gid);\n\t\t}\n\t\trun_coprocess(pamh, cookie, &tmp,\n\t\t\t      tpwd->pw_uid, tpwd->pw_gid,\n\t\t\t      xauth, \"-f\", cookiefile, \"nmerge\", \"-\", NULL);\n\n\t\t/* We don't need to keep a copy of these around any more. */\n\t\tcookiefile = NULL;\n\t\tfree(tmp);\n\t}\ncleanup:\n\t/* Unset any old XAUTHORITY variable in the environment. */\n\tif (retval != PAM_SUCCESS && getenv (XAUTHENV))\n\t\tunsetenv (XAUTHENV);\n\tfree(cookiefile);\n\tfree(cookie);\n\tfree(xauthority);\n\treturn retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <selinux/label.h>",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <grp.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define XAUTHTMP \".xauthXXXXXX\"",
      "#define XAUTHDEF \".Xauthority\"",
      "#define XAUTHENV \"XAUTHORITY\"",
      "#define DATANAME \"pam_xauth_cookie_file\""
    ],
    "globals_used": [
      "static const char * const xauthpaths[] = {\n#ifdef PAM_PATH_XAUTH\n\tPAM_PATH_XAUTH,\n#endif\n\t\"/usr/X11R6/bin/xauth\",\n\t\"/usr/bin/xauth\",\n\t\"/usr/bin/X11/xauth\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xauthority"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "XAUTHENV"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "XAUTHENV"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_coprocess",
          "args": [
            "pamh",
            "cookie",
            "&tmp",
            "tpwd->pw_uid",
            "tpwd->pw_gid",
            "xauth",
            "\"-f\"",
            "cookiefile",
            "\"nmerge\"",
            "\"-\"",
            "NULL"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "run_coprocess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
          "lines": "92-229",
          "snippet": "static int\nrun_coprocess(pam_handle_t *pamh, const char *input, char **output,\n\t      uid_t uid, gid_t gid, const char *command, ...)\n{\n\tint ipipe[2], opipe[2], i;\n\tchar buf[LINE_MAX];\n\tpid_t child;\n\tchar *buffer = NULL;\n\tsize_t buffer_size = 0;\n\tva_list ap;\n\n\t*output = NULL;\n\n\t/* Create stdio pipery. */\n\tif (pipe(ipipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\treturn -1;\n\t}\n\tif (pipe(opipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\treturn -1;\n\t}\n\n\t/* Fork off a child. */\n\tchild = fork();\n\tif (child == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not fork: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\tclose(opipe[0]);\n\t\tclose(opipe[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) {\n\t\t/* We're the child. */\n\t\tsize_t j;\n\t\tconst char *args[10];\n\t\t/* Drop privileges. */\n\t\tif (setgid(gid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) getegid ());\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setgroups(0, NULL) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgroups() failed: %m\");\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setuid(uid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) geteuid ());\n\t\t    _exit (err);\n\t\t  }\n\t\t/* Set the pipe descriptors up as stdin and stdout, and close\n\t\t * everything else, including the original values for the\n\t\t * descriptors. */\n\t\tif (dup2(ipipe[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (dup2(opipe[1], STDOUT_FILENO) != STDOUT_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_NULL_FD) < 0) {\n\t\t    _exit(1);\n\t\t}\n\t\t/* Initialize the argument list. */\n\t\tmemset(args, 0, sizeof(args));\n\t\t/* Convert the varargs list into a regular array of strings. */\n\t\tva_start(ap, command);\n\t\targs[0] = command;\n\t\tfor (j = 1; j < PAM_ARRAY_SIZE(args) - 1; j++) {\n\t\t\targs[j] = va_arg(ap, const char*);\n\t\t\tif (args[j] == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Run the command. */\n\t\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\t\texecv(command, (char *const *) args);\n\t\tDIAG_POP_IGNORE_CAST_QUAL;\n\t\t/* Never reached. */\n\t\t_exit(1);\n\t}\n\n\t/* We're the parent, so close the other ends of the pipes. */\n\tclose(opipe[1]);\n\t/* Send input to the process (if we have any), then send an EOF. */\n\tif (input) {\n\t\t(void)pam_modutil_write(ipipe[1], input, strlen(input));\n\t}\n\tclose(ipipe[0]); /* close here to avoid possible SIGPIPE above */\n\tclose(ipipe[1]);\n\n\t/* Read data output until we run out of stuff to read. */\n\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\twhile ((i != 0) && (i != -1)) {\n\t\tchar *tmp;\n\t\t/* Resize the buffer to hold the data. */\n\t\ttmp = realloc(buffer, buffer_size + i + 1);\n\t\tif (tmp == NULL) {\n\t\t\t/* Uh-oh, bail. */\n\t\t\tif (buffer != NULL) {\n\t\t\t\tfree(buffer);\n\t\t\t}\n\t\t\tclose(opipe[0]);\n\t\t\twaitpid(child, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Save the new buffer location, copy the newly-read data into\n\t\t * the buffer, and make sure the result will be\n\t\t * nul-terminated. */\n\t\tbuffer = tmp;\n\t\tmemcpy(buffer + buffer_size, buf, i);\n\t\tbuffer[buffer_size + i] = '\\0';\n\t\tbuffer_size += i;\n\t\t/* Try to read again. */\n\t\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\t}\n\t/* No more data.  Clean up and return data. */\n\tclose(opipe[0]);\n\t*output = buffer;\n\twaitpid(child, NULL, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <selinux/label.h>",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <grp.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic int\nrun_coprocess(pam_handle_t *pamh, const char *input, char **output,\n\t      uid_t uid, gid_t gid, const char *command, ...)\n{\n\tint ipipe[2], opipe[2], i;\n\tchar buf[LINE_MAX];\n\tpid_t child;\n\tchar *buffer = NULL;\n\tsize_t buffer_size = 0;\n\tva_list ap;\n\n\t*output = NULL;\n\n\t/* Create stdio pipery. */\n\tif (pipe(ipipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\treturn -1;\n\t}\n\tif (pipe(opipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\treturn -1;\n\t}\n\n\t/* Fork off a child. */\n\tchild = fork();\n\tif (child == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not fork: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\tclose(opipe[0]);\n\t\tclose(opipe[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) {\n\t\t/* We're the child. */\n\t\tsize_t j;\n\t\tconst char *args[10];\n\t\t/* Drop privileges. */\n\t\tif (setgid(gid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) getegid ());\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setgroups(0, NULL) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgroups() failed: %m\");\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setuid(uid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) geteuid ());\n\t\t    _exit (err);\n\t\t  }\n\t\t/* Set the pipe descriptors up as stdin and stdout, and close\n\t\t * everything else, including the original values for the\n\t\t * descriptors. */\n\t\tif (dup2(ipipe[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (dup2(opipe[1], STDOUT_FILENO) != STDOUT_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_NULL_FD) < 0) {\n\t\t    _exit(1);\n\t\t}\n\t\t/* Initialize the argument list. */\n\t\tmemset(args, 0, sizeof(args));\n\t\t/* Convert the varargs list into a regular array of strings. */\n\t\tva_start(ap, command);\n\t\targs[0] = command;\n\t\tfor (j = 1; j < PAM_ARRAY_SIZE(args) - 1; j++) {\n\t\t\targs[j] = va_arg(ap, const char*);\n\t\t\tif (args[j] == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Run the command. */\n\t\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\t\texecv(command, (char *const *) args);\n\t\tDIAG_POP_IGNORE_CAST_QUAL;\n\t\t/* Never reached. */\n\t\t_exit(1);\n\t}\n\n\t/* We're the parent, so close the other ends of the pipes. */\n\tclose(opipe[1]);\n\t/* Send input to the process (if we have any), then send an EOF. */\n\tif (input) {\n\t\t(void)pam_modutil_write(ipipe[1], input, strlen(input));\n\t}\n\tclose(ipipe[0]); /* close here to avoid possible SIGPIPE above */\n\tclose(ipipe[1]);\n\n\t/* Read data output until we run out of stuff to read. */\n\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\twhile ((i != 0) && (i != -1)) {\n\t\tchar *tmp;\n\t\t/* Resize the buffer to hold the data. */\n\t\ttmp = realloc(buffer, buffer_size + i + 1);\n\t\tif (tmp == NULL) {\n\t\t\t/* Uh-oh, bail. */\n\t\t\tif (buffer != NULL) {\n\t\t\t\tfree(buffer);\n\t\t\t}\n\t\t\tclose(opipe[0]);\n\t\t\twaitpid(child, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Save the new buffer location, copy the newly-read data into\n\t\t * the buffer, and make sure the result will be\n\t\t * nul-terminated. */\n\t\tbuffer = tmp;\n\t\tmemcpy(buffer + buffer_size, buf, i);\n\t\tbuffer[buffer_size + i] = '\\0';\n\t\tbuffer_size += i;\n\t\t/* Try to read again. */\n\t\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\t}\n\t/* No more data.  Clean up and return data. */\n\tclose(opipe[0]);\n\t*output = buffer;\n\twaitpid(child, NULL, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"running \\\"%s %s %s %s %s\\\" as %lu/%lu\"",
            "xauth",
            "\"-f\"",
            "cookiefile",
            "\"nmerge\"",
            "\"-\"",
            "(unsigned long) tpwd->pw_uid",
            "(unsigned long) tpwd->pw_gid"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"writing key `%s' to temporary file `%s'\"",
            "cookie",
            "cookiefile"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can't set environment variable '%s'\"",
            "d"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "d"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&d",
            "\"XAUTHLOCALHOSTNAME=%s\"",
            "xauthlocalhostname"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHLOCALHOSTNAME\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can't set environment variable '%s'\"",
            "d"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "d"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&d",
            "\"DISPLAY=%s\"",
            "display"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "xauthority"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can't set environment variable '%s'\"",
            "xauthority"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "xauthority"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cookiefile"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error saving name of temporary file `%s'\"",
            "cookiefile"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "DATANAME",
            "cookiefile",
            "cleanup"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xauthority + sizeof(XAUTHENV)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfscreatecon_raw",
          "args": [
            "NULL"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error creating temporary file `%s': %m\"",
            "xauthority + sizeof(XAUTHENV)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "xauthority + sizeof(XAUTHENV)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"setfscreatecon_raw(%s) failed: %m\"",
            "context_raw"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfscreatecon_raw",
          "args": [
            "context_raw"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_close",
          "args": [
            "ctx"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"could not get SELinux label for '%s'\"",
            "xauthority + sizeof(XAUTHENV)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_lookup_raw",
          "args": [
            "ctx",
            "&context_raw",
            "xauthority + sizeof(XAUTHENV)",
            "S_IFREG"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_open",
          "args": [
            "SELABEL_CTX_FILE",
            "NULL",
            "0"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "&privs",
            "tpwd"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"out of memory\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&xauthority",
            "\"%s=%s/%s\"",
            "XAUTHENV",
            "tpwd->pw_dir",
            "XAUTHTMP"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"no key\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"running \"\n\t\t\t\t\t\t       \"\\\"%s %s %s %s %s\\\" as \"\n\t\t\t\t\t\t       \"%lu/%lu\"",
            "xauth",
            "\"-f\"",
            "cookiefile",
            "\"nlist\"",
            "t",
            "(unsigned long) getuid()",
            "(unsigned long) getgid()"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"no key for `%s', \"\n\t\t\t\t\t\t\t   \"trying `%s'\"",
            "display",
            "t"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "t",
            "screen"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "screen"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "display",
            "':'"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "t",
            "\"/unix:\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "t",
            "tlen - 1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "t",
            "0",
            "tlen"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "tlen"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "display"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "display",
            "\"localhost/unix:\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "display",
            "\"localhost:\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"running \\\"%s %s %s %s %s\\\" as %lu/%lu\"",
            "xauth",
            "\"-f\"",
            "cookiefile",
            "\"nlist\"",
            "display",
            "(unsigned long) getuid()",
            "(unsigned long) getgid()"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"reading keys from `%s'\"",
            "cookiefile"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cookiefile",
            "XAUTHDEF"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cookiefile",
            "\"/\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cookiefile",
            "rpwd->pw_dir"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(rpwd->pw_dir) + 1 +\n\t\t\t\t    strlen(XAUTHDEF) + 1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "XAUTHDEF"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rpwd->pw_dir"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(XAUTHENV)"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "XAUTHENV"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "XAUTHENV"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"current and target user are the same, forward X11\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_acl",
          "args": [
            "pamh",
            "\"import\"",
            "user",
            "rpwd->pw_name",
            "i",
            "debug"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
          "lines": "240-349",
          "snippet": "static int\ncheck_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n\tFILE *fp = NULL;\n\tint i, fd = -1, save_errno;\n\tstruct stat st;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Check this user's <sense> file. */\n\tpwd = pam_modutil_getpwnam(pamh, this_user);\n\tif (pwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining home directory for '%s'\",\n\t\t\t   this_user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\t/* Figure out what that file is really named. */\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (!stat(path, &st)) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\tfd = open(path, O_RDONLY | O_NOCTTY);\n\t}\n\tsave_errno = errno;\n\tif (pam_modutil_regain_priv(pamh, &privs)) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (fd >= 0) {\n\t\tif (!fstat(fd, &st)) {\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\terrno = EINVAL;\n\t\t\telse\n\t\t\t\tfp = fdopen(fd, \"r\");\n\t\t}\n\t\tif (!fp) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(fd);\n\t\t}\n\t}\n\tif (fp) {\n\t\tchar buf[LINE_MAX], *tmp;\n\t\t/* Scan the file for a list of specs of users to \"trust\". */\n\t\twhile (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\ttmp = memchr(buf, '\\r', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\ttmp = memchr(buf, '\\n', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\tif (fnmatch(buf, other_user, 0) == 0) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s %s allowed by %s\",\n\t\t\t\t\t\t   other_user, sense, path);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t\t/* If there's no match in the file, we fail. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s not listed in %s\",\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t\t/* Default to okay if the file doesn't exist. */\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <selinux/label.h>",
            "#include <selinux/selinux.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <grp.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PATH_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define PATH_MAX 4096\n\nstatic int\ncheck_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n\tFILE *fp = NULL;\n\tint i, fd = -1, save_errno;\n\tstruct stat st;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Check this user's <sense> file. */\n\tpwd = pam_modutil_getpwnam(pamh, this_user);\n\tif (pwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining home directory for '%s'\",\n\t\t\t   this_user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\t/* Figure out what that file is really named. */\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (!stat(path, &st)) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\tfd = open(path, O_RDONLY | O_NOCTTY);\n\t}\n\tsave_errno = errno;\n\tif (pam_modutil_regain_priv(pamh, &privs)) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (fd >= 0) {\n\t\tif (!fstat(fd, &st)) {\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\terrno = EINVAL;\n\t\t\telse\n\t\t\t\tfp = fdopen(fd, \"r\");\n\t\t}\n\t\tif (!fp) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(fd);\n\t\t}\n\t}\n\tif (fp) {\n\t\tchar buf[LINE_MAX], *tmp;\n\t\t/* Scan the file for a list of specs of users to \"trust\". */\n\t\twhile (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\ttmp = memchr(buf, '\\r', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\ttmp = memchr(buf, '\\n', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\tif (fnmatch(buf, other_user, 0) == 0) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s %s allowed by %s\",\n\t\t\t\t\t\t   other_user, sense, path);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t\t/* If there's no match in the file, we fail. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s not listed in %s\",\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t\t/* Default to okay if the file doesn't exist. */\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rpwd->pw_name",
            "tpwd->pw_name"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"not forwarding cookies to user ID %lu\"",
            "(unsigned long) tpwd->pw_uid"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"requesting user %lu/%lu, target user %lu/%lu\"",
            "(unsigned long) rpwd->pw_uid",
            "(unsigned long) rpwd->pw_gid",
            "(unsigned long) tpwd->pw_uid",
            "(unsigned long) tpwd->pw_gid"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"error determining target user's UID\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error determining invoking user's name\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwuid",
          "args": [
            "pamh",
            "getuid()"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user has no DISPLAY, doing nothing\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "xauthpaths[j]",
            "X_OK"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "login_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "325-425",
          "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAM_ARRAY_SIZE",
          "args": [
            "xauthpaths"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"unrecognized option `%s'\"",
            "argv[i]"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"invalid value for systemuser (`%s')\"",
            "argv[i] + 11"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&tmp",
            "10"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"systemuser=\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"invalid value for targetuser (`%s')\"",
            "argv[i] + 11"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&tmp",
            "10"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"targetuser=\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"xauthpath=\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define XAUTHTMP \".xauthXXXXXX\"\n#define XAUTHDEF \".Xauthority\"\n#define XAUTHENV \"XAUTHORITY\"\n#define DATANAME \"pam_xauth_cookie_file\"\n\nstatic const char * const xauthpaths[] = {\n#ifdef PAM_PATH_XAUTH\n\tPAM_PATH_XAUTH,\n#endif\n\t\"/usr/X11R6/bin/xauth\",\n\t\"/usr/bin/xauth\",\n\t\"/usr/bin/X11/xauth\"\n};\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n\tchar *cookiefile = NULL, *xauthority = NULL,\n\t     *cookie = NULL, *display = NULL, *tmp = NULL,\n\t     *xauthlocalhostname = NULL;\n\tconst char *user, *xauth = NULL;\n\tstruct passwd *tpwd, *rpwd;\n\tint fd, i, debug = 0;\n\tint retval = PAM_SUCCESS;\n\tuid_t systemuser = 499, targetuser = 0;\n\n\t/* Parse arguments.  We don't understand many, so no sense in breaking\n\t * this into a separate function. */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"xauthpath=\")) != NULL) {\n\t\t\txauth = str;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"targetuser=\")) != NULL) {\n\t\t\tlong l = strtol(str, &tmp, 10);\n\t\t\tif ((*str != '\\0') && (*tmp == '\\0')) {\n\t\t\t\ttargetuser = l;\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t   \"invalid value for targetuser (`%s')\",\n\t\t\t\t\t   argv[i] + 11);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"systemuser=\")) != NULL) {\n\t\t\tlong l = strtol(str, &tmp, 10);\n\t\t\tif ((*str != '\\0') && (*tmp == '\\0')) {\n\t\t\t\tsystemuser = l;\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t   \"invalid value for systemuser (`%s')\",\n\t\t\t\t\t   argv[i] + 11);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tpam_syslog(pamh, LOG_WARNING, \"unrecognized option `%s'\",\n\t\t\t   argv[i]);\n\t}\n\n\tif (xauth == NULL) {\n\t        size_t j;\n\t\tfor (j = 0; j < PAM_ARRAY_SIZE(xauthpaths); j++) {\n\t\t\tif (access(xauthpaths[j], X_OK) == 0) {\n\t\t\t\txauth = xauthpaths[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (xauth == NULL) {\n\t\t\t/* xauth executable not found - nothing to do */\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t}\n\n\t/* If DISPLAY isn't set, we don't really care, now do we? */\n\tif ((display = getenv(\"DISPLAY\")) == NULL) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"user has no DISPLAY, doing nothing\");\n\t\t}\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/* Read the target user's name. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\trpwd = pam_modutil_getpwuid(pamh, getuid());\n\tif (rpwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining invoking user's name\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the target user's UID and primary GID, which we'll need to set\n\t * on the xauthority file we create later on. */\n\ttpwd = pam_modutil_getpwnam(pamh, user);\n\tif (tpwd == NULL) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t   \"error determining target user's UID\");\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"requesting user %lu/%lu, target user %lu/%lu\",\n\t\t\t   (unsigned long) rpwd->pw_uid,\n\t\t\t   (unsigned long) rpwd->pw_gid,\n\t\t\t   (unsigned long) tpwd->pw_uid,\n\t\t\t   (unsigned long) tpwd->pw_gid);\n\t}\n\n\t/* If the UID is a system account (and not the superuser), forget\n\t * about forwarding keys. */\n\tif ((tpwd->pw_uid != 0) &&\n\t    (tpwd->pw_uid != targetuser) &&\n\t    (tpwd->pw_uid <= systemuser)) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"not forwarding cookies to user ID %lu\",\n\t\t\t\t   (unsigned long) tpwd->pw_uid);\n\t\t}\n\t\tretval = PAM_SESSION_ERR;\n\t\tgoto cleanup;\n\t}\n\n\n\t/* If current user and the target user are the same, don't\n\t   check the ACL list, but forward X11 */\n\tif (strcmp (rpwd->pw_name, tpwd->pw_name) != 0) {\n\n\t  /* Check that both users are amenable to this.  By default, this\n\t   * boils down to this policy:\n\t   * export(ruser=root): only if <user> is listed in .xauth/export\n\t   * export(ruser=*) if <user> is listed in .xauth/export, or\n\t   *                 if .xauth/export does not exist\n\t   * import(user=*): if <ruser> is listed in .xauth/import, or\n\t   *                 if .xauth/import does not exist */\n\t  i = (getuid() != 0 || tpwd->pw_uid == 0) ? PAM_SUCCESS : PAM_PERM_DENIED;\n\t  i = check_acl(pamh, \"export\", rpwd->pw_name, user, i, debug);\n\t  if (i != PAM_SUCCESS) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto cleanup;\n\t  }\n\t  i = PAM_SUCCESS;\n\t  i = check_acl(pamh, \"import\", user, rpwd->pw_name, i, debug);\n\t  if (i != PAM_SUCCESS) {\n\t    retval = PAM_SESSION_ERR;\n\t    goto cleanup;\n\t  }\n\t}  else {\n\t  if (debug)\n\t    pam_syslog (pamh, LOG_DEBUG, \"current and target user are the same, forward X11\");\n\t}\n\n\t/* Figure out where the source user's .Xauthority file is. */\n\tif (getenv(XAUTHENV) != NULL) {\n\t\tcookiefile = strdup(getenv(XAUTHENV));\n\t} else {\n\t\tcookiefile = malloc(strlen(rpwd->pw_dir) + 1 +\n\t\t\t\t    strlen(XAUTHDEF) + 1);\n\t\tif (cookiefile == NULL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tstrcpy(cookiefile, rpwd->pw_dir);\n\t\tstrcat(cookiefile, \"/\");\n\t\tstrcat(cookiefile, XAUTHDEF);\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"reading keys from `%s'\",\n\t\t\t   cookiefile);\n\t}\n\n\t/* Read the user's .Xauthority file.  Because the current UID is\n\t * the original user's UID, this will only fail if something has\n\t * gone wrong, or we have no cookies. */\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"running \\\"%s %s %s %s %s\\\" as %lu/%lu\",\n\t\t\t   xauth, \"-f\", cookiefile, \"nlist\", display,\n\t\t\t   (unsigned long) getuid(), (unsigned long) getgid());\n\t}\n\tif (run_coprocess(pamh, NULL, &cookie,\n\t\t\t  getuid(), getgid(),\n\t\t\t  xauth, \"-f\", cookiefile, \"nlist\", display,\n\t\t\t  NULL) == 0) {\n#ifdef WITH_SELINUX\n\t\tchar *context_raw = NULL;\n#endif\n\t\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t\t/* Check that we got a cookie.  If not, we get creative. */\n\t\tif (((cookie == NULL) || (strlen(cookie) == 0)) &&\n\t\t    (pam_str_skip_prefix(display, \"localhost:\") != NULL ||\n\t\t     pam_str_skip_prefix(display, \"localhost/unix:\") != NULL)) {\n\t\t\tchar *t, *screen;\n\t\t\tsize_t tlen, slen;\n\t\t\t/* Free the useless cookie string. */\n\t\t\tif (cookie != NULL) {\n\t\t\t\tfree(cookie);\n\t\t\t\tcookie = NULL;\n\t\t\t}\n\t\t\t/* Allocate enough space to hold an adjusted name. */\n\t\t\ttlen = strlen(display) + LINE_MAX + 1;\n\t\t\tt = malloc(tlen);\n\t\t\tif (t != NULL) {\n\t\t\t\tmemset(t, 0, tlen);\n\t\t\t\tif (gethostname(t, tlen - 1) != -1) {\n\t\t\t\t\t/* Append the protocol and then the\n\t\t\t\t\t * screen number. */\n\t\t\t\t\tif (strlen(t) < tlen - 6) {\n\t\t\t\t\t\tstrcat(t, \"/unix:\");\n\t\t\t\t\t}\n\t\t\t\t\tscreen = strchr(display, ':');\n\t\t\t\t\tif (screen != NULL) {\n\t\t\t\t\t\tscreen++;\n\t\t\t\t\t\tslen = strlen(screen);\n\t\t\t\t\t\tif (strlen(t) + slen < tlen) {\n\t\t\t\t\t\t\tstrcat(t, screen);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t\t   \"no key for `%s', \"\n\t\t\t\t\t\t\t   \"trying `%s'\",\n\t\t\t\t\t\t\t   display, t);\n\t\t\t\t\t}\n\t\t\t\t\t/* Read the cookie for this display. */\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t       \"running \"\n\t\t\t\t\t\t       \"\\\"%s %s %s %s %s\\\" as \"\n\t\t\t\t\t\t       \"%lu/%lu\",\n\t\t\t\t\t\t       xauth,\n\t\t\t\t\t\t       \"-f\",\n\t\t\t\t\t\t       cookiefile,\n\t\t\t\t\t\t       \"nlist\",\n\t\t\t\t\t\t       t,\n\t\t\t\t\t\t       (unsigned long) getuid(),\n\t\t\t\t\t\t       (unsigned long) getgid());\n\t\t\t\t\t}\n\t\t\t\t\trun_coprocess(pamh, NULL, &cookie,\n\t\t\t\t\t\t      getuid(), getgid(),\n\t\t\t\t\t\t      xauth, \"-f\", cookiefile,\n\t\t\t\t\t\t      \"nlist\", t, NULL);\n\t\t\t\t}\n\t\t\t\tfree(t);\n\t\t\t\tt = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we got a cookie, this time for real. */\n\t\tif ((cookie == NULL) || (strlen(cookie) == 0)) {\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"no key\");\n\t\t\t}\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate the environment variable\n\t\t * \"XAUTHORITY=<homedir>/filename\". */\n\t\tif (asprintf(&xauthority, \"%s=%s/%s\",\n\t\t\t     XAUTHENV, tpwd->pw_dir, XAUTHTMP) < 0) {\n\t\t\txauthority = NULL;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"out of memory\");\n\t\t\t}\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate a new file to hold the data. */\n\t\tif (pam_modutil_drop_priv(pamh, &privs, tpwd)) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n#ifdef WITH_SELINUX\n\t\tif (is_selinux_enabled() > 0) {\n\t\t\tstruct selabel_handle *ctx = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\t\t\tif (ctx != NULL) {\n\t\t\t\tif (selabel_lookup_raw(ctx, &context_raw,\n\t\t\t\t\t\t       xauthority + sizeof(XAUTHENV), S_IFREG) != 0) {\n\t\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t\t   \"could not get SELinux label for '%s'\",\n\t\t\t\t\t\t   xauthority + sizeof(XAUTHENV));\n\t\t\t\t}\n\t\t\t\tselabel_close(ctx);\n\t\t\t\tif (setfscreatecon_raw(context_raw)) {\n\t\t\t\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t\t\t\t\t   \"setfscreatecon_raw(%s) failed: %m\", context_raw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* WITH_SELINUX */\n\t\tfd = mkstemp(xauthority + sizeof(XAUTHENV));\n\t\tif (fd < 0)\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"error creating temporary file `%s': %m\",\n\t\t\t\t   xauthority + sizeof(XAUTHENV));\n#ifdef WITH_SELINUX\n\t\tif (context_raw != NULL) {\n\t\t\tfree(context_raw);\n\t\t\tsetfscreatecon_raw(NULL);\n\t\t}\n#endif /* WITH_SELINUX */\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tif (pam_modutil_regain_priv(pamh, &privs) || fd < 0) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Get a copy of the filename to save as a data item for\n\t\t * removal at session-close time. */\n\t\tfree(cookiefile);\n\t\tcookiefile = strdup(xauthority + sizeof(XAUTHENV));\n\n\t\t/* Save the filename. */\n\t\tif (pam_set_data(pamh, DATANAME, cookiefile, cleanup) != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"error saving name of temporary file `%s'\",\n\t\t\t\t   cookiefile);\n\t\t\tunlink(cookiefile);\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Set the new variable in the environment. */\n\t\tif (pam_putenv (pamh, xauthority) != PAM_SUCCESS)\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t   \"can't set environment variable '%s'\",\n\t\t\t\t   xauthority);\n\t\tputenv (xauthority); /* The environment owns this string now. */\n\t\txauthority = NULL; /* Don't free environment variables. */\n\n\t\t/* set $DISPLAY in pam handle to make su - work */\n\t\t{\n\t\t  char *d;\n\n\t\t  if (asprintf(&d, \"DISPLAY=%s\", display) < 0)\n\t\t    {\n\t\t      pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t      cookiefile = NULL;\n\t\t      retval = PAM_SESSION_ERR;\n\t\t      goto cleanup;\n\t\t    }\n\n\t\t  if (pam_putenv (pamh, d) != PAM_SUCCESS)\n\t\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\t\"can't set environment variable '%s'\", d);\n\t\t  free (d);\n\t\t}\n\n\t\t/* set XAUTHLOCALHOSTNAME to make sure that su - work under gnome */\n\t\tif ((xauthlocalhostname = getenv(\"XAUTHLOCALHOSTNAME\")) != NULL) {\n\t\t  char *d;\n\n\t\t  if (asprintf(&d, \"XAUTHLOCALHOSTNAME=%s\", xauthlocalhostname) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_SESSION_ERR;\n\t\t    goto cleanup;\n\t\t  }\n\n\t\t  if (pam_putenv (pamh, d) != PAM_SUCCESS)\n\t\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\t\"can't set environment variable '%s'\", d);\n\t\t  free (d);\n\t\t}\n\n\t\t/* Merge the cookie we read before into the new file. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t   \"writing key `%s' to temporary file `%s'\",\n\t\t\t\t   cookie, cookiefile);\n\t\t}\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t  \"running \\\"%s %s %s %s %s\\\" as %lu/%lu\",\n\t\t\t\t  xauth, \"-f\", cookiefile, \"nmerge\", \"-\",\n\t\t\t\t  (unsigned long) tpwd->pw_uid,\n\t\t\t\t  (unsigned long) tpwd->pw_gid);\n\t\t}\n\t\trun_coprocess(pamh, cookie, &tmp,\n\t\t\t      tpwd->pw_uid, tpwd->pw_gid,\n\t\t\t      xauth, \"-f\", cookiefile, \"nmerge\", \"-\", NULL);\n\n\t\t/* We don't need to keep a copy of these around any more. */\n\t\tcookiefile = NULL;\n\t\tfree(tmp);\n\t}\ncleanup:\n\t/* Unset any old XAUTHORITY variable in the environment. */\n\tif (retval != PAM_SUCCESS && getenv (XAUTHENV))\n\t\tunsetenv (XAUTHENV);\n\tfree(cookiefile);\n\tfree(cookie);\n\tfree(xauthority);\n\treturn retval;\n}"
  },
  {
    "function_name": "check_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
    "lines": "240-349",
    "snippet": "static int\ncheck_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n\tFILE *fp = NULL;\n\tint i, fd = -1, save_errno;\n\tstruct stat st;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Check this user's <sense> file. */\n\tpwd = pam_modutil_getpwnam(pamh, this_user);\n\tif (pwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining home directory for '%s'\",\n\t\t\t   this_user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\t/* Figure out what that file is really named. */\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (!stat(path, &st)) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\tfd = open(path, O_RDONLY | O_NOCTTY);\n\t}\n\tsave_errno = errno;\n\tif (pam_modutil_regain_priv(pamh, &privs)) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (fd >= 0) {\n\t\tif (!fstat(fd, &st)) {\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\terrno = EINVAL;\n\t\t\telse\n\t\t\t\tfp = fdopen(fd, \"r\");\n\t\t}\n\t\tif (!fp) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(fd);\n\t\t}\n\t}\n\tif (fp) {\n\t\tchar buf[LINE_MAX], *tmp;\n\t\t/* Scan the file for a list of specs of users to \"trust\". */\n\t\twhile (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\ttmp = memchr(buf, '\\r', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\ttmp = memchr(buf, '\\n', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\tif (fnmatch(buf, other_user, 0) == 0) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s %s allowed by %s\",\n\t\t\t\t\t\t   other_user, sense, path);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t\t/* If there's no match in the file, we fail. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s not listed in %s\",\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t\t/* Default to okay if the file doesn't exist. */\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <selinux/label.h>",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <grp.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PATH_MAX 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"error opening %s: %m\"",
            "path"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s does not exist, failing\"",
            "path"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s does not exist, ignoring\"",
            "path"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s not listed in %s\"",
            "other_user",
            "path"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s %s allowed by %s\"",
            "other_user",
            "sense",
            "path"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnmatch",
          "args": [
            "buf",
            "other_user",
            "0"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "sizeof(buf)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\r'",
            "sizeof(buf)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "fp"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"r\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY | O_NOCTTY"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "&privs",
            "pwd"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"name of user's home directory is too long\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/.xauth/%s\"",
            "pwd->pw_dir",
            "sense"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error determining home directory for '%s'\"",
            "this_user"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "this_user"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define PATH_MAX 4096\n\nstatic int\ncheck_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n\tFILE *fp = NULL;\n\tint i, fd = -1, save_errno;\n\tstruct stat st;\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\t/* Check this user's <sense> file. */\n\tpwd = pam_modutil_getpwnam(pamh, this_user);\n\tif (pwd == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"error determining home directory for '%s'\",\n\t\t\t   this_user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\t/* Figure out what that file is really named. */\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (pam_modutil_drop_priv(pamh, &privs, pwd))\n\t\treturn PAM_SESSION_ERR;\n\tif (!stat(path, &st)) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\tfd = open(path, O_RDONLY | O_NOCTTY);\n\t}\n\tsave_errno = errno;\n\tif (pam_modutil_regain_priv(pamh, &privs)) {\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tif (fd >= 0) {\n\t\tif (!fstat(fd, &st)) {\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\terrno = EINVAL;\n\t\t\telse\n\t\t\t\tfp = fdopen(fd, \"r\");\n\t\t}\n\t\tif (!fp) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(fd);\n\t\t}\n\t}\n\tif (fp) {\n\t\tchar buf[LINE_MAX], *tmp;\n\t\t/* Scan the file for a list of specs of users to \"trust\". */\n\t\twhile (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\ttmp = memchr(buf, '\\r', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\ttmp = memchr(buf, '\\n', sizeof(buf));\n\t\t\tif (tmp != NULL) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t}\n\t\t\tif (fnmatch(buf, other_user, 0) == 0) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s %s allowed by %s\",\n\t\t\t\t\t\t   other_user, sense, path);\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t\t/* If there's no match in the file, we fail. */\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s not listed in %s\",\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t\t/* Default to okay if the file doesn't exist. */\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
    "lines": "232-236",
    "snippet": "static void\ncleanup (pam_handle_t *pamh UNUSED, void *data, int err UNUSED)\n{\n\tfree (data);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <selinux/label.h>",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <grp.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\ncleanup (pam_handle_t *pamh UNUSED, void *data, int err UNUSED)\n{\n\tfree (data);\n}"
  },
  {
    "function_name": "run_coprocess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_xauth/pam_xauth.c",
    "lines": "92-229",
    "snippet": "static int\nrun_coprocess(pam_handle_t *pamh, const char *input, char **output,\n\t      uid_t uid, gid_t gid, const char *command, ...)\n{\n\tint ipipe[2], opipe[2], i;\n\tchar buf[LINE_MAX];\n\tpid_t child;\n\tchar *buffer = NULL;\n\tsize_t buffer_size = 0;\n\tva_list ap;\n\n\t*output = NULL;\n\n\t/* Create stdio pipery. */\n\tif (pipe(ipipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\treturn -1;\n\t}\n\tif (pipe(opipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\treturn -1;\n\t}\n\n\t/* Fork off a child. */\n\tchild = fork();\n\tif (child == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not fork: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\tclose(opipe[0]);\n\t\tclose(opipe[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) {\n\t\t/* We're the child. */\n\t\tsize_t j;\n\t\tconst char *args[10];\n\t\t/* Drop privileges. */\n\t\tif (setgid(gid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) getegid ());\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setgroups(0, NULL) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgroups() failed: %m\");\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setuid(uid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) geteuid ());\n\t\t    _exit (err);\n\t\t  }\n\t\t/* Set the pipe descriptors up as stdin and stdout, and close\n\t\t * everything else, including the original values for the\n\t\t * descriptors. */\n\t\tif (dup2(ipipe[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (dup2(opipe[1], STDOUT_FILENO) != STDOUT_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_NULL_FD) < 0) {\n\t\t    _exit(1);\n\t\t}\n\t\t/* Initialize the argument list. */\n\t\tmemset(args, 0, sizeof(args));\n\t\t/* Convert the varargs list into a regular array of strings. */\n\t\tva_start(ap, command);\n\t\targs[0] = command;\n\t\tfor (j = 1; j < PAM_ARRAY_SIZE(args) - 1; j++) {\n\t\t\targs[j] = va_arg(ap, const char*);\n\t\t\tif (args[j] == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Run the command. */\n\t\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\t\texecv(command, (char *const *) args);\n\t\tDIAG_POP_IGNORE_CAST_QUAL;\n\t\t/* Never reached. */\n\t\t_exit(1);\n\t}\n\n\t/* We're the parent, so close the other ends of the pipes. */\n\tclose(opipe[1]);\n\t/* Send input to the process (if we have any), then send an EOF. */\n\tif (input) {\n\t\t(void)pam_modutil_write(ipipe[1], input, strlen(input));\n\t}\n\tclose(ipipe[0]); /* close here to avoid possible SIGPIPE above */\n\tclose(ipipe[1]);\n\n\t/* Read data output until we run out of stuff to read. */\n\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\twhile ((i != 0) && (i != -1)) {\n\t\tchar *tmp;\n\t\t/* Resize the buffer to hold the data. */\n\t\ttmp = realloc(buffer, buffer_size + i + 1);\n\t\tif (tmp == NULL) {\n\t\t\t/* Uh-oh, bail. */\n\t\t\tif (buffer != NULL) {\n\t\t\t\tfree(buffer);\n\t\t\t}\n\t\t\tclose(opipe[0]);\n\t\t\twaitpid(child, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Save the new buffer location, copy the newly-read data into\n\t\t * the buffer, and make sure the result will be\n\t\t * nul-terminated. */\n\t\tbuffer = tmp;\n\t\tmemcpy(buffer + buffer_size, buf, i);\n\t\tbuffer[buffer_size + i] = '\\0';\n\t\tbuffer_size += i;\n\t\t/* Try to read again. */\n\t\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\t}\n\t/* No more data.  Clean up and return data. */\n\tclose(opipe[0]);\n\t*output = buffer;\n\twaitpid(child, NULL, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <selinux/label.h>",
      "#include <selinux/selinux.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <grp.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opipe[0]"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "opipe[0]",
            "buf",
            "sizeof(buf)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + buffer_size",
            "buf",
            "i"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opipe[0]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "buffer",
            "buffer_size + i + 1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "opipe[0]",
            "buf",
            "sizeof(buf)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[1]"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[0]"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "ipipe[1]",
            "input",
            "strlen(input)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "input"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opipe[1]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "command",
            "(char *const *) args"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ap",
            "constchar*"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_ARRAY_SIZE",
          "args": [
            "args"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "command"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "args",
            "0",
            "sizeof(args)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_NULL_FD"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdout\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "opipe[1]",
            "STDOUT_FILENO"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdin\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "ipipe[0]",
            "STDIN_FILENO"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setuid(%lu) failed: %m\"",
            "(unsigned long) geteuid ()"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "uid"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setgroups() failed: %m\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "err"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setgid(%lu) failed: %m\"",
            "(unsigned long) getegid ()"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "gid"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opipe[1]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opipe[0]"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[1]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[0]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not fork: %m\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[1]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipipe[0]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not create pipe: %m\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "opipe"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not create pipe: %m\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "ipipe"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <limits.h>\n#include <grp.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic int\nrun_coprocess(pam_handle_t *pamh, const char *input, char **output,\n\t      uid_t uid, gid_t gid, const char *command, ...)\n{\n\tint ipipe[2], opipe[2], i;\n\tchar buf[LINE_MAX];\n\tpid_t child;\n\tchar *buffer = NULL;\n\tsize_t buffer_size = 0;\n\tva_list ap;\n\n\t*output = NULL;\n\n\t/* Create stdio pipery. */\n\tif (pipe(ipipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\treturn -1;\n\t}\n\tif (pipe(opipe) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not create pipe: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\treturn -1;\n\t}\n\n\t/* Fork off a child. */\n\tchild = fork();\n\tif (child == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Could not fork: %m\");\n\t\tclose(ipipe[0]);\n\t\tclose(ipipe[1]);\n\t\tclose(opipe[0]);\n\t\tclose(opipe[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) {\n\t\t/* We're the child. */\n\t\tsize_t j;\n\t\tconst char *args[10];\n\t\t/* Drop privileges. */\n\t\tif (setgid(gid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) getegid ());\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setgroups(0, NULL) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setgroups() failed: %m\");\n\t\t    _exit (err);\n\t\t  }\n\t\tif (setuid(uid) == -1)\n\t\t  {\n\t\t    int err = errno;\n\t\t    pam_syslog (pamh, LOG_ERR, \"setuid(%lu) failed: %m\",\n\t\t\t\t(unsigned long) geteuid ());\n\t\t    _exit (err);\n\t\t  }\n\t\t/* Set the pipe descriptors up as stdin and stdout, and close\n\t\t * everything else, including the original values for the\n\t\t * descriptors. */\n\t\tif (dup2(ipipe[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (dup2(opipe[1], STDOUT_FILENO) != STDOUT_FILENO) {\n\t\t    int err = errno;\n\t\t    pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n\t\t    _exit(err);\n\t\t}\n\t\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t\t    PAM_MODUTIL_NULL_FD) < 0) {\n\t\t    _exit(1);\n\t\t}\n\t\t/* Initialize the argument list. */\n\t\tmemset(args, 0, sizeof(args));\n\t\t/* Convert the varargs list into a regular array of strings. */\n\t\tva_start(ap, command);\n\t\targs[0] = command;\n\t\tfor (j = 1; j < PAM_ARRAY_SIZE(args) - 1; j++) {\n\t\t\targs[j] = va_arg(ap, const char*);\n\t\t\tif (args[j] == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Run the command. */\n\t\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\t\texecv(command, (char *const *) args);\n\t\tDIAG_POP_IGNORE_CAST_QUAL;\n\t\t/* Never reached. */\n\t\t_exit(1);\n\t}\n\n\t/* We're the parent, so close the other ends of the pipes. */\n\tclose(opipe[1]);\n\t/* Send input to the process (if we have any), then send an EOF. */\n\tif (input) {\n\t\t(void)pam_modutil_write(ipipe[1], input, strlen(input));\n\t}\n\tclose(ipipe[0]); /* close here to avoid possible SIGPIPE above */\n\tclose(ipipe[1]);\n\n\t/* Read data output until we run out of stuff to read. */\n\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\twhile ((i != 0) && (i != -1)) {\n\t\tchar *tmp;\n\t\t/* Resize the buffer to hold the data. */\n\t\ttmp = realloc(buffer, buffer_size + i + 1);\n\t\tif (tmp == NULL) {\n\t\t\t/* Uh-oh, bail. */\n\t\t\tif (buffer != NULL) {\n\t\t\t\tfree(buffer);\n\t\t\t}\n\t\t\tclose(opipe[0]);\n\t\t\twaitpid(child, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Save the new buffer location, copy the newly-read data into\n\t\t * the buffer, and make sure the result will be\n\t\t * nul-terminated. */\n\t\tbuffer = tmp;\n\t\tmemcpy(buffer + buffer_size, buf, i);\n\t\tbuffer[buffer_size + i] = '\\0';\n\t\tbuffer_size += i;\n\t\t/* Try to read again. */\n\t\ti = pam_modutil_read(opipe[0], buf, sizeof(buf));\n\t}\n\t/* No more data.  Clean up and return data. */\n\tclose(opipe[0]);\n\t*output = buffer;\n\twaitpid(child, NULL, 0);\n\treturn 0;\n}"
  }
]