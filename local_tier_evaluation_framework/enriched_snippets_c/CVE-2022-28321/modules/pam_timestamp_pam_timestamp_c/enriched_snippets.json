[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "721-871",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint i, retval = 0, dflag = 0, kflag = 0;\n\tconst char *target_user = NULL, *user = NULL, *tty = NULL;\n\tstruct passwd *pwd;\n\tstruct timeval tv;\n\tfd_set write_fds;\n\tchar path[BUFLEN];\n\tstruct stat st;\n\n\t/* Check that there's nothing funny going on with stdio. */\n\tif ((fstat(STDIN_FILENO, &st) == -1) ||\n\t    (fstat(STDOUT_FILENO, &st) == -1) ||\n\t    (fstat(STDERR_FILENO, &st) == -1)) {\n\t\t/* Appropriate the \"no controlling tty\" error code. */\n\t\treturn 3;\n\t}\n\n\t/* Parse arguments. */\n\twhile ((i = getopt(argc, argv, \"dk\")) != -1) {\n\t\tswitch (i) {\n\t\t\tcase 'd':\n\t\t\t\tdflag++;\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tkflag++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, USAGE, argv[0]);\n\t\t\t\treturn 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Bail if both -k and -d are given together. */\n\tif ((kflag + dflag) > 1) {\n\t\tfprintf(stderr, USAGE, argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* Check that we're setuid. */\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"%s must be setuid root\\n\",\n\t\t\targv[0]);\n\t\tretval = 2;\n\t}\n\n\t/* Check that we have a controlling tty. */\n\ttty = ttyname(STDIN_FILENO);\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDOUT_FILENO);\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDERR_FILENO);\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = \"unknown\";\n\t}\n\n\t/* Get the name of the invoking (requesting) user. */\n\tpwd = getpwuid(getuid());\n\tif (pwd == NULL) {\n\t\tretval = 4;\n\t}\n\n\t/* Get the name of the target user. */\n\tuser = strdup(pwd->pw_name);\n\tif (user == NULL) {\n\t\tretval = 4;\n\t} else {\n\t\ttarget_user = (optind < argc) ? argv[optind] : user;\n\t\tif ((strchr(target_user, '.') != NULL) ||\n\t\t    (strchr(target_user, '/') != NULL) ||\n\t\t    (strchr(target_user, '%') != NULL)) {\n\t\t\tfprintf(stderr, \"unknown user: %s\\n\",\n\t\t\t\ttarget_user);\n\t\t\tretval = 4;\n\t\t}\n\t}\n\n\t/* Sanity check the tty to make sure we should be checking\n\t * for timestamps which pertain to it. */\n\tif (retval == 0) {\n\t\ttty = check_tty(tty);\n\t\tif (tty == NULL) {\n\t\t\tfprintf(stderr, \"invalid tty\\n\");\n\t\t\tretval = 6;\n\t\t}\n\t}\n\n\tdo {\n\t\t/* Sanity check the timestamp directory itself. */\n\t\tif (retval == 0) {\n\t\t\tif (check_dir_perms(NULL, TIMESTAMPDIR) != PAM_SUCCESS) {\n\t\t\t\tretval = 5;\n\t\t\t}\n\t\t}\n\n\t\tif (retval == 0) {\n\t\t\t/* Generate the name of the timestamp file. */\n\t\t\tformat_timestamp_name(path, sizeof(path), TIMESTAMPDIR,\n\t\t\t\t\t      tty, user, target_user);\n\t\t}\n\n\t\tif (retval == 0) {\n\t\t\tif (kflag) {\n\t\t\t\t/* Remove the timestamp. */\n\t\t\t\tif (lstat(path, &st) != -1) {\n\t\t\t\t\tretval = unlink(path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Check the timestamp. */\n\t\t\t\tif (lstat(path, &st) != -1) {\n\t\t\t\t\t/* Check oldest login against timestamp */\n\t\t\t\t\tif (check_login_time(user, st.st_mtime) != PAM_SUCCESS) {\n\t\t\t\t\t\tretval = 7;\n\t\t\t\t\t} else if (timestamp_good(st.st_mtime, time(NULL),\n\t\t\t\t\t\t\tDEFAULT_TIMESTAMP_TIMEOUT) != PAM_SUCCESS) {\n\t\t\t\t\t\tretval = 7;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tretval = 7;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dflag > 0) {\n\t\t\tstruct timeval now;\n\t\t\t/* Send the would-be-returned value to our parent. */\n\t\t\tsignal(SIGPIPE, SIG_DFL);\n\t\t\tfprintf(stdout, \"%d\\n\", retval);\n\t\t\tfflush(stdout);\n\t\t\t/* Wait. */\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttv.tv_sec = CHECK_INTERVAL;\n\t\t\t/* round the sleep time to get woken up on a whole second */\n\t\t\ttv.tv_usec = 1000000 - now.tv_usec;\n\t\t\tif (now.tv_usec < 500000)\n\t\t\t\ttv.tv_sec--;\n\t\t\tFD_ZERO(&write_fds);\n\t\t\tFD_SET(STDOUT_FILENO, &write_fds);\n\t\t\tselect(STDOUT_FILENO + 1,\n\t\t\t       NULL, NULL, &write_fds,\n\t\t\t       &tv);\n\t\t\tretval = 0;\n\t\t}\n\t} while (dflag > 0);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CHECK_INTERVAL 7",
      "#define USAGE \"Usage: %s [[-k] | [-d]] [target user]\\n\"",
      "#define BUFLEN PATH_MAX",
      "#define BUFLEN LINE_MAX",
      "#define TIMESTAMPDIR _PATH_VARRUN MODULE",
      "#define DEFAULT_TIMESTAMP_TIMEOUT (5 * 60)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "select",
          "args": [
            "STDOUT_FILENO + 1",
            "NULL",
            "NULL",
            "&write_fds",
            "&tv"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "STDOUT_FILENO",
            "&write_fds"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&write_fds"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&now",
            "NULL"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%d\\n\"",
            "retval"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_DFL"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_good",
          "args": [
            "st.st_mtime",
            "time(NULL)",
            "DEFAULT_TIMESTAMP_TIMEOUT"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_good",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "192-200",
          "snippet": "static int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_login_time",
          "args": [
            "user",
            "st.st_mtime"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&st"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&st"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_timestamp_name",
          "args": [
            "path",
            "sizeof(path)",
            "TIMESTAMPDIR",
            "tty",
            "user",
            "target_user"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "format_timestamp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "174-188",
          "snippet": "static int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_dir_perms",
          "args": [
            "NULL",
            "TIMESTAMPDIR"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "check_dir_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "90-146",
          "snippet": "static int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BUFLEN PATH_MAX",
            "#define BUFLEN LINE_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n\nstatic int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid tty\\n\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_tty",
          "args": [
            "tty"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "check_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "150-171",
          "snippet": "static const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown user: %s\\n\"",
            "target_user"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "target_user",
            "'%'"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "target_user",
            "'/'"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "target_user",
            "'.'"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pwd->pw_name"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s must be setuid root\\n\"",
            "argv[0]"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "USAGE",
            "argv[0]"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "USAGE",
            "argv[0]"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"dk\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "STDERR_FILENO",
            "&st"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "STDOUT_FILENO",
            "&st"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "STDIN_FILENO",
            "&st"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define CHECK_INTERVAL 7\n#define USAGE \"Usage: %s [[-k] | [-d]] [target user]\\n\"\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPDIR _PATH_VARRUN MODULE\n#define DEFAULT_TIMESTAMP_TIMEOUT (5 * 60)\n\nint\nmain(int argc, char **argv)\n{\n\tint i, retval = 0, dflag = 0, kflag = 0;\n\tconst char *target_user = NULL, *user = NULL, *tty = NULL;\n\tstruct passwd *pwd;\n\tstruct timeval tv;\n\tfd_set write_fds;\n\tchar path[BUFLEN];\n\tstruct stat st;\n\n\t/* Check that there's nothing funny going on with stdio. */\n\tif ((fstat(STDIN_FILENO, &st) == -1) ||\n\t    (fstat(STDOUT_FILENO, &st) == -1) ||\n\t    (fstat(STDERR_FILENO, &st) == -1)) {\n\t\t/* Appropriate the \"no controlling tty\" error code. */\n\t\treturn 3;\n\t}\n\n\t/* Parse arguments. */\n\twhile ((i = getopt(argc, argv, \"dk\")) != -1) {\n\t\tswitch (i) {\n\t\t\tcase 'd':\n\t\t\t\tdflag++;\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tkflag++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, USAGE, argv[0]);\n\t\t\t\treturn 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Bail if both -k and -d are given together. */\n\tif ((kflag + dflag) > 1) {\n\t\tfprintf(stderr, USAGE, argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* Check that we're setuid. */\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"%s must be setuid root\\n\",\n\t\t\targv[0]);\n\t\tretval = 2;\n\t}\n\n\t/* Check that we have a controlling tty. */\n\ttty = ttyname(STDIN_FILENO);\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDOUT_FILENO);\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDERR_FILENO);\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = \"unknown\";\n\t}\n\n\t/* Get the name of the invoking (requesting) user. */\n\tpwd = getpwuid(getuid());\n\tif (pwd == NULL) {\n\t\tretval = 4;\n\t}\n\n\t/* Get the name of the target user. */\n\tuser = strdup(pwd->pw_name);\n\tif (user == NULL) {\n\t\tretval = 4;\n\t} else {\n\t\ttarget_user = (optind < argc) ? argv[optind] : user;\n\t\tif ((strchr(target_user, '.') != NULL) ||\n\t\t    (strchr(target_user, '/') != NULL) ||\n\t\t    (strchr(target_user, '%') != NULL)) {\n\t\t\tfprintf(stderr, \"unknown user: %s\\n\",\n\t\t\t\ttarget_user);\n\t\t\tretval = 4;\n\t\t}\n\t}\n\n\t/* Sanity check the tty to make sure we should be checking\n\t * for timestamps which pertain to it. */\n\tif (retval == 0) {\n\t\ttty = check_tty(tty);\n\t\tif (tty == NULL) {\n\t\t\tfprintf(stderr, \"invalid tty\\n\");\n\t\t\tretval = 6;\n\t\t}\n\t}\n\n\tdo {\n\t\t/* Sanity check the timestamp directory itself. */\n\t\tif (retval == 0) {\n\t\t\tif (check_dir_perms(NULL, TIMESTAMPDIR) != PAM_SUCCESS) {\n\t\t\t\tretval = 5;\n\t\t\t}\n\t\t}\n\n\t\tif (retval == 0) {\n\t\t\t/* Generate the name of the timestamp file. */\n\t\t\tformat_timestamp_name(path, sizeof(path), TIMESTAMPDIR,\n\t\t\t\t\t      tty, user, target_user);\n\t\t}\n\n\t\tif (retval == 0) {\n\t\t\tif (kflag) {\n\t\t\t\t/* Remove the timestamp. */\n\t\t\t\tif (lstat(path, &st) != -1) {\n\t\t\t\t\tretval = unlink(path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Check the timestamp. */\n\t\t\t\tif (lstat(path, &st) != -1) {\n\t\t\t\t\t/* Check oldest login against timestamp */\n\t\t\t\t\tif (check_login_time(user, st.st_mtime) != PAM_SUCCESS) {\n\t\t\t\t\t\tretval = 7;\n\t\t\t\t\t} else if (timestamp_good(st.st_mtime, time(NULL),\n\t\t\t\t\t\t\tDEFAULT_TIMESTAMP_TIMEOUT) != PAM_SUCCESS) {\n\t\t\t\t\t\tretval = 7;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tretval = 7;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dflag > 0) {\n\t\t\tstruct timeval now;\n\t\t\t/* Send the would-be-returned value to our parent. */\n\t\t\tsignal(SIGPIPE, SIG_DFL);\n\t\t\tfprintf(stdout, \"%d\\n\", retval);\n\t\t\tfflush(stdout);\n\t\t\t/* Wait. */\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttv.tv_sec = CHECK_INTERVAL;\n\t\t\t/* round the sleep time to get woken up on a whole second */\n\t\t\ttv.tv_usec = 1000000 - now.tv_usec;\n\t\t\tif (now.tv_usec < 500000)\n\t\t\t\ttv.tv_sec--;\n\t\t\tFD_ZERO(&write_fds);\n\t\t\tFD_SET(STDOUT_FILENO, &write_fds);\n\t\t\tselect(STDOUT_FILENO + 1,\n\t\t\t       NULL, NULL, &write_fds,\n\t\t\t       &tv);\n\t\t\tretval = 0;\n\t\t}\n\t} while (dflag > 0);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "710-714",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED, int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nint\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED, int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "579-708",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED, int argc, const char **argv)\n{\n\tchar path[BUFLEN], subdir[BUFLEN], *text, *p;\n\tvoid *mac;\n\tsize_t maclen;\n\ttime_t now;\n\tint fd, i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\n\t/* Get the name of the timestamp file. */\n\tif (get_timestamp_name(pamh, argc, argv,\n\t\t\t       path, sizeof(path)) != PAM_SUCCESS) {\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Create the directory for the timestamp file if it doesn't already\n\t * exist. */\n\tfor (i = 1; i < (int) sizeof(path) && path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\t/* Attempt to create the directory. */\n\t\t\tmemcpy(subdir, path, i);\n\t\t\tsubdir[i] = '\\0';\n\t\t\tif (mkdir(subdir, 0700) == 0) {\n\t\t\t\t/* Attempt to set the owner to the superuser. */\n\t\t\t        if (lchown(subdir, 0, 0) != 0) {\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t    \"error setting permissions on `%s': %m\",\n\t\t\t\t\t\t    subdir);\n\t\t\t\t\t}\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (errno != EEXIST) {\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t    \"error creating directory `%s': %m\",\n\t\t\t\t\t\t    subdir);\n\t\t\t\t\t}\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_OPENSSL\n\tif (hmac_size(pamh, debug, &maclen)) {\n\t\treturn PAM_SESSION_ERR;\n\t}\n#else\n\tmaclen = hmac_sha1_size();\n#endif /* WITH_OPENSSL */\n\n\t/* Generate the message. */\n\ttext = malloc(strlen(path) + 1 + sizeof(now) + maclen);\n\tif (text == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"unable to allocate memory: %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tp = text;\n\n\tstrcpy(text, path);\n\tp += strlen(path) + 1;\n\n\tnow = time(NULL);\n\tmemmove(p, &now, sizeof(now));\n\tp += sizeof(now);\n\n\t/* Generate the MAC and append it to the plaintext. */\n#ifdef WITH_OPENSSL\n\tif (hmac_generate(pamh, debug, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t  ROOT_USER, ROOT_GROUP, text, p - text)) {\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n#else\n\thmac_sha1_generate_file(pamh, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\tROOT_USER, ROOT_GROUP, text, p - text);\n\tif (mac == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR, \"failure generating MAC: %m\");\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n#endif /* WITH_OPENSSL */\n\tmemmove(p, mac, maclen);\n\tp += maclen;\n\tfree(mac);\n\n\t/* Open the file. */\n\tfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n\tif (fd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"unable to open `%s': %m\", path);\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Attempt to set the owner to the superuser. */\n\tif (fchown(fd, 0, 0) != 0) {\n\t  if (debug) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"error setting ownership of `%s': %m\",\n\t\t       path);\n\t  }\n\t  close(fd);\n\t  free(text);\n\t  return PAM_SESSION_ERR;\n\t}\n\n\n\t/* Write the timestamp to the file. */\n\tif (write(fd, text, p - text) != p - text) {\n\t\tpam_syslog(pamh, LOG_ERR, \"unable to write to `%s': %m\", path);\n\t\tclose(fd);\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Close the file and return successfully. */\n\tclose(fd);\n\tfree(text);\n\tpam_syslog(pamh, LOG_DEBUG, \"updated timestamp file `%s'\", path);\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define ROOT_GROUP \t0",
      "#define ROOT_USER \t0",
      "#define BUFLEN PATH_MAX",
      "#define BUFLEN LINE_MAX",
      "#define TIMESTAMPKEY TIMESTAMPDIR \"/_pam_timestamp_key\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"updated timestamp file `%s'\"",
            "path"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "text"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to write to `%s': %m\"",
            "path"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "text",
            "p - text"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"error setting ownership of `%s': %m\"",
            "path"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "0",
            "0"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to open `%s': %m\"",
            "path"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "mac",
            "maclen"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failure generating MAC: %m\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_sha1_generate_file",
          "args": [
            "pamh",
            "&mac",
            "&maclen",
            "TIMESTAMPKEY",
            "ROOT_USER",
            "ROOT_GROUP",
            "text",
            "p - text"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_sha1_generate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "268-289",
          "snippet": "void\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE\n\nvoid\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmac_generate",
          "args": [
            "pamh",
            "debug",
            "&mac",
            "&maclen",
            "TIMESTAMPKEY",
            "ROOT_USER",
            "ROOT_GROUP",
            "text",
            "p - text"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "361-379",
          "snippet": "int\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "&now",
            "sizeof(now)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "text",
            "path"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"unable to allocate memory: %m\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(path) + 1 + sizeof(now) + maclen"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_sha1_size",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_sha1_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "291-295",
          "snippet": "size_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nsize_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmac_size",
          "args": [
            "pamh",
            "debug",
            "&maclen"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "311-359",
          "snippet": "int\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"error creating directory `%s': %m\"",
            "subdir"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"error setting permissions on `%s': %m\"",
            "subdir"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lchown",
          "args": [
            "subdir",
            "0",
            "0"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "subdir",
            "0700"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "subdir",
            "path",
            "i"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp_name",
          "args": [
            "pamh",
            "argc",
            "argv",
            "path",
            "sizeof(path)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "273-355",
          "snippet": "static int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BUFLEN PATH_MAX",
            "#define BUFLEN LINE_MAX",
            "#define TIMESTAMPDIR _PATH_VARRUN MODULE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPDIR _PATH_VARRUN MODULE\n\nstatic int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define ROOT_GROUP \t0\n#define ROOT_USER \t0\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPKEY TIMESTAMPDIR \"/_pam_timestamp_key\"\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED, int argc, const char **argv)\n{\n\tchar path[BUFLEN], subdir[BUFLEN], *text, *p;\n\tvoid *mac;\n\tsize_t maclen;\n\ttime_t now;\n\tint fd, i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\n\t/* Get the name of the timestamp file. */\n\tif (get_timestamp_name(pamh, argc, argv,\n\t\t\t       path, sizeof(path)) != PAM_SUCCESS) {\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Create the directory for the timestamp file if it doesn't already\n\t * exist. */\n\tfor (i = 1; i < (int) sizeof(path) && path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\t/* Attempt to create the directory. */\n\t\t\tmemcpy(subdir, path, i);\n\t\t\tsubdir[i] = '\\0';\n\t\t\tif (mkdir(subdir, 0700) == 0) {\n\t\t\t\t/* Attempt to set the owner to the superuser. */\n\t\t\t        if (lchown(subdir, 0, 0) != 0) {\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t    \"error setting permissions on `%s': %m\",\n\t\t\t\t\t\t    subdir);\n\t\t\t\t\t}\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (errno != EEXIST) {\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t    \"error creating directory `%s': %m\",\n\t\t\t\t\t\t    subdir);\n\t\t\t\t\t}\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_OPENSSL\n\tif (hmac_size(pamh, debug, &maclen)) {\n\t\treturn PAM_SESSION_ERR;\n\t}\n#else\n\tmaclen = hmac_sha1_size();\n#endif /* WITH_OPENSSL */\n\n\t/* Generate the message. */\n\ttext = malloc(strlen(path) + 1 + sizeof(now) + maclen);\n\tif (text == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"unable to allocate memory: %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tp = text;\n\n\tstrcpy(text, path);\n\tp += strlen(path) + 1;\n\n\tnow = time(NULL);\n\tmemmove(p, &now, sizeof(now));\n\tp += sizeof(now);\n\n\t/* Generate the MAC and append it to the plaintext. */\n#ifdef WITH_OPENSSL\n\tif (hmac_generate(pamh, debug, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t  ROOT_USER, ROOT_GROUP, text, p - text)) {\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n#else\n\thmac_sha1_generate_file(pamh, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\tROOT_USER, ROOT_GROUP, text, p - text);\n\tif (mac == NULL) {\n\t\tpam_syslog(pamh, LOG_ERR, \"failure generating MAC: %m\");\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n#endif /* WITH_OPENSSL */\n\tmemmove(p, mac, maclen);\n\tp += maclen;\n\tfree(mac);\n\n\t/* Open the file. */\n\tfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n\tif (fd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"unable to open `%s': %m\", path);\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Attempt to set the owner to the superuser. */\n\tif (fchown(fd, 0, 0) != 0) {\n\t  if (debug) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"error setting ownership of `%s': %m\",\n\t\t       path);\n\t  }\n\t  close(fd);\n\t  free(text);\n\t  return PAM_SESSION_ERR;\n\t}\n\n\n\t/* Write the timestamp to the file. */\n\tif (write(fd, text, p - text) != p - text) {\n\t\tpam_syslog(pamh, LOG_ERR, \"unable to write to `%s': %m\", path);\n\t\tclose(fd);\n\t\tfree(text);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/* Close the file and return successfully. */\n\tclose(fd);\n\tfree(text);\n\tpam_syslog(pamh, LOG_DEBUG, \"updated timestamp file `%s'\", path);\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "573-577",
    "snippet": "int\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED, int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nint\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED, int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "365-571",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tstruct stat st;\n\ttime_t interval = DEFAULT_TIMESTAMP_TIMEOUT;\n\tint i, fd, debug = 0, verbose = 0;\n\tchar path[BUFLEN], *p, *message, *message_end;\n\tlong tmp;\n\tconst void *void_service;\n\tconst char *service;\n\ttime_t now, then;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestamp_timeout=\")) != NULL) {\n\t\t\ttmp = strtol(str, &p, 0);\n\t\t\tif ((p != NULL) && (*p == '\\0')) {\n\t\t\t\tinterval = tmp;\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t       \"setting timeout to %ld\"\n\t\t\t\t\t       \" seconds\", (long)interval);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(argv[i], \"verbose\") == 0) {\n\t\t\tverbose = 1;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"becoming more verbose\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & PAM_SILENT) {\n\t\tverbose = 0;\n\t}\n\n\t/* Get the name of the timestamp file. */\n\tif (get_timestamp_name(pamh, argc, argv,\n\t\t\t       path, sizeof(path)) != PAM_SUCCESS) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\n\t/* Get the name of the service. */\n\tif (pam_get_item(pamh, PAM_SERVICE, &void_service) != PAM_SUCCESS) {\n\t\tservice = NULL;\n\t} else {\n\t\tservice = void_service;\n\t}\n\tif ((service == NULL) || (strlen(service) == 0)) {\n\t\tservice = \"(unknown)\";\n\t}\n\n\t/* Open the timestamp file. */\n\tfd = open(path, O_RDONLY | O_NOFOLLOW);\n\tif (fd == -1) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"cannot open timestamp `%s': %m\",\n\t\t\t       path);\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\n\tif (fstat(fd, &st) == 0) {\n\t\tint count;\n\t\tvoid *mac;\n\t\tsize_t maclen;\n\t\tchar ruser[BUFLEN];\n\n\t\t/* Check that the file is owned by the superuser. */\n\t\tif ((st.st_uid != 0) || (st.st_gid != 0)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"timestamp file `%s' is \"\n\t\t\t       \"not owned by root\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Check that the file is a normal file. */\n\t\tif (!(S_ISREG(st.st_mode))) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"timestamp file `%s' is \"\n\t\t\t       \"not a regular file\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n#ifdef WITH_OPENSSL\n\t\tif (hmac_size(pamh, debug, &maclen)) {\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n#else\n\t\tmaclen = hmac_sha1_size();\n#endif /* WITH_OPENSSL */\n\t\t/* Check that the file is the expected size. */\n\t\tif (st.st_size == 0) {\n\t\t\t/* Invalid, but may have been created by sudo. */\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tif (st.st_size !=\n\t\t    (off_t)(strlen(path) + 1 + sizeof(then) + maclen)) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' \"\n\t\t\t       \"appears to be corrupted\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Read the file contents. */\n\t\tmessage = malloc(st.st_size);\n\t\tcount = 0;\n                if (!message) {\n\t\t\tclose(fd);\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\t\twhile (count < st.st_size) {\n\t\t\ti = read(fd, message + count, st.st_size - count);\n\t\t\tif ((i == 0) || (i == -1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += i;\n\t\t}\n\t\tif (count < st.st_size) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"error reading timestamp \"\n\t\t\t\t\"file `%s': %m\", path);\n\t\t\tclose(fd);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tmessage_end = message + strlen(path) + 1 + sizeof(then);\n\n\t\t/* Regenerate the MAC. */\n#ifdef WITH_OPENSSL\n\t\tif (hmac_generate(pamh, debug, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\t  ROOT_USER, ROOT_GROUP, message, message_end - message)) {\n\t\t\tclose(fd);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n#else\n\t\thmac_sha1_generate_file(pamh, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\t\tROOT_USER, ROOT_GROUP, message, message_end - message);\n#endif /* WITH_OPENSSL */\n\t\tif ((mac == NULL) ||\n\t\t    (memcmp(path, message, strlen(path)) != 0) ||\n\t\t    (memcmp(mac, message_end, maclen) != 0)) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t\t\"corrupted\", path);\n\t\t\tclose(fd);\n\t\t\tfree(mac);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tfree(mac);\n\t\tmemmove(&then, message + strlen(path) + 1, sizeof(then));\n\t\tfree(message);\n\n\t\t/* Check oldest login against timestamp */\n\t\tif (get_ruser(pamh, ruser, sizeof(ruser)))\n\t\t{\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tif (check_login_time(ruser, then) != PAM_SUCCESS)\n\t\t{\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t       \"older than oldest login, disallowing \"\n\t\t\t       \"access to %s for user %s\",\n\t\t\t       path, service, ruser);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Compare the dates. */\n\t\tnow = time(NULL);\n\t\tif (timestamp_good(then, now, interval) == PAM_SUCCESS) {\n\t\t\tclose(fd);\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t       \"only %ld seconds old, allowing access to %s \"\n\t\t\t       \"for user %s\", path, (long) (now - st.st_mtime),\n\t\t\t       service, ruser);\n\t\t\tif (verbose) {\n\t\t\t\tverbose_success(pamh, now - st.st_mtime);\n\t\t\t}\n\t\t\treturn PAM_SUCCESS;\n\t\t} else {\n\t\t\tclose(fd);\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' has \"\n\t\t\t       \"unacceptable age (%ld seconds), disallowing \"\n\t\t\t       \"access to %s for user %s\",\n\t\t\t       path, (long) (now - st.st_mtime),\n\t\t\t       service, ruser);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t}\n\tclose(fd);\n\n\t/* Fail by default. */\n\treturn PAM_AUTH_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define ROOT_GROUP \t0",
      "#define ROOT_USER \t0",
      "#define BUFLEN PATH_MAX",
      "#define BUFLEN LINE_MAX",
      "#define TIMESTAMPKEY TIMESTAMPDIR \"/_pam_timestamp_key\"",
      "#define DEFAULT_TIMESTAMP_TIMEOUT (5 * 60)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"timestamp file `%s' has \"\n\t\t\t       \"unacceptable age (%ld seconds), disallowing \"\n\t\t\t       \"access to %s for user %s\"",
            "path",
            "(long) (now - st.st_mtime)",
            "service",
            "ruser"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose_success",
          "args": [
            "pamh",
            "now - st.st_mtime"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "verbose_success",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "358-363",
          "snippet": "static void\nverbose_success(pam_handle_t *pamh, long diff)\n{\n\tpam_info(pamh, _(\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\"), diff);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic void\nverbose_success(pam_handle_t *pamh, long diff)\n{\n\tpam_info(pamh, _(\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\"), diff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"timestamp file `%s' is \"\n\t\t\t       \"only %ld seconds old, allowing access to %s \"\n\t\t\t       \"for user %s\"",
            "path",
            "(long) (now - st.st_mtime)",
            "service",
            "ruser"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_good",
          "args": [
            "then",
            "now",
            "interval"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_good",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "192-200",
          "snippet": "static int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"timestamp file `%s' is \"\n\t\t\t       \"older than oldest login, disallowing \"\n\t\t\t       \"access to %s for user %s\"",
            "path",
            "service",
            "ruser"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_login_time",
          "args": [
            "ruser",
            "then"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ruser",
          "args": [
            "pamh",
            "ruser",
            "sizeof(ruser)"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "get_ruser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "234-270",
          "snippet": "static int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "message"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&then",
            "message + strlen(path) + 1",
            "sizeof(then)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"timestamp file `%s' is \"\n\t\t\t\t\"corrupted\"",
            "path"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mac",
            "message_end",
            "maclen"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "path",
            "message",
            "strlen(path)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_sha1_generate_file",
          "args": [
            "pamh",
            "&mac",
            "&maclen",
            "TIMESTAMPKEY",
            "ROOT_USER",
            "ROOT_GROUP",
            "message",
            "message_end - message"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_sha1_generate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "268-289",
          "snippet": "void\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE\n\nvoid\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_generate",
          "args": [
            "pamh",
            "debug",
            "&mac",
            "&maclen",
            "TIMESTAMPKEY",
            "ROOT_USER",
            "ROOT_GROUP",
            "message",
            "message_end - message"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "361-379",
          "snippet": "int\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_generate(pam_handle_t *pamh, int debug, void **mac, size_t *mac_length,\n              const char *key_file, uid_t owner, gid_t group,\n              const void *text, size_t text_length)\n{\n    char *key = NULL;\n    size_t key_length = MAX_KEY_LENGTH;\n\n    if (key_management(pamh, key_file, &key, key_length, owner, group)) {\n        return PAM_AUTH_ERR;\n    }\n\n    if (hmac_management(pamh, debug, mac, mac_length, key, key_length,\n                        text, text_length)) {\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"error reading timestamp \"\n\t\t\t\t\"file `%s': %m\"",
            "path"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "message + count",
            "st.st_size - count"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "188-275",
          "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
            "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"timestamp file `%s' \"\n\t\t\t       \"appears to be corrupted\"",
            "path"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(path) + 1 + sizeof(then) + maclen"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_sha1_size",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_sha1_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "291-295",
          "snippet": "size_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nsize_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmac_size",
          "args": [
            "pamh",
            "debug",
            "&maclen"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmac_openssl_wrapper.c",
          "lines": "311-359",
          "snippet": "int\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}",
          "includes": [
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <openssl/core_names.h>",
            "#include <openssl/params.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac_openssl_wrapper.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <openssl/core_names.h>\n#include <openssl/params.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define MAX_KEY_LENGTH      EVP_MAX_KEY_LENGTH\n\nint\nhmac_size(pam_handle_t *pamh, int debug, size_t *hmac_length)\n{\n    int ret = PAM_AUTH_ERR;\n    EVP_MAC *evp_mac = NULL;\n    EVP_MAC_CTX *ctx = NULL;\n    const unsigned char key[] = \"ThisIsJustAKey\";\n    size_t key_length = MAX_KEY_LENGTH;\n    char *algo = NULL;\n    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n    algo = get_crypto_algorithm(pamh, debug);\n\n    subalg_param[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                                       algo,\n                                                       0);\n\n    evp_mac = EVP_MAC_fetch(NULL, \"HMAC\", NULL);\n    if (evp_mac == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac implementation\");\n        goto done;\n    }\n\n    ctx = EVP_MAC_CTX_new(evp_mac);\n    if (ctx == NULL) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to create hmac context\");\n        goto done;\n    }\n\n    ret = EVP_MAC_init(ctx, key, key_length, subalg_param);\n    if (ret == 0) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to initialize hmac context\");\n        goto done;\n    }\n\n    *hmac_length = EVP_MAC_CTX_get_mac_size(ctx);\n    ret = PAM_SUCCESS;\n\ndone:\n    if (ctx != NULL) {\n        EVP_MAC_CTX_free(ctx);\n    }\n    if (evp_mac != NULL) {\n        EVP_MAC_free(evp_mac);\n    }\n    free(algo);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"timestamp file `%s' is \"\n\t\t\t       \"not a regular file\"",
            "path"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"timestamp file `%s' is \"\n\t\t\t       \"not owned by root\"",
            "path"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"cannot open timestamp `%s': %m\"",
            "path"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY | O_NOFOLLOW"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "service"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&void_service"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp_name",
          "args": [
            "pamh",
            "argc",
            "argv",
            "path",
            "sizeof(path)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "273-355",
          "snippet": "static int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BUFLEN PATH_MAX",
            "#define BUFLEN LINE_MAX",
            "#define TIMESTAMPDIR _PATH_VARRUN MODULE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPDIR _PATH_VARRUN MODULE\n\nstatic int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"becoming more verbose\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"verbose\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"setting timeout to %ld\"\n\t\t\t\t\t       \" seconds\"",
            "(long)interval"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&p",
            "0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"timestamp_timeout=\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define ROOT_GROUP \t0\n#define ROOT_USER \t0\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPKEY TIMESTAMPDIR \"/_pam_timestamp_key\"\n#define DEFAULT_TIMESTAMP_TIMEOUT (5 * 60)\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tstruct stat st;\n\ttime_t interval = DEFAULT_TIMESTAMP_TIMEOUT;\n\tint i, fd, debug = 0, verbose = 0;\n\tchar path[BUFLEN], *p, *message, *message_end;\n\tlong tmp;\n\tconst void *void_service;\n\tconst char *service;\n\ttime_t now, then;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestamp_timeout=\")) != NULL) {\n\t\t\ttmp = strtol(str, &p, 0);\n\t\t\tif ((p != NULL) && (*p == '\\0')) {\n\t\t\t\tinterval = tmp;\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t       \"setting timeout to %ld\"\n\t\t\t\t\t       \" seconds\", (long)interval);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\tif (strcmp(argv[i], \"verbose\") == 0) {\n\t\t\tverbose = 1;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"becoming more verbose\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & PAM_SILENT) {\n\t\tverbose = 0;\n\t}\n\n\t/* Get the name of the timestamp file. */\n\tif (get_timestamp_name(pamh, argc, argv,\n\t\t\t       path, sizeof(path)) != PAM_SUCCESS) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\n\t/* Get the name of the service. */\n\tif (pam_get_item(pamh, PAM_SERVICE, &void_service) != PAM_SUCCESS) {\n\t\tservice = NULL;\n\t} else {\n\t\tservice = void_service;\n\t}\n\tif ((service == NULL) || (strlen(service) == 0)) {\n\t\tservice = \"(unknown)\";\n\t}\n\n\t/* Open the timestamp file. */\n\tfd = open(path, O_RDONLY | O_NOFOLLOW);\n\tif (fd == -1) {\n\t\tif (debug) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"cannot open timestamp `%s': %m\",\n\t\t\t       path);\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\n\tif (fstat(fd, &st) == 0) {\n\t\tint count;\n\t\tvoid *mac;\n\t\tsize_t maclen;\n\t\tchar ruser[BUFLEN];\n\n\t\t/* Check that the file is owned by the superuser. */\n\t\tif ((st.st_uid != 0) || (st.st_gid != 0)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"timestamp file `%s' is \"\n\t\t\t       \"not owned by root\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Check that the file is a normal file. */\n\t\tif (!(S_ISREG(st.st_mode))) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"timestamp file `%s' is \"\n\t\t\t       \"not a regular file\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n#ifdef WITH_OPENSSL\n\t\tif (hmac_size(pamh, debug, &maclen)) {\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n#else\n\t\tmaclen = hmac_sha1_size();\n#endif /* WITH_OPENSSL */\n\t\t/* Check that the file is the expected size. */\n\t\tif (st.st_size == 0) {\n\t\t\t/* Invalid, but may have been created by sudo. */\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tif (st.st_size !=\n\t\t    (off_t)(strlen(path) + 1 + sizeof(then) + maclen)) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' \"\n\t\t\t       \"appears to be corrupted\", path);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Read the file contents. */\n\t\tmessage = malloc(st.st_size);\n\t\tcount = 0;\n                if (!message) {\n\t\t\tclose(fd);\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\t\twhile (count < st.st_size) {\n\t\t\ti = read(fd, message + count, st.st_size - count);\n\t\t\tif ((i == 0) || (i == -1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += i;\n\t\t}\n\t\tif (count < st.st_size) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"error reading timestamp \"\n\t\t\t\t\"file `%s': %m\", path);\n\t\t\tclose(fd);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tmessage_end = message + strlen(path) + 1 + sizeof(then);\n\n\t\t/* Regenerate the MAC. */\n#ifdef WITH_OPENSSL\n\t\tif (hmac_generate(pamh, debug, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\t  ROOT_USER, ROOT_GROUP, message, message_end - message)) {\n\t\t\tclose(fd);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n#else\n\t\thmac_sha1_generate_file(pamh, &mac, &maclen, TIMESTAMPKEY,\n\t\t\t\t\tROOT_USER, ROOT_GROUP, message, message_end - message);\n#endif /* WITH_OPENSSL */\n\t\tif ((mac == NULL) ||\n\t\t    (memcmp(path, message, strlen(path)) != 0) ||\n\t\t    (memcmp(mac, message_end, maclen) != 0)) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t\t\"corrupted\", path);\n\t\t\tclose(fd);\n\t\t\tfree(mac);\n\t\t\tfree(message);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tfree(mac);\n\t\tmemmove(&then, message + strlen(path) + 1, sizeof(then));\n\t\tfree(message);\n\n\t\t/* Check oldest login against timestamp */\n\t\tif (get_ruser(pamh, ruser, sizeof(ruser)))\n\t\t{\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t\tif (check_login_time(ruser, then) != PAM_SUCCESS)\n\t\t{\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t       \"older than oldest login, disallowing \"\n\t\t\t       \"access to %s for user %s\",\n\t\t\t       path, service, ruser);\n\t\t\tclose(fd);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\n\t\t/* Compare the dates. */\n\t\tnow = time(NULL);\n\t\tif (timestamp_good(then, now, interval) == PAM_SUCCESS) {\n\t\t\tclose(fd);\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' is \"\n\t\t\t       \"only %ld seconds old, allowing access to %s \"\n\t\t\t       \"for user %s\", path, (long) (now - st.st_mtime),\n\t\t\t       service, ruser);\n\t\t\tif (verbose) {\n\t\t\t\tverbose_success(pamh, now - st.st_mtime);\n\t\t\t}\n\t\t\treturn PAM_SUCCESS;\n\t\t} else {\n\t\t\tclose(fd);\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"timestamp file `%s' has \"\n\t\t\t       \"unacceptable age (%ld seconds), disallowing \"\n\t\t\t       \"access to %s for user %s\",\n\t\t\t       path, (long) (now - st.st_mtime),\n\t\t\t       service, ruser);\n\t\t\treturn PAM_AUTH_ERR;\n\t\t}\n\t}\n\tclose(fd);\n\n\t/* Fail by default. */\n\treturn PAM_AUTH_ERR;\n}"
  },
  {
    "function_name": "verbose_success",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "358-363",
    "snippet": "static void\nverbose_success(pam_handle_t *pamh, long diff)\n{\n\tpam_info(pamh, _(\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\"), diff);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\")",
            "diff"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "check_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "150-171",
          "snippet": "static const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic void\nverbose_success(pam_handle_t *pamh, long diff)\n{\n\tpam_info(pamh, _(\"Access has been granted\"\n\t\t\t \" (last access was %ld seconds ago).\"), diff);\n}"
  },
  {
    "function_name": "get_timestamp_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "273-355",
    "snippet": "static int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define BUFLEN PATH_MAX",
      "#define BUFLEN LINE_MAX",
      "#define TIMESTAMPDIR _PATH_VARRUN MODULE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"using timestamp file `%s'\"",
            "path"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_timestamp_name",
          "args": [
            "path",
            "len",
            "tdir",
            "tty",
            "ruser",
            "user"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "format_timestamp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "174-188",
          "snippet": "static int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_tty",
          "args": [
            "tty"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "check_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "150-171",
          "snippet": "static const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"tty is `%s'\"",
            "tty"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&void_tty"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"currently user `%s'\"",
            "ruser"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ruser"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ruser",
          "args": [
            "pamh",
            "ruser",
            "sizeof(ruser)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_ruser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "234-270",
          "snippet": "static int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"becoming user `%s'\"",
            "user"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dir_perms",
          "args": [
            "pamh",
            "tdir"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "check_dir_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
          "lines": "90-146",
          "snippet": "static int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include \"hmacsha1.h\"",
            "#include \"hmac_openssl_wrapper.h\"",
            "#include <paths.h>",
            "#include <syslog.h>",
            "#include <utmp.h>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BUFLEN PATH_MAX",
            "#define BUFLEN LINE_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n\nstatic int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"storing timestamps in `%s'\"",
            "tdir"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"timestampdir=\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n#define TIMESTAMPDIR _PATH_VARRUN MODULE\n\nstatic int\nget_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,\n\t\t   char *path, size_t len)\n{\n\tconst char *user, *tty;\n\tconst void *void_tty;\n\tconst char *tdir = TIMESTAMPDIR;\n\tchar ruser[BUFLEN];\n\tint i, debug = 0;\n\n\t/* Parse arguments. */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"debug\") == 0) {\n\t\t\tdebug = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *str;\n\n\t\tif ((str = pam_str_skip_prefix(argv[i], \"timestampdir=\")) != NULL) {\n\t\t\ttdir = str;\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t       \"storing timestamps in `%s'\",\n\t\t\t\t       tdir);\n\t\t\t}\n\t\t}\n\t}\n\ti = check_dir_perms(pamh, tdir);\n\tif (i != PAM_SUCCESS) {\n\t\treturn i;\n\t}\n\t/* Get the name of the target user. */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user[0] == '\\0') {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"becoming user `%s'\", user);\n\t}\n\t/* Get the name of the source user. */\n\tif (get_ruser(pamh, ruser, sizeof(ruser)) || strlen(ruser) == 0) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"currently user `%s'\", ruser);\n\t}\n\t/* Get the name of the terminal. */\n\tif (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS) {\n\t\ttty = NULL;\n\t} else {\n\t\ttty = void_tty;\n\t}\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\ttty = ttyname(STDIN_FILENO);\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDOUT_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\ttty = ttyname(STDERR_FILENO);\n\t\t}\n\t\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\t\t/* Match sudo's behavior for this case. */\n\t\t\ttty = \"unknown\";\n\t\t}\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"tty is `%s'\", tty);\n\t}\n\t/* Snip off all but the last part of the tty name. */\n\ttty = check_tty(tty);\n\tif (tty == NULL) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Generate the name of the file used to cache auth results.  These\n\t * paths should jive with sudo's per-tty naming scheme. */\n\tif (format_timestamp_name(path, len, tdir, tty, ruser, user) >= (int)len) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\tif (debug) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"using timestamp file `%s'\", path);\n\t}\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "get_ruser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "234-270",
    "snippet": "static int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ruserbuf",
            "ruser"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ruser"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ruser",
            "'/'"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ruser",
            "\"..\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ruser",
            "\".\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwuid",
          "args": [
            "pamh",
            "getuid()"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ruser"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RUSER",
            "&ruser"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nget_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}"
  },
  {
    "function_name": "timestamp_good",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "192-200",
    "snippet": "static int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\ntimestamp_good(time_t then, time_t now, time_t interval)\n{\n\tif (((now >= then) && ((now - then) < interval)) ||\n\t    ((now < then) && ((then - now) < (2 * interval)))) {\n\t\treturn PAM_SUCCESS;\n\t}\n\treturn PAM_AUTH_ERR;\n}"
  },
  {
    "function_name": "format_timestamp_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "174-188",
    "snippet": "static int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/%s:%s\"",
            "timestamp_dir",
            "ruser",
            "tty",
            "user"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"%s/%s/%s\"",
            "timestamp_dir",
            "ruser",
            "tty"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ruser",
            "user"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic int\nformat_timestamp_name(char *path, size_t len,\n\t\t      const char *timestamp_dir,\n\t\t      const char *tty,\n\t\t      const char *ruser,\n\t\t      const char *user)\n{\n\tif (strcmp(ruser, user) == 0) {\n\t\treturn snprintf(path, len, \"%s/%s/%s\", timestamp_dir,\n\t\t\t\truser, tty);\n\t} else {\n\t\treturn snprintf(path, len, \"%s/%s/%s:%s\", timestamp_dir,\n\t\t\t\truser, tty, user);\n\t}\n}"
  },
  {
    "function_name": "check_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "150-171",
    "snippet": "static const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tty",
            "\"..\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tty",
            "\".\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "tty",
            "'/'"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "tty",
            "\"/dev/\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tty",
            "'/'"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tty"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\nstatic const char *\ncheck_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}"
  },
  {
    "function_name": "check_dir_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/pam_timestamp.c",
    "lines": "90-146",
    "snippet": "static int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include \"hmacsha1.h\"",
      "#include \"hmac_openssl_wrapper.h\"",
      "#include <paths.h>",
      "#include <syslog.h>",
      "#include <utmp.h>",
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define BUFLEN PATH_MAX",
      "#define BUFLEN LINE_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"`%s' permissions are lax\"",
            "scratch"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"`%s' owner GID != 0\"",
            "scratch"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"`%s' owner UID != 0\"",
            "scratch"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"`%s' is a symbolic link\"",
            "scratch"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"`%s' is not a directory\"",
            "scratch"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to read `%s': %m\"",
            "scratch"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "scratch",
            "&st"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "scratch",
            "0",
            "sizeof(scratch)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tdir"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include \"hmacsha1.h\"\n#include \"hmac_openssl_wrapper.h\"\n#include <paths.h>\n#include <syslog.h>\n#include <utmp.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"config.h\"\n\n#define BUFLEN PATH_MAX\n#define BUFLEN LINE_MAX\n\nstatic int\ncheck_dir_perms(pam_handle_t *pamh, const char *tdir)\n{\n\tchar scratch[BUFLEN];\n\tstruct stat st;\n\tint i;\n\t/* Check that the directory is \"safe\". */\n\tif ((tdir == NULL) || (strlen(tdir) == 0)) {\n\t\treturn PAM_AUTH_ERR;\n\t}\n\t/* Iterate over the path, checking intermediate directories. */\n\tmemset(scratch, 0, sizeof(scratch));\n\tfor (i = 0; (tdir[i] != '\\0') && (i < (int)sizeof(scratch)); i++) {\n\t\tscratch[i] = tdir[i];\n\t\tif ((scratch[i] == '/') || (tdir[i + 1] == '\\0')) {\n\t\t\t/* We now have the name of a directory in the path, so\n\t\t\t * we need to check it. */\n\t\t\tif ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"unable to read `%s': %m\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is not a directory\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' is a symbolic link\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_uid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner UID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif (st.st_gid != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' owner GID != 0\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tif ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t       \"`%s' permissions are lax\",\n\t\t\t\t       scratch);\n\t\t\t\treturn PAM_AUTH_ERR;\n\t\t\t}\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}"
  }
]