[
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "351-443",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n    int retval = PAM_IGNORE;\n    const char *motd_path = NULL;\n    char *motd_path_copy = NULL;\n    unsigned int num_motd_paths = 0;\n    char **motd_path_split = NULL;\n    const char *motd_dir_path = NULL;\n    char *motd_dir_path_copy = NULL;\n    unsigned int num_motd_dir_paths = 0;\n    char **motd_dir_path_split = NULL;\n    int report_missing;\n\n    if (flags & PAM_SILENT) {\n\treturn retval;\n    }\n\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\tif ((str = pam_str_skip_prefix(*argv, \"motd=\")) != NULL) {\n\n            motd_path = str;\n            if (*motd_path != '\\0') {\n                D((\"set motd path: %s\", motd_path));\n\t    } else {\n\t\tmotd_path = NULL;\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"motd= specification missing argument - ignored\");\n\t    }\n\t}\n\telse if ((str = pam_str_skip_prefix(*argv, \"motd_dir=\")) != NULL) {\n\n            motd_dir_path = str;\n            if (*motd_dir_path != '\\0') {\n                D((\"set motd.d path: %s\", motd_dir_path));\n\t    } else {\n\t\tmotd_dir_path = NULL;\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"motd_dir= specification missing argument - ignored\");\n\t    }\n\t}\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (motd_path == NULL && motd_dir_path == NULL) {\n\tmotd_path = default_motd;\n\tmotd_dir_path = default_motd_dir;\n\treport_missing = 0;\n    } else {\n\treport_missing = 1;\n    }\n\n    if (motd_path != NULL) {\n\tmotd_path_copy = strdup(motd_path);\n    }\n\n    if (motd_path_copy != NULL) {\n\tif (pam_split_string(pamh, motd_path_copy, ':',\n\t\t&motd_path_split, &num_motd_paths) == 0) {\n\t    goto out;\n\t}\n    }\n\n    if (motd_dir_path != NULL) {\n\tmotd_dir_path_copy = strdup(motd_dir_path);\n    }\n\n    if (motd_dir_path_copy != NULL) {\n\tif (pam_split_string(pamh, motd_dir_path_copy, ':',\n\t\t&motd_dir_path_split, &num_motd_dir_paths) == 0) {\n\t    goto out;\n\t}\n    }\n\n    retval = try_to_display(pamh, motd_path_split, num_motd_paths,\n                            motd_dir_path_split, num_motd_dir_paths,\n                            report_missing);\n\n  out:\n    _pam_drop(motd_path_copy);\n    _pam_drop(motd_path_split);\n    _pam_drop(motd_dir_path_copy);\n    _pam_drop(motd_dir_path_split);\n\n    if (retval == PAM_SUCCESS) {\n        retval = pam_putenv(pamh, \"MOTD_SHOWN=pam\");\n        return retval == PAM_SUCCESS ? PAM_IGNORE : retval;\n    } else {\n        return retval;\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char default_motd[] = DEFAULT_MOTD;",
      "static const char default_motd_dir[] = DEFAULT_MOTD_D;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "\"MOTD_SHOWN=pam\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "motd_dir_path_split"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "motd_dir_path_copy"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "motd_path_split"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "motd_path_copy"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_display",
          "args": [
            "pamh",
            "motd_path_split",
            "num_motd_paths",
            "motd_dir_path_split",
            "num_motd_dir_paths",
            "report_missing"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "306-349",
          "snippet": "static int try_to_display(pam_handle_t *pamh, char **motd_path_split,\n                          unsigned int num_motd_paths,\n                          char **motd_dir_path_split,\n                          unsigned int num_motd_dir_paths, int report_missing)\n{\n    PAM_MODUTIL_DEF_PRIVS(privs);\n\n    if (drop_privileges(pamh, &privs) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to drop privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    if (motd_path_split != NULL) {\n        unsigned int i;\n\n        for (i = 0; i < num_motd_paths; i++) {\n            int fd = open(motd_path_split[i], O_RDONLY, 0);\n\n            if (fd >= 0) {\n                try_to_display_fd(pamh, fd);\n                close(fd);\n\n                /* We found and displayed a file,\n                    * move onto next filename.\n                    */\n                break;\n            }\n        }\n    }\n\n    if (motd_dir_path_split != NULL) {\n        try_to_display_directories_with_overrides(pamh,\n                                                    motd_dir_path_split,\n                                                    num_motd_dir_paths,\n                                                    report_missing);\n    }\n\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to regain privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int try_to_display(pam_handle_t *pamh, char **motd_path_split,\n                          unsigned int num_motd_paths,\n                          char **motd_dir_path_split,\n                          unsigned int num_motd_dir_paths, int report_missing)\n{\n    PAM_MODUTIL_DEF_PRIVS(privs);\n\n    if (drop_privileges(pamh, &privs) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to drop privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    if (motd_path_split != NULL) {\n        unsigned int i;\n\n        for (i = 0; i < num_motd_paths; i++) {\n            int fd = open(motd_path_split[i], O_RDONLY, 0);\n\n            if (fd >= 0) {\n                try_to_display_fd(pamh, fd);\n                close(fd);\n\n                /* We found and displayed a file,\n                    * move onto next filename.\n                    */\n                break;\n            }\n        }\n    }\n\n    if (motd_dir_path_split != NULL) {\n        try_to_display_directories_with_overrides(pamh,\n                                                    motd_dir_path_split,\n                                                    num_motd_dir_paths,\n                                                    report_missing);\n    }\n\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to regain privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_split_string",
          "args": [
            "pamh",
            "motd_dir_path_copy",
            "':'",
            "&motd_dir_path_split",
            "&num_motd_dir_paths"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "pam_split_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "73-115",
          "snippet": "static int pam_split_string(const pam_handle_t *pamh, char *arg, char delim,\n\t\t\t    char ***out_arg_split, unsigned int *out_num_strs)\n{\n    char *arg_extracted = NULL;\n    const char *arg_ptr = arg;\n    char **arg_split = NULL;\n    char delim_str[2];\n    unsigned int i = 0;\n    unsigned int num_strs = 0;\n    int retval = 0;\n\n    delim_str[0] = delim;\n    delim_str[1] = '\\0';\n\n    if (arg == NULL) {\n\tgoto out;\n    }\n\n    while (arg_ptr != NULL) {\n\tnum_strs++;\n\targ_ptr = strchr(arg_ptr + sizeof(const char), delim);\n    }\n\n    arg_split = calloc(num_strs, sizeof(*arg_split));\n    if (arg_split == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate string array\");\n\tgoto out;\n    }\n\n    arg_extracted = strtok_r(arg, delim_str, &arg);\n    while (arg_extracted != NULL && i < num_strs) {\n\targ_split[i++] = arg_extracted;\n\targ_extracted = strtok_r(NULL, delim_str, &arg);\n    }\n\n    retval = 1;\n\n  out:\n    *out_num_strs = num_strs;\n    *out_arg_split = arg_split;\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int pam_split_string(const pam_handle_t *pamh, char *arg, char delim,\n\t\t\t    char ***out_arg_split, unsigned int *out_num_strs)\n{\n    char *arg_extracted = NULL;\n    const char *arg_ptr = arg;\n    char **arg_split = NULL;\n    char delim_str[2];\n    unsigned int i = 0;\n    unsigned int num_strs = 0;\n    int retval = 0;\n\n    delim_str[0] = delim;\n    delim_str[1] = '\\0';\n\n    if (arg == NULL) {\n\tgoto out;\n    }\n\n    while (arg_ptr != NULL) {\n\tnum_strs++;\n\targ_ptr = strchr(arg_ptr + sizeof(const char), delim);\n    }\n\n    arg_split = calloc(num_strs, sizeof(*arg_split));\n    if (arg_split == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate string array\");\n\tgoto out;\n    }\n\n    arg_extracted = strtok_r(arg, delim_str, &arg);\n    while (arg_extracted != NULL && i < num_strs) {\n\targ_split[i++] = arg_extracted;\n\targ_extracted = strtok_r(NULL, delim_str, &arg);\n    }\n\n    retval = 1;\n\n  out:\n    *out_num_strs = num_strs;\n    *out_arg_split = arg_split;\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "motd_dir_path"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "motd_path"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"motd_dir= specification missing argument - ignored\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"set motd.d path: %s\", motd_dir_path)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"motd_dir=\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"motd= specification missing argument - ignored\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"motd=\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic const char default_motd[] = DEFAULT_MOTD;\nstatic const char default_motd_dir[] = DEFAULT_MOTD_D;\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n    int retval = PAM_IGNORE;\n    const char *motd_path = NULL;\n    char *motd_path_copy = NULL;\n    unsigned int num_motd_paths = 0;\n    char **motd_path_split = NULL;\n    const char *motd_dir_path = NULL;\n    char *motd_dir_path_copy = NULL;\n    unsigned int num_motd_dir_paths = 0;\n    char **motd_dir_path_split = NULL;\n    int report_missing;\n\n    if (flags & PAM_SILENT) {\n\treturn retval;\n    }\n\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\tif ((str = pam_str_skip_prefix(*argv, \"motd=\")) != NULL) {\n\n            motd_path = str;\n            if (*motd_path != '\\0') {\n                D((\"set motd path: %s\", motd_path));\n\t    } else {\n\t\tmotd_path = NULL;\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"motd= specification missing argument - ignored\");\n\t    }\n\t}\n\telse if ((str = pam_str_skip_prefix(*argv, \"motd_dir=\")) != NULL) {\n\n            motd_dir_path = str;\n            if (*motd_dir_path != '\\0') {\n                D((\"set motd.d path: %s\", motd_dir_path));\n\t    } else {\n\t\tmotd_dir_path = NULL;\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"motd_dir= specification missing argument - ignored\");\n\t    }\n\t}\n\telse\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (motd_path == NULL && motd_dir_path == NULL) {\n\tmotd_path = default_motd;\n\tmotd_dir_path = default_motd_dir;\n\treport_missing = 0;\n    } else {\n\treport_missing = 1;\n    }\n\n    if (motd_path != NULL) {\n\tmotd_path_copy = strdup(motd_path);\n    }\n\n    if (motd_path_copy != NULL) {\n\tif (pam_split_string(pamh, motd_path_copy, ':',\n\t\t&motd_path_split, &num_motd_paths) == 0) {\n\t    goto out;\n\t}\n    }\n\n    if (motd_dir_path != NULL) {\n\tmotd_dir_path_copy = strdup(motd_dir_path);\n    }\n\n    if (motd_dir_path_copy != NULL) {\n\tif (pam_split_string(pamh, motd_dir_path_copy, ':',\n\t\t&motd_dir_path_split, &num_motd_dir_paths) == 0) {\n\t    goto out;\n\t}\n    }\n\n    retval = try_to_display(pamh, motd_path_split, num_motd_paths,\n                            motd_dir_path_split, num_motd_dir_paths,\n                            report_missing);\n\n  out:\n    _pam_drop(motd_path_copy);\n    _pam_drop(motd_path_split);\n    _pam_drop(motd_dir_path_copy);\n    _pam_drop(motd_dir_path_split);\n\n    if (retval == PAM_SUCCESS) {\n        retval = pam_putenv(pamh, \"MOTD_SHOWN=pam\");\n        return retval == PAM_SUCCESS ? PAM_IGNORE : retval;\n    } else {\n        return retval;\n    }\n}"
  },
  {
    "function_name": "try_to_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "306-349",
    "snippet": "static int try_to_display(pam_handle_t *pamh, char **motd_path_split,\n                          unsigned int num_motd_paths,\n                          char **motd_dir_path_split,\n                          unsigned int num_motd_dir_paths, int report_missing)\n{\n    PAM_MODUTIL_DEF_PRIVS(privs);\n\n    if (drop_privileges(pamh, &privs) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to drop privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    if (motd_path_split != NULL) {\n        unsigned int i;\n\n        for (i = 0; i < num_motd_paths; i++) {\n            int fd = open(motd_path_split[i], O_RDONLY, 0);\n\n            if (fd >= 0) {\n                try_to_display_fd(pamh, fd);\n                close(fd);\n\n                /* We found and displayed a file,\n                    * move onto next filename.\n                    */\n                break;\n            }\n        }\n    }\n\n    if (motd_dir_path_split != NULL) {\n        try_to_display_directories_with_overrides(pamh,\n                                                    motd_dir_path_split,\n                                                    num_motd_dir_paths,\n                                                    report_missing);\n    }\n\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to regain privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to regain privileges\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_display_directories_with_overrides",
          "args": [
            "pamh",
            "motd_dir_path_split",
            "num_motd_dir_paths",
            "report_missing"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_display_directories_with_overrides",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "174-283",
          "snippet": "static void try_to_display_directories_with_overrides(pam_handle_t *pamh,\n\tchar **motd_dir_path_split, unsigned int num_motd_dirs, int report_missing)\n{\n    struct dirent ***dirscans = NULL;\n    unsigned int *dirscans_sizes = NULL;\n    unsigned int dirscans_size_total = 0;\n    char **dirnames_all = NULL;\n    unsigned int i;\n    int i_dirnames = 0;\n\n    if (pamh == NULL || motd_dir_path_split == NULL) {\n\tgoto out;\n    }\n    if (num_motd_dirs < 1) {\n\tgoto out;\n    }\n\n    if ((dirscans = calloc(num_motd_dirs, sizeof(*dirscans))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent arrays\");\n\tgoto out;\n    }\n    if ((dirscans_sizes = calloc(num_motd_dirs, sizeof(*dirscans_sizes))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent array sizes\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tint rv;\n\trv = scandir(motd_dir_path_split[i], &(dirscans[i]),\n\t\tfilter_dirents, alphasort);\n\tif (rv < 0) {\n\t    if (errno != ENOENT || report_missing) {\n\t\tpam_syslog(pamh, LOG_ERR, \"error scanning directory %s: %m\",\n\t\t    motd_dir_path_split[i]);\n\t    }\n\t} else {\n\t    dirscans_sizes[i] = rv;\n\t}\n\tdirscans_size_total += dirscans_sizes[i];\n    }\n\n    if (dirscans_size_total == 0)\n        goto out;\n\n    /* Allocate space for all file names found in the directories, including duplicates. */\n    if ((dirnames_all = calloc(dirscans_size_total, sizeof(*dirnames_all))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirname array\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tunsigned int j;\n\n\tfor (j = 0; j < dirscans_sizes[i]; j++) {\n\t    dirnames_all[i_dirnames] = dirscans[i][j]->d_name;\n\t    i_dirnames++;\n\t}\n    }\n\n    qsort(dirnames_all, dirscans_size_total,\n\t    sizeof(const char *), compare_strings);\n\n    for (i = 0; i < dirscans_size_total; i++) {\n\tunsigned int j;\n\n\tif (dirnames_all[i] == NULL) {\n\t    continue;\n\t}\n\n\t/* Skip duplicate file names. */\n\tif (i > 0 && strcmp(dirnames_all[i], dirnames_all[i - 1]) == 0) {\n\t    continue;\n\t}\n\n\tfor (j = 0; j < num_motd_dirs; j++) {\n\t    char *abs_path = NULL;\n\t    int fd;\n\n\t    if (join_dir_strings(&abs_path, motd_dir_path_split[j],\n\t\t    dirnames_all[i]) < 0 || abs_path == NULL) {\n\t\tcontinue;\n\t    }\n\n\t    fd = open(abs_path, O_RDONLY, 0);\n\t    _pam_drop(abs_path);\n\n\t    if (fd >= 0) {\n\t\ttry_to_display_fd(pamh, fd);\n\t\tclose(fd);\n\n\t\t/* We displayed a file, skip to the next file name. */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  out:\n    _pam_drop(dirnames_all);\n    if (dirscans_sizes != NULL) {\n\tfor (i = 0; i < num_motd_dirs; i++) {\n\t    unsigned int j;\n\n\t    for (j = 0; j < dirscans_sizes[i]; j++)\n\t\t_pam_drop(dirscans[i][j]);\n\t    _pam_drop(dirscans[i]);\n\t}\n\t_pam_drop(dirscans_sizes);\n    }\n    _pam_drop(dirscans);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void try_to_display_directories_with_overrides(pam_handle_t *pamh,\n\tchar **motd_dir_path_split, unsigned int num_motd_dirs, int report_missing)\n{\n    struct dirent ***dirscans = NULL;\n    unsigned int *dirscans_sizes = NULL;\n    unsigned int dirscans_size_total = 0;\n    char **dirnames_all = NULL;\n    unsigned int i;\n    int i_dirnames = 0;\n\n    if (pamh == NULL || motd_dir_path_split == NULL) {\n\tgoto out;\n    }\n    if (num_motd_dirs < 1) {\n\tgoto out;\n    }\n\n    if ((dirscans = calloc(num_motd_dirs, sizeof(*dirscans))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent arrays\");\n\tgoto out;\n    }\n    if ((dirscans_sizes = calloc(num_motd_dirs, sizeof(*dirscans_sizes))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent array sizes\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tint rv;\n\trv = scandir(motd_dir_path_split[i], &(dirscans[i]),\n\t\tfilter_dirents, alphasort);\n\tif (rv < 0) {\n\t    if (errno != ENOENT || report_missing) {\n\t\tpam_syslog(pamh, LOG_ERR, \"error scanning directory %s: %m\",\n\t\t    motd_dir_path_split[i]);\n\t    }\n\t} else {\n\t    dirscans_sizes[i] = rv;\n\t}\n\tdirscans_size_total += dirscans_sizes[i];\n    }\n\n    if (dirscans_size_total == 0)\n        goto out;\n\n    /* Allocate space for all file names found in the directories, including duplicates. */\n    if ((dirnames_all = calloc(dirscans_size_total, sizeof(*dirnames_all))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirname array\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tunsigned int j;\n\n\tfor (j = 0; j < dirscans_sizes[i]; j++) {\n\t    dirnames_all[i_dirnames] = dirscans[i][j]->d_name;\n\t    i_dirnames++;\n\t}\n    }\n\n    qsort(dirnames_all, dirscans_size_total,\n\t    sizeof(const char *), compare_strings);\n\n    for (i = 0; i < dirscans_size_total; i++) {\n\tunsigned int j;\n\n\tif (dirnames_all[i] == NULL) {\n\t    continue;\n\t}\n\n\t/* Skip duplicate file names. */\n\tif (i > 0 && strcmp(dirnames_all[i], dirnames_all[i - 1]) == 0) {\n\t    continue;\n\t}\n\n\tfor (j = 0; j < num_motd_dirs; j++) {\n\t    char *abs_path = NULL;\n\t    int fd;\n\n\t    if (join_dir_strings(&abs_path, motd_dir_path_split[j],\n\t\t    dirnames_all[i]) < 0 || abs_path == NULL) {\n\t\tcontinue;\n\t    }\n\n\t    fd = open(abs_path, O_RDONLY, 0);\n\t    _pam_drop(abs_path);\n\n\t    if (fd >= 0) {\n\t\ttry_to_display_fd(pamh, fd);\n\t\tclose(fd);\n\n\t\t/* We displayed a file, skip to the next file name. */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  out:\n    _pam_drop(dirnames_all);\n    if (dirscans_sizes != NULL) {\n\tfor (i = 0; i < num_motd_dirs; i++) {\n\t    unsigned int j;\n\n\t    for (j = 0; j < dirscans_sizes[i]; j++)\n\t\t_pam_drop(dirscans[i][j]);\n\t    _pam_drop(dirscans[i]);\n\t}\n\t_pam_drop(dirscans_sizes);\n    }\n    _pam_drop(dirscans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_display_fd",
          "args": [
            "pamh",
            "fd"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_display_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "43-65",
          "snippet": "static void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "motd_path_split[i]",
            "O_RDONLY",
            "0"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to drop privileges\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privileges",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privileges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "285-304",
          "snippet": "static int drop_privileges(pam_handle_t *pamh, struct pam_modutil_privs *privs)\n{\n    struct passwd *pw;\n    const char *username;\n    int retval;\n\n    retval = pam_get_user(pamh, &username, NULL);\n\n    if (retval == PAM_SUCCESS) {\n        pw = pam_modutil_getpwnam (pamh, username);\n    } else {\n        return PAM_SESSION_ERR;\n    }\n\n    if (pw == NULL || pam_modutil_drop_priv(pamh, privs, pw)) {\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int drop_privileges(pam_handle_t *pamh, struct pam_modutil_privs *privs)\n{\n    struct passwd *pw;\n    const char *username;\n    int retval;\n\n    retval = pam_get_user(pamh, &username, NULL);\n\n    if (retval == PAM_SUCCESS) {\n        pw = pam_modutil_getpwnam (pamh, username);\n    } else {\n        return PAM_SESSION_ERR;\n    }\n\n    if (pw == NULL || pam_modutil_drop_priv(pamh, privs, pw)) {\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int try_to_display(pam_handle_t *pamh, char **motd_path_split,\n                          unsigned int num_motd_paths,\n                          char **motd_dir_path_split,\n                          unsigned int num_motd_dir_paths, int report_missing)\n{\n    PAM_MODUTIL_DEF_PRIVS(privs);\n\n    if (drop_privileges(pamh, &privs) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to drop privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    if (motd_path_split != NULL) {\n        unsigned int i;\n\n        for (i = 0; i < num_motd_paths; i++) {\n            int fd = open(motd_path_split[i], O_RDONLY, 0);\n\n            if (fd >= 0) {\n                try_to_display_fd(pamh, fd);\n                close(fd);\n\n                /* We found and displayed a file,\n                    * move onto next filename.\n                    */\n                break;\n            }\n        }\n    }\n\n    if (motd_dir_path_split != NULL) {\n        try_to_display_directories_with_overrides(pamh,\n                                                    motd_dir_path_split,\n                                                    num_motd_dir_paths,\n                                                    report_missing);\n    }\n\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n        pam_syslog(pamh, LOG_ERR, \"Unable to regain privileges\");\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "drop_privileges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "285-304",
    "snippet": "static int drop_privileges(pam_handle_t *pamh, struct pam_modutil_privs *privs)\n{\n    struct passwd *pw;\n    const char *username;\n    int retval;\n\n    retval = pam_get_user(pamh, &username, NULL);\n\n    if (retval == PAM_SUCCESS) {\n        pw = pam_modutil_getpwnam (pamh, username);\n    } else {\n        return PAM_SESSION_ERR;\n    }\n\n    if (pw == NULL || pam_modutil_drop_priv(pamh, privs, pw)) {\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "privs",
            "pw"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int drop_privileges(pam_handle_t *pamh, struct pam_modutil_privs *privs)\n{\n    struct passwd *pw;\n    const char *username;\n    int retval;\n\n    retval = pam_get_user(pamh, &username, NULL);\n\n    if (retval == PAM_SUCCESS) {\n        pw = pam_modutil_getpwnam (pamh, username);\n    } else {\n        return PAM_SESSION_ERR;\n    }\n\n    if (pw == NULL || pam_modutil_drop_priv(pamh, privs, pw)) {\n        return PAM_SESSION_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "try_to_display_directories_with_overrides",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "174-283",
    "snippet": "static void try_to_display_directories_with_overrides(pam_handle_t *pamh,\n\tchar **motd_dir_path_split, unsigned int num_motd_dirs, int report_missing)\n{\n    struct dirent ***dirscans = NULL;\n    unsigned int *dirscans_sizes = NULL;\n    unsigned int dirscans_size_total = 0;\n    char **dirnames_all = NULL;\n    unsigned int i;\n    int i_dirnames = 0;\n\n    if (pamh == NULL || motd_dir_path_split == NULL) {\n\tgoto out;\n    }\n    if (num_motd_dirs < 1) {\n\tgoto out;\n    }\n\n    if ((dirscans = calloc(num_motd_dirs, sizeof(*dirscans))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent arrays\");\n\tgoto out;\n    }\n    if ((dirscans_sizes = calloc(num_motd_dirs, sizeof(*dirscans_sizes))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent array sizes\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tint rv;\n\trv = scandir(motd_dir_path_split[i], &(dirscans[i]),\n\t\tfilter_dirents, alphasort);\n\tif (rv < 0) {\n\t    if (errno != ENOENT || report_missing) {\n\t\tpam_syslog(pamh, LOG_ERR, \"error scanning directory %s: %m\",\n\t\t    motd_dir_path_split[i]);\n\t    }\n\t} else {\n\t    dirscans_sizes[i] = rv;\n\t}\n\tdirscans_size_total += dirscans_sizes[i];\n    }\n\n    if (dirscans_size_total == 0)\n        goto out;\n\n    /* Allocate space for all file names found in the directories, including duplicates. */\n    if ((dirnames_all = calloc(dirscans_size_total, sizeof(*dirnames_all))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirname array\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tunsigned int j;\n\n\tfor (j = 0; j < dirscans_sizes[i]; j++) {\n\t    dirnames_all[i_dirnames] = dirscans[i][j]->d_name;\n\t    i_dirnames++;\n\t}\n    }\n\n    qsort(dirnames_all, dirscans_size_total,\n\t    sizeof(const char *), compare_strings);\n\n    for (i = 0; i < dirscans_size_total; i++) {\n\tunsigned int j;\n\n\tif (dirnames_all[i] == NULL) {\n\t    continue;\n\t}\n\n\t/* Skip duplicate file names. */\n\tif (i > 0 && strcmp(dirnames_all[i], dirnames_all[i - 1]) == 0) {\n\t    continue;\n\t}\n\n\tfor (j = 0; j < num_motd_dirs; j++) {\n\t    char *abs_path = NULL;\n\t    int fd;\n\n\t    if (join_dir_strings(&abs_path, motd_dir_path_split[j],\n\t\t    dirnames_all[i]) < 0 || abs_path == NULL) {\n\t\tcontinue;\n\t    }\n\n\t    fd = open(abs_path, O_RDONLY, 0);\n\t    _pam_drop(abs_path);\n\n\t    if (fd >= 0) {\n\t\ttry_to_display_fd(pamh, fd);\n\t\tclose(fd);\n\n\t\t/* We displayed a file, skip to the next file name. */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  out:\n    _pam_drop(dirnames_all);\n    if (dirscans_sizes != NULL) {\n\tfor (i = 0; i < num_motd_dirs; i++) {\n\t    unsigned int j;\n\n\t    for (j = 0; j < dirscans_sizes[i]; j++)\n\t\t_pam_drop(dirscans[i][j]);\n\t    _pam_drop(dirscans[i]);\n\t}\n\t_pam_drop(dirscans_sizes);\n    }\n    _pam_drop(dirscans);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dirscans"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dirscans_sizes"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dirscans[i]"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dirscans[i][j]"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "dirnames_all"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_display_fd",
          "args": [
            "pamh",
            "fd"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_display_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "43-65",
          "snippet": "static void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "abs_path"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "abs_path",
            "O_RDONLY",
            "0"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_dir_strings",
          "args": [
            "&abs_path",
            "motd_dir_path_split[j]",
            "dirnames_all[i]"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "join_dir_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
          "lines": "122-148",
          "snippet": "static int join_dir_strings(char **strp_out, const char *a_str, const char *b_str)\n{\n    int has_sep = 0;\n    int retval = -1;\n    char *join_strp = NULL;\n\n    if (strp_out == NULL || a_str == NULL || b_str == NULL) {\n\tgoto out;\n    }\n    if (strlen(a_str) == 0) {\n\tgoto out;\n    }\n\n    has_sep = (a_str[strlen(a_str) - 1] == '/') || (b_str[0] == '/');\n\n    retval = asprintf(&join_strp, \"%s%s%s\", a_str,\n\t(has_sep == 1) ? \"\" : \"/\", b_str);\n\n    if (retval < 0) {\n\tgoto out;\n    }\n\n    *strp_out = join_strp;\n\n  out:\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int join_dir_strings(char **strp_out, const char *a_str, const char *b_str)\n{\n    int has_sep = 0;\n    int retval = -1;\n    char *join_strp = NULL;\n\n    if (strp_out == NULL || a_str == NULL || b_str == NULL) {\n\tgoto out;\n    }\n    if (strlen(a_str) == 0) {\n\tgoto out;\n    }\n\n    has_sep = (a_str[strlen(a_str) - 1] == '/') || (b_str[0] == '/');\n\n    retval = asprintf(&join_strp, \"%s%s%s\", a_str,\n\t(has_sep == 1) ? \"\" : \"/\", b_str);\n\n    if (retval < 0) {\n\tgoto out;\n    }\n\n    *strp_out = join_strp;\n\n  out:\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dirnames_all[i]",
            "dirnames_all[i - 1]"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "dirnames_all",
            "dirscans_size_total",
            "sizeof(const char *)",
            "compare_strings"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"failed to allocate dirname array\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "dirscans_size_total",
            "sizeof(*dirnames_all)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error scanning directory %s: %m\"",
            "motd_dir_path_split[i]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "motd_dir_path_split[i]",
            "&(dirscans[i])",
            "filter_dirents",
            "alphasort"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"failed to allocate dirent array sizes\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_motd_dirs",
            "sizeof(*dirscans_sizes)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"failed to allocate dirent arrays\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_motd_dirs",
            "sizeof(*dirscans)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void try_to_display_directories_with_overrides(pam_handle_t *pamh,\n\tchar **motd_dir_path_split, unsigned int num_motd_dirs, int report_missing)\n{\n    struct dirent ***dirscans = NULL;\n    unsigned int *dirscans_sizes = NULL;\n    unsigned int dirscans_size_total = 0;\n    char **dirnames_all = NULL;\n    unsigned int i;\n    int i_dirnames = 0;\n\n    if (pamh == NULL || motd_dir_path_split == NULL) {\n\tgoto out;\n    }\n    if (num_motd_dirs < 1) {\n\tgoto out;\n    }\n\n    if ((dirscans = calloc(num_motd_dirs, sizeof(*dirscans))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent arrays\");\n\tgoto out;\n    }\n    if ((dirscans_sizes = calloc(num_motd_dirs, sizeof(*dirscans_sizes))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirent array sizes\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tint rv;\n\trv = scandir(motd_dir_path_split[i], &(dirscans[i]),\n\t\tfilter_dirents, alphasort);\n\tif (rv < 0) {\n\t    if (errno != ENOENT || report_missing) {\n\t\tpam_syslog(pamh, LOG_ERR, \"error scanning directory %s: %m\",\n\t\t    motd_dir_path_split[i]);\n\t    }\n\t} else {\n\t    dirscans_sizes[i] = rv;\n\t}\n\tdirscans_size_total += dirscans_sizes[i];\n    }\n\n    if (dirscans_size_total == 0)\n        goto out;\n\n    /* Allocate space for all file names found in the directories, including duplicates. */\n    if ((dirnames_all = calloc(dirscans_size_total, sizeof(*dirnames_all))) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate dirname array\");\n\tgoto out;\n    }\n\n    for (i = 0; i < num_motd_dirs; i++) {\n\tunsigned int j;\n\n\tfor (j = 0; j < dirscans_sizes[i]; j++) {\n\t    dirnames_all[i_dirnames] = dirscans[i][j]->d_name;\n\t    i_dirnames++;\n\t}\n    }\n\n    qsort(dirnames_all, dirscans_size_total,\n\t    sizeof(const char *), compare_strings);\n\n    for (i = 0; i < dirscans_size_total; i++) {\n\tunsigned int j;\n\n\tif (dirnames_all[i] == NULL) {\n\t    continue;\n\t}\n\n\t/* Skip duplicate file names. */\n\tif (i > 0 && strcmp(dirnames_all[i], dirnames_all[i - 1]) == 0) {\n\t    continue;\n\t}\n\n\tfor (j = 0; j < num_motd_dirs; j++) {\n\t    char *abs_path = NULL;\n\t    int fd;\n\n\t    if (join_dir_strings(&abs_path, motd_dir_path_split[j],\n\t\t    dirnames_all[i]) < 0 || abs_path == NULL) {\n\t\tcontinue;\n\t    }\n\n\t    fd = open(abs_path, O_RDONLY, 0);\n\t    _pam_drop(abs_path);\n\n\t    if (fd >= 0) {\n\t\ttry_to_display_fd(pamh, fd);\n\t\tclose(fd);\n\n\t\t/* We displayed a file, skip to the next file name. */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  out:\n    _pam_drop(dirnames_all);\n    if (dirscans_sizes != NULL) {\n\tfor (i = 0; i < num_motd_dirs; i++) {\n\t    unsigned int j;\n\n\t    for (j = 0; j < dirscans_sizes[i]; j++)\n\t\t_pam_drop(dirscans[i][j]);\n\t    _pam_drop(dirscans[i]);\n\t}\n\t_pam_drop(dirscans_sizes);\n    }\n    _pam_drop(dirscans);\n}"
  },
  {
    "function_name": "filter_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "169-172",
    "snippet": "static int filter_dirents(const struct dirent *d)\n{\n    return (d->d_type == DT_REG || d->d_type == DT_LNK);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int filter_dirents(const struct dirent *d)\n{\n    return (d->d_type == DT_REG || d->d_type == DT_LNK);\n}"
  },
  {
    "function_name": "compare_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "150-167",
    "snippet": "static int compare_strings(const void *a, const void *b)\n{\n    const char *a_str = *(const char * const *)a;\n    const char *b_str = *(const char * const *)b;\n\n    if (a_str == NULL && b_str == NULL) {\n        return 0;\n    }\n    else if (a_str == NULL) {\n\treturn -1;\n    }\n    else if (b_str == NULL) {\n\treturn 1;\n    }\n    else {\n\treturn strcmp(a_str, b_str);\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a_str",
            "b_str"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int compare_strings(const void *a, const void *b)\n{\n    const char *a_str = *(const char * const *)a;\n    const char *b_str = *(const char * const *)b;\n\n    if (a_str == NULL && b_str == NULL) {\n        return 0;\n    }\n    else if (a_str == NULL) {\n\treturn -1;\n    }\n    else if (b_str == NULL) {\n\treturn 1;\n    }\n    else {\n\treturn strcmp(a_str, b_str);\n    }\n}"
  },
  {
    "function_name": "join_dir_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "122-148",
    "snippet": "static int join_dir_strings(char **strp_out, const char *a_str, const char *b_str)\n{\n    int has_sep = 0;\n    int retval = -1;\n    char *join_strp = NULL;\n\n    if (strp_out == NULL || a_str == NULL || b_str == NULL) {\n\tgoto out;\n    }\n    if (strlen(a_str) == 0) {\n\tgoto out;\n    }\n\n    has_sep = (a_str[strlen(a_str) - 1] == '/') || (b_str[0] == '/');\n\n    retval = asprintf(&join_strp, \"%s%s%s\", a_str,\n\t(has_sep == 1) ? \"\" : \"/\", b_str);\n\n    if (retval < 0) {\n\tgoto out;\n    }\n\n    *strp_out = join_strp;\n\n  out:\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&join_strp",
            "\"%s%s%s\"",
            "a_str",
            "(has_sep == 1) ? \"\" : \"/\"",
            "b_str"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "a_str"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "a_str"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int join_dir_strings(char **strp_out, const char *a_str, const char *b_str)\n{\n    int has_sep = 0;\n    int retval = -1;\n    char *join_strp = NULL;\n\n    if (strp_out == NULL || a_str == NULL || b_str == NULL) {\n\tgoto out;\n    }\n    if (strlen(a_str) == 0) {\n\tgoto out;\n    }\n\n    has_sep = (a_str[strlen(a_str) - 1] == '/') || (b_str[0] == '/');\n\n    retval = asprintf(&join_strp, \"%s%s%s\", a_str,\n\t(has_sep == 1) ? \"\" : \"/\", b_str);\n\n    if (retval < 0) {\n\tgoto out;\n    }\n\n    *strp_out = join_strp;\n\n  out:\n    return retval;\n}"
  },
  {
    "function_name": "pam_split_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "73-115",
    "snippet": "static int pam_split_string(const pam_handle_t *pamh, char *arg, char delim,\n\t\t\t    char ***out_arg_split, unsigned int *out_num_strs)\n{\n    char *arg_extracted = NULL;\n    const char *arg_ptr = arg;\n    char **arg_split = NULL;\n    char delim_str[2];\n    unsigned int i = 0;\n    unsigned int num_strs = 0;\n    int retval = 0;\n\n    delim_str[0] = delim;\n    delim_str[1] = '\\0';\n\n    if (arg == NULL) {\n\tgoto out;\n    }\n\n    while (arg_ptr != NULL) {\n\tnum_strs++;\n\targ_ptr = strchr(arg_ptr + sizeof(const char), delim);\n    }\n\n    arg_split = calloc(num_strs, sizeof(*arg_split));\n    if (arg_split == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate string array\");\n\tgoto out;\n    }\n\n    arg_extracted = strtok_r(arg, delim_str, &arg);\n    while (arg_extracted != NULL && i < num_strs) {\n\targ_split[i++] = arg_extracted;\n\targ_extracted = strtok_r(NULL, delim_str, &arg);\n    }\n\n    retval = 1;\n\n  out:\n    *out_num_strs = num_strs;\n    *out_arg_split = arg_split;\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "delim_str",
            "&arg"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "arg",
            "delim_str",
            "&arg"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"failed to allocate string array\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_strs",
            "sizeof(*arg_split)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg_ptr + sizeof(const char)",
            "delim"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int pam_split_string(const pam_handle_t *pamh, char *arg, char delim,\n\t\t\t    char ***out_arg_split, unsigned int *out_num_strs)\n{\n    char *arg_extracted = NULL;\n    const char *arg_ptr = arg;\n    char **arg_split = NULL;\n    char delim_str[2];\n    unsigned int i = 0;\n    unsigned int num_strs = 0;\n    int retval = 0;\n\n    delim_str[0] = delim;\n    delim_str[1] = '\\0';\n\n    if (arg == NULL) {\n\tgoto out;\n    }\n\n    while (arg_ptr != NULL) {\n\tnum_strs++;\n\targ_ptr = strchr(arg_ptr + sizeof(const char), delim);\n    }\n\n    arg_split = calloc(num_strs, sizeof(*arg_split));\n    if (arg_split == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"failed to allocate string array\");\n\tgoto out;\n    }\n\n    arg_extracted = strtok_r(arg, delim_str, &arg);\n    while (arg_extracted != NULL && i < num_strs) {\n\targ_split[i++] = arg_extracted;\n\targ_extracted = strtok_r(NULL, delim_str, &arg);\n    }\n\n    retval = 1;\n\n  out:\n    *out_num_strs = num_strs;\n    *out_arg_split = arg_split;\n\n    return retval;\n}"
  },
  {
    "function_name": "try_to_display_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "43-65",
    "snippet": "static void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "mtmp"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "mtmp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "mtmp",
            "st.st_size"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size+1"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void try_to_display_fd(pam_handle_t *pamh, int fd)\n{\n    struct stat st;\n    char *mtmp = NULL;\n\n    /* fill in message buffer with contents of motd */\n    if ((fstat(fd, &st) < 0) || !st.st_size || st.st_size > 0x10000)\n\treturn;\n\n    if (!(mtmp = malloc(st.st_size+1)))\n\treturn;\n\n    if (pam_modutil_read(fd, mtmp, st.st_size) == st.st_size) {\n\tif (mtmp[st.st_size-1] == '\\n')\n\t    mtmp[st.st_size-1] = '\\0';\n\telse\n\t    mtmp[st.st_size] = '\\0';\n\n\tpam_info (pamh, \"%s\", mtmp);\n    }\n\n    _pam_drop(mtmp);\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_motd/pam_motd.c",
    "lines": "33-38",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}"
  }
]