[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "375-534",
    "snippet": "int pam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n     int retval;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_chauthtok\", flags, argc, argv);\n\n     /* this function should be called twice by the Linux-PAM library */\n\n     if (flags & PAM_PRELIM_CHECK) {           /* first call */\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG, \"pam_sm_chauthtok: prelim check\");\n\t  }\n\t  if (ctrl & PAM_ST_PRELIM)\n\t       return PAM_TRY_AGAIN;\n\n\t  return PAM_SUCCESS;\n     } else if (flags & PAM_UPDATE_AUTHTOK) {  /* second call */\n\t  struct pam_message msg[3];\n\t  const struct pam_message *pmsg[3];\n\t  struct pam_response *resp;\n\t  const void *text;\n\t  char *txt=NULL;\n\t  int i;\n\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG, \"pam_sm_chauthtok: alter password\");\n\t  }\n\n\t  if (ctrl & PAM_ST_FAIL_1)\n\t       return PAM_AUTHTOK_LOCK_BUSY;\n\n\t  if ( !(ctrl & PAM_ST_EXPIRED)\n\t       && (flags & PAM_CHANGE_EXPIRED_AUTHTOK)\n\t       && (pam_get_data(pamh,\"stress_new_pwd\", &text)\n\t\t      != PAM_SUCCESS || strcmp(text,\"yes\"))) {\n\t       return PAM_SUCCESS;          /* the token has not expired */\n\t  }\n\n\t  /* the password should be changed */\n\n\t  if ((ctrl & PAM_ST_REQUIRE_PWD)\n\t      && !(getuid() == 0 && (ctrl & PAM_ST_ROOTOK))\n\t       ) {                       /* first get old one? */\n\t       char *pass;\n\n\t       if (ctrl & PAM_ST_DEBUG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: getting old password\");\n\t       }\n\t       retval = stress_get_password(pamh,flags,ctrl,&pass);\n\t       if (retval != PAM_SUCCESS) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: no password obtained\");\n\t\t    return retval;\n\t       }\n\t       retval = pam_set_item(pamh, PAM_OLDAUTHTOK, pass);\n\t       _pam_overwrite(pass);\n\t       free(pass);\n\t       pass = NULL;\n\t       if (retval != PAM_SUCCESS) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: could not set OLDAUTHTOK\");\n\t\t    return retval;\n\t       }\n\t  }\n\n\t  /* set up for conversation */\n\n\t  if (!(flags & PAM_SILENT)) {\n\t       const void *username;\n\n\t       if ( pam_get_item(pamh, PAM_USER, &username)\n\t\t    || username == NULL ) {\n\t\t    pam_syslog(pamh, LOG_ERR, \"no username set\");\n\t\t    return PAM_USER_UNKNOWN;\n\t       }\n\t       pmsg[0] = &msg[0];\n\t       msg[0].msg_style = PAM_TEXT_INFO;\n\t       if (asprintf(&txt, \"Changing STRESS password for %s.\",\n\t\t\t    (const char *)username) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    return PAM_BUF_ERR;\n\t       }\n\n\t       msg[0].msg = txt;\n\t       i = 1;\n\t  } else {\n\t       i = 0;\n\t  }\n\n\t  pmsg[i] = &msg[i];\n\t  msg[i].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[i++].msg = \"Enter new STRESS password: \";\n\t  pmsg[i] = &msg[i];\n\t  msg[i].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[i++].msg = \"Retype new STRESS password: \";\n\t  resp = NULL;\n\n\t  retval = converse(pamh,i,pmsg,&resp);\n\t  if (txt) {\n\t       free(txt);\n\t       txt = NULL;               /* clean up */\n\t  }\n\t  if (retval != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp == NULL) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"pam_sm_chauthtok: no response from conv\");\n\t       return PAM_CONV_ERR;\n\t  }\n\n\t  /* store the password */\n\n\t  if (resp[i-2].resp && resp[i-1].resp) {\n\t       if (strcmp(resp[i-2].resp,resp[i-1].resp)) {\n\t\t    /* passwords are not the same; forget and return error */\n\n\t\t    _pam_drop_reply(resp, i);\n\n\t\t    if (!(flags & PAM_SILENT) && !(ctrl & PAM_ST_NO_WARN)) {\n\t\t\t pmsg[0] = &msg[0];\n\t\t\t msg[0].msg_style = PAM_ERROR_MSG;\n\t\t\t msg[0].msg = \"Verification mis-typed; \"\n\t\t\t\t      \"password unchanged\";\n\t\t\t resp = NULL;\n\t\t\t (void) converse(pamh,1,pmsg,&resp);\n\t\t\t if (resp) {\n\t\t\t     _pam_drop_reply(resp, 1);\n\t\t\t }\n\t\t    }\n\t\t    return PAM_AUTHTOK_ERR;\n\t       }\n\n\t       if (pam_get_item(pamh,PAM_AUTHTOK,&text)\n\t\t   == PAM_SUCCESS) {\n\t\t    (void) pam_set_item(pamh,PAM_OLDAUTHTOK,text);\n\t\t    text = NULL;\n\t       }\n\t       (void) pam_set_item(pamh,PAM_AUTHTOK,resp[0].resp);\n\t  } else {\n\t       pam_syslog(pamh, LOG_DEBUG,\n\t\t\t  \"pam_sm_chauthtok: problem with resp\");\n\t       retval = PAM_SYSTEM_ERR;\n\t  }\n\n\t  _pam_drop_reply(resp, i);      /* clean up the passwords */\n     } else {\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"pam_sm_chauthtok: this must be a Linux-PAM error\");\n\t  return PAM_SYSTEM_ERR;\n     }\n\n     return retval;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_REQUIRE_PWD 01000",
      "#define PAM_ST_PRELIM       0400",
      "#define PAM_ST_FAIL_1       0100",
      "#define PAM_ST_EXPIRED       040",
      "#define PAM_ST_ROOTOK       020",
      "#define PAM_ST_NO_WARN       02",
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_sm_chauthtok: this must be a Linux-PAM error\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop_reply",
          "args": [
            "resp",
            "i"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: problem with resp\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "resp[0].resp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_OLDAUTHTOK",
            "text"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&text"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop_reply",
          "args": [
            "resp",
            "1"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "converse",
          "args": [
            "pamh",
            "1",
            "pmsg",
            "&resp"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "converse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "106-129",
          "snippet": "static int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_drop_reply",
          "args": [
            "resp",
            "i"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "resp[i-2].resp",
            "resp[i-1].resp"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_sm_chauthtok: no response from conv\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "txt"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&txt",
            "\"Changing STRESS password for %s.\"",
            "(const char *)username"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"no username set\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&username"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: could not set OLDAUTHTOK\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "pass"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_OLDAUTHTOK",
            "pass"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: no password obtained\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stress_get_password",
          "args": [
            "pamh",
            "flags",
            "ctrl",
            "&pass"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "stress_get_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "133-194",
          "snippet": "static int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_DEBUG         01\n\nstatic int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: getting old password\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "text",
            "\"yes\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "\"stress_new_pwd\"",
            "&text"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: alter password\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_chauthtok: prelim check\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_chauthtok\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called. [post parsing]\")"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nint pam_sm_chauthtok(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n     int retval;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_chauthtok\", flags, argc, argv);\n\n     /* this function should be called twice by the Linux-PAM library */\n\n     if (flags & PAM_PRELIM_CHECK) {           /* first call */\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG, \"pam_sm_chauthtok: prelim check\");\n\t  }\n\t  if (ctrl & PAM_ST_PRELIM)\n\t       return PAM_TRY_AGAIN;\n\n\t  return PAM_SUCCESS;\n     } else if (flags & PAM_UPDATE_AUTHTOK) {  /* second call */\n\t  struct pam_message msg[3];\n\t  const struct pam_message *pmsg[3];\n\t  struct pam_response *resp;\n\t  const void *text;\n\t  char *txt=NULL;\n\t  int i;\n\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG, \"pam_sm_chauthtok: alter password\");\n\t  }\n\n\t  if (ctrl & PAM_ST_FAIL_1)\n\t       return PAM_AUTHTOK_LOCK_BUSY;\n\n\t  if ( !(ctrl & PAM_ST_EXPIRED)\n\t       && (flags & PAM_CHANGE_EXPIRED_AUTHTOK)\n\t       && (pam_get_data(pamh,\"stress_new_pwd\", &text)\n\t\t      != PAM_SUCCESS || strcmp(text,\"yes\"))) {\n\t       return PAM_SUCCESS;          /* the token has not expired */\n\t  }\n\n\t  /* the password should be changed */\n\n\t  if ((ctrl & PAM_ST_REQUIRE_PWD)\n\t      && !(getuid() == 0 && (ctrl & PAM_ST_ROOTOK))\n\t       ) {                       /* first get old one? */\n\t       char *pass;\n\n\t       if (ctrl & PAM_ST_DEBUG) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: getting old password\");\n\t       }\n\t       retval = stress_get_password(pamh,flags,ctrl,&pass);\n\t       if (retval != PAM_SUCCESS) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: no password obtained\");\n\t\t    return retval;\n\t       }\n\t       retval = pam_set_item(pamh, PAM_OLDAUTHTOK, pass);\n\t       _pam_overwrite(pass);\n\t       free(pass);\n\t       pass = NULL;\n\t       if (retval != PAM_SUCCESS) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_chauthtok: could not set OLDAUTHTOK\");\n\t\t    return retval;\n\t       }\n\t  }\n\n\t  /* set up for conversation */\n\n\t  if (!(flags & PAM_SILENT)) {\n\t       const void *username;\n\n\t       if ( pam_get_item(pamh, PAM_USER, &username)\n\t\t    || username == NULL ) {\n\t\t    pam_syslog(pamh, LOG_ERR, \"no username set\");\n\t\t    return PAM_USER_UNKNOWN;\n\t       }\n\t       pmsg[0] = &msg[0];\n\t       msg[0].msg_style = PAM_TEXT_INFO;\n\t       if (asprintf(&txt, \"Changing STRESS password for %s.\",\n\t\t\t    (const char *)username) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    return PAM_BUF_ERR;\n\t       }\n\n\t       msg[0].msg = txt;\n\t       i = 1;\n\t  } else {\n\t       i = 0;\n\t  }\n\n\t  pmsg[i] = &msg[i];\n\t  msg[i].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[i++].msg = \"Enter new STRESS password: \";\n\t  pmsg[i] = &msg[i];\n\t  msg[i].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[i++].msg = \"Retype new STRESS password: \";\n\t  resp = NULL;\n\n\t  retval = converse(pamh,i,pmsg,&resp);\n\t  if (txt) {\n\t       free(txt);\n\t       txt = NULL;               /* clean up */\n\t  }\n\t  if (retval != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp == NULL) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"pam_sm_chauthtok: no response from conv\");\n\t       return PAM_CONV_ERR;\n\t  }\n\n\t  /* store the password */\n\n\t  if (resp[i-2].resp && resp[i-1].resp) {\n\t       if (strcmp(resp[i-2].resp,resp[i-1].resp)) {\n\t\t    /* passwords are not the same; forget and return error */\n\n\t\t    _pam_drop_reply(resp, i);\n\n\t\t    if (!(flags & PAM_SILENT) && !(ctrl & PAM_ST_NO_WARN)) {\n\t\t\t pmsg[0] = &msg[0];\n\t\t\t msg[0].msg_style = PAM_ERROR_MSG;\n\t\t\t msg[0].msg = \"Verification mis-typed; \"\n\t\t\t\t      \"password unchanged\";\n\t\t\t resp = NULL;\n\t\t\t (void) converse(pamh,1,pmsg,&resp);\n\t\t\t if (resp) {\n\t\t\t     _pam_drop_reply(resp, 1);\n\t\t\t }\n\t\t    }\n\t\t    return PAM_AUTHTOK_ERR;\n\t       }\n\n\t       if (pam_get_item(pamh,PAM_AUTHTOK,&text)\n\t\t   == PAM_SUCCESS) {\n\t\t    (void) pam_set_item(pamh,PAM_OLDAUTHTOK,text);\n\t\t    text = NULL;\n\t       }\n\t       (void) pam_set_item(pamh,PAM_AUTHTOK,resp[0].resp);\n\t  } else {\n\t       pam_syslog(pamh, LOG_DEBUG,\n\t\t\t  \"pam_sm_chauthtok: problem with resp\");\n\t       retval = PAM_SYSTEM_ERR;\n\t  }\n\n\t  _pam_drop_reply(resp, i);      /* clean up the passwords */\n     } else {\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"pam_sm_chauthtok: this must be a Linux-PAM error\");\n\t  return PAM_SYSTEM_ERR;\n     }\n\n     return retval;\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "348-373",
    "snippet": "int pam_sm_close_session(pam_handle_t *pamh, int flags,\n\t\t\t int argc, const char **argv)\n{\n     const void *username, *service;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_close_session\", flags, argc, argv);\n\n     if ((pam_get_item(pamh, PAM_USER, &username)\n\t  != PAM_SUCCESS || !username)\n\t || (pam_get_item(pamh, PAM_SERVICE, &service)\n\t     != PAM_SUCCESS || !service)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"pam_sm_close_session: for whom?\");\n\t  return PAM_SESSION_ERR;\n     }\n\n     pam_syslog(pamh, LOG_NOTICE, \"closed [%s] session for user [%s]\",\n\t      (const char *)service, (const char *)username);\n\n     if (ctrl & PAM_ST_FAIL_2)\n\t  return PAM_SESSION_ERR;\n\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_FAIL_2       0200"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"closed [%s] session for user [%s]\"",
            "(const char *)service",
            "(const char *)username"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"pam_sm_close_session: for whom?\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&username"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_close_session\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called. [post parsing]\")"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_FAIL_2       0200\n\nint pam_sm_close_session(pam_handle_t *pamh, int flags,\n\t\t\t int argc, const char **argv)\n{\n     const void *username, *service;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_close_session\", flags, argc, argv);\n\n     if ((pam_get_item(pamh, PAM_USER, &username)\n\t  != PAM_SUCCESS || !username)\n\t || (pam_get_item(pamh, PAM_SERVICE, &service)\n\t     != PAM_SUCCESS || !service)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"pam_sm_close_session: for whom?\");\n\t  return PAM_SESSION_ERR;\n     }\n\n     pam_syslog(pamh, LOG_NOTICE, \"closed [%s] session for user [%s]\",\n\t      (const char *)service, (const char *)username);\n\n     if (ctrl & PAM_ST_FAIL_2)\n\t  return PAM_SESSION_ERR;\n\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "321-346",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n     const void *username, *service;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_open_session\", flags, argc, argv);\n\n     if ((pam_get_item(pamh, PAM_USER, &username)\n\t  != PAM_SUCCESS || !username)\n\t || (pam_get_item(pamh, PAM_SERVICE, &service)\n\t     != PAM_SUCCESS || !service)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"pam_sm_open_session: for whom?\");\n\t  return PAM_SESSION_ERR;\n     }\n\n     pam_syslog(pamh, LOG_NOTICE, \"opened [%s] session for user [%s]\",\n\t        (const char *)service, (const char *)username);\n\n     if (ctrl & PAM_ST_FAIL_1)\n\t  return PAM_SESSION_ERR;\n\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_FAIL_1       0100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"opened [%s] session for user [%s]\"",
            "(const char *)service",
            "(const char *)username"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"pam_sm_open_session: for whom?\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&username"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_open_session\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called. [post parsing]\")"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_FAIL_1       0100\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n     const void *username, *service;\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_open_session\", flags, argc, argv);\n\n     if ((pam_get_item(pamh, PAM_USER, &username)\n\t  != PAM_SUCCESS || !username)\n\t || (pam_get_item(pamh, PAM_SERVICE, &service)\n\t     != PAM_SUCCESS || !service)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"pam_sm_open_session: for whom?\");\n\t  return PAM_SESSION_ERR;\n     }\n\n     pam_syslog(pamh, LOG_NOTICE, \"opened [%s] session for user [%s]\",\n\t        (const char *)service, (const char *)username);\n\n     if (ctrl & PAM_ST_FAIL_1)\n\t  return PAM_SESSION_ERR;\n\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "287-319",
    "snippet": "int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_acct_mgmt\", flags, argc, argv);\n\n     if (ctrl & PAM_ST_FAIL_1)\n\t  return PAM_PERM_DENIED;\n     else if (ctrl & PAM_ST_EXPIRED) {\n\t  int retval;\n\t  void *text = strdup(\"yes\");\n\t  if (!text)\n\t        return PAM_BUF_ERR;\n\t  retval = pam_set_data(pamh,\"stress_new_pwd\",text,wipe_up);\n\t  if (retval != PAM_SUCCESS) {\n\t        pam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"pam_sm_acct_mgmt: failed setting stress_new_pwd\");\n\t        free(text);\n\t        return retval;\n\t  }\n\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG,\n\t\t\t  \"pam_sm_acct_mgmt: need a new password\");\n\t  }\n\t  return PAM_NEW_AUTHTOK_REQD;\n     }\n\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_FAIL_1       0100",
      "#define PAM_ST_EXPIRED       040",
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_acct_mgmt: need a new password\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "text"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_acct_mgmt: failed setting stress_new_pwd\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "\"stress_new_pwd\"",
            "text",
            "wipe_up"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"yes\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_acct_mgmt\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called. [post parsing]\")"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_DEBUG         01\n\nint pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl,\"pam_sm_acct_mgmt\", flags, argc, argv);\n\n     if (ctrl & PAM_ST_FAIL_1)\n\t  return PAM_PERM_DENIED;\n     else if (ctrl & PAM_ST_EXPIRED) {\n\t  int retval;\n\t  void *text = strdup(\"yes\");\n\t  if (!text)\n\t        return PAM_BUF_ERR;\n\t  retval = pam_set_data(pamh,\"stress_new_pwd\",text,wipe_up);\n\t  if (retval != PAM_SUCCESS) {\n\t        pam_syslog(pamh, LOG_DEBUG,\n\t\t\t   \"pam_sm_acct_mgmt: failed setting stress_new_pwd\");\n\t        free(text);\n\t        return retval;\n\t  }\n\n\t  if (ctrl & PAM_ST_DEBUG) {\n\t       pam_syslog(pamh, LOG_DEBUG,\n\t\t\t  \"pam_sm_acct_mgmt: need a new password\");\n\t  }\n\t  return PAM_NEW_AUTHTOK_REQD;\n     }\n\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "270-283",
    "snippet": "int pam_sm_setcred(pam_handle_t *pamh, int flags,\n\t\t   int argc, const char **argv)\n{\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl, \"pam_sm_setcred\", flags, argc, argv);\n\n     if (ctrl & PAM_ST_FAIL_2)\n\t  return PAM_CRED_ERR;\n\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_FAIL_2       0200"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_setcred\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called. [post parsing]\")"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_FAIL_2       0200\n\nint pam_sm_setcred(pam_handle_t *pamh, int flags,\n\t\t   int argc, const char **argv)\n{\n     int ctrl = _pam_parse(pamh, argc, argv);\n\n     D((\"called. [post parsing]\"));\n\n     _pam_report(pamh, ctrl, \"pam_sm_setcred\", flags, argc, argv);\n\n     if (ctrl & PAM_ST_FAIL_2)\n\t  return PAM_CRED_ERR;\n\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "204-268",
    "snippet": "int pam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n     const char *username;\n     int retval=PAM_SUCCESS;\n     char *pass;\n     int ctrl;\n\n     D((\"called.\"));\n\n     ctrl = _pam_parse(pamh, argc, argv);\n     _pam_report(pamh, ctrl, \"pam_sm_authenticate\", flags, argc, argv);\n\n     /* try to get the username */\n\n     retval = pam_get_user(pamh, &username, \"username: \");\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_NOTICE,\n\t\t     \"pam_sm_authenticate: cannot determine user name: %s\",\n\t\t     pam_strerror(pamh, retval));\n\t  return retval;\n     }\n     else if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"pam_sm_authenticate: username = %s\", username);\n     }\n\n     /* now get the password */\n\n     retval = stress_get_password(pamh,flags,ctrl,&pass);\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_WARNING,\n\t\t     \"pam_sm_authenticate: failed to get a password\");\n\t  return retval;\n     }\n\n     /* try to set password item */\n\n     retval = pam_set_item(pamh,PAM_AUTHTOK,pass);\n     _pam_overwrite(pass); /* clean up local copy of password */\n     free(pass);\n     pass = NULL;\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_WARNING,\n\t\t     \"pam_sm_authenticate: failed to store new password\");\n\t  return retval;\n     }\n\n     /* if we are debugging then we print the password */\n\n     if (ctrl & PAM_ST_DEBUG) {\n          const void *pam_pass;\n\t  (void) pam_get_item(pamh,PAM_AUTHTOK,&pam_pass);\n\t  pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"pam_st_authenticate: password entered is: [%s]\",\n\t\t     (const char *)pam_pass);\n     }\n\n     /* if we signal a fail for this function then fail */\n\n     if ((ctrl & PAM_ST_FAIL_1) && retval == PAM_SUCCESS)\n\t  return PAM_PERM_DENIED;\n\n     return retval;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_FAIL_1       0100",
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_st_authenticate: password entered is: [%s]\"",
            "(const char *)pam_pass"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&pam_pass"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"pam_sm_authenticate: failed to store new password\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pass"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "pass"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "pass"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"pam_sm_authenticate: failed to get a password\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stress_get_password",
          "args": [
            "pamh",
            "flags",
            "ctrl",
            "&pass"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "stress_get_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "133-194",
          "snippet": "static int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_DEBUG         01\n\nstatic int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_authenticate: username = %s\"",
            "username"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"pam_sm_authenticate: cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&username",
            "\"username: \""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_report",
          "args": [
            "pamh",
            "ctrl",
            "\"pam_sm_authenticate\"",
            "flags",
            "argc",
            "argv"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "45-59",
          "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "61-104",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_ST_REQUIRE_PWD 01000",
            "#define PAM_ST_PRELIM       0400",
            "#define PAM_ST_FAIL_2       0200",
            "#define PAM_ST_FAIL_1       0100",
            "#define PAM_ST_EXPIRED       040",
            "#define PAM_ST_ROOTOK       020",
            "#define PAM_ST_TRY_PASS1    010",
            "#define PAM_ST_USE_PASS1     04",
            "#define PAM_ST_NO_WARN       02",
            "#define PAM_ST_DEBUG         01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"called.\")"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_DEBUG         01\n\nint pam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t\tint argc, const char **argv)\n{\n     const char *username;\n     int retval=PAM_SUCCESS;\n     char *pass;\n     int ctrl;\n\n     D((\"called.\"));\n\n     ctrl = _pam_parse(pamh, argc, argv);\n     _pam_report(pamh, ctrl, \"pam_sm_authenticate\", flags, argc, argv);\n\n     /* try to get the username */\n\n     retval = pam_get_user(pamh, &username, \"username: \");\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_NOTICE,\n\t\t     \"pam_sm_authenticate: cannot determine user name: %s\",\n\t\t     pam_strerror(pamh, retval));\n\t  return retval;\n     }\n     else if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"pam_sm_authenticate: username = %s\", username);\n     }\n\n     /* now get the password */\n\n     retval = stress_get_password(pamh,flags,ctrl,&pass);\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_WARNING,\n\t\t     \"pam_sm_authenticate: failed to get a password\");\n\t  return retval;\n     }\n\n     /* try to set password item */\n\n     retval = pam_set_item(pamh,PAM_AUTHTOK,pass);\n     _pam_overwrite(pass); /* clean up local copy of password */\n     free(pass);\n     pass = NULL;\n     if (retval != PAM_SUCCESS) {\n\t  pam_syslog(pamh, LOG_WARNING,\n\t\t     \"pam_sm_authenticate: failed to store new password\");\n\t  return retval;\n     }\n\n     /* if we are debugging then we print the password */\n\n     if (ctrl & PAM_ST_DEBUG) {\n          const void *pam_pass;\n\t  (void) pam_get_item(pamh,PAM_AUTHTOK,&pam_pass);\n\t  pam_syslog(pamh, LOG_DEBUG,\n\t\t     \"pam_st_authenticate: password entered is: [%s]\",\n\t\t     (const char *)pam_pass);\n     }\n\n     /* if we signal a fail for this function then fail */\n\n     if ((ctrl & PAM_ST_FAIL_1) && retval == PAM_SUCCESS)\n\t  return PAM_PERM_DENIED;\n\n     return retval;\n}"
  },
  {
    "function_name": "wipe_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "198-202",
    "snippet": "static void\nwipe_up (pam_handle_t *pamh UNUSED, void *data, int error UNUSED)\n{\n     free(data);\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic void\nwipe_up (pam_handle_t *pamh UNUSED, void *data, int error UNUSED)\n{\n     free(data);\n}"
  },
  {
    "function_name": "stress_get_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "133-194",
    "snippet": "static int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_TRY_PASS1    010",
      "#define PAM_ST_USE_PASS1     04",
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "resp"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"getting password, but NULL returned!?\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_authenticate: no error reported\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_sm_authenticate: NULL authtok given\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "converse",
          "args": [
            "pamh",
            "1",
            "pmsg",
            "&resp"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "converse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
          "lines": "106-129",
          "snippet": "static int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"no forwarded password\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pam_pass"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&pam_pass"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_DEBUG         01\n\nstatic int stress_get_password(pam_handle_t *pamh, int flags\n\t\t\t       , int ctrl, char **password)\n{\n     const void *pam_pass;\n     char *pass;\n\n     if ( (ctrl & (PAM_ST_TRY_PASS1|PAM_ST_USE_PASS1))\n\t && (pam_get_item(pamh,PAM_AUTHTOK,&pam_pass)\n\t     == PAM_SUCCESS)\n\t && (pam_pass != NULL) ) {\n\t  if ((pass = strdup(pam_pass)) == NULL)\n\t       return PAM_BUF_ERR;\n     } else if ((ctrl & PAM_ST_USE_PASS1)) {\n\t  pam_syslog(pamh, LOG_WARNING, \"no forwarded password\");\n\t  return PAM_PERM_DENIED;\n     } else {                                /* we will have to get one */\n\t  struct pam_message msg[1];\n\t  const struct pam_message *pmsg[1];\n\t  struct pam_response *resp;\n\t  int retval;\n\n\t  /* set up conversation call */\n\n\t  pmsg[0] = &msg[0];\n\t  msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n\t  msg[0].msg = \"STRESS Password: \";\n\t  resp = NULL;\n\n\t  if ((retval = converse(pamh,1,pmsg,&resp)) != PAM_SUCCESS) {\n\t       return retval;\n\t  }\n\n\t  if (resp) {\n\t       if ((resp[0].resp == NULL) && (ctrl & PAM_ST_DEBUG)) {\n\t\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t\t       \"pam_sm_authenticate: NULL authtok given\");\n\t       }\n\t       if ((flags & PAM_DISALLOW_NULL_AUTHTOK)\n\t\t   && resp[0].resp == NULL) {\n\t\t    free(resp);\n\t\t    return PAM_AUTH_ERR;\n\t       }\n\n\t       pass = resp[0].resp;          /* remember this! */\n\n\t       resp[0].resp = NULL;\n\t  } else {\n               if (ctrl & PAM_ST_DEBUG) {\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"pam_sm_authenticate: no error reported\");\n\t          pam_syslog(pamh, LOG_DEBUG,\n\t\t\t     \"getting password, but NULL returned!?\");\n               }\n\t       return PAM_CONV_ERR;\n\t  }\n\t  free(resp);\n     }\n\n     *password = pass;             /* this *MUST* be free()'d by this module */\n\n     return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "converse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "106-129",
    "snippet": "static int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"converse failed to get pam_conv\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"converse returned %d: %s\"",
            "retval",
            "pam_strerror(pamh, retval)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv->conv",
          "args": [
            "nargs",
            "message",
            "response",
            "conv->appdata_ptr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_CONV",
            "&void_conv"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic int converse(pam_handle_t *pamh, int nargs\n\t\t    , const struct pam_message **message\n\t\t    , struct pam_response **response)\n{\n     int retval;\n     const void *void_conv;\n     const struct pam_conv *conv;\n\n     retval = pam_get_item(pamh,PAM_CONV,&void_conv);\n     conv = void_conv;\n     if (retval == PAM_SUCCESS && conv) {\n\t  retval = conv->conv(nargs, message, response, conv->appdata_ptr);\n\t  if (retval != PAM_SUCCESS) {\n\t       pam_syslog(pamh, LOG_ERR, \"converse returned %d: %s\",\n\t\t\tretval, pam_strerror(pamh, retval));\n\t  }\n     } else {\n\t  pam_syslog(pamh, LOG_ERR, \"converse failed to get pam_conv\");\n         if (retval == PAM_SUCCESS)\n             retval = PAM_BAD_ITEM; /* conv was null */\n     }\n\n     return retval;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "61-104",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_REQUIRE_PWD 01000",
      "#define PAM_ST_PRELIM       0400",
      "#define PAM_ST_FAIL_2       0200",
      "#define PAM_ST_FAIL_1       0100",
      "#define PAM_ST_EXPIRED       040",
      "#define PAM_ST_ROOTOK       020",
      "#define PAM_ST_TRY_PASS1    010",
      "#define PAM_ST_USE_PASS1     04",
      "#define PAM_ST_NO_WARN       02",
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"required\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"prelim\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"fail_2\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"fail_1\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"expired\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"rootok\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"try_first_pass\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"use_first_pass\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"no_warn\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_REQUIRE_PWD 01000\n#define PAM_ST_PRELIM       0400\n#define PAM_ST_FAIL_2       0200\n#define PAM_ST_FAIL_1       0100\n#define PAM_ST_EXPIRED       040\n#define PAM_ST_ROOTOK       020\n#define PAM_ST_TRY_PASS1    010\n#define PAM_ST_USE_PASS1     04\n#define PAM_ST_NO_WARN       02\n#define PAM_ST_DEBUG         01\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv)\n{\n     int ctrl=0;\n\n     /* step through arguments */\n     for (ctrl=0; argc-- > 0; ++argv) {\n\n\t  /* generic options */\n\n\t  if (!strcmp(*argv,\"debug\"))\n\t       ctrl |= PAM_ST_DEBUG;\n\t  else if (!strcmp(*argv,\"no_warn\"))\n\t       ctrl |= PAM_ST_NO_WARN;\n\t  else if (!strcmp(*argv,\"use_first_pass\"))\n\t       ctrl |= PAM_ST_USE_PASS1;\n\t  else if (!strcmp(*argv,\"try_first_pass\"))\n\t       ctrl |= PAM_ST_TRY_PASS1;\n\t  else if (!strcmp(*argv,\"rootok\"))\n\t       ctrl |= PAM_ST_ROOTOK;\n\n\t  /* simulation options */\n\n\t  else if (!strcmp(*argv,\"expired\"))   /* signal password needs\n\t\t\t\t\t\t  renewal */\n\t       ctrl |= PAM_ST_EXPIRED;\n\t  else if (!strcmp(*argv,\"fail_1\"))    /* instruct fn 1 to fail */\n\t       ctrl |= PAM_ST_FAIL_1;\n\t  else if (!strcmp(*argv,\"fail_2\"))    /* instruct fn 2 to fail */\n\t       ctrl |= PAM_ST_FAIL_2;\n\t  else if (!strcmp(*argv,\"prelim\"))    /* instruct pam_sm_setcred\n\t\t\t\t\t\t  to fail on first call */\n\t       ctrl |= PAM_ST_PRELIM;\n\t  else if (!strcmp(*argv,\"required\"))  /* module is fussy about the\n\t\t\t\t\t\t  user being authenticated */\n\t       ctrl |= PAM_ST_REQUIRE_PWD;\n\n\t  else {\n\t       pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t  }\n     }\n\n     return ctrl;\n}"
  },
  {
    "function_name": "_pam_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_stress/pam_stress.c",
    "lines": "45-59",
    "snippet": "static void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}",
    "includes": [
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_ST_DEBUG         01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\" \\\"%s\\\"\"",
            "*argv++"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"ARGV  :\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"CTRL  = 0%o\"",
            "ctrl"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"FLAGS : 0%o%s\"",
            "flags",
            "(flags & PAM_SILENT) ? \" (silent)\":\"\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"CALLED: %s\"",
            "name"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define PAM_ST_DEBUG         01\n\nstatic void\n_pam_report (const pam_handle_t *pamh, int ctrl, const char *name,\n\t     int flags, int argc, const char **argv)\n{\n     if (ctrl & PAM_ST_DEBUG) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"CALLED: %s\", name);\n\t  pam_syslog(pamh, LOG_DEBUG, \"FLAGS : 0%o%s\",\n\t\t     flags, (flags & PAM_SILENT) ? \" (silent)\":\"\");\n\t  pam_syslog(pamh, LOG_DEBUG, \"CTRL  = 0%o\", ctrl);\n\t  pam_syslog(pamh, LOG_DEBUG, \"ARGV  :\");\n\t  while (argc--) {\n\t       pam_syslog(pamh, LOG_DEBUG, \" \\\"%s\\\"\", *argv++);\n\t  }\n     }\n}"
  }
]