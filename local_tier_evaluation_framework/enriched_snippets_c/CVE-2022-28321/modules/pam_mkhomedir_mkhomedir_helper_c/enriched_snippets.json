[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
    "lines": "383-439",
    "snippet": "int\nmain(int argc, char *argv[])\n{\n   struct passwd *pwd;\n   struct stat st;\n   char *eptr;\n\n   if (argc < 2) {\n\tfprintf(stderr, \"Usage: %s <username> [<umask> [<skeldir> [<home_mode>]]]\\n\", argv[0]);\n\treturn PAM_SESSION_ERR;\n   }\n\n   pwd = getpwnam(argv[1]);\n   if (pwd == NULL) {\n\tpam_syslog(NULL, LOG_ERR, \"User unknown.\");\n\treturn PAM_USER_UNKNOWN;\n   }\n\n   if (argc >= 3) {\n\terrno = 0;\n\tu_mask = strtoul(argv[2], &eptr, 0);\n\tif (errno != 0 || *eptr != '\\0') {\n\t\tpam_syslog(NULL, LOG_ERR, \"Bogus umask value %s\", argv[2]);\n\t\treturn PAM_SESSION_ERR;\n\t}\n   }\n\n   if (argc >= 4) {\n\tif (strlen(argv[3]) >= sizeof(skeldir)) {\n\t\tpam_syslog(NULL, LOG_ERR, \"Too long skeldir path.\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tstrcpy(skeldir, argv[3]);\n   }\n\n   if (argc >= 5) {\n       errno = 0;\n       home_mode = strtoul(argv[4], &eptr, 0);\n       if (errno != 0 || *eptr != '\\0') {\n\t\tpam_syslog(NULL, LOG_ERR, \"Bogus home_mode value %s\", argv[4]);\n\t\treturn PAM_SESSION_ERR;\n       }\n   }\n\n   if (home_mode == 0)\n      home_mode = 0777 & ~u_mask;\n\n   /* Stat the home directory, if something exists then we assume it is\n      correct and return a success */\n   if (stat(pwd->pw_dir, &st) == 0)\n\treturn PAM_SUCCESS;\n\n   if (make_parent_dirs(pwd->pw_dir, 0) != PAM_SUCCESS)\n\treturn PAM_PERM_DENIED;\n\n   return create_homedir_helper(pwd, skeldir, pwd->pw_dir);\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long u_mask = 0022;",
      "static unsigned long home_mode = 0;",
      "static char skeldir[BUFSIZ] = \"/etc/skel\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_homedir_helper",
          "args": [
            "pwd",
            "skeldir",
            "pwd->pw_dir"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "create_homedir_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
          "lines": "337-353",
          "snippet": "static int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}",
          "includes": [
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long home_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic unsigned long home_mode = 0;\n\nstatic int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_parent_dirs",
          "args": [
            "pwd->pw_dir",
            "0"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "make_parent_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
          "lines": "355-381",
          "snippet": "static int\nmake_parent_dirs(char *dir, int make)\n{\n  int rc = PAM_SUCCESS;\n  char *cp = strrchr(dir, '/');\n  struct stat st;\n\n  if (!cp)\n    return rc;\n\n  if (cp != dir) {\n    *cp = '\\0';\n    if (stat(dir, &st) && errno == ENOENT)\n      rc = make_parent_dirs(dir, 1);\n    *cp = '/';\n\n    if (rc != PAM_SUCCESS)\n      return rc;\n  }\n\n  if (make && mkdir(dir, 0755) && errno != EEXIST) {\n    pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dir);\n    return PAM_PERM_DENIED;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int\nmake_parent_dirs(char *dir, int make)\n{\n  int rc = PAM_SUCCESS;\n  char *cp = strrchr(dir, '/');\n  struct stat st;\n\n  if (!cp)\n    return rc;\n\n  if (cp != dir) {\n    *cp = '\\0';\n    if (stat(dir, &st) && errno == ENOENT)\n      rc = make_parent_dirs(dir, 1);\n    *cp = '/';\n\n    if (rc != PAM_SUCCESS)\n      return rc;\n  }\n\n  if (make && mkdir(dir, 0755) && errno != EEXIST) {\n    pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dir);\n    return PAM_PERM_DENIED;\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "pwd->pw_dir",
            "&st"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"Bogus home_mode value %s\"",
            "argv[4]"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "argv[4]",
            "&eptr",
            "0"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "skeldir",
            "argv[3]"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"Too long skeldir path.\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[3]"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"Bogus umask value %s\"",
            "argv[2]"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "argv[2]",
            "&eptr",
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"User unknown.\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "argv[1]"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: %s <username> [<umask> [<skeldir> [<home_mode>]]]\\n\"",
            "argv[0]"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic unsigned long u_mask = 0022;\nstatic unsigned long home_mode = 0;\nstatic char skeldir[BUFSIZ] = \"/etc/skel\";\n\nint\nmain(int argc, char *argv[])\n{\n   struct passwd *pwd;\n   struct stat st;\n   char *eptr;\n\n   if (argc < 2) {\n\tfprintf(stderr, \"Usage: %s <username> [<umask> [<skeldir> [<home_mode>]]]\\n\", argv[0]);\n\treturn PAM_SESSION_ERR;\n   }\n\n   pwd = getpwnam(argv[1]);\n   if (pwd == NULL) {\n\tpam_syslog(NULL, LOG_ERR, \"User unknown.\");\n\treturn PAM_USER_UNKNOWN;\n   }\n\n   if (argc >= 3) {\n\terrno = 0;\n\tu_mask = strtoul(argv[2], &eptr, 0);\n\tif (errno != 0 || *eptr != '\\0') {\n\t\tpam_syslog(NULL, LOG_ERR, \"Bogus umask value %s\", argv[2]);\n\t\treturn PAM_SESSION_ERR;\n\t}\n   }\n\n   if (argc >= 4) {\n\tif (strlen(argv[3]) >= sizeof(skeldir)) {\n\t\tpam_syslog(NULL, LOG_ERR, \"Too long skeldir path.\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tstrcpy(skeldir, argv[3]);\n   }\n\n   if (argc >= 5) {\n       errno = 0;\n       home_mode = strtoul(argv[4], &eptr, 0);\n       if (errno != 0 || *eptr != '\\0') {\n\t\tpam_syslog(NULL, LOG_ERR, \"Bogus home_mode value %s\", argv[4]);\n\t\treturn PAM_SESSION_ERR;\n       }\n   }\n\n   if (home_mode == 0)\n      home_mode = 0777 & ~u_mask;\n\n   /* Stat the home directory, if something exists then we assume it is\n      correct and return a success */\n   if (stat(pwd->pw_dir, &st) == 0)\n\treturn PAM_SUCCESS;\n\n   if (make_parent_dirs(pwd->pw_dir, 0) != PAM_SUCCESS)\n\treturn PAM_PERM_DENIED;\n\n   return create_homedir_helper(pwd, skeldir, pwd->pw_dir);\n}"
  },
  {
    "function_name": "make_parent_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
    "lines": "355-381",
    "snippet": "static int\nmake_parent_dirs(char *dir, int make)\n{\n  int rc = PAM_SUCCESS;\n  char *cp = strrchr(dir, '/');\n  struct stat st;\n\n  if (!cp)\n    return rc;\n\n  if (cp != dir) {\n    *cp = '\\0';\n    if (stat(dir, &st) && errno == ENOENT)\n      rc = make_parent_dirs(dir, 1);\n    *cp = '/';\n\n    if (rc != PAM_SUCCESS)\n      return rc;\n  }\n\n  if (make && mkdir(dir, 0755) && errno != EEXIST) {\n    pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dir);\n    return PAM_PERM_DENIED;\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"unable to create directory %s: %m\"",
            "dir"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "0755"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_parent_dirs",
          "args": [
            "dir",
            "1"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "make_parent_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
          "lines": "355-381",
          "snippet": "static int\nmake_parent_dirs(char *dir, int make)\n{\n  int rc = PAM_SUCCESS;\n  char *cp = strrchr(dir, '/');\n  struct stat st;\n\n  if (!cp)\n    return rc;\n\n  if (cp != dir) {\n    *cp = '\\0';\n    if (stat(dir, &st) && errno == ENOENT)\n      rc = make_parent_dirs(dir, 1);\n    *cp = '/';\n\n    if (rc != PAM_SUCCESS)\n      return rc;\n  }\n\n  if (make && mkdir(dir, 0755) && errno != EEXIST) {\n    pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dir);\n    return PAM_PERM_DENIED;\n  }\n\n  return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&st"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "dir",
            "'/'"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic int\nmake_parent_dirs(char *dir, int make)\n{\n  int rc = PAM_SUCCESS;\n  char *cp = strrchr(dir, '/');\n  struct stat st;\n\n  if (!cp)\n    return rc;\n\n  if (cp != dir) {\n    *cp = '\\0';\n    if (stat(dir, &st) && errno == ENOENT)\n      rc = make_parent_dirs(dir, 1);\n    *cp = '/';\n\n    if (rc != PAM_SUCCESS)\n      return rc;\n  }\n\n  if (make && mkdir(dir, 0755) && errno != EEXIST) {\n    pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dir);\n    return PAM_PERM_DENIED;\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "create_homedir_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
    "lines": "337-353",
    "snippet": "static int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long home_mode = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to change perms on home directory %s: %m\"",
            "_homedir"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "_homedir",
            "home_mode"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_homedir",
          "args": [
            "_pwd",
            "_skeldir",
            "_homedir"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "create_homedir_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
          "lines": "337-353",
          "snippet": "static int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic unsigned long home_mode = 0;\n\nstatic int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}"
  },
  {
    "function_name": "create_homedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
    "lines": "34-335",
    "snippet": "static int\ncreate_homedir(const struct passwd *pwd,\n\t       const char *source, const char *dest)\n{\n   char remark[BUFSIZ];\n   DIR *d;\n   struct dirent *dent;\n   int retval = PAM_SESSION_ERR;\n\n   /* Create the new directory */\n   if (mkdir(dest, 0700) && errno != EEXIST)\n   {\n      pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dest);\n      return PAM_PERM_DENIED;\n   }\n\n   /* See if we need to copy the skel dir over. */\n   if ((source == NULL) || (strlen(source) == 0))\n   {\n      retval = PAM_SUCCESS;\n      goto go_out;\n   }\n\n   /* Scan the directory */\n   d = opendir(source);\n   if (d == NULL)\n   {\n      pam_syslog(NULL, LOG_DEBUG, \"unable to read directory %s: %m\", source);\n      retval = PAM_PERM_DENIED;\n      goto go_out;\n   }\n\n   for (dent = readdir(d); dent != NULL; dent = readdir(d))\n   {\n      int srcfd;\n      int destfd;\n      int res;\n      struct stat st;\n#ifndef PATH_MAX\n      char *newsource = NULL, *newdest = NULL;\n      /* track length of buffers */\n      int nslen = 0, ndlen = 0;\n      int slen = strlen(source), dlen = strlen(dest);\n#else\n      char newsource[PATH_MAX], newdest[PATH_MAX];\n#endif\n\n      /* Skip some files.. */\n      if (strcmp(dent->d_name,\".\") == 0 ||\n\t  strcmp(dent->d_name,\"..\") == 0)\n\t continue;\n\n      /* Determine what kind of file it is. */\n#ifndef PATH_MAX\n      nslen = slen + strlen(dent->d_name) + 2;\n\n      if (nslen <= 0)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      if ((newsource = malloc(nslen)) == NULL)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      sprintf(newsource, \"%s/%s\", source, dent->d_name);\n#else\n      snprintf(newsource, sizeof(newsource), \"%s/%s\", source, dent->d_name);\n#endif\n\n      if (lstat(newsource, &st) != 0)\n#ifndef PATH_MAX\n      {\n\t      free(newsource);\n\t      newsource = NULL;\n         continue;\n      }\n#else\n      continue;\n#endif\n\n\n      /* We'll need the new file's name. */\n#ifndef PATH_MAX\n      ndlen = dlen + strlen(dent->d_name)+2;\n\n      if (ndlen <= 0)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      if ((newdest = malloc(ndlen)) == NULL)\n\t{\n\t  free (newsource);\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      sprintf (newdest, \"%s/%s\", dest, dent->d_name);\n#else\n      snprintf (newdest, sizeof (newdest), \"%s/%s\", dest, dent->d_name);\n#endif\n\n      /* If it's a directory, recurse. */\n      if (S_ISDIR(st.st_mode))\n      {\n         retval = create_homedir(pwd, newsource, newdest);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n         if (retval != PAM_SUCCESS)\n\t   {\n\t     closedir(d);\n\t     goto go_out;\n\t   }\n         continue;\n      }\n\n      /* If it's a symlink, create a new link. */\n      if (S_ISLNK(st.st_mode))\n      {\n\t int pointedlen = 0;\n#ifndef PATH_MAX\n\t char *pointed = NULL;\n           {\n\t\t   int size = 100;\n\n\t\t   while (1) {\n\t\t\t   pointed = malloc(size);\n\t\t\t   if (pointed == NULL) {\n\t\t\t\t   free(newsource);\n\t\t\t\t   free(newdest);\n\t\t\t\t   return PAM_BUF_ERR;\n\t\t\t   }\n\t\t\t   pointedlen = readlink(newsource, pointed, size);\n\t\t\t   if (pointedlen < 0) break;\n\t\t\t   if (pointedlen < size) break;\n\t\t\t   free(pointed);\n\t\t\t   size *= 2;\n\t\t   }\n\t   }\n\t   if (pointedlen < 0)\n\t\t   free(pointed);\n\t   else\n\t\t   pointed[pointedlen] = 0;\n#else\n         char pointed[PATH_MAX];\n         memset(pointed, 0, sizeof(pointed));\n\n         pointedlen = readlink(newsource, pointed, sizeof(pointed) - 1);\n#endif\n\n\t if (pointedlen >= 0) {\n            if(symlink(pointed, newdest) == 0)\n            {\n               if (lchown(newdest, pwd->pw_uid, pwd->pw_gid) != 0)\n               {\n                   pam_syslog(NULL, LOG_DEBUG,\n\t\t\t      \"unable to change perms on link %s: %m\", newdest);\n                   closedir(d);\n#ifndef PATH_MAX\n\t\t   free(pointed);\n\t\t   free(newsource);\n\t\t   free(newdest);\n#endif\n                   return PAM_PERM_DENIED;\n               }\n            }\n#ifndef PATH_MAX\n\t    free(pointed);\n#endif\n         }\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n         continue;\n      }\n\n      /* If it's not a regular file, it's probably not a good idea to create\n       * the new device node, FIFO, or whatever it is. */\n      if (!S_ISREG(st.st_mode))\n      {\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n         continue;\n      }\n\n      /* Open the source file */\n      if ((srcfd = open(newsource, O_RDONLY)) < 0 || fstat(srcfd, &st) != 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to open or stat src file %s: %m\", newsource);\n         if (srcfd >= 0)\n            close(srcfd);\n         closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Open the dest file */\n      if ((destfd = open(newdest, O_WRONLY | O_TRUNC | O_CREAT, 0600)) < 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to open dest file %s: %m\", newdest);\n\t close(srcfd);\n\t closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Set the proper ownership and permissions for the module. We make\n         the file a+w and then mask it with the set mask. This preserves\n\t execute bits */\n      if (fchmod(destfd, (st.st_mode | 0222) & (~u_mask)) != 0 ||\n\t  fchown(destfd, pwd->pw_uid, pwd->pw_gid) != 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to change perms on copy %s: %m\", newdest);\n         close(srcfd);\n         close(destfd);\n         closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Copy the file */\n      do\n      {\n\t res = pam_modutil_read(srcfd, remark, sizeof(remark));\n\n\t if (res == 0)\n\t     continue;\n\n\t if (res > 0) {\n\t     if (pam_modutil_write(destfd, remark, res) == res)\n\t\tcontinue;\n\t }\n\n\t /* If we get here, pam_modutil_read returned a -1 or\n\t    pam_modutil_write returned something unexpected. */\n\t pam_syslog(NULL, LOG_DEBUG, \"unable to perform IO: %m\");\n\t close(srcfd);\n\t close(destfd);\n\t closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n      while (res != 0);\n      close(srcfd);\n      close(destfd);\n\n#ifndef PATH_MAX\n      free(newsource); newsource = NULL;\n      free(newdest); newdest = NULL;\n#endif\n\n   }\n   closedir(d);\n\n   retval = PAM_SUCCESS;\n\n go_out:\n\n   if (chmod(dest, 0777 & (~u_mask)) != 0 ||\n       chown(dest, pwd->pw_uid, pwd->pw_gid) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on directory %s: %m\", dest);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}",
    "includes": [
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <dirent.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdarg.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long u_mask = 0022;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to change perms on directory %s: %m\"",
            "dest"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "dest",
            "pwd->pw_uid",
            "pwd->pw_gid"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dest",
            "0777 & (~u_mask)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newdest"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "destfd"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "srcfd"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "destfd"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "srcfd"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to perform IO: %m\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "destfd",
            "remark",
            "res"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "srcfd",
            "remark",
            "sizeof(remark)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "destfd"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "srcfd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to change perms on copy %s: %m\"",
            "newdest"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "destfd",
            "pwd->pw_uid",
            "pwd->pw_gid"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "destfd",
            "(st.st_mode | 0222) & (~u_mask)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "srcfd"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to open dest file %s: %m\"",
            "newdest"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "newdest",
            "O_WRONLY | O_TRUNC | O_CREAT",
            "0600"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "srcfd"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to open or stat src file %s: %m\"",
            "newsource"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "srcfd",
            "&st"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "newsource",
            "O_RDONLY"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to change perms on link %s: %m\"",
            "newdest"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lchown",
          "args": [
            "newdest",
            "pwd->pw_uid",
            "pwd->pw_gid"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "pointed",
            "newdest"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "newsource",
            "pointed",
            "sizeof(pointed) - 1"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointed",
            "0",
            "sizeof(pointed)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "newsource",
            "pointed",
            "size"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_homedir",
          "args": [
            "pwd",
            "newsource",
            "newdest"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "create_homedir_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_mkhomedir/mkhomedir_helper.c",
          "lines": "337-353",
          "snippet": "static int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}",
          "includes": [
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdarg.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long home_mode = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic unsigned long home_mode = 0;\n\nstatic int\ncreate_homedir_helper(const struct passwd *_pwd,\n\t\t      const char *_skeldir, const char *_homedir)\n{\n   int retval = PAM_SESSION_ERR;\n\n   retval = create_homedir(_pwd, _skeldir, _homedir);\n\n   if (chmod(_homedir, home_mode) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on home directory %s: %m\", _homedir);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newdest",
            "sizeof (newdest)",
            "\"%s/%s\"",
            "dest",
            "dent->d_name"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "newdest",
            "\"%s/%s\"",
            "dest",
            "dent->d_name"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ndlen"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dent->d_name"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "newsource",
            "&st"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "newsource",
            "sizeof(newsource)",
            "\"%s/%s\"",
            "source",
            "dent->d_name"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "newsource",
            "\"%s/%s\"",
            "source",
            "dent->d_name"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nslen"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dent->d_name"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\"..\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\".\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "source"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "d"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "d"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_DEBUG",
            "\"unable to read directory %s: %m\"",
            "source"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "source"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "source"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "NULL",
            "LOG_ERR",
            "\"unable to create directory %s: %m\"",
            "dest"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dest",
            "0700"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include \"config.h\"\n\nstatic unsigned long u_mask = 0022;\n\nstatic int\ncreate_homedir(const struct passwd *pwd,\n\t       const char *source, const char *dest)\n{\n   char remark[BUFSIZ];\n   DIR *d;\n   struct dirent *dent;\n   int retval = PAM_SESSION_ERR;\n\n   /* Create the new directory */\n   if (mkdir(dest, 0700) && errno != EEXIST)\n   {\n      pam_syslog(NULL, LOG_ERR, \"unable to create directory %s: %m\", dest);\n      return PAM_PERM_DENIED;\n   }\n\n   /* See if we need to copy the skel dir over. */\n   if ((source == NULL) || (strlen(source) == 0))\n   {\n      retval = PAM_SUCCESS;\n      goto go_out;\n   }\n\n   /* Scan the directory */\n   d = opendir(source);\n   if (d == NULL)\n   {\n      pam_syslog(NULL, LOG_DEBUG, \"unable to read directory %s: %m\", source);\n      retval = PAM_PERM_DENIED;\n      goto go_out;\n   }\n\n   for (dent = readdir(d); dent != NULL; dent = readdir(d))\n   {\n      int srcfd;\n      int destfd;\n      int res;\n      struct stat st;\n#ifndef PATH_MAX\n      char *newsource = NULL, *newdest = NULL;\n      /* track length of buffers */\n      int nslen = 0, ndlen = 0;\n      int slen = strlen(source), dlen = strlen(dest);\n#else\n      char newsource[PATH_MAX], newdest[PATH_MAX];\n#endif\n\n      /* Skip some files.. */\n      if (strcmp(dent->d_name,\".\") == 0 ||\n\t  strcmp(dent->d_name,\"..\") == 0)\n\t continue;\n\n      /* Determine what kind of file it is. */\n#ifndef PATH_MAX\n      nslen = slen + strlen(dent->d_name) + 2;\n\n      if (nslen <= 0)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      if ((newsource = malloc(nslen)) == NULL)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      sprintf(newsource, \"%s/%s\", source, dent->d_name);\n#else\n      snprintf(newsource, sizeof(newsource), \"%s/%s\", source, dent->d_name);\n#endif\n\n      if (lstat(newsource, &st) != 0)\n#ifndef PATH_MAX\n      {\n\t      free(newsource);\n\t      newsource = NULL;\n         continue;\n      }\n#else\n      continue;\n#endif\n\n\n      /* We'll need the new file's name. */\n#ifndef PATH_MAX\n      ndlen = dlen + strlen(dent->d_name)+2;\n\n      if (ndlen <= 0)\n\t{\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      if ((newdest = malloc(ndlen)) == NULL)\n\t{\n\t  free (newsource);\n\t  retval = PAM_BUF_ERR;\n\t  goto go_out;\n\t}\n\n      sprintf (newdest, \"%s/%s\", dest, dent->d_name);\n#else\n      snprintf (newdest, sizeof (newdest), \"%s/%s\", dest, dent->d_name);\n#endif\n\n      /* If it's a directory, recurse. */\n      if (S_ISDIR(st.st_mode))\n      {\n         retval = create_homedir(pwd, newsource, newdest);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n         if (retval != PAM_SUCCESS)\n\t   {\n\t     closedir(d);\n\t     goto go_out;\n\t   }\n         continue;\n      }\n\n      /* If it's a symlink, create a new link. */\n      if (S_ISLNK(st.st_mode))\n      {\n\t int pointedlen = 0;\n#ifndef PATH_MAX\n\t char *pointed = NULL;\n           {\n\t\t   int size = 100;\n\n\t\t   while (1) {\n\t\t\t   pointed = malloc(size);\n\t\t\t   if (pointed == NULL) {\n\t\t\t\t   free(newsource);\n\t\t\t\t   free(newdest);\n\t\t\t\t   return PAM_BUF_ERR;\n\t\t\t   }\n\t\t\t   pointedlen = readlink(newsource, pointed, size);\n\t\t\t   if (pointedlen < 0) break;\n\t\t\t   if (pointedlen < size) break;\n\t\t\t   free(pointed);\n\t\t\t   size *= 2;\n\t\t   }\n\t   }\n\t   if (pointedlen < 0)\n\t\t   free(pointed);\n\t   else\n\t\t   pointed[pointedlen] = 0;\n#else\n         char pointed[PATH_MAX];\n         memset(pointed, 0, sizeof(pointed));\n\n         pointedlen = readlink(newsource, pointed, sizeof(pointed) - 1);\n#endif\n\n\t if (pointedlen >= 0) {\n            if(symlink(pointed, newdest) == 0)\n            {\n               if (lchown(newdest, pwd->pw_uid, pwd->pw_gid) != 0)\n               {\n                   pam_syslog(NULL, LOG_DEBUG,\n\t\t\t      \"unable to change perms on link %s: %m\", newdest);\n                   closedir(d);\n#ifndef PATH_MAX\n\t\t   free(pointed);\n\t\t   free(newsource);\n\t\t   free(newdest);\n#endif\n                   return PAM_PERM_DENIED;\n               }\n            }\n#ifndef PATH_MAX\n\t    free(pointed);\n#endif\n         }\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n         continue;\n      }\n\n      /* If it's not a regular file, it's probably not a good idea to create\n       * the new device node, FIFO, or whatever it is. */\n      if (!S_ISREG(st.st_mode))\n      {\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n         continue;\n      }\n\n      /* Open the source file */\n      if ((srcfd = open(newsource, O_RDONLY)) < 0 || fstat(srcfd, &st) != 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to open or stat src file %s: %m\", newsource);\n         if (srcfd >= 0)\n            close(srcfd);\n         closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Open the dest file */\n      if ((destfd = open(newdest, O_WRONLY | O_TRUNC | O_CREAT, 0600)) < 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to open dest file %s: %m\", newdest);\n\t close(srcfd);\n\t closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Set the proper ownership and permissions for the module. We make\n         the file a+w and then mask it with the set mask. This preserves\n\t execute bits */\n      if (fchmod(destfd, (st.st_mode | 0222) & (~u_mask)) != 0 ||\n\t  fchown(destfd, pwd->pw_uid, pwd->pw_gid) != 0)\n      {\n         pam_syslog(NULL, LOG_DEBUG,\n\t\t    \"unable to change perms on copy %s: %m\", newdest);\n         close(srcfd);\n         close(destfd);\n         closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n\n      /* Copy the file */\n      do\n      {\n\t res = pam_modutil_read(srcfd, remark, sizeof(remark));\n\n\t if (res == 0)\n\t     continue;\n\n\t if (res > 0) {\n\t     if (pam_modutil_write(destfd, remark, res) == res)\n\t\tcontinue;\n\t }\n\n\t /* If we get here, pam_modutil_read returned a -1 or\n\t    pam_modutil_write returned something unexpected. */\n\t pam_syslog(NULL, LOG_DEBUG, \"unable to perform IO: %m\");\n\t close(srcfd);\n\t close(destfd);\n\t closedir(d);\n\n#ifndef PATH_MAX\n\t free(newsource); newsource = NULL;\n\t free(newdest); newdest = NULL;\n#endif\n\n\t return PAM_PERM_DENIED;\n      }\n      while (res != 0);\n      close(srcfd);\n      close(destfd);\n\n#ifndef PATH_MAX\n      free(newsource); newsource = NULL;\n      free(newdest); newdest = NULL;\n#endif\n\n   }\n   closedir(d);\n\n   retval = PAM_SUCCESS;\n\n go_out:\n\n   if (chmod(dest, 0777 & (~u_mask)) != 0 ||\n       chown(dest, pwd->pw_uid, pwd->pw_gid) != 0)\n   {\n      pam_syslog(NULL, LOG_DEBUG,\n\t\t \"unable to change perms on directory %s: %m\", dest);\n      return PAM_PERM_DENIED;\n   }\n\n   return retval;\n}"
  }
]