[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "618-694",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    const void *service=NULL, *void_tty=NULL;\n    const char *tty;\n    const char *user=NULL;\n    const char *conf_file = NULL;\n    int ctrl;\n    int rv;\n\n    ctrl = _pam_parse(pamh, argc, argv, &conf_file);\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"conffile=%s\", conf_file);\n    }\n\n    /* set service name */\n\n    if (pam_get_item(pamh, PAM_SERVICE, &service)\n\t!= PAM_SUCCESS || service == NULL) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the current service name\");\n\treturn PAM_ABORT;\n    }\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    /* set tty name */\n\n    if (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS\n\t|| void_tty == NULL) {\n\tD((\"PAM_TTY not set, probing stdin\"));\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    tty = \"\";\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    else\n      tty = void_tty;\n\n    if (tty[0] == '/') {   /* full path */\n        const char *t;\n        tty++;\n        if ((t = strchr(tty, '/')) != NULL) {\n            tty = t + 1;\n        }\n    }\n\n    /* good, now we have the service name, the user and the terminal name */\n\n    D((\"service=%s\", service));\n    D((\"user=%s\", user));\n    D((\"tty=%s\", tty));\n\n    rv = check_account(pamh, service, tty, user, conf_file);\n    if (rv != PAM_SUCCESS) {\n#ifdef HAVE_LIBAUDIT\n\tif (!(ctrl & PAM_NO_AUDIT)) {\n            pam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_TIME,\n\t\t    \"pam_time\", rv); /* ignore return value as we fail anyway */\n        }\n#endif\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"user %s rejected\", user);\n\t}\n    }\n    return rv;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_NO_AUDIT        0x0002",
      "#define PAM_DEBUG_ARG       0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user %s rejected\"",
            "user"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_audit_write",
          "args": [
            "pamh",
            "AUDIT_ANOM_LOGIN_TIME",
            "\"pam_time\"",
            "rv"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_account",
          "args": [
            "pamh",
            "service",
            "tty",
            "user",
            "conf_file"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "check_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "528-614",
          "snippet": "static int\ncheck_account(pam_handle_t *pamh, const char *service,\n\t      const char *tty, const char *user, const char *file)\n{\n     int from=0, state=STATE_NL, fd=-1;\n     char *buffer=NULL;\n     int count=0;\n     TIME here_and_now;\n     int retval=PAM_SUCCESS;\n\n     here_and_now = time_now();                     /* find current time */\n     do {\n\t  int good=TRUE,intime;\n\n\t  /* here we get the service name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (!buffer || !buffer[0]) {\n\t       /* empty line .. ? */\n\t       continue;\n\t  }\n\t  ++count;\n\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  good = logic_field(pamh, service, buffer, count, is_same);\n\t  D((\"with service: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the terminal name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  good &= logic_field(pamh, tty, buffer, count, is_same);\n\t  D((\"with tty: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the username field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  /* If buffer starts with @, we are using netgroups */\n\t  if (buffer[0] == '@')\n#ifdef HAVE_INNETGR\n\t    good &= innetgr (&buffer[1], NULL, user, NULL);\n#else\n\t    pam_syslog (pamh, LOG_ERR, \"pam_time does not have netgroup support\");\n#endif\n\t  else\n\t    good &= logic_field(pamh, user, buffer, count, is_same);\n\t  D((\"with user: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the time field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state == STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: poorly terminated rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  intime = logic_field(pamh, &here_and_now, buffer, count, check_time);\n\t  D((\"with time: %s\", intime ? \"passes\":\"fails\" ));\n\n\t  if (good && !intime) {\n\t       /*\n\t\t* for security parse whole file..  also need to ensure\n\t\t* that the buffer is free()'d and the file is closed.\n\t\t*/\n\t       retval = PAM_PERM_DENIED;\n\t  } else {\n\t       D((\"rule passed\"));\n\t  }\n     } while (state != STATE_EOF);\n\n     return retval;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define STATE_EOF      3 /* end of file or error */",
            "#define STATE_FIELD    2 /* field following */",
            "#define STATE_NL       0 /* new line starting */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define STATE_EOF      3 /* end of file or error */\n#define STATE_FIELD    2 /* field following */\n#define STATE_NL       0 /* new line starting */\n\nstatic int\ncheck_account(pam_handle_t *pamh, const char *service,\n\t      const char *tty, const char *user, const char *file)\n{\n     int from=0, state=STATE_NL, fd=-1;\n     char *buffer=NULL;\n     int count=0;\n     TIME here_and_now;\n     int retval=PAM_SUCCESS;\n\n     here_and_now = time_now();                     /* find current time */\n     do {\n\t  int good=TRUE,intime;\n\n\t  /* here we get the service name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (!buffer || !buffer[0]) {\n\t       /* empty line .. ? */\n\t       continue;\n\t  }\n\t  ++count;\n\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  good = logic_field(pamh, service, buffer, count, is_same);\n\t  D((\"with service: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the terminal name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  good &= logic_field(pamh, tty, buffer, count, is_same);\n\t  D((\"with tty: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the username field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  /* If buffer starts with @, we are using netgroups */\n\t  if (buffer[0] == '@')\n#ifdef HAVE_INNETGR\n\t    good &= innetgr (&buffer[1], NULL, user, NULL);\n#else\n\t    pam_syslog (pamh, LOG_ERR, \"pam_time does not have netgroup support\");\n#endif\n\t  else\n\t    good &= logic_field(pamh, user, buffer, count, is_same);\n\t  D((\"with user: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the time field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state == STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: poorly terminated rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  intime = logic_field(pamh, &here_and_now, buffer, count, check_time);\n\t  D((\"with time: %s\", intime ? \"passes\":\"fails\" ));\n\n\t  if (good && !intime) {\n\t       /*\n\t\t* for security parse whole file..  also need to ensure\n\t\t* that the buffer is free()'d and the file is closed.\n\t\t*/\n\t       retval = PAM_PERM_DENIED;\n\t  } else {\n\t       D((\"rule passed\"));\n\t  }\n     } while (state != STATE_EOF);\n\n     return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"tty=%s\", tty)"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tty",
            "'/'"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"couldn't set tty name\""
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "tty"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&void_tty"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"cannot find the current service name\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"conffile=%s\"",
            "conf_file"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&conf_file"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "56-100",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_NO_AUDIT        0x0002",
            "#define PAM_DEBUG_ARG       0x0001",
            "#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")",
            "#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_NO_AUDIT        0x0002\n#define PAM_DEBUG_ARG       0x0001\n#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")\n#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_NO_AUDIT        0x0002\n#define PAM_DEBUG_ARG       0x0001\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags UNUSED,\n\t\t int argc, const char **argv)\n{\n    const void *service=NULL, *void_tty=NULL;\n    const char *tty;\n    const char *user=NULL;\n    const char *conf_file = NULL;\n    int ctrl;\n    int rv;\n\n    ctrl = _pam_parse(pamh, argc, argv, &conf_file);\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_DEBUG, \"conffile=%s\", conf_file);\n    }\n\n    /* set service name */\n\n    if (pam_get_item(pamh, PAM_SERVICE, &service)\n\t!= PAM_SUCCESS || service == NULL) {\n\tpam_syslog(pamh, LOG_ERR, \"cannot find the current service name\");\n\treturn PAM_ABORT;\n    }\n\n    /* set username */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || *user == '\\0') {\n\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    /* set tty name */\n\n    if (pam_get_item(pamh, PAM_TTY, &void_tty) != PAM_SUCCESS\n\t|| void_tty == NULL) {\n\tD((\"PAM_TTY not set, probing stdin\"));\n\ttty = ttyname(STDIN_FILENO);\n\tif (tty == NULL) {\n\t    tty = \"\";\n\t}\n\tif (pam_set_item(pamh, PAM_TTY, tty) != PAM_SUCCESS) {\n\t    pam_syslog(pamh, LOG_ERR, \"couldn't set tty name\");\n\t    return PAM_ABORT;\n\t}\n    }\n    else\n      tty = void_tty;\n\n    if (tty[0] == '/') {   /* full path */\n        const char *t;\n        tty++;\n        if ((t = strchr(tty, '/')) != NULL) {\n            tty = t + 1;\n        }\n    }\n\n    /* good, now we have the service name, the user and the terminal name */\n\n    D((\"service=%s\", service));\n    D((\"user=%s\", user));\n    D((\"tty=%s\", tty));\n\n    rv = check_account(pamh, service, tty, user, conf_file);\n    if (rv != PAM_SUCCESS) {\n#ifdef HAVE_LIBAUDIT\n\tif (!(ctrl & PAM_NO_AUDIT)) {\n            pam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_TIME,\n\t\t    \"pam_time\", rv); /* ignore return value as we fail anyway */\n        }\n#endif\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG, \"user %s rejected\", user);\n\t}\n    }\n    return rv;\n}"
  },
  {
    "function_name": "check_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "528-614",
    "snippet": "static int\ncheck_account(pam_handle_t *pamh, const char *service,\n\t      const char *tty, const char *user, const char *file)\n{\n     int from=0, state=STATE_NL, fd=-1;\n     char *buffer=NULL;\n     int count=0;\n     TIME here_and_now;\n     int retval=PAM_SUCCESS;\n\n     here_and_now = time_now();                     /* find current time */\n     do {\n\t  int good=TRUE,intime;\n\n\t  /* here we get the service name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (!buffer || !buffer[0]) {\n\t       /* empty line .. ? */\n\t       continue;\n\t  }\n\t  ++count;\n\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  good = logic_field(pamh, service, buffer, count, is_same);\n\t  D((\"with service: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the terminal name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  good &= logic_field(pamh, tty, buffer, count, is_same);\n\t  D((\"with tty: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the username field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  /* If buffer starts with @, we are using netgroups */\n\t  if (buffer[0] == '@')\n#ifdef HAVE_INNETGR\n\t    good &= innetgr (&buffer[1], NULL, user, NULL);\n#else\n\t    pam_syslog (pamh, LOG_ERR, \"pam_time does not have netgroup support\");\n#endif\n\t  else\n\t    good &= logic_field(pamh, user, buffer, count, is_same);\n\t  D((\"with user: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the time field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state == STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: poorly terminated rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  intime = logic_field(pamh, &here_and_now, buffer, count, check_time);\n\t  D((\"with time: %s\", intime ? \"passes\":\"fails\" ));\n\n\t  if (good && !intime) {\n\t       /*\n\t\t* for security parse whole file..  also need to ensure\n\t\t* that the buffer is free()'d and the file is closed.\n\t\t*/\n\t       retval = PAM_PERM_DENIED;\n\t  } else {\n\t       D((\"rule passed\"));\n\t  }\n     } while (state != STATE_EOF);\n\n     return retval;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define STATE_EOF      3 /* end of file or error */",
      "#define STATE_FIELD    2 /* field following */",
      "#define STATE_NL       0 /* new line starting */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"rule passed\")"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logic_field",
          "args": [
            "pamh",
            "&here_and_now",
            "buffer",
            "count",
            "check_time"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "logic_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "306-358",
          "snippet": "static int\nlogic_field(pam_handle_t *pamh, const void *me, const char *x, int rule,\n\t    int (*agrees)(pam_handle_t *pamh,\n\t\t\t      const void *, const char *, int, int))\n{\n     int left=FALSE, right, not=FALSE;\n     operator oper=OR;\n     int at=0, l;\n     expect next=VAL;\n\n     while ((l = logic_member(x,&at))) {\n\t  int c = x[at];\n\n\t  if (next == VAL) {\n\t       if (c == '!')\n\t\t    not = !not;\n\t       else if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n                    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    right = not ^ agrees(pamh, me, x+at, l, rule);\n\t\t    if (oper == AND)\n\t\t\t left &= right;\n\t\t    else\n\t\t\t left |= right;\n\t\t    next = OP;\n\t       } else {\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected name (rule #%d)\",\n\t\t\t       rule);\n\t\t    return FALSE;\n\t       }\n\t  } else {   /* OP */\n\t       switch (c) {\n\t       case '&':\n\t\t    oper = AND;\n\t\t    break;\n\t       case '|':\n\t\t    oper = OR;\n\t\t    break;\n\t       default:\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected & or | (rule #%d)\",\n\t\t\t       rule);\n\t\t    D((\"%c at %d\",c,at));\n\t\t    return FALSE;\n\t       }\n\t       next = VAL;\n\t       not = FALSE;\n\t  }\n\t  at += l;\n     }\n\n     return left;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic int\nlogic_field(pam_handle_t *pamh, const void *me, const char *x, int rule,\n\t    int (*agrees)(pam_handle_t *pamh,\n\t\t\t      const void *, const char *, int, int))\n{\n     int left=FALSE, right, not=FALSE;\n     operator oper=OR;\n     int at=0, l;\n     expect next=VAL;\n\n     while ((l = logic_member(x,&at))) {\n\t  int c = x[at];\n\n\t  if (next == VAL) {\n\t       if (c == '!')\n\t\t    not = !not;\n\t       else if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n                    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    right = not ^ agrees(pamh, me, x+at, l, rule);\n\t\t    if (oper == AND)\n\t\t\t left &= right;\n\t\t    else\n\t\t\t left |= right;\n\t\t    next = OP;\n\t       } else {\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected name (rule #%d)\",\n\t\t\t       rule);\n\t\t    return FALSE;\n\t       }\n\t  } else {   /* OP */\n\t       switch (c) {\n\t       case '&':\n\t\t    oper = AND;\n\t\t    break;\n\t       case '|':\n\t\t    oper = OR;\n\t\t    break;\n\t       default:\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected & or | (rule #%d)\",\n\t\t\t       rule);\n\t\t    D((\"%c at %d\",c,at));\n\t\t    return FALSE;\n\t       }\n\t       next = VAL;\n\t       not = FALSE;\n\t  }\n\t  at += l;\n     }\n\n     return left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: poorly terminated rule #%d\"",
            "file",
            "count"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_field",
          "args": [
            "pamh",
            "fd",
            "&buffer",
            "&from",
            "&state",
            "file"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "read_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "131-257",
          "snippet": "static int\nread_field(const pam_handle_t *pamh, int fd, char **buf, int *from, int *state, const char *file)\n{\n    char *to;\n    char *src;\n    int i;\n    char c;\n    int onspace;\n\n    /* is buf set ? */\n    if (! *buf) {\n\t*buf = (char *) calloc(1, PAM_TIME_BUFLEN+1);\n\tif (! *buf) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    D((\"no memory\"));\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n\t*from = 0;\n        *state = STATE_NL;\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", file);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n    }\n\n\n    if (*from > 0)\n\tto = shift_buf(*buf, *from);\n    else\n\tto = *buf;\n\n    while (fd != -1 && to - *buf < PAM_TIME_BUFLEN) {\n\ti = pam_modutil_read(fd, to, PAM_TIME_BUFLEN - (to - *buf));\n\tif (i < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error reading %s: %m\", file);\n\t    close(fd);\n\t    memset(*buf, 0, PAM_TIME_BUFLEN);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t} else if (!i) {\n\t    close(fd);\n\t    fd = -1;          /* end of file reached */\n\t}\n\n\tto += i;\n    }\n\n    if (to == *buf) {\n\t/* nothing previously in buf, nothing read */\n\t_pam_drop(*buf);\n\t*state = STATE_EOF;\n\treturn -1;\n    }\n\n    memset(to, '\\0', PAM_TIME_BUFLEN - (to - *buf));\n\n    to = *buf;\n    onspace = 1; /* delete any leading spaces */\n\n    for (src = to; (c=*src) != '\\0'; ++src) {\n\tif (*state == STATE_COMMENT && c != '\\n') {\n\t\tcontinue;\n\t}\n\n\tswitch (c) {\n\t    case '\\n':\n\t\t*state = STATE_NL;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\t':\n            case ' ':\n\t\tif (!onspace) {\n\t\t    onspace = 1;\n\t\t    *to++ = ' ';\n\t\t}\n\t\tbreak;\n\n            case '!':\n\t\tonspace = 1; /* ignore following spaces */\n\t\t*to++ = '!';\n\t\tbreak;\n\n\t    case '#':\n\t\t*state = STATE_COMMENT;\n\t\tbreak;\n\n\t    case FIELD_SEPARATOR:\n\t\t*state = STATE_FIELD;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\\\':\n\t\tif (src[1] == '\\n') {\n\t\t    ++src; /* skip it */\n\t\t    break;\n\t\t}\n\t\t/* fallthrough */\n\t    default:\n\t\t*to++ = c;\n\t\tonspace = 0;\n\t}\n\tif (src > to)\n\t    *src = '\\0'; /* clearing */\n    }\n\n    if (*state != STATE_COMMENT) {\n\t*state = STATE_COMMENT;\n\tpam_syslog(pamh, LOG_ERR, \"field too long - ignored\");\n\t**buf = '\\0';\n    } else {\n\t*to = '\\0';\n\ttrim_spaces(*buf, to);\n    }\n\n    *from = 0;\n    return fd;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define STATE_EOF      3 /* end of file or error */",
            "#define STATE_FIELD    2 /* field following */",
            "#define STATE_COMMENT  1 /* inside comment */",
            "#define STATE_NL       0 /* new line starting */",
            "#define FIELD_SEPARATOR        ';'   /* this is new as of .02 */",
            "#define PAM_TIME_BUFLEN        1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define STATE_EOF      3 /* end of file or error */\n#define STATE_FIELD    2 /* field following */\n#define STATE_COMMENT  1 /* inside comment */\n#define STATE_NL       0 /* new line starting */\n#define FIELD_SEPARATOR        ';'   /* this is new as of .02 */\n#define PAM_TIME_BUFLEN        1000\n\nstatic int\nread_field(const pam_handle_t *pamh, int fd, char **buf, int *from, int *state, const char *file)\n{\n    char *to;\n    char *src;\n    int i;\n    char c;\n    int onspace;\n\n    /* is buf set ? */\n    if (! *buf) {\n\t*buf = (char *) calloc(1, PAM_TIME_BUFLEN+1);\n\tif (! *buf) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    D((\"no memory\"));\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n\t*from = 0;\n        *state = STATE_NL;\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", file);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n    }\n\n\n    if (*from > 0)\n\tto = shift_buf(*buf, *from);\n    else\n\tto = *buf;\n\n    while (fd != -1 && to - *buf < PAM_TIME_BUFLEN) {\n\ti = pam_modutil_read(fd, to, PAM_TIME_BUFLEN - (to - *buf));\n\tif (i < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error reading %s: %m\", file);\n\t    close(fd);\n\t    memset(*buf, 0, PAM_TIME_BUFLEN);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t} else if (!i) {\n\t    close(fd);\n\t    fd = -1;          /* end of file reached */\n\t}\n\n\tto += i;\n    }\n\n    if (to == *buf) {\n\t/* nothing previously in buf, nothing read */\n\t_pam_drop(*buf);\n\t*state = STATE_EOF;\n\treturn -1;\n    }\n\n    memset(to, '\\0', PAM_TIME_BUFLEN - (to - *buf));\n\n    to = *buf;\n    onspace = 1; /* delete any leading spaces */\n\n    for (src = to; (c=*src) != '\\0'; ++src) {\n\tif (*state == STATE_COMMENT && c != '\\n') {\n\t\tcontinue;\n\t}\n\n\tswitch (c) {\n\t    case '\\n':\n\t\t*state = STATE_NL;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\t':\n            case ' ':\n\t\tif (!onspace) {\n\t\t    onspace = 1;\n\t\t    *to++ = ' ';\n\t\t}\n\t\tbreak;\n\n            case '!':\n\t\tonspace = 1; /* ignore following spaces */\n\t\t*to++ = '!';\n\t\tbreak;\n\n\t    case '#':\n\t\t*state = STATE_COMMENT;\n\t\tbreak;\n\n\t    case FIELD_SEPARATOR:\n\t\t*state = STATE_FIELD;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\\\':\n\t\tif (src[1] == '\\n') {\n\t\t    ++src; /* skip it */\n\t\t    break;\n\t\t}\n\t\t/* fallthrough */\n\t    default:\n\t\t*to++ = c;\n\t\tonspace = 0;\n\t}\n\tif (src > to)\n\t    *src = '\\0'; /* clearing */\n    }\n\n    if (*state != STATE_COMMENT) {\n\t*state = STATE_COMMENT;\n\tpam_syslog(pamh, LOG_ERR, \"field too long - ignored\");\n\t**buf = '\\0';\n    } else {\n\t*to = '\\0';\n\ttrim_spaces(*buf, to);\n    }\n\n    *from = 0;\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"pam_time does not have netgroup support\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "innetgr",
          "args": [
            "&buffer[1]",
            "NULL",
            "user",
            "NULL"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate_notinnetgr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_succeed_if/pam_succeed_if.c",
          "lines": "277-287",
          "snippet": "static int\nevaluate_notinnetgr(const pam_handle_t* pamh SOMETIMES_UNUSED, const char *host, const char *user, const char *group)\n{\n#ifdef HAVE_INNETGR\n\tif (innetgr(group, host, user, NULL) == 0)\n\t\treturn PAM_SUCCESS;\n#else\n\tpam_syslog (pamh, LOG_ERR, \"pam_succeed_if does not have netgroup support\");\n#endif\n\treturn PAM_AUTH_ERR;\n}",
          "includes": [
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <fnmatch.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <netdb.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <fnmatch.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic int\nevaluate_notinnetgr(const pam_handle_t* pamh SOMETIMES_UNUSED, const char *host, const char *user, const char *group)\n{\n#ifdef HAVE_INNETGR\n\tif (innetgr(group, host, user, NULL) == 0)\n\t\treturn PAM_SUCCESS;\n#else\n\tpam_syslog (pamh, LOG_ERR, \"pam_succeed_if does not have netgroup support\");\n#endif\n\treturn PAM_AUTH_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: malformed rule #%d\"",
            "file",
            "count"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: malformed rule #%d\"",
            "file",
            "count"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s: malformed rule #%d\"",
            "file",
            "count"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_now",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "time_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "408-422",
          "snippet": "static TIME\ntime_now(void)\n{\n     struct tm *local;\n     time_t the_time;\n     TIME this;\n\n     the_time = time((time_t *)0);                /* get the current time */\n     local = localtime(&the_time);\n     this.day = days[local->tm_wday].bit;\n     this.minute = local->tm_hour*100 + local->tm_min;\n\n     D((\"day: 0%o, time: %.4d\", this.day, this.minute));\n     return this;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};\n\nstatic TIME\ntime_now(void)\n{\n     struct tm *local;\n     time_t the_time;\n     TIME this;\n\n     the_time = time((time_t *)0);                /* get the current time */\n     local = localtime(&the_time);\n     this.day = days[local->tm_wday].bit;\n     this.minute = local->tm_hour*100 + local->tm_min;\n\n     D((\"day: 0%o, time: %.4d\", this.day, this.minute));\n     return this;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define STATE_EOF      3 /* end of file or error */\n#define STATE_FIELD    2 /* field following */\n#define STATE_NL       0 /* new line starting */\n\nstatic int\ncheck_account(pam_handle_t *pamh, const char *service,\n\t      const char *tty, const char *user, const char *file)\n{\n     int from=0, state=STATE_NL, fd=-1;\n     char *buffer=NULL;\n     int count=0;\n     TIME here_and_now;\n     int retval=PAM_SUCCESS;\n\n     here_and_now = time_now();                     /* find current time */\n     do {\n\t  int good=TRUE,intime;\n\n\t  /* here we get the service name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (!buffer || !buffer[0]) {\n\t       /* empty line .. ? */\n\t       continue;\n\t  }\n\t  ++count;\n\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  good = logic_field(pamh, service, buffer, count, is_same);\n\t  D((\"with service: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the terminal name field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  good &= logic_field(pamh, tty, buffer, count, is_same);\n\t  D((\"with tty: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the username field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state != STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: malformed rule #%d\", file, count);\n\t       continue;\n\t  }\n\t  /* If buffer starts with @, we are using netgroups */\n\t  if (buffer[0] == '@')\n#ifdef HAVE_INNETGR\n\t    good &= innetgr (&buffer[1], NULL, user, NULL);\n#else\n\t    pam_syslog (pamh, LOG_ERR, \"pam_time does not have netgroup support\");\n#endif\n\t  else\n\t    good &= logic_field(pamh, user, buffer, count, is_same);\n\t  D((\"with user: %s\", good ? \"passes\":\"fails\" ));\n\n\t  /* here we get the time field */\n\n\t  fd = read_field(pamh, fd, &buffer, &from, &state, file);\n\t  if (state == STATE_FIELD) {\n\t       pam_syslog(pamh, LOG_ERR,\n\t\t\t  \"%s: poorly terminated rule #%d\", file, count);\n\t       continue;\n\t  }\n\n\t  intime = logic_field(pamh, &here_and_now, buffer, count, check_time);\n\t  D((\"with time: %s\", intime ? \"passes\":\"fails\" ));\n\n\t  if (good && !intime) {\n\t       /*\n\t\t* for security parse whole file..  also need to ensure\n\t\t* that the buffer is free()'d and the file is closed.\n\t\t*/\n\t       retval = PAM_PERM_DENIED;\n\t  } else {\n\t       D((\"rule passed\"));\n\t  }\n     } while (state != STATE_EOF);\n\n     return retval;\n}"
  },
  {
    "function_name": "check_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "425-526",
    "snippet": "static int\ncheck_time(pam_handle_t *pamh, const void *AT, const char *times,\n\t   int len, int rule)\n{\n     int not,pass;\n     int marked_day, time_start, time_end;\n     const TIME *at;\n     int i,j=0;\n\n     at = AT;\n     D((\"chcking: 0%o/%.4d vs. %s\", at->day, at->minute, times));\n\n     if (times == NULL) {\n\t  /* this should not happen */\n\t  pam_syslog(pamh, LOG_CRIT,\n\t\t     \"internal error in file %s at line %d\",\n\t\t     __FILE__, __LINE__);\n\t  return FALSE;\n     }\n\n     if (times[j] == '!') {\n\t  ++j;\n\t  not = TRUE;\n     } else {\n\t  not = FALSE;\n     }\n\n     for (marked_day = 0; len > 0 && isalpha(times[j]); --len) {\n\t  int this_day=-1;\n\n\t  D((\"%c%c ?\", times[j], times[j+1]));\n\t  for (i=0; days[i].d != NULL; ++i) {\n\t       if (tolower(times[j]) == days[i].d[0]\n\t\t   && tolower(times[j+1]) == days[i].d[1] ) {\n\t\t    this_day = days[i].bit;\n\t\t    break;\n\t       }\n\t  }\n\t  j += 2;\n\t  if (this_day == -1) {\n\t       pam_syslog(pamh, LOG_ERR, \"bad day specified (rule #%d)\", rule);\n\t       return FALSE;\n\t  }\n\t  marked_day ^= this_day;\n     }\n     if (marked_day == 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"no day specified\");\n\t  return FALSE;\n     }\n     D((\"day range = 0%o\", marked_day));\n\n     time_start = 0;\n     for (i=0; len > 0 && i < 4 && isdigit(times[i+j]); ++i, --len) {\n\t  time_start *= 10;\n\t  time_start += times[i+j]-'0';        /* is this portable? */\n     }\n     j += i;\n\n     if (times[j] == '-') {\n\t  time_end = 0;\n\t  for (i=1; len > 0 && i < 5 && isdigit(times[i+j]); ++i, --len) {\n\t       time_end *= 10;\n\t       time_end += times[i+j]-'0';    /* is this portable */\n\t  }\n\t  j += i;\n     } else\n\t  time_end = -1;\n\n     D((\"i=%d, time_end=%d, times[j]='%c'\", i, time_end, times[j]));\n     if (i != 5 || time_end == -1) {\n\t  pam_syslog(pamh, LOG_ERR, \"no/bad times specified (rule #%d)\", rule);\n\t  return TRUE;\n     }\n     D((\"times(%d to %d)\", time_start,time_end));\n     D((\"marked_day = 0%o\", marked_day));\n\n     /* compare with the actual time now */\n\n     pass = FALSE;\n     if (time_start < time_end) {    /* start < end ? --> same day */\n\t  if ((at->day & marked_day) && (at->minute >= time_start)\n\t      && (at->minute < time_end)) {\n\t       D((\"time is listed\"));\n\t       pass = TRUE;\n\t  }\n     } else {                                    /* spans two days */\n\t  if ((at->day & marked_day) && (at->minute >= time_start)) {\n\t       D((\"caught on first day\"));\n\t       pass = TRUE;\n\t  } else {\n\t       marked_day <<= 1;\n\t       marked_day |= (marked_day & 0200) ? 1:0;\n\t       D((\"next day = 0%o\", marked_day));\n\t       if ((at->day & marked_day) && (at->minute <= time_end)) {\n\t\t    D((\"caught on second day\"));\n\t\t    pass = TRUE;\n\t       }\n\t  }\n     }\n\n     return (not ^ pass);\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"caught on second day\")"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"no/bad times specified (rule #%d)\"",
            "rule"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "times[i+j]"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "times[i+j]"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"no day specified\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"bad day specified (rule #%d)\"",
            "rule"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "times[j+1]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "times[j]"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "times[j]"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"internal error in file %s at line %d\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};\n\nstatic int\ncheck_time(pam_handle_t *pamh, const void *AT, const char *times,\n\t   int len, int rule)\n{\n     int not,pass;\n     int marked_day, time_start, time_end;\n     const TIME *at;\n     int i,j=0;\n\n     at = AT;\n     D((\"chcking: 0%o/%.4d vs. %s\", at->day, at->minute, times));\n\n     if (times == NULL) {\n\t  /* this should not happen */\n\t  pam_syslog(pamh, LOG_CRIT,\n\t\t     \"internal error in file %s at line %d\",\n\t\t     __FILE__, __LINE__);\n\t  return FALSE;\n     }\n\n     if (times[j] == '!') {\n\t  ++j;\n\t  not = TRUE;\n     } else {\n\t  not = FALSE;\n     }\n\n     for (marked_day = 0; len > 0 && isalpha(times[j]); --len) {\n\t  int this_day=-1;\n\n\t  D((\"%c%c ?\", times[j], times[j+1]));\n\t  for (i=0; days[i].d != NULL; ++i) {\n\t       if (tolower(times[j]) == days[i].d[0]\n\t\t   && tolower(times[j+1]) == days[i].d[1] ) {\n\t\t    this_day = days[i].bit;\n\t\t    break;\n\t       }\n\t  }\n\t  j += 2;\n\t  if (this_day == -1) {\n\t       pam_syslog(pamh, LOG_ERR, \"bad day specified (rule #%d)\", rule);\n\t       return FALSE;\n\t  }\n\t  marked_day ^= this_day;\n     }\n     if (marked_day == 0) {\n\t  pam_syslog(pamh, LOG_ERR, \"no day specified\");\n\t  return FALSE;\n     }\n     D((\"day range = 0%o\", marked_day));\n\n     time_start = 0;\n     for (i=0; len > 0 && i < 4 && isdigit(times[i+j]); ++i, --len) {\n\t  time_start *= 10;\n\t  time_start += times[i+j]-'0';        /* is this portable? */\n     }\n     j += i;\n\n     if (times[j] == '-') {\n\t  time_end = 0;\n\t  for (i=1; len > 0 && i < 5 && isdigit(times[i+j]); ++i, --len) {\n\t       time_end *= 10;\n\t       time_end += times[i+j]-'0';    /* is this portable */\n\t  }\n\t  j += i;\n     } else\n\t  time_end = -1;\n\n     D((\"i=%d, time_end=%d, times[j]='%c'\", i, time_end, times[j]));\n     if (i != 5 || time_end == -1) {\n\t  pam_syslog(pamh, LOG_ERR, \"no/bad times specified (rule #%d)\", rule);\n\t  return TRUE;\n     }\n     D((\"times(%d to %d)\", time_start,time_end));\n     D((\"marked_day = 0%o\", marked_day));\n\n     /* compare with the actual time now */\n\n     pass = FALSE;\n     if (time_start < time_end) {    /* start < end ? --> same day */\n\t  if ((at->day & marked_day) && (at->minute >= time_start)\n\t      && (at->minute < time_end)) {\n\t       D((\"time is listed\"));\n\t       pass = TRUE;\n\t  }\n     } else {                                    /* spans two days */\n\t  if ((at->day & marked_day) && (at->minute >= time_start)) {\n\t       D((\"caught on first day\"));\n\t       pass = TRUE;\n\t  } else {\n\t       marked_day <<= 1;\n\t       marked_day |= (marked_day & 0200) ? 1:0;\n\t       D((\"next day = 0%o\", marked_day));\n\t       if ((at->day & marked_day) && (at->minute <= time_end)) {\n\t\t    D((\"caught on second day\"));\n\t\t    pass = TRUE;\n\t       }\n\t  }\n     }\n\n     return (not ^ pass);\n}"
  },
  {
    "function_name": "time_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "408-422",
    "snippet": "static TIME\ntime_now(void)\n{\n     struct tm *local;\n     time_t the_time;\n     TIME this;\n\n     the_time = time((time_t *)0);                /* get the current time */\n     local = localtime(&the_time);\n     this.day = days[local->tm_wday].bit;\n     this.minute = local->tm_hour*100 + local->tm_min;\n\n     D((\"day: 0%o, time: %.4d\", this.day, this.minute));\n     return this;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"day: 0%o, time: %.4d\", this.day, this.minute)"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&the_time"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "(time_t *)0"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic struct day {\n     const char *d;\n     int bit;\n} const days[11] = {\n     { \"su\", 01 },\n     { \"mo\", 02 },\n     { \"tu\", 04 },\n     { \"we\", 010 },\n     { \"th\", 020 },\n     { \"fr\", 040 },\n     { \"sa\", 0100 },\n     { \"wk\", 076 },\n     { \"wd\", 0101 },\n     { \"al\", 0177 },\n     { NULL, 0 }\n};\n\nstatic TIME\ntime_now(void)\n{\n     struct tm *local;\n     time_t the_time;\n     TIME this;\n\n     the_time = time((time_t *)0);                /* get the current time */\n     local = localtime(&the_time);\n     this.day = days[local->tm_wday].bit;\n     this.minute = local->tm_hour*100 + local->tm_min;\n\n     D((\"day: 0%o, time: %.4d\", this.day, this.minute));\n     return this;\n}"
  },
  {
    "function_name": "is_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "360-384",
    "snippet": "static int\nis_same(pam_handle_t *pamh UNUSED, const void *A, const char *b,\n\tint len, int rule UNUSED)\n{\n     int i;\n     const char *a;\n\n     a = A;\n     for (i=0; len > 0; ++i, --len) {\n\t  if (b[i] != a[i]) {\n\t       if (b[i++] == '*') {\n\t\t    return (!--len || !strncmp(b+i,a+strlen(a)-len,len));\n\t       } else\n\t\t    return FALSE;\n\t  }\n     }\n\n     /* Ok, we know that b is a substring from A and does not contain\n        wildcards, but now the length of both strings must be the same,\n        too. In this case it means, a[i] has to be the end of the string. */\n     if (a[i] != '\\0')\n          return FALSE;\n\n     return ( !len );\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "b+i",
            "a+strlen(a)-len",
            "len"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "a"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic int\nis_same(pam_handle_t *pamh UNUSED, const void *A, const char *b,\n\tint len, int rule UNUSED)\n{\n     int i;\n     const char *a;\n\n     a = A;\n     for (i=0; len > 0; ++i, --len) {\n\t  if (b[i] != a[i]) {\n\t       if (b[i++] == '*') {\n\t\t    return (!--len || !strncmp(b+i,a+strlen(a)-len,len));\n\t       } else\n\t\t    return FALSE;\n\t  }\n     }\n\n     /* Ok, we know that b is a substring from A and does not contain\n        wildcards, but now the length of both strings must be the same,\n        too. In this case it means, a[i] has to be the end of the string. */\n     if (a[i] != '\\0')\n          return FALSE;\n\n     return ( !len );\n}"
  },
  {
    "function_name": "logic_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "306-358",
    "snippet": "static int\nlogic_field(pam_handle_t *pamh, const void *me, const char *x, int rule,\n\t    int (*agrees)(pam_handle_t *pamh,\n\t\t\t      const void *, const char *, int, int))\n{\n     int left=FALSE, right, not=FALSE;\n     operator oper=OR;\n     int at=0, l;\n     expect next=VAL;\n\n     while ((l = logic_member(x,&at))) {\n\t  int c = x[at];\n\n\t  if (next == VAL) {\n\t       if (c == '!')\n\t\t    not = !not;\n\t       else if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n                    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    right = not ^ agrees(pamh, me, x+at, l, rule);\n\t\t    if (oper == AND)\n\t\t\t left &= right;\n\t\t    else\n\t\t\t left |= right;\n\t\t    next = OP;\n\t       } else {\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected name (rule #%d)\",\n\t\t\t       rule);\n\t\t    return FALSE;\n\t       }\n\t  } else {   /* OP */\n\t       switch (c) {\n\t       case '&':\n\t\t    oper = AND;\n\t\t    break;\n\t       case '|':\n\t\t    oper = OR;\n\t\t    break;\n\t       default:\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected & or | (rule #%d)\",\n\t\t\t       rule);\n\t\t    D((\"%c at %d\",c,at));\n\t\t    return FALSE;\n\t       }\n\t       next = VAL;\n\t       not = FALSE;\n\t  }\n\t  at += l;\n     }\n\n     return left;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"%c at %d\",c,at)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"garbled syntax; expected & or | (rule #%d)\"",
            "rule"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"garbled syntax; expected name (rule #%d)\"",
            "rule"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "agrees",
          "args": [
            "pamh",
            "me",
            "x+at",
            "l",
            "rule"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "c"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logic_member",
          "args": [
            "x",
            "&at"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "logic_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "261-302",
          "snippet": "static int\nlogic_member(const char *string, int *at)\n{\n     int c,to;\n     int done=0;\n     int token=0;\n\n     to=*at;\n     do {\n\t  c = string[to++];\n\n\t  switch (c) {\n\n\t  case '\\0':\n\t       --to;\n\t       done = 1;\n\t       break;\n\n\t  case '&':\n\t  case '|':\n\t  case '!':\n\t       if (token) {\n\t\t    --to;\n\t       }\n\t       done = 1;\n\t       break;\n\n\t  default:\n\t       if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n\t\t    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    token = 1;\n\t       } else if (token) {\n\t\t    --to;\n\t\t    done = 1;\n\t       } else {\n\t\t    ++*at;\n\t       }\n\t  }\n     } while (!done);\n\n     return to - *at;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic int\nlogic_member(const char *string, int *at)\n{\n     int c,to;\n     int done=0;\n     int token=0;\n\n     to=*at;\n     do {\n\t  c = string[to++];\n\n\t  switch (c) {\n\n\t  case '\\0':\n\t       --to;\n\t       done = 1;\n\t       break;\n\n\t  case '&':\n\t  case '|':\n\t  case '!':\n\t       if (token) {\n\t\t    --to;\n\t       }\n\t       done = 1;\n\t       break;\n\n\t  default:\n\t       if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n\t\t    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    token = 1;\n\t       } else if (token) {\n\t\t    --to;\n\t\t    done = 1;\n\t       } else {\n\t\t    ++*at;\n\t       }\n\t  }\n     } while (!done);\n\n     return to - *at;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic int\nlogic_field(pam_handle_t *pamh, const void *me, const char *x, int rule,\n\t    int (*agrees)(pam_handle_t *pamh,\n\t\t\t      const void *, const char *, int, int))\n{\n     int left=FALSE, right, not=FALSE;\n     operator oper=OR;\n     int at=0, l;\n     expect next=VAL;\n\n     while ((l = logic_member(x,&at))) {\n\t  int c = x[at];\n\n\t  if (next == VAL) {\n\t       if (c == '!')\n\t\t    not = !not;\n\t       else if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n                    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    right = not ^ agrees(pamh, me, x+at, l, rule);\n\t\t    if (oper == AND)\n\t\t\t left &= right;\n\t\t    else\n\t\t\t left |= right;\n\t\t    next = OP;\n\t       } else {\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected name (rule #%d)\",\n\t\t\t       rule);\n\t\t    return FALSE;\n\t       }\n\t  } else {   /* OP */\n\t       switch (c) {\n\t       case '&':\n\t\t    oper = AND;\n\t\t    break;\n\t       case '|':\n\t\t    oper = OR;\n\t\t    break;\n\t       default:\n\t\t    pam_syslog(pamh, LOG_ERR,\n\t\t\t       \"garbled syntax; expected & or | (rule #%d)\",\n\t\t\t       rule);\n\t\t    D((\"%c at %d\",c,at));\n\t\t    return FALSE;\n\t       }\n\t       next = VAL;\n\t       not = FALSE;\n\t  }\n\t  at += l;\n     }\n\n     return left;\n}"
  },
  {
    "function_name": "logic_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "261-302",
    "snippet": "static int\nlogic_member(const char *string, int *at)\n{\n     int c,to;\n     int done=0;\n     int token=0;\n\n     to=*at;\n     do {\n\t  c = string[to++];\n\n\t  switch (c) {\n\n\t  case '\\0':\n\t       --to;\n\t       done = 1;\n\t       break;\n\n\t  case '&':\n\t  case '|':\n\t  case '!':\n\t       if (token) {\n\t\t    --to;\n\t       }\n\t       done = 1;\n\t       break;\n\n\t  default:\n\t       if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n\t\t    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    token = 1;\n\t       } else if (token) {\n\t\t    --to;\n\t\t    done = 1;\n\t       } else {\n\t\t    ++*at;\n\t       }\n\t  }\n     } while (!done);\n\n     return to - *at;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "c"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic int\nlogic_member(const char *string, int *at)\n{\n     int c,to;\n     int done=0;\n     int token=0;\n\n     to=*at;\n     do {\n\t  c = string[to++];\n\n\t  switch (c) {\n\n\t  case '\\0':\n\t       --to;\n\t       done = 1;\n\t       break;\n\n\t  case '&':\n\t  case '|':\n\t  case '!':\n\t       if (token) {\n\t\t    --to;\n\t       }\n\t       done = 1;\n\t       break;\n\n\t  default:\n\t       if (isalpha(c) || c == '*' || isdigit(c) || c == '_'\n\t\t    || c == '-' || c == '.' || c == '/' || c == ':') {\n\t\t    token = 1;\n\t       } else if (token) {\n\t\t    --to;\n\t\t    done = 1;\n\t       } else {\n\t\t    ++*at;\n\t       }\n\t  }\n     } while (!done);\n\n     return to - *at;\n}"
  },
  {
    "function_name": "read_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "131-257",
    "snippet": "static int\nread_field(const pam_handle_t *pamh, int fd, char **buf, int *from, int *state, const char *file)\n{\n    char *to;\n    char *src;\n    int i;\n    char c;\n    int onspace;\n\n    /* is buf set ? */\n    if (! *buf) {\n\t*buf = (char *) calloc(1, PAM_TIME_BUFLEN+1);\n\tif (! *buf) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    D((\"no memory\"));\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n\t*from = 0;\n        *state = STATE_NL;\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", file);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n    }\n\n\n    if (*from > 0)\n\tto = shift_buf(*buf, *from);\n    else\n\tto = *buf;\n\n    while (fd != -1 && to - *buf < PAM_TIME_BUFLEN) {\n\ti = pam_modutil_read(fd, to, PAM_TIME_BUFLEN - (to - *buf));\n\tif (i < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error reading %s: %m\", file);\n\t    close(fd);\n\t    memset(*buf, 0, PAM_TIME_BUFLEN);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t} else if (!i) {\n\t    close(fd);\n\t    fd = -1;          /* end of file reached */\n\t}\n\n\tto += i;\n    }\n\n    if (to == *buf) {\n\t/* nothing previously in buf, nothing read */\n\t_pam_drop(*buf);\n\t*state = STATE_EOF;\n\treturn -1;\n    }\n\n    memset(to, '\\0', PAM_TIME_BUFLEN - (to - *buf));\n\n    to = *buf;\n    onspace = 1; /* delete any leading spaces */\n\n    for (src = to; (c=*src) != '\\0'; ++src) {\n\tif (*state == STATE_COMMENT && c != '\\n') {\n\t\tcontinue;\n\t}\n\n\tswitch (c) {\n\t    case '\\n':\n\t\t*state = STATE_NL;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\t':\n            case ' ':\n\t\tif (!onspace) {\n\t\t    onspace = 1;\n\t\t    *to++ = ' ';\n\t\t}\n\t\tbreak;\n\n            case '!':\n\t\tonspace = 1; /* ignore following spaces */\n\t\t*to++ = '!';\n\t\tbreak;\n\n\t    case '#':\n\t\t*state = STATE_COMMENT;\n\t\tbreak;\n\n\t    case FIELD_SEPARATOR:\n\t\t*state = STATE_FIELD;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\\\':\n\t\tif (src[1] == '\\n') {\n\t\t    ++src; /* skip it */\n\t\t    break;\n\t\t}\n\t\t/* fallthrough */\n\t    default:\n\t\t*to++ = c;\n\t\tonspace = 0;\n\t}\n\tif (src > to)\n\t    *src = '\\0'; /* clearing */\n    }\n\n    if (*state != STATE_COMMENT) {\n\t*state = STATE_COMMENT;\n\tpam_syslog(pamh, LOG_ERR, \"field too long - ignored\");\n\t**buf = '\\0';\n    } else {\n\t*to = '\\0';\n\ttrim_spaces(*buf, to);\n    }\n\n    *from = 0;\n    return fd;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define STATE_EOF      3 /* end of file or error */",
      "#define STATE_FIELD    2 /* field following */",
      "#define STATE_COMMENT  1 /* inside comment */",
      "#define STATE_NL       0 /* new line starting */",
      "#define FIELD_SEPARATOR        ';'   /* this is new as of .02 */",
      "#define PAM_TIME_BUFLEN        1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trim_spaces",
          "args": [
            "*buf",
            "to"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "trim_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "114-124",
          "snippet": "static void\ntrim_spaces(char *buf, char *from)\n{\n    while (from > buf) {\n\t--from;\n\tif (*from == ' ')\n\t    *from = '\\0';\n\telse\n\t    break;\n    }\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic void\ntrim_spaces(char *buf, char *from)\n{\n    while (from > buf) {\n\t--from;\n\tif (*from == ' ')\n\t    *from = '\\0';\n\telse\n\t    break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"field too long - ignored\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "to",
            "'\\0'",
            "PAM_TIME_BUFLEN - (to - *buf)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "*buf"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "*buf"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*buf",
            "0",
            "PAM_TIME_BUFLEN"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error reading %s: %m\"",
            "file"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "to",
            "PAM_TIME_BUFLEN - (to - *buf)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shift_buf",
          "args": [
            "*buf",
            "*from"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "shift_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
          "lines": "104-112",
          "snippet": "static char *\nshift_buf(char *mem, int from)\n{\n    char *start = mem;\n    while ((*mem = mem[from]) != '\\0')\n\t++mem;\n    memset(mem, '\\0', PAM_TIME_BUFLEN - (mem - start));\n    return mem;\n}",
          "includes": [
            "#include <libaudit.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/file.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_TIME_BUFLEN        1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_TIME_BUFLEN        1000\n\nstatic char *\nshift_buf(char *mem, int from)\n{\n    char *start = mem;\n    while ((*mem = mem[from]) != '\\0')\n\t++mem;\n    memset(mem, '\\0', PAM_TIME_BUFLEN - (mem - start));\n    return mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "*buf"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error opening %s: %m\"",
            "file"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file",
            "O_RDONLY"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"no memory\")"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "PAM_TIME_BUFLEN+1"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define STATE_EOF      3 /* end of file or error */\n#define STATE_FIELD    2 /* field following */\n#define STATE_COMMENT  1 /* inside comment */\n#define STATE_NL       0 /* new line starting */\n#define FIELD_SEPARATOR        ';'   /* this is new as of .02 */\n#define PAM_TIME_BUFLEN        1000\n\nstatic int\nread_field(const pam_handle_t *pamh, int fd, char **buf, int *from, int *state, const char *file)\n{\n    char *to;\n    char *src;\n    int i;\n    char c;\n    int onspace;\n\n    /* is buf set ? */\n    if (! *buf) {\n\t*buf = (char *) calloc(1, PAM_TIME_BUFLEN+1);\n\tif (! *buf) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    D((\"no memory\"));\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n\t*from = 0;\n        *state = STATE_NL;\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", file);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t}\n    }\n\n\n    if (*from > 0)\n\tto = shift_buf(*buf, *from);\n    else\n\tto = *buf;\n\n    while (fd != -1 && to - *buf < PAM_TIME_BUFLEN) {\n\ti = pam_modutil_read(fd, to, PAM_TIME_BUFLEN - (to - *buf));\n\tif (i < 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"error reading %s: %m\", file);\n\t    close(fd);\n\t    memset(*buf, 0, PAM_TIME_BUFLEN);\n\t    _pam_drop(*buf);\n\t    *state = STATE_EOF;\n\t    return -1;\n\t} else if (!i) {\n\t    close(fd);\n\t    fd = -1;          /* end of file reached */\n\t}\n\n\tto += i;\n    }\n\n    if (to == *buf) {\n\t/* nothing previously in buf, nothing read */\n\t_pam_drop(*buf);\n\t*state = STATE_EOF;\n\treturn -1;\n    }\n\n    memset(to, '\\0', PAM_TIME_BUFLEN - (to - *buf));\n\n    to = *buf;\n    onspace = 1; /* delete any leading spaces */\n\n    for (src = to; (c=*src) != '\\0'; ++src) {\n\tif (*state == STATE_COMMENT && c != '\\n') {\n\t\tcontinue;\n\t}\n\n\tswitch (c) {\n\t    case '\\n':\n\t\t*state = STATE_NL;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\t':\n            case ' ':\n\t\tif (!onspace) {\n\t\t    onspace = 1;\n\t\t    *to++ = ' ';\n\t\t}\n\t\tbreak;\n\n            case '!':\n\t\tonspace = 1; /* ignore following spaces */\n\t\t*to++ = '!';\n\t\tbreak;\n\n\t    case '#':\n\t\t*state = STATE_COMMENT;\n\t\tbreak;\n\n\t    case FIELD_SEPARATOR:\n\t\t*state = STATE_FIELD;\n                *to = '\\0';\n\t\t*from = (src - *buf) + 1;\n\t\ttrim_spaces(*buf, to);\n\t\treturn fd;\n\n\t    case '\\\\':\n\t\tif (src[1] == '\\n') {\n\t\t    ++src; /* skip it */\n\t\t    break;\n\t\t}\n\t\t/* fallthrough */\n\t    default:\n\t\t*to++ = c;\n\t\tonspace = 0;\n\t}\n\tif (src > to)\n\t    *src = '\\0'; /* clearing */\n    }\n\n    if (*state != STATE_COMMENT) {\n\t*state = STATE_COMMENT;\n\tpam_syslog(pamh, LOG_ERR, \"field too long - ignored\");\n\t**buf = '\\0';\n    } else {\n\t*to = '\\0';\n\ttrim_spaces(*buf, to);\n    }\n\n    *from = 0;\n    return fd;\n}"
  },
  {
    "function_name": "trim_spaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "114-124",
    "snippet": "static void\ntrim_spaces(char *buf, char *from)\n{\n    while (from > buf) {\n\t--from;\n\tif (*from == ' ')\n\t    *from = '\\0';\n\telse\n\t    break;\n    }\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\nstatic void\ntrim_spaces(char *buf, char *from)\n{\n    while (from > buf) {\n\t--from;\n\tif (*from == ' ')\n\t    *from = '\\0';\n\telse\n\t    break;\n    }\n}"
  },
  {
    "function_name": "shift_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "104-112",
    "snippet": "static char *\nshift_buf(char *mem, int from)\n{\n    char *start = mem;\n    while ((*mem = mem[from]) != '\\0')\n\t++mem;\n    memset(mem, '\\0', PAM_TIME_BUFLEN - (mem - start));\n    return mem;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_TIME_BUFLEN        1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem",
            "'\\0'",
            "PAM_TIME_BUFLEN - (mem - start)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_TIME_BUFLEN        1000\n\nstatic char *\nshift_buf(char *mem, int from)\n{\n    char *start = mem;\n    while ((*mem = mem[from]) != '\\0')\n\t++mem;\n    memset(mem, '\\0', PAM_TIME_BUFLEN - (mem - start));\n    return mem;\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_time/pam_time.c",
    "lines": "56-100",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}",
    "includes": [
      "#include <libaudit.h>",
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/file.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_NO_AUDIT        0x0002",
      "#define PAM_DEBUG_ARG       0x0001",
      "#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")",
      "#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "*conffile",
            "&buffer"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"new Configuration File: %s\", *conffile)"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"conffile= specification missing argument - ignored\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"conffile=\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noaudit\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libaudit.h>\n#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/file.h>\n#include \"config.h\"\n\n#define PAM_NO_AUDIT        0x0002\n#define PAM_DEBUG_ARG       0x0001\n#define VENDOR_PAM_TIME_CONF (VENDOR_SCONFIGDIR \"/time.conf\")\n#define PAM_TIME_CONF\t(SCONFIGDIR \"/time.conf\")\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv, const char **conffile)\n{\n    int ctrl = 0;\n\n    *conffile = NULL;\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv, \"debug\")) {\n\t    ctrl |= PAM_DEBUG_ARG;\n\t} else if (!strcmp(*argv, \"noaudit\")) {\n\t    ctrl |= PAM_NO_AUDIT;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t    if (str[0] == '\\0') {\n\t\t    pam_syslog(pamh, LOG_ERR,\n                       \"conffile= specification missing argument - ignored\");\n            } else {\n\t\t  *conffile = str;\n\t\t  D((\"new Configuration File: %s\", *conffile));\n\t    }\n        } else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    if (*conffile == NULL) {\n\t*conffile = PAM_TIME_CONF;\n#ifdef VENDOR_PAM_TIME_CONF\n\t/*\n\t * Check whether PAM_TIME_CONF file is available.\n\t * If it does not exist, fall back to VENDOR_PAM_TIME_CONF file.\n\t */\n\tstruct stat buffer;\n\tif (stat(*conffile, &buffer) != 0 && errno == ENOENT) {\n\t    *conffile = VENDOR_PAM_TIME_CONF;\n\t}\n#endif\n    }\n\n    return ctrl;\n}"
  }
]