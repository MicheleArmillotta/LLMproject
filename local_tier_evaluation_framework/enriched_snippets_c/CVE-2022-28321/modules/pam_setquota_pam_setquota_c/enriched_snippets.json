[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "384-389",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nint\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "169-382",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n  int retval;\n  char *val, *mntdevice = NULL;\n  const void *user;\n  const struct passwd *pwd;\n  struct pam_params param = {\n          .start_uid = PAM_USERTYPE_UIDMIN,\n          .end_uid = 0,\n          .fs = NULL };\n  struct if_dqblk ndqblk;\n  FILE *fp;\n  size_t mnt_len = 0, match_size = 0;\n#ifdef HAVE_GETMNTENT_R\n  char buf[BUFSIZ];\n  struct mntent ent;\n#endif\n  const struct mntent *mnt;\n  const char *service;\n\n  if (pam_get_item(pamh, PAM_SERVICE, (const void **)&service) != PAM_SUCCESS)\n    service = \"\";\n\n  /* Get UID_MIN for default start_uid from login.defs */\n  val = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"UID_MIN\");\n\n  /* Should UID_MIN be undefined, use current value of param.start_uid\n   * pre-defined as PAM_USERTYPE_UIDMIN set by configure as safe\n   * starting UID to avoid setting a quota for root and system\n   * users if startuid= parameter is absent.\n   */\n  if (val) {\n    param.start_uid = str_to_uid(pamh, val, param.start_uid, PATH_LOGIN_DEFS\":UID_MIN\");\n  }\n\n  /* Parse parameter values\n   * Must come after pam_modutil_search_key so that the current system\n   * default for UID_MIN is already in p.start_uid to serve as default\n   * for str_to_uid in case of a parse error.\n   * */\n  parse_params(pamh, argc, argv, &param);\n\n  if (param.debug >= 1)\n    pam_syslog(pamh, LOG_DEBUG, \"Config: startuid=%u enduid=%u fs=%s \"\n                    \"debug=%d overwrite=%d\",\n                    param.start_uid, param.end_uid,\n                    param.fs ? param.fs : \"(none)\",\n                    param.debug, param.overwrite);\n\n  /* Determine the user name so we can get the home directory */\n  retval = pam_get_item(pamh, PAM_USER, &user);\n  if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0') {\n    pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n    return PAM_USER_UNKNOWN;\n  }\n\n  /* Get the password entry */\n  pwd = pam_modutil_getpwnam(pamh, user);\n  if (pwd == NULL) {\n    pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n    return PAM_USER_UNKNOWN;\n  }\n\n  /* Check if we should not set quotas for user */\n  if ((pwd->pw_uid < param.start_uid) ||\n      ((param.end_uid >= param.start_uid) && (param.start_uid != 0) &&\n       (pwd->pw_uid > param.end_uid)))\n    return PAM_SUCCESS;\n\n  /* Find out what device the filesystem is hosted on */\n  if ((fp = setmntent(\"/proc/mounts\", \"r\")) == NULL) {\n    pam_syslog(pamh, LOG_ERR, \"Unable to open /proc/mounts\");\n    return PAM_PERM_DENIED;\n  }\n\n  while (\n#ifdef HAVE_GETMNTENT_R\n           (mnt = getmntent_r(fp, &ent, buf, sizeof(buf))) != NULL\n#else\n           (mnt = getmntent(fp)) != NULL\n#endif\n        ) {\n    /* If param.fs is not specified use filesystem with users homedir\n     * as default.\n     */\n    if (param.fs == NULL) {\n      /* Mask trailing / from mnt->mnt_dir, to get a leading / on the\n       * remaining suffix returned by pam_str_skip_prefix_len()\n       */\n      for (mnt_len = strlen(mnt->mnt_dir); mnt_len > 0; --mnt_len)\n        if (mnt->mnt_dir[mnt_len - 1] != '/')\n          break;\n      const char *s;\n      if (param.debug >= 2)\n        pam_syslog(pamh, LOG_DEBUG, \"Trying to match pw_dir=\\\"%s\\\" \"\n                        \"with mnt_dir=\\\"%s\\\"\", pwd->pw_dir, mnt->mnt_dir);\n      /*\n       * (mnt_len > match_size) Only try matching the mnt_dir if its length\n       * is longer than the last matched length, trying to find the longest\n       * mnt_dir for a given pwd_dir.\n       *\n       * (mnt_len == 0 && mnt->mnt_dir[0] == '/') special-cases the\n       * root-dir /, which is the only mnt_dir with a trailing '/', which\n       * got masked earlier.\n       */\n      if ((mnt_len > match_size || (mnt_len == 0 && mnt->mnt_dir[0] == '/')) &&\n         (s = pam_str_skip_prefix_len(pwd->pw_dir, mnt->mnt_dir, mnt_len)) != NULL &&\n         s[0] == '/') {\n        free(mntdevice);\n        if ((mntdevice = strdup(mnt->mnt_fsname)) == NULL) {\n          pam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n          endmntent(fp);\n          return PAM_PERM_DENIED;\n        }\n        match_size = mnt_len;\n        if (param.debug >= 2)\n          pam_syslog(pamh, LOG_DEBUG, \"Found pw_dir=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"with suffix=\\\"%s\\\" on device=\\\"%s\\\"\", pwd->pw_dir,\n                     mnt->mnt_dir, s, mntdevice);\n      }\n    /* param.fs has been specified, find exactly matching filesystem */\n    } else if ((strncmp(param.fs, mnt->mnt_dir, param.fs_len) == 0\n                && mnt->mnt_dir[param.fs_len] == '\\0') ||\n               (strncmp(param.fs, mnt->mnt_fsname, param.fs_len) == 0\n                && mnt->mnt_fsname[param.fs_len] == '\\0' )) {\n        free(mntdevice);\n        if ((mntdevice = strdup(mnt->mnt_fsname)) == NULL) {\n          pam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n          endmntent(fp);\n          return PAM_PERM_DENIED;\n        }\n        if (param.debug >= 2)\n          pam_syslog(pamh, LOG_DEBUG, \"Found fs=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"on device=\\\"%s\\\"\", param.fs, mnt->mnt_dir, mntdevice);\n    }\n  }\n\n  endmntent(fp);\n\n  if (mntdevice == NULL) {\n    pam_syslog(pamh, LOG_ERR, \"Filesystem or device not found: %s\", param.fs ? param.fs : pwd->pw_dir);\n    return PAM_PERM_DENIED;\n  }\n\n  /* Get limits */\n  if (quotactl(QCMD(Q_GETQUOTA, USRQUOTA), mntdevice, pwd->pw_uid,\n               (void *)&ndqblk) == -1) {\n    pam_syslog(pamh, LOG_ERR, \"fail to get limits for user %s : %m\",\n               pwd->pw_name);\n    free(mntdevice);\n    return PAM_PERM_DENIED;\n  }\n\n  if (param.debug >= 1)\n    debug(pamh, &ndqblk, mntdevice, \"Quota read:\");\n\n  /* Only overwrite if quotas aren't already set or if overwrite is set */\n  if ((ndqblk.dqb_bsoftlimit == 0 && ndqblk.dqb_bhardlimit == 0 &&\n       ndqblk.dqb_isoftlimit == 0 && ndqblk.dqb_ihardlimit == 0) ||\n      param.overwrite == 1) {\n\n    /* Parse new limits\n     * Exit with an error should only the hard- or softlimit be\n     * configured but not both.\n     * This avoids errors, inconsistencies and possible race conditions\n     * during setquota.\n     */\n    ndqblk.dqb_valid = 0;\n    if (!parse_dqblk(pamh, argc, argv, &ndqblk)) {\n      pam_syslog(pamh, LOG_ERR,\n                 \"Both soft- and hardlimits for %s need to be configured \"\n                 \"at the same time!\", mntdevice);\n      free(mntdevice);\n      return PAM_PERM_DENIED;\n    }\n\n    /* Nothing changed? Are no limits defined at all in configuration? */\n    if (ndqblk.dqb_valid == 0) {\n      pam_syslog(pamh, LOG_AUTH | LOG_WARNING, \"no limits defined in \"\n                 \"configuration for user %s on %s\", pwd->pw_name, mntdevice);\n      free(mntdevice);\n      return PAM_IGNORE;\n    }\n\n    /* Set limits */\n    if (quotactl(QCMD(Q_SETQUOTA, USRQUOTA), mntdevice, pwd->pw_uid,\n                 (void *)&ndqblk) == -1) {\n      pam_syslog(pamh, LOG_ERR, \"failed to set limits for user %s on %s: %m\",\n                 pwd->pw_name, mntdevice);\n      free(mntdevice);\n      return PAM_PERM_DENIED;\n    }\n    if (param.debug >= 1)\n      debug(pamh, &ndqblk, mntdevice, \"Quota set:\");\n\n    /* End module */\n    free(mntdevice);\n    return PAM_SUCCESS;\n\n  } else {\n    /* Quota exists and overwrite!=1 */\n    if (param.debug >= 1) {\n      pam_syslog(pamh, LOG_DEBUG, \"Quota already exists for user %s \"\n                 \"on %s, not overwriting it without \\\"overwrite=1\\\"\",\n                 pwd->pw_name, mntdevice);\n    }\n    /* End module */\n    free(mntdevice);\n    return PAM_IGNORE;\n  }\n\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdevice"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Quota already exists for user %s \"\n                 \"on %s, not overwriting it without \\\"overwrite=1\\\"\"",
            "pwd->pw_name",
            "mntdevice"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "pamh",
            "&ndqblk",
            "mntdevice",
            "\"Quota set:\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "42-54",
          "snippet": "static inline void\ndebug(pam_handle_t *pamh, const struct if_dqblk *p,\n      const char *device, const char *dbgprefix) {\n  pam_syslog(pamh, LOG_DEBUG, \"%s device=%s bsoftlimit=%llu bhardlimit=%llu \"\n                              \"isoftlimit=%llu ihardlimit=%llu btime=%llu itime=%llu\",\n\t     dbgprefix, device,\n\t     (unsigned long long) p->dqb_bsoftlimit,\n\t     (unsigned long long) p->dqb_bhardlimit,\n\t     (unsigned long long) p->dqb_isoftlimit,\n\t     (unsigned long long) p->dqb_ihardlimit,\n\t     (unsigned long long) p->dqb_btime,\n\t     (unsigned long long) p->dqb_itime);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic inline void\ndebug(pam_handle_t *pamh, const struct if_dqblk *p,\n      const char *device, const char *dbgprefix) {\n  pam_syslog(pamh, LOG_DEBUG, \"%s device=%s bsoftlimit=%llu bhardlimit=%llu \"\n                              \"isoftlimit=%llu ihardlimit=%llu btime=%llu itime=%llu\",\n\t     dbgprefix, device,\n\t     (unsigned long long) p->dqb_bsoftlimit,\n\t     (unsigned long long) p->dqb_bhardlimit,\n\t     (unsigned long long) p->dqb_isoftlimit,\n\t     (unsigned long long) p->dqb_ihardlimit,\n\t     (unsigned long long) p->dqb_btime,\n\t     (unsigned long long) p->dqb_itime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to set limits for user %s on %s: %m\"",
            "pwd->pw_name",
            "mntdevice"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quotactl",
          "args": [
            "QCMD(Q_SETQUOTA, USRQUOTA)",
            "mntdevice",
            "pwd->pw_uid",
            "(void *)&ndqblk"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QCMD",
          "args": [
            "Q_SETQUOTA",
            "USRQUOTA"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_AUTH | LOG_WARNING",
            "\"no limits defined in \"\n                 \"configuration for user %s on %s\"",
            "pwd->pw_name",
            "mntdevice"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Both soft- and hardlimits for %s need to be configured \"\n                 \"at the same time!\"",
            "mntdevice"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_dqblk",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&ndqblk"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "71-107",
          "snippet": "static bool\nparse_dqblk(pam_handle_t *pamh, int argc, const char **argv, struct if_dqblk *p) {\n  bool bhard = false, bsoft = false, ihard = false, isoft = false;\n\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    if ((str = pam_str_skip_prefix(*argv, \"bhardlimit=\")) != NULL) {\n      p->dqb_bhardlimit = str_to_dqb_num(pamh, str, \"bhardlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bhard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"bsoftlimit=\")) != NULL) {\n      p->dqb_bsoftlimit = str_to_dqb_num(pamh, str, \"bsoftlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bsoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"ihardlimit=\")) != NULL) {\n      p->dqb_ihardlimit = str_to_dqb_num(pamh, str, \"ihardlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      ihard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"isoftlimit=\")) != NULL) {\n      p->dqb_isoftlimit = str_to_dqb_num(pamh, str, \"isoftlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      isoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"btime=\")) != NULL) {\n      p->dqb_btime = str_to_dqb_num(pamh, str, \"btime\");\n      p->dqb_valid |= QIF_BTIME;\n    } else if ((str = pam_str_skip_prefix(*argv, \"itime=\")) != NULL) {\n      p->dqb_itime = str_to_dqb_num(pamh, str, \"itime\");\n      p->dqb_valid |= QIF_ITIME;\n    }\n  }\n\n  /* return FALSE if a softlimit or hardlimit has been set\n   * independently of its counterpart.\n   */\n  return !(bhard ^ bsoft) && !(ihard ^ isoft);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic bool\nparse_dqblk(pam_handle_t *pamh, int argc, const char **argv, struct if_dqblk *p) {\n  bool bhard = false, bsoft = false, ihard = false, isoft = false;\n\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    if ((str = pam_str_skip_prefix(*argv, \"bhardlimit=\")) != NULL) {\n      p->dqb_bhardlimit = str_to_dqb_num(pamh, str, \"bhardlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bhard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"bsoftlimit=\")) != NULL) {\n      p->dqb_bsoftlimit = str_to_dqb_num(pamh, str, \"bsoftlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bsoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"ihardlimit=\")) != NULL) {\n      p->dqb_ihardlimit = str_to_dqb_num(pamh, str, \"ihardlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      ihard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"isoftlimit=\")) != NULL) {\n      p->dqb_isoftlimit = str_to_dqb_num(pamh, str, \"isoftlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      isoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"btime=\")) != NULL) {\n      p->dqb_btime = str_to_dqb_num(pamh, str, \"btime\");\n      p->dqb_valid |= QIF_BTIME;\n    } else if ((str = pam_str_skip_prefix(*argv, \"itime=\")) != NULL) {\n      p->dqb_itime = str_to_dqb_num(pamh, str, \"itime\");\n      p->dqb_valid |= QIF_ITIME;\n    }\n  }\n\n  /* return FALSE if a softlimit or hardlimit has been set\n   * independently of its counterpart.\n   */\n  return !(bhard ^ bsoft) && !(ihard ^ isoft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"fail to get limits for user %s : %m\"",
            "pwd->pw_name"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quotactl",
          "args": [
            "QCMD(Q_GETQUOTA, USRQUOTA)",
            "mntdevice",
            "pwd->pw_uid",
            "(void *)&ndqblk"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QCMD",
          "args": [
            "Q_GETQUOTA",
            "USRQUOTA"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Filesystem or device not found: %s\"",
            "param.fs ? param.fs : pwd->pw_dir"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endmntent",
          "args": [
            "fp"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Found fs=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"on device=\\\"%s\\\"\"",
            "param.fs",
            "mnt->mnt_dir",
            "mntdevice"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endmntent",
          "args": [
            "fp"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "mnt->mnt_fsname"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "param.fs",
            "mnt->mnt_fsname",
            "param.fs_len"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "param.fs",
            "mnt->mnt_dir",
            "param.fs_len"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Found pw_dir=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"with suffix=\\\"%s\\\" on device=\\\"%s\\\"\"",
            "pwd->pw_dir",
            "mnt->mnt_dir",
            "s",
            "mntdevice"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endmntent",
          "args": [
            "fp"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "mnt->mnt_fsname"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix_len",
          "args": [
            "pwd->pw_dir",
            "mnt->mnt_dir",
            "mnt_len"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Trying to match pw_dir=\\\"%s\\\" \"\n                        \"with mnt_dir=\\\"%s\\\"\"",
            "pwd->pw_dir",
            "mnt->mnt_dir"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mnt->mnt_dir"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "#else",
          "args": [
            "mnt = getmntent(fp)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getmntent",
          "args": [
            "fp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAVE_GETMNTENT_R",
          "args": [
            "mnt = getmntent_r(fp, &ent, buf, sizeof(buf))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getmntent_r",
          "args": [
            "fp",
            "&ent",
            "buf",
            "sizeof(buf)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open /proc/mounts\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setmntent",
          "args": [
            "\"/proc/mounts\"",
            "\"r\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user unknown\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user unknown\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&user"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Config: startuid=%u enduid=%u fs=%s \"\n                    \"debug=%d overwrite=%d\"",
            "param.start_uid",
            "param.end_uid",
            "param.fs ? param.fs : \"(none)\"",
            "param.debug",
            "param.overwrite"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_params",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&param"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "parse_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "133-167",
          "snippet": "static void\nparse_params(pam_handle_t *pamh, int argc, const char **argv, struct pam_params *p) {\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    char *ep = NULL;\n    if ((str = pam_str_skip_prefix(*argv, \"startuid=\")) != NULL) {\n      p->start_uid = str_to_uid(pamh, str, p->start_uid, \"startuid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"enduid=\")) != NULL) {\n      p->end_uid = str_to_uid(pamh, str, p->end_uid, \"enduid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"fs=\")) != NULL) {\n      p->fs = str;\n      p->fs_len = strlen(str);\n      /* Mask the unnecessary '/' from the end of fs parameter */\n      if (p->fs_len > 1 && p->fs[p->fs_len - 1] == '/')\n        --p->fs_len;\n    } else if ((str = pam_str_skip_prefix(*argv, \"overwrite=\")) != NULL) {\n      errno = 0;\n      p->overwrite = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno !=0 || (p->overwrite < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"overwrite=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->overwrite = 0;\n      }\n    } else if ((str = pam_str_skip_prefix(*argv, \"debug=\")) != NULL) {\n      errno = 0;\n      p->debug = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno != 0 || (p->debug < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"debug=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->debug = 0;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic void\nparse_params(pam_handle_t *pamh, int argc, const char **argv, struct pam_params *p) {\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    char *ep = NULL;\n    if ((str = pam_str_skip_prefix(*argv, \"startuid=\")) != NULL) {\n      p->start_uid = str_to_uid(pamh, str, p->start_uid, \"startuid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"enduid=\")) != NULL) {\n      p->end_uid = str_to_uid(pamh, str, p->end_uid, \"enduid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"fs=\")) != NULL) {\n      p->fs = str;\n      p->fs_len = strlen(str);\n      /* Mask the unnecessary '/' from the end of fs parameter */\n      if (p->fs_len > 1 && p->fs[p->fs_len - 1] == '/')\n        --p->fs_len;\n    } else if ((str = pam_str_skip_prefix(*argv, \"overwrite=\")) != NULL) {\n      errno = 0;\n      p->overwrite = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno !=0 || (p->overwrite < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"overwrite=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->overwrite = 0;\n      }\n    } else if ((str = pam_str_skip_prefix(*argv, \"debug=\")) != NULL) {\n      errno = 0;\n      p->debug = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno != 0 || (p->debug < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"debug=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->debug = 0;\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_to_uid",
          "args": [
            "pamh",
            "val",
            "param.start_uid",
            "PATH_LOGIN_DEFS\":UID_MIN\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "str_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "110-131",
          "snippet": "static uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "PATH_LOGIN_DEFS",
            "\"UID_MIN\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "(const void **)&service"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n\t\t    int argc, const char **argv)\n{\n  int retval;\n  char *val, *mntdevice = NULL;\n  const void *user;\n  const struct passwd *pwd;\n  struct pam_params param = {\n          .start_uid = PAM_USERTYPE_UIDMIN,\n          .end_uid = 0,\n          .fs = NULL };\n  struct if_dqblk ndqblk;\n  FILE *fp;\n  size_t mnt_len = 0, match_size = 0;\n#ifdef HAVE_GETMNTENT_R\n  char buf[BUFSIZ];\n  struct mntent ent;\n#endif\n  const struct mntent *mnt;\n  const char *service;\n\n  if (pam_get_item(pamh, PAM_SERVICE, (const void **)&service) != PAM_SUCCESS)\n    service = \"\";\n\n  /* Get UID_MIN for default start_uid from login.defs */\n  val = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"UID_MIN\");\n\n  /* Should UID_MIN be undefined, use current value of param.start_uid\n   * pre-defined as PAM_USERTYPE_UIDMIN set by configure as safe\n   * starting UID to avoid setting a quota for root and system\n   * users if startuid= parameter is absent.\n   */\n  if (val) {\n    param.start_uid = str_to_uid(pamh, val, param.start_uid, PATH_LOGIN_DEFS\":UID_MIN\");\n  }\n\n  /* Parse parameter values\n   * Must come after pam_modutil_search_key so that the current system\n   * default for UID_MIN is already in p.start_uid to serve as default\n   * for str_to_uid in case of a parse error.\n   * */\n  parse_params(pamh, argc, argv, &param);\n\n  if (param.debug >= 1)\n    pam_syslog(pamh, LOG_DEBUG, \"Config: startuid=%u enduid=%u fs=%s \"\n                    \"debug=%d overwrite=%d\",\n                    param.start_uid, param.end_uid,\n                    param.fs ? param.fs : \"(none)\",\n                    param.debug, param.overwrite);\n\n  /* Determine the user name so we can get the home directory */\n  retval = pam_get_item(pamh, PAM_USER, &user);\n  if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0') {\n    pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n    return PAM_USER_UNKNOWN;\n  }\n\n  /* Get the password entry */\n  pwd = pam_modutil_getpwnam(pamh, user);\n  if (pwd == NULL) {\n    pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n    return PAM_USER_UNKNOWN;\n  }\n\n  /* Check if we should not set quotas for user */\n  if ((pwd->pw_uid < param.start_uid) ||\n      ((param.end_uid >= param.start_uid) && (param.start_uid != 0) &&\n       (pwd->pw_uid > param.end_uid)))\n    return PAM_SUCCESS;\n\n  /* Find out what device the filesystem is hosted on */\n  if ((fp = setmntent(\"/proc/mounts\", \"r\")) == NULL) {\n    pam_syslog(pamh, LOG_ERR, \"Unable to open /proc/mounts\");\n    return PAM_PERM_DENIED;\n  }\n\n  while (\n#ifdef HAVE_GETMNTENT_R\n           (mnt = getmntent_r(fp, &ent, buf, sizeof(buf))) != NULL\n#else\n           (mnt = getmntent(fp)) != NULL\n#endif\n        ) {\n    /* If param.fs is not specified use filesystem with users homedir\n     * as default.\n     */\n    if (param.fs == NULL) {\n      /* Mask trailing / from mnt->mnt_dir, to get a leading / on the\n       * remaining suffix returned by pam_str_skip_prefix_len()\n       */\n      for (mnt_len = strlen(mnt->mnt_dir); mnt_len > 0; --mnt_len)\n        if (mnt->mnt_dir[mnt_len - 1] != '/')\n          break;\n      const char *s;\n      if (param.debug >= 2)\n        pam_syslog(pamh, LOG_DEBUG, \"Trying to match pw_dir=\\\"%s\\\" \"\n                        \"with mnt_dir=\\\"%s\\\"\", pwd->pw_dir, mnt->mnt_dir);\n      /*\n       * (mnt_len > match_size) Only try matching the mnt_dir if its length\n       * is longer than the last matched length, trying to find the longest\n       * mnt_dir for a given pwd_dir.\n       *\n       * (mnt_len == 0 && mnt->mnt_dir[0] == '/') special-cases the\n       * root-dir /, which is the only mnt_dir with a trailing '/', which\n       * got masked earlier.\n       */\n      if ((mnt_len > match_size || (mnt_len == 0 && mnt->mnt_dir[0] == '/')) &&\n         (s = pam_str_skip_prefix_len(pwd->pw_dir, mnt->mnt_dir, mnt_len)) != NULL &&\n         s[0] == '/') {\n        free(mntdevice);\n        if ((mntdevice = strdup(mnt->mnt_fsname)) == NULL) {\n          pam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n          endmntent(fp);\n          return PAM_PERM_DENIED;\n        }\n        match_size = mnt_len;\n        if (param.debug >= 2)\n          pam_syslog(pamh, LOG_DEBUG, \"Found pw_dir=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"with suffix=\\\"%s\\\" on device=\\\"%s\\\"\", pwd->pw_dir,\n                     mnt->mnt_dir, s, mntdevice);\n      }\n    /* param.fs has been specified, find exactly matching filesystem */\n    } else if ((strncmp(param.fs, mnt->mnt_dir, param.fs_len) == 0\n                && mnt->mnt_dir[param.fs_len] == '\\0') ||\n               (strncmp(param.fs, mnt->mnt_fsname, param.fs_len) == 0\n                && mnt->mnt_fsname[param.fs_len] == '\\0' )) {\n        free(mntdevice);\n        if ((mntdevice = strdup(mnt->mnt_fsname)) == NULL) {\n          pam_syslog(pamh, LOG_CRIT, \"Memory allocation error\");\n          endmntent(fp);\n          return PAM_PERM_DENIED;\n        }\n        if (param.debug >= 2)\n          pam_syslog(pamh, LOG_DEBUG, \"Found fs=\\\"%s\\\" in mnt_dir=\\\"%s\\\" \"\n                     \"on device=\\\"%s\\\"\", param.fs, mnt->mnt_dir, mntdevice);\n    }\n  }\n\n  endmntent(fp);\n\n  if (mntdevice == NULL) {\n    pam_syslog(pamh, LOG_ERR, \"Filesystem or device not found: %s\", param.fs ? param.fs : pwd->pw_dir);\n    return PAM_PERM_DENIED;\n  }\n\n  /* Get limits */\n  if (quotactl(QCMD(Q_GETQUOTA, USRQUOTA), mntdevice, pwd->pw_uid,\n               (void *)&ndqblk) == -1) {\n    pam_syslog(pamh, LOG_ERR, \"fail to get limits for user %s : %m\",\n               pwd->pw_name);\n    free(mntdevice);\n    return PAM_PERM_DENIED;\n  }\n\n  if (param.debug >= 1)\n    debug(pamh, &ndqblk, mntdevice, \"Quota read:\");\n\n  /* Only overwrite if quotas aren't already set or if overwrite is set */\n  if ((ndqblk.dqb_bsoftlimit == 0 && ndqblk.dqb_bhardlimit == 0 &&\n       ndqblk.dqb_isoftlimit == 0 && ndqblk.dqb_ihardlimit == 0) ||\n      param.overwrite == 1) {\n\n    /* Parse new limits\n     * Exit with an error should only the hard- or softlimit be\n     * configured but not both.\n     * This avoids errors, inconsistencies and possible race conditions\n     * during setquota.\n     */\n    ndqblk.dqb_valid = 0;\n    if (!parse_dqblk(pamh, argc, argv, &ndqblk)) {\n      pam_syslog(pamh, LOG_ERR,\n                 \"Both soft- and hardlimits for %s need to be configured \"\n                 \"at the same time!\", mntdevice);\n      free(mntdevice);\n      return PAM_PERM_DENIED;\n    }\n\n    /* Nothing changed? Are no limits defined at all in configuration? */\n    if (ndqblk.dqb_valid == 0) {\n      pam_syslog(pamh, LOG_AUTH | LOG_WARNING, \"no limits defined in \"\n                 \"configuration for user %s on %s\", pwd->pw_name, mntdevice);\n      free(mntdevice);\n      return PAM_IGNORE;\n    }\n\n    /* Set limits */\n    if (quotactl(QCMD(Q_SETQUOTA, USRQUOTA), mntdevice, pwd->pw_uid,\n                 (void *)&ndqblk) == -1) {\n      pam_syslog(pamh, LOG_ERR, \"failed to set limits for user %s on %s: %m\",\n                 pwd->pw_name, mntdevice);\n      free(mntdevice);\n      return PAM_PERM_DENIED;\n    }\n    if (param.debug >= 1)\n      debug(pamh, &ndqblk, mntdevice, \"Quota set:\");\n\n    /* End module */\n    free(mntdevice);\n    return PAM_SUCCESS;\n\n  } else {\n    /* Quota exists and overwrite!=1 */\n    if (param.debug >= 1) {\n      pam_syslog(pamh, LOG_DEBUG, \"Quota already exists for user %s \"\n                 \"on %s, not overwriting it without \\\"overwrite=1\\\"\",\n                 pwd->pw_name, mntdevice);\n    }\n    /* End module */\n    free(mntdevice);\n    return PAM_IGNORE;\n  }\n\n}"
  },
  {
    "function_name": "parse_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "133-167",
    "snippet": "static void\nparse_params(pam_handle_t *pamh, int argc, const char **argv, struct pam_params *p) {\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    char *ep = NULL;\n    if ((str = pam_str_skip_prefix(*argv, \"startuid=\")) != NULL) {\n      p->start_uid = str_to_uid(pamh, str, p->start_uid, \"startuid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"enduid=\")) != NULL) {\n      p->end_uid = str_to_uid(pamh, str, p->end_uid, \"enduid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"fs=\")) != NULL) {\n      p->fs = str;\n      p->fs_len = strlen(str);\n      /* Mask the unnecessary '/' from the end of fs parameter */\n      if (p->fs_len > 1 && p->fs[p->fs_len - 1] == '/')\n        --p->fs_len;\n    } else if ((str = pam_str_skip_prefix(*argv, \"overwrite=\")) != NULL) {\n      errno = 0;\n      p->overwrite = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno !=0 || (p->overwrite < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"overwrite=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->overwrite = 0;\n      }\n    } else if ((str = pam_str_skip_prefix(*argv, \"debug=\")) != NULL) {\n      errno = 0;\n      p->debug = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno != 0 || (p->debug < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"debug=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->debug = 0;\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Parameter \\\"debug=%s\\\" invalid, \"\n                        \"setting to 0\"",
            "str"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&ep",
            "10"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"debug=\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Parameter \\\"overwrite=%s\\\" invalid, \"\n                        \"setting to 0\"",
            "str"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&ep",
            "10"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"overwrite=\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"fs=\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_to_uid",
          "args": [
            "pamh",
            "str",
            "p->end_uid",
            "\"enduid\""
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "str_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "110-131",
          "snippet": "static uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"enduid=\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"startuid=\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic void\nparse_params(pam_handle_t *pamh, int argc, const char **argv, struct pam_params *p) {\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    char *ep = NULL;\n    if ((str = pam_str_skip_prefix(*argv, \"startuid=\")) != NULL) {\n      p->start_uid = str_to_uid(pamh, str, p->start_uid, \"startuid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"enduid=\")) != NULL) {\n      p->end_uid = str_to_uid(pamh, str, p->end_uid, \"enduid\");\n    } else if ((str = pam_str_skip_prefix(*argv, \"fs=\")) != NULL) {\n      p->fs = str;\n      p->fs_len = strlen(str);\n      /* Mask the unnecessary '/' from the end of fs parameter */\n      if (p->fs_len > 1 && p->fs[p->fs_len - 1] == '/')\n        --p->fs_len;\n    } else if ((str = pam_str_skip_prefix(*argv, \"overwrite=\")) != NULL) {\n      errno = 0;\n      p->overwrite = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno !=0 || (p->overwrite < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"overwrite=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->overwrite = 0;\n      }\n    } else if ((str = pam_str_skip_prefix(*argv, \"debug=\")) != NULL) {\n      errno = 0;\n      p->debug = strtol(str, &ep, 10);\n      if (*ep != '\\0' || str == ep || errno != 0 || (p->debug < 0)) {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"debug=%s\\\" invalid, \"\n                        \"setting to 0\", str);\n        p->debug = 0;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "str_to_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "110-131",
    "snippet": "static uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define MAX_UID_VALUE 0xFFFFFFFFUL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\"",
            "param",
            "value",
            "default_value"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "&ep",
            "10"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nstr_to_uid(pam_handle_t *pamh, const char *value, uid_t default_value, const char *param) {\n    unsigned long ul;\n    char *ep;\n    uid_t uid;\n\n    errno = 0;\n    ul = strtoul(value, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n        || (uid_t)ul >= MAX_UID_VALUE\n        || (errno != 0 && ul == 0)\n        || value == ep\n        || *ep != '\\0')) {\n        uid = (uid_t)ul;\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, \"\n                   \"setting to %u\", param, value, default_value);\n        uid = default_value;\n    }\n\n    return uid;\n}"
  },
  {
    "function_name": "parse_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "71-107",
    "snippet": "static bool\nparse_dqblk(pam_handle_t *pamh, int argc, const char **argv, struct if_dqblk *p) {\n  bool bhard = false, bsoft = false, ihard = false, isoft = false;\n\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    if ((str = pam_str_skip_prefix(*argv, \"bhardlimit=\")) != NULL) {\n      p->dqb_bhardlimit = str_to_dqb_num(pamh, str, \"bhardlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bhard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"bsoftlimit=\")) != NULL) {\n      p->dqb_bsoftlimit = str_to_dqb_num(pamh, str, \"bsoftlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bsoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"ihardlimit=\")) != NULL) {\n      p->dqb_ihardlimit = str_to_dqb_num(pamh, str, \"ihardlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      ihard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"isoftlimit=\")) != NULL) {\n      p->dqb_isoftlimit = str_to_dqb_num(pamh, str, \"isoftlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      isoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"btime=\")) != NULL) {\n      p->dqb_btime = str_to_dqb_num(pamh, str, \"btime\");\n      p->dqb_valid |= QIF_BTIME;\n    } else if ((str = pam_str_skip_prefix(*argv, \"itime=\")) != NULL) {\n      p->dqb_itime = str_to_dqb_num(pamh, str, \"itime\");\n      p->dqb_valid |= QIF_ITIME;\n    }\n  }\n\n  /* return FALSE if a softlimit or hardlimit has been set\n   * independently of its counterpart.\n   */\n  return !(bhard ^ bsoft) && !(ihard ^ isoft);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str_to_dqb_num",
          "args": [
            "pamh",
            "str",
            "\"itime\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "str_to_dqb_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
          "lines": "56-69",
          "snippet": "static unsigned long long\nstr_to_dqb_num(pam_handle_t *pamh, const char *str, const char *param) {\n  char *ep = NULL;\n\n  errno = 0;\n  long long temp = strtoll(str, &ep, 10);\n  if (temp < 0 || str == ep || *ep != '\\0' || errno !=0) {\n    pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, setting to 0\", param, str);\n    return 0;\n  }\n  else {\n    return temp;\n  }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <mntent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <linux/quota.h>",
            "#include <sys/quota.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic unsigned long long\nstr_to_dqb_num(pam_handle_t *pamh, const char *str, const char *param) {\n  char *ep = NULL;\n\n  errno = 0;\n  long long temp = strtoll(str, &ep, 10);\n  if (temp < 0 || str == ep || *ep != '\\0' || errno !=0) {\n    pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, setting to 0\", param, str);\n    return 0;\n  }\n  else {\n    return temp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"itime=\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"btime=\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"isoftlimit=\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"ihardlimit=\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"bsoftlimit=\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"bhardlimit=\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic bool\nparse_dqblk(pam_handle_t *pamh, int argc, const char **argv, struct if_dqblk *p) {\n  bool bhard = false, bsoft = false, ihard = false, isoft = false;\n\n  /* step through arguments */\n  for (; argc-- > 0; ++argv) {\n    const char *str;\n    if ((str = pam_str_skip_prefix(*argv, \"bhardlimit=\")) != NULL) {\n      p->dqb_bhardlimit = str_to_dqb_num(pamh, str, \"bhardlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bhard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"bsoftlimit=\")) != NULL) {\n      p->dqb_bsoftlimit = str_to_dqb_num(pamh, str, \"bsoftlimit\");\n      p->dqb_valid |= QIF_BLIMITS;\n      bsoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"ihardlimit=\")) != NULL) {\n      p->dqb_ihardlimit = str_to_dqb_num(pamh, str, \"ihardlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      ihard = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"isoftlimit=\")) != NULL) {\n      p->dqb_isoftlimit = str_to_dqb_num(pamh, str, \"isoftlimit\");\n      p->dqb_valid |= QIF_ILIMITS;\n      isoft = true;\n    } else if ((str = pam_str_skip_prefix(*argv, \"btime=\")) != NULL) {\n      p->dqb_btime = str_to_dqb_num(pamh, str, \"btime\");\n      p->dqb_valid |= QIF_BTIME;\n    } else if ((str = pam_str_skip_prefix(*argv, \"itime=\")) != NULL) {\n      p->dqb_itime = str_to_dqb_num(pamh, str, \"itime\");\n      p->dqb_valid |= QIF_ITIME;\n    }\n  }\n\n  /* return FALSE if a softlimit or hardlimit has been set\n   * independently of its counterpart.\n   */\n  return !(bhard ^ bsoft) && !(ihard ^ isoft);\n}"
  },
  {
    "function_name": "str_to_dqb_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "56-69",
    "snippet": "static unsigned long long\nstr_to_dqb_num(pam_handle_t *pamh, const char *str, const char *param) {\n  char *ep = NULL;\n\n  errno = 0;\n  long long temp = strtoll(str, &ep, 10);\n  if (temp < 0 || str == ep || *ep != '\\0' || errno !=0) {\n    pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, setting to 0\", param, str);\n    return 0;\n  }\n  else {\n    return temp;\n  }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Parameter \\\"%s=%s\\\" invalid, setting to 0\"",
            "param",
            "str"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoll",
          "args": [
            "str",
            "&ep",
            "10"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic unsigned long long\nstr_to_dqb_num(pam_handle_t *pamh, const char *str, const char *param) {\n  char *ep = NULL;\n\n  errno = 0;\n  long long temp = strtoll(str, &ep, 10);\n  if (temp < 0 || str == ep || *ep != '\\0' || errno !=0) {\n    pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, setting to 0\", param, str);\n    return 0;\n  }\n  else {\n    return temp;\n  }\n}"
  },
  {
    "function_name": "debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_setquota/pam_setquota.c",
    "lines": "42-54",
    "snippet": "static inline void\ndebug(pam_handle_t *pamh, const struct if_dqblk *p,\n      const char *device, const char *dbgprefix) {\n  pam_syslog(pamh, LOG_DEBUG, \"%s device=%s bsoftlimit=%llu bhardlimit=%llu \"\n                              \"isoftlimit=%llu ihardlimit=%llu btime=%llu itime=%llu\",\n\t     dbgprefix, device,\n\t     (unsigned long long) p->dqb_bsoftlimit,\n\t     (unsigned long long) p->dqb_bhardlimit,\n\t     (unsigned long long) p->dqb_isoftlimit,\n\t     (unsigned long long) p->dqb_ihardlimit,\n\t     (unsigned long long) p->dqb_btime,\n\t     (unsigned long long) p->dqb_itime);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <mntent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <linux/quota.h>",
      "#include <sys/quota.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"%s device=%s bsoftlimit=%llu bhardlimit=%llu \"\n                              \"isoftlimit=%llu ihardlimit=%llu btime=%llu itime=%llu\"",
            "dbgprefix",
            "device",
            "(unsigned long long) p->dqb_bsoftlimit",
            "(unsigned long long) p->dqb_bhardlimit",
            "(unsigned long long) p->dqb_isoftlimit",
            "(unsigned long long) p->dqb_ihardlimit",
            "(unsigned long long) p->dqb_btime",
            "(unsigned long long) p->dqb_itime"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <linux/quota.h>\n#include <sys/quota.h>\n#include <sys/types.h>\n\nstatic inline void\ndebug(pam_handle_t *pamh, const struct if_dqblk *p,\n      const char *device, const char *dbgprefix) {\n  pam_syslog(pamh, LOG_DEBUG, \"%s device=%s bsoftlimit=%llu bhardlimit=%llu \"\n                              \"isoftlimit=%llu ihardlimit=%llu btime=%llu itime=%llu\",\n\t     dbgprefix, device,\n\t     (unsigned long long) p->dqb_bsoftlimit,\n\t     (unsigned long long) p->dqb_bhardlimit,\n\t     (unsigned long long) p->dqb_isoftlimit,\n\t     (unsigned long long) p->dqb_ihardlimit,\n\t     (unsigned long long) p->dqb_btime,\n\t     (unsigned long long) p->dqb_itime);\n}"
  }
]