[
  {
    "function_name": "hmac_sha1_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "291-295",
    "snippet": "size_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nsize_t\nhmac_sha1_size(void)\n{\n\treturn SHA1_OUTPUT_SIZE;\n}"
  },
  {
    "function_name": "hmac_sha1_generate_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "268-289",
    "snippet": "void\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "key"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "key_length"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_sha1_generate",
          "args": [
            "mac",
            "mac_length",
            "key",
            "key_length",
            "text",
            "text_length"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_sha1_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "202-266",
          "snippet": "void\nhmac_sha1_generate(void **mac, size_t *mac_length,\n\t\t   const void *raw_key, size_t raw_key_size,\n\t\t   const void *text, size_t text_length)\n{\n\tunsigned char key[MAXIMUM_KEY_SIZE], tmp_key[MAXIMUM_KEY_SIZE];\n\tsize_t maximum_key_size = SHA1_BLOCK_SIZE,\n\t       minimum_key_size = SHA1_OUTPUT_SIZE;\n\tconst unsigned char ipad = 0x36, opad = 0x5c;\n\tstruct sha1_context sha1;\n\tunsigned char inner[SHA1_OUTPUT_SIZE], outer[SHA1_OUTPUT_SIZE];\n\n\t*mac = NULL;\n\t*mac_length = 0;\n\n#ifndef HMAC_ALLOW_SHORT_KEYS\n\t/* If the key is too short, don't bother. */\n\tif (raw_key_size < minimum_key_size) {\n\t\treturn;\n\t}\n#endif\n\n\t/* If the key is too long, \"compress\" it, else copy it and pad it\n\t * out with zero bytes. */\n\tmemset(key, 0, sizeof(key));\n\tif (raw_key_size > maximum_key_size) {\n\t\tsha1_init(&sha1);\n\t\tsha1_update(&sha1, raw_key, raw_key_size);\n\t\tsha1_output(&sha1, key);\n\t} else {\n\t\tmemmove(key, raw_key, raw_key_size);\n\t}\n\n\t/* Generate the inner sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, ipad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, text, text_length);\n\tsha1_output(&sha1, inner);\n\n\t/* Generate the outer sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, opad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, inner, sizeof(inner));\n\tsha1_output(&sha1, outer);\n\n\t/* We don't need any of the keys any more. */\n\tmemset(key, 0, sizeof(key));\n\tmemset(tmp_key, 0, sizeof(tmp_key));\n\n\t/* Allocate space to store the output. */\n\t*mac_length = sizeof(outer);\n\t*mac = malloc(*mac_length);\n\tif (*mac == NULL) {\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\n\tmemcpy(*mac, outer, *mac_length);\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE\n\nvoid\nhmac_sha1_generate(void **mac, size_t *mac_length,\n\t\t   const void *raw_key, size_t raw_key_size,\n\t\t   const void *text, size_t text_length)\n{\n\tunsigned char key[MAXIMUM_KEY_SIZE], tmp_key[MAXIMUM_KEY_SIZE];\n\tsize_t maximum_key_size = SHA1_BLOCK_SIZE,\n\t       minimum_key_size = SHA1_OUTPUT_SIZE;\n\tconst unsigned char ipad = 0x36, opad = 0x5c;\n\tstruct sha1_context sha1;\n\tunsigned char inner[SHA1_OUTPUT_SIZE], outer[SHA1_OUTPUT_SIZE];\n\n\t*mac = NULL;\n\t*mac_length = 0;\n\n#ifndef HMAC_ALLOW_SHORT_KEYS\n\t/* If the key is too short, don't bother. */\n\tif (raw_key_size < minimum_key_size) {\n\t\treturn;\n\t}\n#endif\n\n\t/* If the key is too long, \"compress\" it, else copy it and pad it\n\t * out with zero bytes. */\n\tmemset(key, 0, sizeof(key));\n\tif (raw_key_size > maximum_key_size) {\n\t\tsha1_init(&sha1);\n\t\tsha1_update(&sha1, raw_key, raw_key_size);\n\t\tsha1_output(&sha1, key);\n\t} else {\n\t\tmemmove(key, raw_key, raw_key_size);\n\t}\n\n\t/* Generate the inner sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, ipad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, text, text_length);\n\tsha1_output(&sha1, inner);\n\n\t/* Generate the outer sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, opad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, inner, sizeof(inner));\n\tsha1_output(&sha1, outer);\n\n\t/* We don't need any of the keys any more. */\n\tmemset(key, 0, sizeof(key));\n\tmemset(tmp_key, 0, sizeof(tmp_key));\n\n\t/* Allocate space to store the output. */\n\t*mac_length = sizeof(outer);\n\t*mac = malloc(*mac_length);\n\tif (*mac == NULL) {\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\n\tmemcpy(*mac, outer, *mac_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmac_key_read",
          "args": [
            "pamh",
            "keyfile",
            "MAXIMUM_KEY_SIZE",
            "owner",
            "group",
            "&key",
            "&key_length"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_key_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "130-191",
          "snippet": "static void\nhmac_key_read(pam_handle_t *pamh, const char *filename, size_t default_key_size,\n\t      uid_t owner, gid_t group,\n\t      void **key, size_t *key_size)\n{\n\tchar *tmp;\n\tint keyfd, i, count;\n\tstruct stat st;\n\n\ttmp = NULL;\n\t*key = NULL;\n\t*key_size = 0;\n\n\t/* Try to open the key file. */\n\tkeyfd = open(filename, O_RDONLY);\n\tif (keyfd == -1) {\n\t\t/* No such thing? Create it. */\n\t\tif (errno == ENOENT) {\n\t\t\thmac_key_create(pamh, filename, default_key_size,\n\t\t\t\t\towner, group);\n\t\t\tkeyfd = open(filename, O_RDONLY);\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\", filename);\n\t\t}\n\t\tif (keyfd == -1)\n\t\t\treturn;\n\t}\n\n\t/* If we failed to open the file, we're done. */\n\tif (fstat(keyfd, &st) == -1) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read the contents of the file. */\n\ttmp = malloc(st.st_size);\n\tif (!tmp) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\tcount = 0;\n\twhile (count < st.st_size) {\n\t\ti = read(keyfd, tmp + count, st.st_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tclose(keyfd);\n\n\t/* Require that we got the expected amount of data. */\n\tif (count < st.st_size) {\n\t\tmemset(tmp, 0, st.st_size);\n\t\tfree(tmp);\n\t\treturn;\n\t}\n\n\t/* Pass the key back. */\n\t*key = tmp;\n\t*key_size = st.st_size;\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nhmac_key_read(pam_handle_t *pamh, const char *filename, size_t default_key_size,\n\t      uid_t owner, gid_t group,\n\t      void **key, size_t *key_size)\n{\n\tchar *tmp;\n\tint keyfd, i, count;\n\tstruct stat st;\n\n\ttmp = NULL;\n\t*key = NULL;\n\t*key_size = 0;\n\n\t/* Try to open the key file. */\n\tkeyfd = open(filename, O_RDONLY);\n\tif (keyfd == -1) {\n\t\t/* No such thing? Create it. */\n\t\tif (errno == ENOENT) {\n\t\t\thmac_key_create(pamh, filename, default_key_size,\n\t\t\t\t\towner, group);\n\t\t\tkeyfd = open(filename, O_RDONLY);\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\", filename);\n\t\t}\n\t\tif (keyfd == -1)\n\t\t\treturn;\n\t}\n\n\t/* If we failed to open the file, we're done. */\n\tif (fstat(keyfd, &st) == -1) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read the contents of the file. */\n\ttmp = malloc(st.st_size);\n\tif (!tmp) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\tcount = 0;\n\twhile (count < st.st_size) {\n\t\ti = read(keyfd, tmp + count, st.st_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tclose(keyfd);\n\n\t/* Require that we got the expected amount of data. */\n\tif (count < st.st_size) {\n\t\tmemset(tmp, 0, st.st_size);\n\t\tfree(tmp);\n\t\treturn;\n\t}\n\n\t/* Pass the key back. */\n\t*key = tmp;\n\t*key_size = st.st_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE\n\nvoid\nhmac_sha1_generate_file(pam_handle_t *pamh, void **mac, size_t *mac_length,\n\t\t\tconst char *keyfile, uid_t owner, gid_t group,\n\t\t\tconst void *text, size_t text_length)\n{\n\tvoid *key;\n\tsize_t key_length;\n\n\thmac_key_read(pamh, keyfile,\n\t\t      MAXIMUM_KEY_SIZE, owner, group,\n\t\t      &key, &key_length);\n\tif (key == NULL) {\n\t\t*mac = NULL;\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\thmac_sha1_generate(mac, mac_length,\n\t\t\t   key, key_length,\n\t\t\t   text, text_length);\n\tmemset(key, 0, key_length);\n\tfree(key);\n}"
  },
  {
    "function_name": "hmac_sha1_generate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "202-266",
    "snippet": "void\nhmac_sha1_generate(void **mac, size_t *mac_length,\n\t\t   const void *raw_key, size_t raw_key_size,\n\t\t   const void *text, size_t text_length)\n{\n\tunsigned char key[MAXIMUM_KEY_SIZE], tmp_key[MAXIMUM_KEY_SIZE];\n\tsize_t maximum_key_size = SHA1_BLOCK_SIZE,\n\t       minimum_key_size = SHA1_OUTPUT_SIZE;\n\tconst unsigned char ipad = 0x36, opad = 0x5c;\n\tstruct sha1_context sha1;\n\tunsigned char inner[SHA1_OUTPUT_SIZE], outer[SHA1_OUTPUT_SIZE];\n\n\t*mac = NULL;\n\t*mac_length = 0;\n\n#ifndef HMAC_ALLOW_SHORT_KEYS\n\t/* If the key is too short, don't bother. */\n\tif (raw_key_size < minimum_key_size) {\n\t\treturn;\n\t}\n#endif\n\n\t/* If the key is too long, \"compress\" it, else copy it and pad it\n\t * out with zero bytes. */\n\tmemset(key, 0, sizeof(key));\n\tif (raw_key_size > maximum_key_size) {\n\t\tsha1_init(&sha1);\n\t\tsha1_update(&sha1, raw_key, raw_key_size);\n\t\tsha1_output(&sha1, key);\n\t} else {\n\t\tmemmove(key, raw_key, raw_key_size);\n\t}\n\n\t/* Generate the inner sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, ipad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, text, text_length);\n\tsha1_output(&sha1, inner);\n\n\t/* Generate the outer sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, opad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, inner, sizeof(inner));\n\tsha1_output(&sha1, outer);\n\n\t/* We don't need any of the keys any more. */\n\tmemset(key, 0, sizeof(key));\n\tmemset(tmp_key, 0, sizeof(tmp_key));\n\n\t/* Allocate space to store the output. */\n\t*mac_length = sizeof(outer);\n\t*mac = malloc(*mac_length);\n\tif (*mac == NULL) {\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\n\tmemcpy(*mac, outer, *mac_length);\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*mac",
            "outer",
            "*mac_length"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "*mac_length"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp_key",
            "0",
            "sizeof(tmp_key)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "sizeof(key)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha1_output",
          "args": [
            "&sha1",
            "outer"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/sha1.c",
          "lines": "184-253",
          "snippet": "size_t\nsha1_output(struct sha1_context *ctx, unsigned char *out)\n{\n\tstruct sha1_context ctx2;\n\n\t/* Output the sum. */\n\tif (out != NULL) {\n\t\tuint32_t c;\n\t\tmemcpy(&ctx2, ctx, sizeof(ctx2));\n\n\t\t/* Pad this block. */\n\t\tc = ctx2.pending_count;\n\t\tmemcpy(ctx2.pending.c + c,\n\t\t       padding, SHA1_BLOCK_SIZE - c);\n\n\t\t/* Do we need to process two blocks now? */\n\t\tif (c >= (SHA1_BLOCK_SIZE - (sizeof(uint32_t) * 2))) {\n\t\t\t/* Process this block. */\n\t\t\tsha1_process(&ctx2, ctx2.pending.i);\n\t\t\t/* Set up another block. */\n\t\t\tctx2.pending_count = 0;\n\t\t\tmemset(ctx2.pending.c, 0, SHA1_BLOCK_SIZE);\n                        ctx2.pending.c[0] =\n\t\t\t\t(c == SHA1_BLOCK_SIZE) ? 0x80 : 0;\n\t\t}\n\n\t\t/* Process the final block. */\n\t\tctx2.counts[1] <<= 3;\n\t\tif (ctx2.counts[0] >> 29) {\n\t\t\tctx2.counts[1] |=\n\t\t\t(ctx2.counts[0] >> 29);\n\t\t}\n\t\tctx2.counts[0] <<= 3;\n\t\tctx2.counts[0] = htonl(ctx2.counts[0]);\n\t\tctx2.counts[1] = htonl(ctx2.counts[1]);\n\t\tmemcpy(ctx2.pending.c + 56,\n\t\t       &ctx2.counts[1], sizeof(uint32_t));\n\t\tmemcpy(ctx2.pending.c + 60,\n\t\t       &ctx2.counts[0], sizeof(uint32_t));\n\t\tsha1_process(&ctx2, ctx2.pending.i);\n\n\t\t/* Output the data. */\n\t\tout[ 3] = (ctx2.a >>  0) & 0xff;\n\t\tout[ 2] = (ctx2.a >>  8) & 0xff;\n\t\tout[ 1] = (ctx2.a >> 16) & 0xff;\n\t\tout[ 0] = (ctx2.a >> 24) & 0xff;\n\n\t\tout[ 7] = (ctx2.b >>  0) & 0xff;\n\t\tout[ 6] = (ctx2.b >>  8) & 0xff;\n\t\tout[ 5] = (ctx2.b >> 16) & 0xff;\n\t\tout[ 4] = (ctx2.b >> 24) & 0xff;\n\n\t\tout[11] = (ctx2.c >>  0) & 0xff;\n\t\tout[10] = (ctx2.c >>  8) & 0xff;\n\t\tout[ 9] = (ctx2.c >> 16) & 0xff;\n\t\tout[ 8] = (ctx2.c >> 24) & 0xff;\n\n\t\tout[15] = (ctx2.d >>  0) & 0xff;\n\t\tout[14] = (ctx2.d >>  8) & 0xff;\n\t\tout[13] = (ctx2.d >> 16) & 0xff;\n\t\tout[12] = (ctx2.d >> 24) & 0xff;\n\n\t\tout[19] = (ctx2.e >>  0) & 0xff;\n\t\tout[18] = (ctx2.e >>  8) & 0xff;\n\t\tout[17] = (ctx2.e >> 16) & 0xff;\n\t\tout[16] = (ctx2.e >> 24) & 0xff;\n\t}\n\n\treturn SHA1_OUTPUT_SIZE;\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include <unistd.h>",
            "#include <endian.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char\npadding[SHA1_BLOCK_SIZE] = {\n\t0x80, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include <unistd.h>\n#include <endian.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic unsigned char\npadding[SHA1_BLOCK_SIZE] = {\n\t0x80, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n\t   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nsize_t\nsha1_output(struct sha1_context *ctx, unsigned char *out)\n{\n\tstruct sha1_context ctx2;\n\n\t/* Output the sum. */\n\tif (out != NULL) {\n\t\tuint32_t c;\n\t\tmemcpy(&ctx2, ctx, sizeof(ctx2));\n\n\t\t/* Pad this block. */\n\t\tc = ctx2.pending_count;\n\t\tmemcpy(ctx2.pending.c + c,\n\t\t       padding, SHA1_BLOCK_SIZE - c);\n\n\t\t/* Do we need to process two blocks now? */\n\t\tif (c >= (SHA1_BLOCK_SIZE - (sizeof(uint32_t) * 2))) {\n\t\t\t/* Process this block. */\n\t\t\tsha1_process(&ctx2, ctx2.pending.i);\n\t\t\t/* Set up another block. */\n\t\t\tctx2.pending_count = 0;\n\t\t\tmemset(ctx2.pending.c, 0, SHA1_BLOCK_SIZE);\n                        ctx2.pending.c[0] =\n\t\t\t\t(c == SHA1_BLOCK_SIZE) ? 0x80 : 0;\n\t\t}\n\n\t\t/* Process the final block. */\n\t\tctx2.counts[1] <<= 3;\n\t\tif (ctx2.counts[0] >> 29) {\n\t\t\tctx2.counts[1] |=\n\t\t\t(ctx2.counts[0] >> 29);\n\t\t}\n\t\tctx2.counts[0] <<= 3;\n\t\tctx2.counts[0] = htonl(ctx2.counts[0]);\n\t\tctx2.counts[1] = htonl(ctx2.counts[1]);\n\t\tmemcpy(ctx2.pending.c + 56,\n\t\t       &ctx2.counts[1], sizeof(uint32_t));\n\t\tmemcpy(ctx2.pending.c + 60,\n\t\t       &ctx2.counts[0], sizeof(uint32_t));\n\t\tsha1_process(&ctx2, ctx2.pending.i);\n\n\t\t/* Output the data. */\n\t\tout[ 3] = (ctx2.a >>  0) & 0xff;\n\t\tout[ 2] = (ctx2.a >>  8) & 0xff;\n\t\tout[ 1] = (ctx2.a >> 16) & 0xff;\n\t\tout[ 0] = (ctx2.a >> 24) & 0xff;\n\n\t\tout[ 7] = (ctx2.b >>  0) & 0xff;\n\t\tout[ 6] = (ctx2.b >>  8) & 0xff;\n\t\tout[ 5] = (ctx2.b >> 16) & 0xff;\n\t\tout[ 4] = (ctx2.b >> 24) & 0xff;\n\n\t\tout[11] = (ctx2.c >>  0) & 0xff;\n\t\tout[10] = (ctx2.c >>  8) & 0xff;\n\t\tout[ 9] = (ctx2.c >> 16) & 0xff;\n\t\tout[ 8] = (ctx2.c >> 24) & 0xff;\n\n\t\tout[15] = (ctx2.d >>  0) & 0xff;\n\t\tout[14] = (ctx2.d >>  8) & 0xff;\n\t\tout[13] = (ctx2.d >> 16) & 0xff;\n\t\tout[12] = (ctx2.d >> 24) & 0xff;\n\n\t\tout[19] = (ctx2.e >>  0) & 0xff;\n\t\tout[18] = (ctx2.e >>  8) & 0xff;\n\t\tout[17] = (ctx2.e >> 16) & 0xff;\n\t\tout[16] = (ctx2.e >> 24) & 0xff;\n\t}\n\n\treturn SHA1_OUTPUT_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sha1_update",
          "args": [
            "&sha1",
            "inner",
            "sizeof(inner)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/sha1.c",
          "lines": "149-182",
          "snippet": "void\nsha1_update(struct sha1_context *ctx, const unsigned char *data, size_t length)\n{\n\tsize_t i = 0, l = length, c, t;\n\tuint32_t count = 0;\n\n\t/* Process any pending + data blocks. */\n\twhile (l + ctx->pending_count >= SHA1_BLOCK_SIZE) {\n\t\tc = ctx->pending_count;\n\t\tt = SHA1_BLOCK_SIZE - c;\n\t\tmemcpy(ctx->pending.c + c, &data[i], t);\n\t\tsha1_process(ctx, ctx->pending.i);\n\t\ti += t;\n\t\tl -= t;\n\t\tctx->pending_count = 0;\n\t}\n\n\t/* Save what's left of the data block as a pending data block. */\n\tc = ctx->pending_count;\n\tmemcpy(ctx->pending.c + c, &data[i], l);\n\tctx->pending_count += l;\n\n\t/* Update the message length. */\n\tctx->count += length;\n\n\t/* Update our internal counts. */\n\tif (length != 0) {\n\t\tcount = ctx->counts[0];\n\t\tctx->counts[0] += length;\n\t\tif (count >= ctx->counts[0]) {\n\t\t\tctx->counts[1]++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include <unistd.h>",
            "#include <endian.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include <unistd.h>\n#include <endian.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nsha1_update(struct sha1_context *ctx, const unsigned char *data, size_t length)\n{\n\tsize_t i = 0, l = length, c, t;\n\tuint32_t count = 0;\n\n\t/* Process any pending + data blocks. */\n\twhile (l + ctx->pending_count >= SHA1_BLOCK_SIZE) {\n\t\tc = ctx->pending_count;\n\t\tt = SHA1_BLOCK_SIZE - c;\n\t\tmemcpy(ctx->pending.c + c, &data[i], t);\n\t\tsha1_process(ctx, ctx->pending.i);\n\t\ti += t;\n\t\tl -= t;\n\t\tctx->pending_count = 0;\n\t}\n\n\t/* Save what's left of the data block as a pending data block. */\n\tc = ctx->pending_count;\n\tmemcpy(ctx->pending.c + c, &data[i], l);\n\tctx->pending_count += l;\n\n\t/* Update the message length. */\n\tctx->count += length;\n\n\t/* Update our internal counts. */\n\tif (length != 0) {\n\t\tcount = ctx->counts[0];\n\t\tctx->counts[0] += length;\n\t\tif (count >= ctx->counts[0]) {\n\t\t\tctx->counts[1]++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sha1_init",
          "args": [
            "&sha1"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/sha1.c",
          "lines": "91-100",
          "snippet": "void\nsha1_init(struct sha1_context *ctx)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->a = 0x67452301;\n\tctx->b = 0xefcdab89;\n\tctx->c = 0x98badcfe;\n\tctx->d = 0x10325476;\n\tctx->e = 0xc3d2e1f0;\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include <unistd.h>",
            "#include <endian.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include <unistd.h>\n#include <endian.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nsha1_init(struct sha1_context *ctx)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->a = 0x67452301;\n\tctx->b = 0xefcdab89;\n\tctx->c = 0x98badcfe;\n\tctx->d = 0x10325476;\n\tctx->e = 0xc3d2e1f0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xor_block",
          "args": [
            "tmp_key",
            "opad",
            "sizeof(tmp_key)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "xor_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "193-200",
          "snippet": "static void\nxor_block(unsigned char *p, unsigned char byte, size_t length)\n{\n\tsize_t i;\n\tfor (i = 0; i < length; i++) {\n\t\tp[i] = p[i] ^ byte;\n\t}\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nxor_block(unsigned char *p, unsigned char byte, size_t length)\n{\n\tsize_t i;\n\tfor (i = 0; i < length; i++) {\n\t\tp[i] = p[i] ^ byte;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_key",
            "key",
            "sizeof(tmp_key)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_key",
            "key",
            "sizeof(tmp_key)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "key",
            "raw_key",
            "raw_key_size"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "sizeof(key)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\n#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE\n\nvoid\nhmac_sha1_generate(void **mac, size_t *mac_length,\n\t\t   const void *raw_key, size_t raw_key_size,\n\t\t   const void *text, size_t text_length)\n{\n\tunsigned char key[MAXIMUM_KEY_SIZE], tmp_key[MAXIMUM_KEY_SIZE];\n\tsize_t maximum_key_size = SHA1_BLOCK_SIZE,\n\t       minimum_key_size = SHA1_OUTPUT_SIZE;\n\tconst unsigned char ipad = 0x36, opad = 0x5c;\n\tstruct sha1_context sha1;\n\tunsigned char inner[SHA1_OUTPUT_SIZE], outer[SHA1_OUTPUT_SIZE];\n\n\t*mac = NULL;\n\t*mac_length = 0;\n\n#ifndef HMAC_ALLOW_SHORT_KEYS\n\t/* If the key is too short, don't bother. */\n\tif (raw_key_size < minimum_key_size) {\n\t\treturn;\n\t}\n#endif\n\n\t/* If the key is too long, \"compress\" it, else copy it and pad it\n\t * out with zero bytes. */\n\tmemset(key, 0, sizeof(key));\n\tif (raw_key_size > maximum_key_size) {\n\t\tsha1_init(&sha1);\n\t\tsha1_update(&sha1, raw_key, raw_key_size);\n\t\tsha1_output(&sha1, key);\n\t} else {\n\t\tmemmove(key, raw_key, raw_key_size);\n\t}\n\n\t/* Generate the inner sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, ipad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, text, text_length);\n\tsha1_output(&sha1, inner);\n\n\t/* Generate the outer sum. */\n\tmemcpy(tmp_key, key, sizeof(tmp_key));\n\txor_block(tmp_key, opad, sizeof(tmp_key));\n\n\tsha1_init(&sha1);\n\tsha1_update(&sha1, tmp_key, sizeof(tmp_key));\n\tsha1_update(&sha1, inner, sizeof(inner));\n\tsha1_output(&sha1, outer);\n\n\t/* We don't need any of the keys any more. */\n\tmemset(key, 0, sizeof(key));\n\tmemset(tmp_key, 0, sizeof(tmp_key));\n\n\t/* Allocate space to store the output. */\n\t*mac_length = sizeof(outer);\n\t*mac = malloc(*mac_length);\n\tif (*mac == NULL) {\n\t\t*mac_length = 0;\n\t\treturn;\n\t}\n\n\tmemcpy(*mac, outer, *mac_length);\n}"
  },
  {
    "function_name": "xor_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "193-200",
    "snippet": "static void\nxor_block(unsigned char *p, unsigned char byte, size_t length)\n{\n\tsize_t i;\n\tfor (i = 0; i < length; i++) {\n\t\tp[i] = p[i] ^ byte;\n\t}\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nxor_block(unsigned char *p, unsigned char byte, size_t length)\n{\n\tsize_t i;\n\tfor (i = 0; i < length; i++) {\n\t\tp[i] = p[i] ^ byte;\n\t}\n}"
  },
  {
    "function_name": "hmac_key_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "130-191",
    "snippet": "static void\nhmac_key_read(pam_handle_t *pamh, const char *filename, size_t default_key_size,\n\t      uid_t owner, gid_t group,\n\t      void **key, size_t *key_size)\n{\n\tchar *tmp;\n\tint keyfd, i, count;\n\tstruct stat st;\n\n\ttmp = NULL;\n\t*key = NULL;\n\t*key_size = 0;\n\n\t/* Try to open the key file. */\n\tkeyfd = open(filename, O_RDONLY);\n\tif (keyfd == -1) {\n\t\t/* No such thing? Create it. */\n\t\tif (errno == ENOENT) {\n\t\t\thmac_key_create(pamh, filename, default_key_size,\n\t\t\t\t\towner, group);\n\t\t\tkeyfd = open(filename, O_RDONLY);\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\", filename);\n\t\t}\n\t\tif (keyfd == -1)\n\t\t\treturn;\n\t}\n\n\t/* If we failed to open the file, we're done. */\n\tif (fstat(keyfd, &st) == -1) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read the contents of the file. */\n\ttmp = malloc(st.st_size);\n\tif (!tmp) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\tcount = 0;\n\twhile (count < st.st_size) {\n\t\ti = read(keyfd, tmp + count, st.st_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tclose(keyfd);\n\n\t/* Require that we got the expected amount of data. */\n\tif (count < st.st_size) {\n\t\tmemset(tmp, 0, st.st_size);\n\t\tfree(tmp);\n\t\treturn;\n\t}\n\n\t/* Pass the key back. */\n\t*key = tmp;\n\t*key_size = st.st_size;\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "st.st_size"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "keyfd",
            "tmp + count",
            "st.st_size - count"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "188-275",
          "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
            "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "keyfd",
            "&st"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open %s: %m\"",
            "filename"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_key_create",
          "args": [
            "pamh",
            "filename",
            "default_key_size",
            "owner",
            "group"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_key_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
          "lines": "57-128",
          "snippet": "static void\nhmac_key_create(pam_handle_t *pamh, const char *filename, size_t key_size,\n\t\tuid_t owner, gid_t group)\n{\n\tint randfd, keyfd, i;\n\tsize_t count;\n\tchar *key;\n\n\t/* Open the destination file. */\n\tkeyfd = open(filename,\n\t\t     O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n\t\t     S_IRUSR | S_IWUSR);\n\tif (keyfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot create %s: %m\", filename);\n\t\treturn;\n\t}\n\n\n\t if (fchown(keyfd, owner, group) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot chown %s: %m\", filename);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Open the random device to get key data. */\n\trandfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (randfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read random data for use as the key. */\n\tkey = malloc(key_size);\n\tcount = 0;\n\tif (!key) {\n\t\tclose(keyfd);\n\t\tclose(randfd);\n\t\treturn;\n\t}\n\twhile (count < key_size) {\n\t\ti = read(randfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\n\tclose(randfd);\n\n\t/* If we didn't get enough, stop here. */\n\tif (count < key_size) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n\t\tmemset(key, 0, key_size);\n\t\tfree(key);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Now write the key. */\n\tcount = 0;\n\twhile (count < key_size) {\n\t\ti = write(keyfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tmemset(key, 0, key_size);\n\tfree(key);\n\tclose(keyfd);\n}",
          "includes": [
            "#include \"sha1.h\"",
            "#include \"hmacsha1.h\"",
            "#include <security/pam_ext.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nhmac_key_create(pam_handle_t *pamh, const char *filename, size_t key_size,\n\t\tuid_t owner, gid_t group)\n{\n\tint randfd, keyfd, i;\n\tsize_t count;\n\tchar *key;\n\n\t/* Open the destination file. */\n\tkeyfd = open(filename,\n\t\t     O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n\t\t     S_IRUSR | S_IWUSR);\n\tif (keyfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot create %s: %m\", filename);\n\t\treturn;\n\t}\n\n\n\t if (fchown(keyfd, owner, group) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot chown %s: %m\", filename);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Open the random device to get key data. */\n\trandfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (randfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read random data for use as the key. */\n\tkey = malloc(key_size);\n\tcount = 0;\n\tif (!key) {\n\t\tclose(keyfd);\n\t\tclose(randfd);\n\t\treturn;\n\t}\n\twhile (count < key_size) {\n\t\ti = read(randfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\n\tclose(randfd);\n\n\t/* If we didn't get enough, stop here. */\n\tif (count < key_size) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n\t\tmemset(key, 0, key_size);\n\t\tfree(key);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Now write the key. */\n\tcount = 0;\n\twhile (count < key_size) {\n\t\ti = write(keyfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tmemset(key, 0, key_size);\n\tfree(key);\n\tclose(keyfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nhmac_key_read(pam_handle_t *pamh, const char *filename, size_t default_key_size,\n\t      uid_t owner, gid_t group,\n\t      void **key, size_t *key_size)\n{\n\tchar *tmp;\n\tint keyfd, i, count;\n\tstruct stat st;\n\n\ttmp = NULL;\n\t*key = NULL;\n\t*key_size = 0;\n\n\t/* Try to open the key file. */\n\tkeyfd = open(filename, O_RDONLY);\n\tif (keyfd == -1) {\n\t\t/* No such thing? Create it. */\n\t\tif (errno == ENOENT) {\n\t\t\thmac_key_create(pamh, filename, default_key_size,\n\t\t\t\t\towner, group);\n\t\t\tkeyfd = open(filename, O_RDONLY);\n\t\t} else {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\", filename);\n\t\t}\n\t\tif (keyfd == -1)\n\t\t\treturn;\n\t}\n\n\t/* If we failed to open the file, we're done. */\n\tif (fstat(keyfd, &st) == -1) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read the contents of the file. */\n\ttmp = malloc(st.st_size);\n\tif (!tmp) {\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\tcount = 0;\n\twhile (count < st.st_size) {\n\t\ti = read(keyfd, tmp + count, st.st_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tclose(keyfd);\n\n\t/* Require that we got the expected amount of data. */\n\tif (count < st.st_size) {\n\t\tmemset(tmp, 0, st.st_size);\n\t\tfree(tmp);\n\t\treturn;\n\t}\n\n\t/* Pass the key back. */\n\t*key = tmp;\n\t*key_size = st.st_size;\n}"
  },
  {
    "function_name": "hmac_key_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_timestamp/hmacsha1.c",
    "lines": "57-128",
    "snippet": "static void\nhmac_key_create(pam_handle_t *pamh, const char *filename, size_t key_size,\n\t\tuid_t owner, gid_t group)\n{\n\tint randfd, keyfd, i;\n\tsize_t count;\n\tchar *key;\n\n\t/* Open the destination file. */\n\tkeyfd = open(filename,\n\t\t     O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n\t\t     S_IRUSR | S_IWUSR);\n\tif (keyfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot create %s: %m\", filename);\n\t\treturn;\n\t}\n\n\n\t if (fchown(keyfd, owner, group) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot chown %s: %m\", filename);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Open the random device to get key data. */\n\trandfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (randfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read random data for use as the key. */\n\tkey = malloc(key_size);\n\tcount = 0;\n\tif (!key) {\n\t\tclose(keyfd);\n\t\tclose(randfd);\n\t\treturn;\n\t}\n\twhile (count < key_size) {\n\t\ti = read(randfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\n\tclose(randfd);\n\n\t/* If we didn't get enough, stop here. */\n\tif (count < key_size) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n\t\tmemset(key, 0, key_size);\n\t\tfree(key);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Now write the key. */\n\tcount = 0;\n\twhile (count < key_size) {\n\t\ti = write(keyfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tmemset(key, 0, key_size);\n\tfree(key);\n\tclose(keyfd);\n}",
    "includes": [
      "#include \"sha1.h\"",
      "#include \"hmacsha1.h\"",
      "#include <security/pam_ext.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "key"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "key_size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "keyfd",
            "key + count",
            "key_size - count"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "key_size"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Short read on random device\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "randfd"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "randfd",
            "key + count",
            "key_size - count"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "188-275",
          "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
            "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "randfd"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "key_size"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open /dev/urandom: %m\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "keyfd"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot chown %s: %m\"",
            "filename"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "keyfd",
            "owner",
            "group"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot create %s: %m\"",
            "filename"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_WRONLY | O_CREAT | O_EXCL | O_TRUNC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sha1.h\"\n#include \"hmacsha1.h\"\n#include <security/pam_ext.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nstatic void\nhmac_key_create(pam_handle_t *pamh, const char *filename, size_t key_size,\n\t\tuid_t owner, gid_t group)\n{\n\tint randfd, keyfd, i;\n\tsize_t count;\n\tchar *key;\n\n\t/* Open the destination file. */\n\tkeyfd = open(filename,\n\t\t     O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n\t\t     S_IRUSR | S_IWUSR);\n\tif (keyfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot create %s: %m\", filename);\n\t\treturn;\n\t}\n\n\n\t if (fchown(keyfd, owner, group) == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot chown %s: %m\", filename);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Open the random device to get key data. */\n\trandfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (randfd == -1) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open /dev/urandom: %m\");\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Read random data for use as the key. */\n\tkey = malloc(key_size);\n\tcount = 0;\n\tif (!key) {\n\t\tclose(keyfd);\n\t\tclose(randfd);\n\t\treturn;\n\t}\n\twhile (count < key_size) {\n\t\ti = read(randfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\n\tclose(randfd);\n\n\t/* If we didn't get enough, stop here. */\n\tif (count < key_size) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Short read on random device\");\n\t\tmemset(key, 0, key_size);\n\t\tfree(key);\n\t\tclose(keyfd);\n\t\treturn;\n\t}\n\n\t/* Now write the key. */\n\tcount = 0;\n\twhile (count < key_size) {\n\t\ti = write(keyfd, key + count, key_size - count);\n\t\tif ((i == 0) || (i == -1)) {\n\t\t\tbreak;\n\t\t}\n\t\tcount += i;\n\t}\n\tmemset(key, 0, key_size);\n\tfree(key);\n\tclose(keyfd);\n}"
  }
]