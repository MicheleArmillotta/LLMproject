[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "2192-2272",
    "snippet": "int pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n                                    int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    const void *polyptr;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"unmount_on_close\") == 0)\n            idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;\n    }\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - start\");\n\n    /*\n     * Normally the unmount is implicitly done when the last\n     * process in the private namespace exits.\n     * If it is ensured that there are no child processes left in\n     * the private namespace by other means and if there are\n     * multiple sessions opened and closed sequentially by the\n     * same process, the \"unmount_on_close\" option might be\n     * used to unmount the polydirs explicitly.\n     */\n    if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {\n\tpam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n\tpam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n\tif (idata.flags & PAMNS_DEBUG)\n\t    pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - successful\");\n        return PAM_SUCCESS;\n    }\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);\n    if (retval != PAM_SUCCESS || polyptr == NULL)\n\t/* nothing to reset */\n\treturn PAM_SUCCESS;\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    idata.polydirs_ptr = (void *)polyptr;\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Resetting namespace for pid %d\",\n\t\tgetpid());\n\n    retval = orig_namespace(&idata);\n    if (idata.flags & PAMNS_DEBUG) {\n        if (retval)\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace failed for pid %d\", getpid());\n        else\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace ok for pid %d\", getpid());\n    }\n\n    pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n    pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata.pamh",
            "NAMESPACE_PROTECT_DATA",
            "NULL",
            "NULL"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata.pamh",
            "NAMESPACE_POLYDIR_DATA",
            "NULL",
            "NULL"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"resetting namespace ok for pid %d\"",
            "getpid()"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"resetting namespace failed for pid %d\"",
            "getpid()"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orig_namespace",
          "args": [
            "&idata"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "orig_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1933-1968",
          "snippet": "static int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"Resetting namespace for pid %d\"",
            "getpid()"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "idata.pamh",
            "NAMESPACE_POLYDIR_DATA",
            "&polyptr"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_data",
          "args": [
            "&idata"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "2044-2091",
          "snippet": "static int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"close_session - successful\""
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata.pamh",
            "NAMESPACE_PROTECT_DATA",
            "NULL",
            "NULL"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata.pamh",
            "NAMESPACE_POLYDIR_DATA",
            "NULL",
            "NULL"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"close_session - start\""
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"unmount_on_close\""
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"ignore_config_error\""
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt_based_inst_needed",
          "args": [],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "ctxt_based_inst_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1981-1993",
          "snippet": "static int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nint pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n                                    int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    const void *polyptr;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"unmount_on_close\") == 0)\n            idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;\n    }\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - start\");\n\n    /*\n     * Normally the unmount is implicitly done when the last\n     * process in the private namespace exits.\n     * If it is ensured that there are no child processes left in\n     * the private namespace by other means and if there are\n     * multiple sessions opened and closed sequentially by the\n     * same process, the \"unmount_on_close\" option might be\n     * used to unmount the polydirs explicitly.\n     */\n    if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {\n\tpam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n\tpam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n\tif (idata.flags & PAMNS_DEBUG)\n\t    pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - successful\");\n        return PAM_SUCCESS;\n    }\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);\n    if (retval != PAM_SUCCESS || polyptr == NULL)\n\t/* nothing to reset */\n\treturn PAM_SUCCESS;\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    idata.polydirs_ptr = (void *)polyptr;\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Resetting namespace for pid %d\",\n\t\tgetpid());\n\n    retval = orig_namespace(&idata);\n    if (idata.flags & PAMNS_DEBUG) {\n        if (retval)\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace failed for pid %d\", getpid());\n        else\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace ok for pid %d\", getpid());\n    }\n\n    pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n    pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "2096-2186",
    "snippet": "int pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n                                   int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    enum unmnt_op unmnt = NO_UNMNT;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.protect_dirs = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"gen_hash\") == 0)\n            idata.flags |= PAMNS_GEN_HASH;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"ignore_instance_parent_mode\") == 0)\n            idata.flags |= PAMNS_IGN_INST_PARENT_MODE;\n        if (strcmp(argv[i], \"use_current_context\") == 0) {\n            idata.flags |= PAMNS_USE_CURRENT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"use_default_context\") == 0) {\n            idata.flags |= PAMNS_USE_DEFAULT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"mount_private\") == 0) {\n            idata.flags |= PAMNS_MOUNT_PRIVATE;\n        }\n        if (strcmp(argv[i], \"unmnt_remnt\") == 0)\n            unmnt = UNMNT_REMNT;\n        if (strcmp(argv[i], \"unmnt_only\") == 0)\n            unmnt = UNMNT_ONLY;\n\tif (strcmp(argv[i], \"require_selinux\") == 0) {\n\t\tif (!(idata.flags & PAMNS_SELINUX_ENABLED)) {\n\t\t\tpam_syslog(idata.pamh, LOG_ERR,\n\t\t    \"selinux_required option given and selinux is disabled\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n    }\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"open_session - start\");\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (root_shared()) {\n\tidata.flags |= PAMNS_MOUNT_PRIVATE;\n    }\n\n    /*\n     * Parse namespace configuration file which lists directories to\n     * polyinstantiate, directory where instance directories are to\n     * be created and the method used for polyinstantiation.\n     */\n    retval = parse_config_file(&idata);\n    if (retval != PAM_SUCCESS) {\n\tdel_polydir_list(idata.polydirs_ptr);\n        return PAM_SESSION_ERR;\n    }\n\n    if (idata.polydirs_ptr) {\n        retval = setup_namespace(&idata, unmnt);\n        if (idata.flags & PAMNS_DEBUG) {\n            if (retval)\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup failed for pid %d\", getpid());\n            else\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup ok for pid %d\", getpid());\n        }\n    } else if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Nothing to polyinstantiate\");\n\n    if (retval != PAM_SUCCESS)\n\tdel_polydir_list(idata.polydirs_ptr);\n    return retval;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_polydir_list",
          "args": [
            "idata.polydirs_ptr"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "del_polydir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "77-86",
          "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"Nothing to polyinstantiate\""
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"namespace setup ok for pid %d\"",
            "getpid()"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"namespace setup failed for pid %d\"",
            "getpid()"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_namespace",
          "args": [
            "&idata",
            "unmnt"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "setup_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1762-1926",
          "snippet": "static int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_config_file",
          "args": [
            "&idata"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "618-739",
          "snippet": "static int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    glob_t globbuf;\n    const char *oldlocale;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    memset(&globbuf, '\\0', sizeof(globbuf));\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob(NAMESPACE_D_GLOB, 0, NULL, &globbuf);\n    if (oldlocale != NULL)\n\tsetlocale(LC_COLLATE, oldlocale);\n\n    confname = PAM_NAMESPACE_CONFIG;\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n            globfree(&globbuf);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        globfree(&globbuf);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (n >= globbuf.gl_pathc)\n\t    break;\n\n\tconfname = globbuf.gl_pathv[n];\n\tn++;\n    }\n\n    globfree(&globbuf);\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    glob_t globbuf;\n    const char *oldlocale;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    memset(&globbuf, '\\0', sizeof(globbuf));\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob(NAMESPACE_D_GLOB, 0, NULL, &globbuf);\n    if (oldlocale != NULL)\n\tsetlocale(LC_COLLATE, oldlocale);\n\n    confname = PAM_NAMESPACE_CONFIG;\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n            globfree(&globbuf);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        globfree(&globbuf);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (n >= globbuf.gl_pathc)\n\t    break;\n\n\tconfname = globbuf.gl_pathv[n];\n\tn++;\n    }\n\n    globfree(&globbuf);\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_shared",
          "args": [],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "root_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1996-2042",
          "snippet": "static int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_data",
          "args": [
            "&idata"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "2044-2091",
          "snippet": "static int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_DEBUG",
            "\"open_session - start\""
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata.pamh",
            "LOG_ERR",
            "\"selinux_required option given and selinux is disabled\""
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"require_selinux\""
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"unmnt_only\""
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"unmnt_remnt\""
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"mount_private\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"use_default_context\""
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"use_current_context\""
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"ignore_instance_parent_mode\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"ignore_config_error\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"gen_hash\""
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"debug\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctxt_based_inst_needed",
          "args": [],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "ctxt_based_inst_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1981-1993",
          "snippet": "static int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nint pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n                                   int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    enum unmnt_op unmnt = NO_UNMNT;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.protect_dirs = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"gen_hash\") == 0)\n            idata.flags |= PAMNS_GEN_HASH;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"ignore_instance_parent_mode\") == 0)\n            idata.flags |= PAMNS_IGN_INST_PARENT_MODE;\n        if (strcmp(argv[i], \"use_current_context\") == 0) {\n            idata.flags |= PAMNS_USE_CURRENT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"use_default_context\") == 0) {\n            idata.flags |= PAMNS_USE_DEFAULT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"mount_private\") == 0) {\n            idata.flags |= PAMNS_MOUNT_PRIVATE;\n        }\n        if (strcmp(argv[i], \"unmnt_remnt\") == 0)\n            unmnt = UNMNT_REMNT;\n        if (strcmp(argv[i], \"unmnt_only\") == 0)\n            unmnt = UNMNT_ONLY;\n\tif (strcmp(argv[i], \"require_selinux\") == 0) {\n\t\tif (!(idata.flags & PAMNS_SELINUX_ENABLED)) {\n\t\t\tpam_syslog(idata.pamh, LOG_ERR,\n\t\t    \"selinux_required option given and selinux is disabled\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n    }\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"open_session - start\");\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (root_shared()) {\n\tidata.flags |= PAMNS_MOUNT_PRIVATE;\n    }\n\n    /*\n     * Parse namespace configuration file which lists directories to\n     * polyinstantiate, directory where instance directories are to\n     * be created and the method used for polyinstantiation.\n     */\n    retval = parse_config_file(&idata);\n    if (retval != PAM_SUCCESS) {\n\tdel_polydir_list(idata.polydirs_ptr);\n        return PAM_SESSION_ERR;\n    }\n\n    if (idata.polydirs_ptr) {\n        retval = setup_namespace(&idata, unmnt);\n        if (idata.flags & PAMNS_DEBUG) {\n            if (retval)\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup failed for pid %d\", getpid());\n            else\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup ok for pid %d\", getpid());\n        }\n    } else if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Nothing to polyinstantiate\");\n\n    if (retval != PAM_SUCCESS)\n\tdel_polydir_list(idata.polydirs_ptr);\n    return retval;\n}"
  },
  {
    "function_name": "get_user_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "2044-2091",
    "snippet": "static int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "idata->ruser",
            "user_name",
            "sizeof(idata->ruser) - 1"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"user unknown '%s'\"",
            "user_name"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwuid",
          "args": [
            "idata->pamh",
            "getuid()"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "idata->pamh",
            "user_name"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "idata->ruser",
            "user_name",
            "sizeof(idata->ruser) - 1"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "idata->pamh",
            "PAM_RUSER",
            "(void*) &user_name"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "idata->user",
            "user_name",
            "sizeof(idata->user) - 1"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"user unknown '%s'\"",
            "user_name"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "idata->pamh",
            "user_name"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error recovering pam user name\""
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "idata->pamh",
            "PAM_USER",
            "(void*) &user_name"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "root_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1996-2042",
    "snippet": "static int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "tok",
            "\"shared:\""
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tok",
            "\"/\""
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "l",
            "\" \"",
            "&sptr"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&n",
            "f"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}"
  },
  {
    "function_name": "ctxt_based_inst_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1981-1993",
    "snippet": "static int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getexeccon",
          "args": [
            "&scon"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}"
  },
  {
    "function_name": "orig_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1933-1968",
    "snippet": "static int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_tmpdirs",
          "args": [
            "idata"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_tmpdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1702-1754",
          "snippet": "static int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Unmount of %s succeeded\"",
            "pptr->dir"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unmount of %s failed, %m\"",
            "pptr->dir"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "pptr->dir"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Unmounting instance dir for user %d & dir %s\"",
            "idata->uid",
            "pptr->dir"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_override",
          "args": [
            "pptr",
            "idata",
            "idata->uid"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "ns_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "749-766",
          "snippet": "static int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"orig namespace for pid %d\"",
            "getpid()"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}"
  },
  {
    "function_name": "setup_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1762-1926",
    "snippet": "static int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata->pamh",
            "NAMESPACE_PROTECT_DATA",
            "NULL",
            "NULL"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_tmpdirs",
          "args": [
            "idata"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_tmpdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1702-1754",
          "snippet": "static int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unable to set namespace polydir data\""
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata->pamh",
            "NAMESPACE_POLYDIR_DATA",
            "idata->polydirs_ptr",
            "cleanup_polydir_data"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unprotect_dirs",
          "args": [
            "idata->protect_dirs"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "unprotect_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "88-99",
          "snippet": "static void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unable to set namespace protect data\""
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "idata->pamh",
            "NAMESPACE_PROTECT_DATA",
            "idata->protect_dirs",
            "cleanup_protect_data"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_setup",
          "args": [
            "pptr",
            "idata"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "ns_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1539-1673",
          "snippet": "static int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Umount succeeded %s\"",
            "pptr->rdir"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unmount of %s failed, %m\"",
            "pptr->rdir"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "pptr->rdir"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Can't chdir to %s, %m\"",
            "poly_parent"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "poly_parent"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "poly_parent",
            "\"/\""
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "poly_parent",
            "'/'"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "poly_parent",
            "'/'"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "poly_parent",
            "pptr->rdir"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"changing cwd\""
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cwd_in",
          "args": [
            "pptr->rdir",
            "idata"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "cwd_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1680-1700",
          "snippet": "static int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Setting poly ns for user %d for dir %s\"",
            "idata->uid",
            "pptr->dir"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_override",
          "args": [
            "pptr",
            "idata",
            "idata->uid"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "ns_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "749-766",
          "snippet": "static int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_polydir_list",
          "args": [
            "idata->polydirs_ptr"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "del_polydir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "77-86",
          "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"The / mount point was marked as slave\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Failed to mark / as a slave mount point, %m\""
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/\"",
            "\"/\"",
            "NULL",
            "MS_SLAVE | MS_REC",
            "NULL"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unable to unshare from parent namespace, %m\""
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Need poly ns for user %d for dir %s\"",
            "idata->uid",
            "pptr->dir"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Need unmount ns for user %d for dir %s\"",
            "idata->ruid",
            "pptr->dir"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Overriding poly for user %d for dir %s\"",
            "idata->uid",
            "pptr->dir"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Set up namespace for pid %d\"",
            "getpid()"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}"
  },
  {
    "function_name": "cleanup_tmpdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1702-1754",
    "snippet": "static int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Cannot fork to run namespace init script, %m\""
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error removing %s\"",
            "pptr->instance_prefix"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"waitpid failed: %m\""
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execle",
          "args": [
            "\"/bin/rm\"",
            "\"/bin/rm\"",
            "\"-rf\"",
            "pptr->instance_prefix",
            "NULL",
            "envp"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon",
          "args": [
            "NULL"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "pptr->instance_prefix",
            "F_OK"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "login_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "325-425",
          "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Cannot set signal value\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}"
  },
  {
    "function_name": "cwd_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1680-1700",
    "snippet": "static int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"cwd is outside %s\"",
            "dir"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"cwd is inside %s\"",
            "dir"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cwd",
            "dir",
            "strlen(dir)"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Can't get current dir, %m\""
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "cwd",
            "PATH_MAX"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "ns_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1539-1673",
    "snippet": "static int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "origcontext"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "instcontext"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "instname"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inst_init",
          "args": [
            "polyptr",
            "inst_dir",
            "idata",
            "newdir"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "inst_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1249-1319",
          "snippet": "static int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tstruct sigaction newsa, oldsa;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n\tmemset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\trc = PAM_SESSION_ERR;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = PAM_SUCCESS;\nout:\n   (void) sigaction(SIGCHLD, &oldsa, NULL);\n\n   return rc;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tstruct sigaction newsa, oldsa;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n\tmemset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\trc = PAM_SESSION_ERR;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = PAM_SUCCESS;\nout:\n   (void) sigaction(SIGCHLD, &oldsa, NULL);\n\n   return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error mounting %s on %s, %m\"",
            "inst_dir",
            "polyptr->dir"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "inst_dir",
            "polyptr->dir",
            "NULL",
            "MS_BIND",
            "NULL"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_instance",
          "args": [
            "polyptr",
            "inst_dir",
            "&statbuf",
            "idata"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "create_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1433-1529",
          "snippet": "static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_instance",
          "args": [
            "polyptr",
            "inst_dir",
            "&statbuf",
            "instcontext",
            "origcontext",
            "idata"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"instance_dir %s\"",
            "inst_dir"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&inst_dir",
            "\"%s%s\"",
            "polyptr->instance_prefix",
            "instname"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Inst ctxt %s Orig ctxt %s\"",
            "instcontext",
            "origcontext"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting instance name\""
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poly_name",
          "args": [
            "polyptr",
            "&instname",
            "idata"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poly_name",
          "args": [
            "polyptr",
            "&instname",
            "&instcontext",
            "&origcontext",
            "idata"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error stating %s: %m\"",
            "polyptr->dir"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "polyptr->dir",
            "&statbuf"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error mounting tmpfs on %s, %m\"",
            "polyptr->dir"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "polyptr->dir",
            "\"tmpfs\"",
            "polyptr->mount_flags",
            "polyptr->mount_opts"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "retval"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_polydir",
          "args": [
            "polyptr",
            "idata"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "create_polydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1321-1423",
          "snippet": "static int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Polydir %s access error: %m\"",
            "polyptr->dir"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protect_dir",
          "args": [
            "polyptr->dir",
            "0",
            "0",
            "idata"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "protect_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1097-1194",
          "snippet": "static int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Set namespace for directory %s\"",
            "polyptr->dir"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}"
  },
  {
    "function_name": "create_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1433-1529",
    "snippet": "static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error changing mode for %s, %m\"",
            "ipath"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "statbuf->st_mode & 07777"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error changing owner for %s, %m\"",
            "ipath"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "statbuf->st_uid",
            "statbuf->st_gid"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error stating %s, %m\"",
            "ipath"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&newstatbuf"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error setting context of %s to %s\"",
            "ipath",
            "ocontext"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsetfilecon",
          "args": [
            "fd",
            "ocontext"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error setting context of %s to %s\"",
            "ipath",
            "icontext"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsetfilecon",
          "args": [
            "fd",
            "icontext"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "ipath"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error opening %s, %m\"",
            "ipath"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "ipath",
            "O_DIRECTORY | O_RDONLY"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error creating %s, %m\"",
            "ipath"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "ipath",
            "S_IRUSR"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ipath",
            "polyptr->instance_prefix"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error creating temporary instance %s, %m\"",
            "polyptr->instance_prefix"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "polyptr->instance_prefix"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_inst_parent",
          "args": [
            "ipath",
            "idata"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "check_inst_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1196-1241",
          "snippet": "static int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = (char *) malloc(strlen(ipath)+1);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tstrcpy(inst_parent, ipath);\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = (char *) malloc(strlen(ipath)+1);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tstrcpy(inst_parent, ipath);\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "create_polydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1321-1423",
    "snippet": "static int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Polydir owner %u group %u\"",
            "uid",
            "gid"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rc"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dir"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "dir"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rc"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unable to change owner on directory %s: %m\"",
            "dir"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "rc",
            "uid",
            "gid"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dir"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "dir"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rc"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error changing mode of directory %s: %m\"",
            "dir"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "rc",
            "mode"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Created polydir %s\"",
            "dir"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "oldcon_raw"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Error resetting fs create context: %m\""
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfscreatecon_raw",
          "args": [
            "oldcon_raw"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error creating directory %s: %m\"",
            "dir"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protect_dir",
          "args": [
            "dir",
            "mode",
            "1",
            "idata"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "protect_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1097-1194",
          "snippet": "static int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selabel_close",
          "args": [
            "label_handle"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "dircon_raw"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Error setting context for directory %s: %m\"",
            "dir"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfscreatecon_raw",
          "args": [
            "dircon_raw"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Polydir %s context: %s\"",
            "dir",
            "dircon_raw"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Unable to get default context for directory %s, check your policy: %m\"",
            "dir"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_lookup_raw",
          "args": [
            "label_handle",
            "&dircon_raw",
            "dir",
            "S_IFDIR"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Unable to initialize SELinux labeling handle: %m\""
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_open",
          "args": [
            "SELABEL_CTX_FILE",
            "NULL",
            "0"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getfscreatecon_raw",
          "args": [
            "&oldcon_raw"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "inst_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1249-1319",
    "snippet": "static int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tstruct sigaction newsa, oldsa;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n\tmemset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\trc = PAM_SESSION_ERR;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = PAM_SUCCESS;\nout:\n   (void) sigaction(SIGCHLD, &oldsa, NULL);\n\n   return rc;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Cannot fork to run namespace init script, %m\""
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error initializing instance\""
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"waitpid failed- %m\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execle",
          "args": [
            "init_script",
            "init_script",
            "polyptr->dir",
            "ipath",
            "newdir?\"1\":\"0\"",
            "idata->user",
            "NULL",
            "envp"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "geteuid()"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon",
          "args": [
            "NULL"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Namespace init script not executable\""
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "init_script",
            "X_OK"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "login_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
          "lines": "325-425",
          "snippet": "static int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <libaudit.h>",
            "#include <glob.h>",
            "#include <sys/socket.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NOMATCH        -1",
            "#define NO              0",
            "#define YES             1",
            "#define ALL             2"
          ],
          "globals_used": [
            "static int user_match (pam_handle_t *, char *, struct login_info *);",
            "static int group_match (pam_handle_t *, const char *, const char *, int);",
            "static int from_match (pam_handle_t *, char *, struct login_info *);",
            "static int remote_match (pam_handle_t *, char *, struct login_info *);",
            "static int string_match (pam_handle_t *, const char *, const char *, int);",
            "static int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NOMATCH        -1\n#define NO              0\n#define YES             1\n#define ALL             2\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nlogin_access (pam_handle_t *pamh, struct login_info *item)\n{\n    FILE   *fp;\n    char    line[BUFSIZ];\n    char   *perm;\t\t/* becomes permission field */\n    char   *users;\t\t/* becomes list of login names */\n    char   *froms;\t\t/* becomes list of terminals or hosts */\n    int     match = NO;\n#ifdef HAVE_LIBAUDIT\n    int     nonall_match = NO;\n#endif\n    int     end;\n    int     lineno = 0;\t\t/* for diagnostics */\n    char   *sptr;\n\n    if (item->debug)\n      pam_syslog (pamh, LOG_DEBUG,\n\t\t  \"login_access: user=%s, from=%s, file=%s\",\n\t\t  item->user->pw_name,\n\t\t  item->from, item->config_file);\n\n    /*\n     * Process the table one line at a time and stop at the first match.\n     * Blank lines and lines that begin with a '#' character are ignored.\n     * Non-comment lines are broken at the ':' character. All fields are\n     * mandatory. The first field should be a \"+\" or \"-\" character. A\n     * non-existing table means no access control.\n     */\n\n    if ((fp = fopen(item->config_file, \"r\"))!=NULL) {\n\twhile (!match && fgets(line, sizeof(line), fp)) {\n\t    lineno++;\n\t    if (line[end = strlen(line) - 1] != '\\n') {\n\t\tpam_syslog(pamh, LOG_ERR,\n                           \"%s: line %d: missing newline or line too long\",\n\t\t           item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (line[0] == '#')\n\t\tcontinue;\t\t\t/* comment line */\n\t    while (end > 0 && isspace(line[end - 1]))\n\t\tend--;\n\t    line[end] = 0;\t\t\t/* strip trailing whitespace */\n\t    if (line[0] == 0)\t\t\t/* skip blank lines */\n\t\tcontinue;\n\n\t    /* Allow field separator in last field of froms */\n\t    if (!(perm = strtok_r(line, item->fs, &sptr))\n\t\t|| !(users = strtok_r(NULL, item->fs, &sptr))\n\t\t|| !(froms = strtok_r(NULL, \"\\n\", &sptr))) {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad field count\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (perm[0] != '+' && perm[0] != '-') {\n\t\tpam_syslog(pamh, LOG_ERR, \"%s: line %d: bad first field\",\n\t\t\t   item->config_file, lineno);\n\t\tcontinue;\n\t    }\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG,\n\t\t\t  \"line %d: %s : %s : %s\", lineno, perm, users, froms);\n\t    match = list_match(pamh, users, NULL, item, user_match);\n\t    if (item->debug)\n\t      pam_syslog (pamh, LOG_DEBUG, \"user_match=%d, \\\"%s\\\"\",\n\t\t\t  match, item->user->pw_name);\n\t    if (match) {\n\t\tmatch = list_match(pamh, froms, NULL, item, from_match);\n#ifdef HAVE_LIBAUDIT\n\t\tif (!match && perm[0] == '+') {\n\t\t    nonall_match = YES;\n\t\t}\n#endif\n\t\tif (item->debug)\n\t\t    pam_syslog (pamh, LOG_DEBUG,\n\t\t\t\t\"from_match=%d, \\\"%s\\\"\", match, item->from);\n\t    }\n\t}\n\t(void) fclose(fp);\n    } else if (errno == ENOENT) {\n        /* This is no error.  */\n\tpam_syslog(pamh, LOG_WARNING, \"warning: cannot open %s: %m\",\n\t           item->config_file);\n    } else {\n        pam_syslog(pamh, LOG_ERR, \"cannot open %s: %m\", item->config_file);\n\treturn NO;\n    }\n#ifdef HAVE_LIBAUDIT\n    if (!item->noaudit && (match == YES || (match == ALL &&\n\tnonall_match == YES)) && line[0] == '-') {\n\tpam_modutil_audit_write(pamh, AUDIT_ANOM_LOGIN_LOCATION,\n\t    \"pam_access\", 0);\n    }\n#endif\n    if (match == NO)\n\treturn NOMATCH;\n    if (line[0] == '+')\n\treturn YES;\n    return NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Cannot set signal value\""
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tstruct sigaction newsa, oldsa;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n\tmemset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\trc = PAM_SESSION_ERR;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = PAM_SUCCESS;\nout:\n   (void) sigaction(SIGCHLD, &oldsa, NULL);\n\n   return rc;\n}"
  },
  {
    "function_name": "check_inst_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1196-1241",
    "snippet": "static int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = (char *) malloc(strlen(ipath)+1);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tstrcpy(inst_parent, ipath);\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "inst_parent"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Mode of inst parent %s not 000 or owner not root\"",
            "inst_parent"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error creating or accessing instance parent %s, %m\"",
            "inst_parent"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "dfd",
            "&instpbuf"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protect_dir",
          "args": [
            "inst_parent",
            "0",
            "1",
            "idata"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "protect_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1097-1194",
          "snippet": "static int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "inst_parent",
            "'/'"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "inst_parent",
            "ipath"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Error allocating pathname string\""
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(ipath)+1"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ipath"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = (char *) malloc(strlen(ipath)+1);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tstrcpy(inst_parent, ipath);\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "protect_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1097-1194",
    "snippet": "static int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rv"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protect_mount",
          "args": [
            "rv",
            "p",
            "idata"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "protect_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "1049-1095",
          "snippet": "static int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rv"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rv"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "rv",
            "&st"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dfd",
            "dir",
            "flags"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdirat",
          "args": [
            "dfd",
            "dir",
            "mode"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dfd",
            "dir",
            "flags"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "dfd",
            "&st"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dfd",
            "dir",
            "flags"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "dir",
            "'/'"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/\"",
            "flags"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}"
  },
  {
    "function_name": "protect_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "1049-1095",
    "snippet": "static int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dir"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Protect mount of %s failed: %m\"",
            "tmpbuf"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "tmpbuf",
            "tmpbuf",
            "NULL",
            "MS_BIND",
            "NULL"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_INFO",
            "\"Protect mount of %s over itself\"",
            "path"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmpbuf",
            "sizeof(tmpbuf)",
            "\"/proc/self/fd/%d\"",
            "dfd"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*dir)"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "dir->dir"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "form_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "799-907",
    "snippet": "static int form_context(const struct polydir_s *polyptr,\n\t\tchar **i_context, char **origcon,\n\t\tstruct instance_data *idata)\n{\n\tint rc = PAM_SUCCESS;\n\tchar *scon = NULL;\n\tsecurity_class_t tclass;\n\n\t/*\n\t * Get the security context of the directory to polyinstantiate.\n\t */\n\trc = getfilecon(polyptr->dir, origcon);\n\tif (rc < 0 || *origcon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Error getting poly dir context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->method == USER) return PAM_SUCCESS;\n\n\tif (idata->flags & PAMNS_USE_CURRENT_CONTEXT) {\n\t\trc = getcon(&scon);\n\t} else if (idata->flags & PAMNS_USE_DEFAULT_CONTEXT) {\n\t\tchar *seuser = NULL, *level = NULL;\n\n\t\tif ((rc=getseuserbyname(idata->user, &seuser, &level)) == 0) {\n\t\t\trc = get_default_context_with_level(seuser, level, NULL, &scon);\n\t\t\tfree(seuser);\n\t\t\tfree(level);\n\t\t}\n\t} else {\n\t\trc = getexeccon(&scon);\n\t}\n\tif (rc < 0 || scon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error getting exec context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security context, get current\n\t * process security context, get security class for directories,\n\t * and ask the policy to provide security context of the\n\t * polyinstantiated instance directory.\n\t */\n\n\tif (polyptr->method == CONTEXT) {\n\t\ttclass = string_to_security_class(\"dir\");\n\t\tif (tclass == 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t   \"Error getting dir security class\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\n\t\tif (security_compute_member(scon, *origcon, tclass,\n\t\t\t\t\ti_context) < 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\"Error computing poly dir member context\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else if (idata->flags & PAMNS_DEBUG)\n\t\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\t\t\"member context returned by policy %s\", *i_context);\n\t\tfreecon(scon);\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security level, get current\n\t * process security context, get security class for directories,\n\t * and change the directories MLS Level to match process.\n\t */\n\n\tif (polyptr->method == LEVEL) {\n\t\tcontext_t scontext = NULL;\n\t\tcontext_t fcontext = NULL;\n\t\trc = PAM_SESSION_ERR;\n\n\t\tscontext = context_new(scon);\n\t\tif (! scontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tfcontext = context_new(*origcon);\n\t\tif (! fcontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (context_range_set(fcontext, context_range_get(scontext)) != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set MLS Component of context\");\n\t\t\tgoto fail;\n\t\t}\n\t\t*i_context=strdup(context_str(fcontext));\n\t\tif (! *i_context) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\trc = PAM_SUCCESS;\n fail:\n\t\tcontext_free(scontext);\n\t\tcontext_free(fcontext);\n\t\tfreecon(scon);\n\t\treturn rc;\n\t}\n\t/* Should never get here */\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "fcontext"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "scontext"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "context_str(fcontext)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_str",
          "args": [
            "fcontext"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unable to set MLS Component of context\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_set",
          "args": [
            "fcontext",
            "context_range_get(scontext)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "scontext"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "*origcon"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "scon"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"member context returned by policy %s\"",
            "*i_context"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error computing poly dir member context\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_compute_member",
          "args": [
            "scon",
            "*origcon",
            "tclass",
            "i_context"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting dir security class\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_to_security_class",
          "args": [
            "\"dir\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting exec context, %m\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getexeccon",
          "args": [
            "&scon"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "level"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_default_context_with_level",
          "args": [
            "seuser",
            "level",
            "NULL",
            "&scon"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getseuserbyname",
          "args": [
            "idata->user",
            "&seuser",
            "&level"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcon",
          "args": [
            "&scon"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting poly dir context, %m\""
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getfilecon",
          "args": [
            "polyptr->dir",
            "origcon"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int form_context(const struct polydir_s *polyptr,\n\t\tchar **i_context, char **origcon,\n\t\tstruct instance_data *idata)\n{\n\tint rc = PAM_SUCCESS;\n\tchar *scon = NULL;\n\tsecurity_class_t tclass;\n\n\t/*\n\t * Get the security context of the directory to polyinstantiate.\n\t */\n\trc = getfilecon(polyptr->dir, origcon);\n\tif (rc < 0 || *origcon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Error getting poly dir context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->method == USER) return PAM_SUCCESS;\n\n\tif (idata->flags & PAMNS_USE_CURRENT_CONTEXT) {\n\t\trc = getcon(&scon);\n\t} else if (idata->flags & PAMNS_USE_DEFAULT_CONTEXT) {\n\t\tchar *seuser = NULL, *level = NULL;\n\n\t\tif ((rc=getseuserbyname(idata->user, &seuser, &level)) == 0) {\n\t\t\trc = get_default_context_with_level(seuser, level, NULL, &scon);\n\t\t\tfree(seuser);\n\t\t\tfree(level);\n\t\t}\n\t} else {\n\t\trc = getexeccon(&scon);\n\t}\n\tif (rc < 0 || scon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error getting exec context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security context, get current\n\t * process security context, get security class for directories,\n\t * and ask the policy to provide security context of the\n\t * polyinstantiated instance directory.\n\t */\n\n\tif (polyptr->method == CONTEXT) {\n\t\ttclass = string_to_security_class(\"dir\");\n\t\tif (tclass == 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t   \"Error getting dir security class\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\n\t\tif (security_compute_member(scon, *origcon, tclass,\n\t\t\t\t\ti_context) < 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\"Error computing poly dir member context\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else if (idata->flags & PAMNS_DEBUG)\n\t\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\t\t\"member context returned by policy %s\", *i_context);\n\t\tfreecon(scon);\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security level, get current\n\t * process security context, get security class for directories,\n\t * and change the directories MLS Level to match process.\n\t */\n\n\tif (polyptr->method == LEVEL) {\n\t\tcontext_t scontext = NULL;\n\t\tcontext_t fcontext = NULL;\n\t\trc = PAM_SESSION_ERR;\n\n\t\tscontext = context_new(scon);\n\t\tif (! scontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tfcontext = context_new(*origcon);\n\t\tif (! fcontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (context_range_set(fcontext, context_range_get(scontext)) != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set MLS Component of context\");\n\t\t\tgoto fail;\n\t\t}\n\t\t*i_context=strdup(context_str(fcontext));\n\t\tif (! *i_context) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\trc = PAM_SUCCESS;\n fail:\n\t\tcontext_free(scontext);\n\t\tcontext_free(fcontext);\n\t\tfreecon(scon);\n\t\treturn rc;\n\t}\n\t/* Should never get here */\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "md5hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "771-796",
    "snippet": "static char *md5hash(const char *instname, struct instance_data *idata)\n{\n    int i;\n    char *md5inst = NULL;\n    char *to;\n    unsigned char inst_digest[MD5_DIGEST_LENGTH];\n\n    /*\n     * Create MD5 hashes for instance pathname.\n     */\n\n    MD5((const unsigned char *)instname, strlen(instname), inst_digest);\n\n    if ((md5inst = malloc(MD5_DIGEST_LENGTH * 2 + 1)) == NULL) {\n        pam_syslog(idata->pamh, LOG_CRIT, \"Unable to allocate buffer\");\n        return NULL;\n    }\n\n    to = md5inst;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        snprintf(to, 3, \"%02x\", (unsigned int)inst_digest[i]);\n        to += 2;\n    }\n\n    return md5inst;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "to",
            "3",
            "\"%02x\"",
            "(unsigned int)inst_digest[i]"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Unable to allocate buffer\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "MD5_DIGEST_LENGTH * 2 + 1"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MD5",
          "args": [
            "(const unsigned char *)instname",
            "strlen(instname)",
            "inst_digest"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/md5.c",
          "lines": "255-261",
          "snippet": "void MD5Name(MD5)(unsigned const char *buf, unsigned len, unsigned char digest[16])\n{\n\tstruct MD5Context ctx;\n\tMD5Name(MD5Init)(&ctx);\n\tMD5Name(MD5Update)(&ctx, buf, len);\n\tMD5Name(MD5Final)(digest, &ctx);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"md5.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"md5.h\"\n\nvoid MD5Name(MD5)(unsigned const char *buf, unsigned len, unsigned char digest[16])\n{\n\tstruct MD5Context ctx;\n\tMD5Name(MD5Init)(&ctx);\n\tMD5Name(MD5Update)(&ctx, buf, len);\n\tMD5Name(MD5Final)(digest, &ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "instname"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic char *md5hash(const char *instname, struct instance_data *idata)\n{\n    int i;\n    char *md5inst = NULL;\n    char *to;\n    unsigned char inst_digest[MD5_DIGEST_LENGTH];\n\n    /*\n     * Create MD5 hashes for instance pathname.\n     */\n\n    MD5((const unsigned char *)instname, strlen(instname), inst_digest);\n\n    if ((md5inst = malloc(MD5_DIGEST_LENGTH * 2 + 1)) == NULL) {\n        pam_syslog(idata->pamh, LOG_CRIT, \"Unable to allocate buffer\");\n        return NULL;\n    }\n\n    to = md5inst;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        snprintf(to, 3, \"%02x\", (unsigned int)inst_digest[i]);\n        to += 2;\n    }\n\n    return md5inst;\n}"
  },
  {
    "function_name": "ns_override",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "749-766",
    "snippet": "static int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Checking for ns override in dir %s for uid %d\"",
            "polyptr->dir",
            "uid"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}"
  },
  {
    "function_name": "parse_config_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "618-739",
    "snippet": "static int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    glob_t globbuf;\n    const char *oldlocale;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    memset(&globbuf, '\\0', sizeof(globbuf));\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob(NAMESPACE_D_GLOB, 0, NULL, &globbuf);\n    if (oldlocale != NULL)\n\tsetlocale(LC_COLLATE, oldlocale);\n\n    confname = PAM_NAMESPACE_CONFIG;\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n            globfree(&globbuf);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        globfree(&globbuf);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (n >= globbuf.gl_pathc)\n\t    break;\n\n\tconfname = globbuf.gl_pathv[n];\n\tn++;\n    }\n\n    globfree(&globbuf);\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"override user %d \"",
            "*iptr"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"dir='%s' iprefix='%s' meth=%d\"",
            "dptr->dir",
            "dptr->instance_prefix",
            "dptr->method"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "dptr?\"Configured poly dirs:\":\"No configured poly dirs\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "home"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fil"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fil"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error processing conf file %s line %s\"",
            "confname",
            "line"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_line",
          "args": [
            "line",
            "home",
            "rhome",
            "idata"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "process_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "383-609",
          "snippet": "static int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    int len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace(*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        instance_prefix = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (strlen(dir) >= sizeof(poly->dir)\n        || strlen(rdir) >= sizeof(poly->rdir)\n\t|| strlen(instance_prefix) >= sizeof(poly->instance_prefix)) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n    strcpy(poly->dir, dir);\n    strcpy(poly->rdir, rdir);\n    strcpy(poly->instance_prefix, instance_prefix);\n\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n    if (poly->method == TMPDIR) {\n\tif (sizeof(poly->instance_prefix) - strlen(poly->instance_prefix) < 7) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\t\tgoto skipping;\n\t}\n\tstrcat(poly->instance_prefix, \"XXXXXX\");\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        int count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        poly->num_uids = count;\n        poly->uid = (uid_t *) malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    int len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace(*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        instance_prefix = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (strlen(dir) >= sizeof(poly->dir)\n        || strlen(rdir) >= sizeof(poly->rdir)\n\t|| strlen(instance_prefix) >= sizeof(poly->instance_prefix)) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n    strcpy(poly->dir, dir);\n    strcpy(poly->rdir, rdir);\n    strcpy(poly->instance_prefix, instance_prefix);\n\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n    if (poly->method == TMPDIR) {\n\tif (sizeof(poly->instance_prefix) - strlen(poly->instance_prefix) < 7) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\t\tgoto skipping;\n\t}\n\tstrcat(poly->instance_prefix, \"XXXXXX\");\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        int count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        poly->num_uids = count;\n        poly->uid = (uid_t *) malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "fil"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fsetlocking",
          "args": [
            "fil",
            "FSETLOCKING_BYCALLER"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error opening config file %s\"",
            "confname"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "confname",
            "\"r\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Parsing config file %s\"",
            "confname"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "oldlocale"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "NAMESPACE_D_GLOB",
            "0",
            "NULL",
            "&globbuf"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_COLLATE",
            "\"C\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&globbuf",
            "'\\0'",
            "sizeof(globbuf)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cpwd->pw_dir"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting home dir for '%s'\"",
            "idata->ruser"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "idata->pamh",
            "idata->ruser"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cpwd->pw_dir"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Error getting home dir for '%s'\"",
            "idata->user"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "idata->pamh",
            "idata->user"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    glob_t globbuf;\n    const char *oldlocale;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    memset(&globbuf, '\\0', sizeof(globbuf));\n    oldlocale = setlocale(LC_COLLATE, \"C\");\n    glob(NAMESPACE_D_GLOB, 0, NULL, &globbuf);\n    if (oldlocale != NULL)\n\tsetlocale(LC_COLLATE, oldlocale);\n\n    confname = PAM_NAMESPACE_CONFIG;\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n            globfree(&globbuf);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        globfree(&globbuf);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (n >= globbuf.gl_pathc)\n\t    break;\n\n\tconfname = globbuf.gl_pathv[n];\n\tn++;\n    }\n\n    globfree(&globbuf);\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "process_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "383-609",
    "snippet": "static int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    int len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace(*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        instance_prefix = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (strlen(dir) >= sizeof(poly->dir)\n        || strlen(rdir) >= sizeof(poly->rdir)\n\t|| strlen(instance_prefix) >= sizeof(poly->instance_prefix)) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n    strcpy(poly->dir, dir);\n    strcpy(poly->rdir, rdir);\n    strcpy(poly->instance_prefix, instance_prefix);\n\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n    if (poly->method == TMPDIR) {\n\tif (sizeof(poly->instance_prefix) - strlen(poly->instance_prefix) < 7) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\t\tgoto skipping;\n\t}\n\tstrcat(poly->instance_prefix, \"XXXXXX\");\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        int count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        poly->num_uids = count;\n        poly->uid = (uid_t *) malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "config_options"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_polydir",
          "args": [
            "poly"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "del_polydir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "77-86",
          "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_polydir_entry",
          "args": [
            "idata",
            "poly"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "add_polydir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "47-62",
          "snippet": "static void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_ERR",
            "\"Unknown user %s in configuration\"",
            "ustr"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "idata->pamh",
            "ustr"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ustr",
            "','"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "count * sizeof (uid_t)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ustr",
            "','"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Pathnames must not contain '..'\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "poly->instance_prefix",
            "\"..\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dir",
            "\"..\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Pathnames must start with '/'\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "poly->instance_prefix",
            "\"XXXXXX\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Pathnames too long\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "poly->instance_prefix"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_method",
          "args": [
            "method",
            "poly",
            "idata"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "parse_method",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "302-373",
          "snippet": "static int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tint namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tint namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "poly->instance_prefix",
            "instance_prefix"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "poly->rdir",
            "rdir"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "poly->dir",
            "dir"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Pathnames too long\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "instance_prefix"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rdir"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Invalid polydir\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rdir"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Expanded instance prefix: '%s'\"",
            "instance_prefix"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Expanded ruser polydir: '%s'\"",
            "rdir"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_DEBUG",
            "\"Expanded polydir: '%s'\"",
            "dir"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_variables",
          "args": [
            "instance_prefix",
            "var_names",
            "var_values"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "expand_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "111-156",
          "snippet": "static char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Invalid line missing method\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Invalid line missing instance_prefix\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Invalid line missing polydir\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_parse",
          "args": [
            "line",
            "NULL",
            "&config_options"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "argv_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "43-129",
          "snippet": "int argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define STATE_QUOTED\t\t3",
            "#define STATE_TOKEN\t\t2",
            "#define STATE_WHITESPACE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define STATE_QUOTED\t\t3\n#define STATE_TOKEN\t\t2\n#define STATE_WHITESPACE\t1\n\nint argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*poly)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'#'"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*line"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    int len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace(*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        instance_prefix = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (strlen(dir) >= sizeof(poly->dir)\n        || strlen(rdir) >= sizeof(poly->rdir)\n\t|| strlen(instance_prefix) >= sizeof(poly->instance_prefix)) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n    strcpy(poly->dir, dir);\n    strcpy(poly->rdir, rdir);\n    strcpy(poly->instance_prefix, instance_prefix);\n\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n    if (poly->method == TMPDIR) {\n\tif (sizeof(poly->instance_prefix) - strlen(poly->instance_prefix) < 7) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\t\tgoto skipping;\n\t}\n\tstrcat(poly->instance_prefix, \"XXXXXX\");\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        int count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        poly->num_uids = count;\n        poly->uid = (uid_t *) malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}"
  },
  {
    "function_name": "parse_method",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "302-373",
    "snippet": "static int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tint namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_mntopts",
          "args": [
            "flag+namelen+1",
            "&poly->mount_opts",
            "&poly->mount_flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "filter_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "249-300",
          "snippet": "static int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };\n\nstatic int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "poly->mount_opts"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_WARNING",
            "\"Mount options applicable only to tmpfs method\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Memory allocation error\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_iscript_params",
          "args": [
            "flag+namelen",
            "poly"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "parse_iscript_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "216-233",
          "snippet": "static int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_CRIT",
            "\"Invalid create parameters\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_create_params",
          "args": [
            "flag+namelen",
            "poly"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "parse_create_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "158-214",
          "snippet": "static int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "flag",
            "flag_names[i]",
            "namelen"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "flag_names[i]"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&sptr"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "idata->pamh",
            "LOG_NOTICE",
            "\"Unknown method\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "method",
            "method_names[i]"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "method",
            "\":\"",
            "&sptr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tint namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "filter_mntopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "249-300",
    "snippet": "static int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "opts",
            "len"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "origlen + 1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mntflags[i].name",
            "opts",
            "len"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_ARRAY_SIZE",
          "args": [
            "mntflags"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "opts",
            "','"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };\n\nstatic int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}"
  },
  {
    "function_name": "parse_iscript_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "216-233",
    "snippet": "static int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "params"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&poly->init_script",
            "\"%s%s\"",
            "NAMESPACE_D_DIR",
            "params"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "parse_create_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "158-214",
    "snippet": "static int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "params"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "params"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "params",
            "','"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "params",
            "NULL",
            "0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "params",
            "','"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}"
  },
  {
    "function_name": "expand_variables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "111-156",
    "snippet": "static char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stpcpy",
          "args": [
            "dst",
            "var_values[i]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "var_names[i]",
            "src+1",
            "namelen"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_names[i]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dstlen + 1"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_values[i]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "var_names[i]",
            "src+1",
            "namelen"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_names[i]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tint namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}"
  },
  {
    "function_name": "cleanup_protect_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "106-109",
    "snippet": "static void cleanup_protect_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tunprotect_dirs(data);\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unprotect_dirs",
          "args": [
            "data"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "unprotect_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "88-99",
          "snippet": "static void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void cleanup_protect_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tunprotect_dirs(data);\n}"
  },
  {
    "function_name": "cleanup_polydir_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "101-104",
    "snippet": "static void cleanup_polydir_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tdel_polydir_list(data);\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_polydir_list",
          "args": [
            "data"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "del_polydir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "77-86",
          "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
          "includes": [
            "#include \"argv_parse.h\"",
            "#include \"pam_namespace.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void cleanup_polydir_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tdel_polydir_list(data);\n}"
  },
  {
    "function_name": "unprotect_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "88-99",
    "snippet": "static void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dir"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "dir->dir"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}"
  },
  {
    "function_name": "del_polydir_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "77-86",
    "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_polydir",
          "args": [
            "tptr"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "del_polydir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
          "lines": "77-86",
          "snippet": "static void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}"
  },
  {
    "function_name": "del_polydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "64-72",
    "snippet": "static void del_polydir(struct polydir_s *poly)\n{\n\tif (poly) {\n\t\tfree(poly->uid);\n\t\tfree(poly->init_script);\n\t\tfree(poly->mount_opts);\n\t\tfree(poly);\n\t}\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "poly"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void del_polydir(struct polydir_s *poly)\n{\n\tif (poly) {\n\t\tfree(poly->uid);\n\t\tfree(poly->init_script);\n\t\tfree(poly->mount_opts);\n\t\tfree(poly);\n\t}\n}"
  },
  {
    "function_name": "add_polydir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/pam_namespace.c",
    "lines": "47-62",
    "snippet": "static void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}",
    "includes": [
      "#include \"argv_parse.h\"",
      "#include \"pam_namespace.h\"",
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"argv_parse.h\"\n#include \"pam_namespace.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n\nstatic void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}"
  }
]