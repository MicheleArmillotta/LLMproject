[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "262-267",
    "snippet": "int\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_close_session(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "256-260",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\treturn _pam_loginuid(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_loginuid",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\treturn _pam_loginuid(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "250-254",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\treturn _pam_loginuid(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_loginuid",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\treturn _pam_loginuid(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "_pam_loginuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "189-243",
    "snippet": "static int\n_pam_loginuid(pam_handle_t *pamh, int flags UNUSED,\n#ifdef HAVE_LIBAUDIT\n\t      int argc, const char **argv\n#else\n\t      int argc UNUSED, const char **argv UNUSED\n#endif\n)\n{\n        const char *user = NULL;\n\tstruct passwd *pwd;\n\tint ret;\n#ifdef HAVE_LIBAUDIT\n\tint require_auditd = 0;\n#endif\n\n\t/* get user name */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n        /* get user info */\n\tif ((pwd = pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t \"error: login user-name '%s' does not exist\", user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tret = set_loginuid(pamh, pwd->pw_uid);\n\tswitch (ret) {\n\t\tcase PAM_SUCCESS:\n\t\tcase PAM_IGNORE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpam_syslog(pamh, LOG_ERR, \"set_loginuid failed\");\n\t\t\treturn ret;\n\t}\n\n#ifdef HAVE_LIBAUDIT\n\twhile (argc-- > 0) {\n\t\tif (strcmp(*argv, \"require_auditd\") == 0)\n\t\t\trequire_auditd = 1;\n\t\targv++;\n\t}\n\n\tif (require_auditd) {\n\t\tint rc = check_auditd();\n\t\tif (rc != PAM_SUCCESS)\n\t\t\tpam_syslog(pamh, LOG_ERR, \"required running auditd not detected\");\n\t\treturn rc != PAM_SUCCESS ? rc : ret;\n\t} else\n#endif\n\t\treturn ret;\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"required running auditd not detected\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_auditd",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "check_auditd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
          "lines": "112-183",
          "snippet": "static int check_auditd(void)\n{\n\tint fd, retval;\n\n\tfd = audit_open();\n\tif (fd < 0) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. You get these error\n\t\t   codes only when the kernel doesn't have audit\n\t\t   compiled in. */\n\t\tif (errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t    errno == EAFNOSUPPORT)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tretval = audit_request_status(fd);\n\tif (retval > 0) {\n\t\tstruct audit_reply rep;\n\t\tint i;\n\t\tint timeout = 30; /* tenths of seconds */\n\t\tfd_set read_mask;\n\n\t\tFD_ZERO(&read_mask);\n\t\tFD_SET(fd, &read_mask);\n\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tstruct timeval t;\n\t\t\tint rc;\n\n\t\t\tt.tv_sec  = 0;\n\t\t\tt.tv_usec = 100000;\n\t\t\tdo {\n\t\t\t\trc = select(fd+1, &read_mask, NULL, NULL, &t);\n\t\t\t} while (rc < 0 && errno == EINTR);\n\n\t\t\trc = audit_get_reply(fd, &rep, GET_REPLY_NONBLOCKING,0);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* If we get done or error, break out */\n\t\t\t\tif (rep.type == NLMSG_DONE ||\n\t\t\t\t\t\trep.type == NLMSG_ERROR)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* If its not status, keep looping */\n\t\t\t\tif (rep.type != AUDIT_GET)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Found it... */\n\t\t\t\tclose(fd);\n\t\t\t\tif (rep.status->pid == 0)\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\telse\n\t\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fd);\n\tif (retval == -ECONNREFUSED) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. ECONNREFUSED is\n\t\t   issued by the kernel when there is \"no on listening\". */\n\t\treturn PAM_SUCCESS;\n\t} else if (retval == -EPERM && getuid() != 0) {\n\t\t/* If we get this, then the kernel supports auditing\n\t\t * but we don't have enough privilege to write to the\n\t\t * socket. Therefore, we have already been authenticated\n\t\t * and we are a common user. Just act as though auditing\n\t\t * is not enabled. Any other error we take seriously. */\n\t\treturn PAM_SUCCESS;\n\t}\n\n\treturn PAM_SESSION_ERR;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <fcntl.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int check_auditd(void)\n{\n\tint fd, retval;\n\n\tfd = audit_open();\n\tif (fd < 0) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. You get these error\n\t\t   codes only when the kernel doesn't have audit\n\t\t   compiled in. */\n\t\tif (errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t    errno == EAFNOSUPPORT)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tretval = audit_request_status(fd);\n\tif (retval > 0) {\n\t\tstruct audit_reply rep;\n\t\tint i;\n\t\tint timeout = 30; /* tenths of seconds */\n\t\tfd_set read_mask;\n\n\t\tFD_ZERO(&read_mask);\n\t\tFD_SET(fd, &read_mask);\n\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tstruct timeval t;\n\t\t\tint rc;\n\n\t\t\tt.tv_sec  = 0;\n\t\t\tt.tv_usec = 100000;\n\t\t\tdo {\n\t\t\t\trc = select(fd+1, &read_mask, NULL, NULL, &t);\n\t\t\t} while (rc < 0 && errno == EINTR);\n\n\t\t\trc = audit_get_reply(fd, &rep, GET_REPLY_NONBLOCKING,0);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* If we get done or error, break out */\n\t\t\t\tif (rep.type == NLMSG_DONE ||\n\t\t\t\t\t\trep.type == NLMSG_ERROR)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* If its not status, keep looping */\n\t\t\t\tif (rep.type != AUDIT_GET)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Found it... */\n\t\t\t\tclose(fd);\n\t\t\t\tif (rep.status->pid == 0)\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\telse\n\t\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fd);\n\tif (retval == -ECONNREFUSED) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. ECONNREFUSED is\n\t\t   issued by the kernel when there is \"no on listening\". */\n\t\treturn PAM_SUCCESS;\n\t} else if (retval == -EPERM && getuid() != 0) {\n\t\t/* If we get this, then the kernel supports auditing\n\t\t * but we don't have enough privilege to write to the\n\t\t * socket. Therefore, we have already been authenticated\n\t\t * and we are a common user. Just act as though auditing\n\t\t * is not enabled. Any other error we take seriously. */\n\t\treturn PAM_SUCCESS;\n\t}\n\n\treturn PAM_SESSION_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"require_auditd\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"set_loginuid failed\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_loginuid",
          "args": [
            "pamh",
            "pwd->pw_uid"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "set_loginuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
          "lines": "55-103",
          "snippet": "static int set_loginuid(pam_handle_t *pamh, uid_t uid)\n{\n\tint fd, count, rc = PAM_SESSION_ERR;\n\tchar loginuid[24], buf[24];\n\tstatic const char host_uid_map[] = \"         0          0 4294967295\\n\";\n\tchar uid_map[sizeof(host_uid_map)];\n\n\t/* loginuid in user namespaces currently isn't writable and in some\n\t   case, not even readable, so consider any failure as ignorable (but try\n\t   anyway, in case we hit a kernel which supports it). */\n\tfd = open(\"/proc/self/uid_map\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tcount = pam_modutil_read(fd, uid_map, sizeof(uid_map));\n\t\tif (count <= 0 || strncmp(uid_map, host_uid_map, count) != 0)\n\t\t\trc = PAM_IGNORE;\n\t\tclose(fd);\n\t}\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDWR);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\trc = PAM_IGNORE;\n\t\t}\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t\treturn rc;\n\t}\n\n\tcount = snprintf(loginuid, sizeof(loginuid), \"%lu\", (unsigned long)uid);\n\tif (pam_modutil_read(fd, buf, sizeof(buf)) == count &&\n\t    memcmp(buf, loginuid, count) == 0) {\n\t\trc = PAM_SUCCESS;\n\t\tgoto done;\t/* already correct */\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == 0 && ftruncate(fd, 0) == 0 &&\n\t    pam_modutil_write(fd, loginuid, count) == count) {\n\t\trc = PAM_SUCCESS;\n\t} else {\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error writing %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t}\n done:\n\tclose(fd);\n\treturn rc;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <fcntl.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <syslog.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int set_loginuid(pam_handle_t *pamh, uid_t uid)\n{\n\tint fd, count, rc = PAM_SESSION_ERR;\n\tchar loginuid[24], buf[24];\n\tstatic const char host_uid_map[] = \"         0          0 4294967295\\n\";\n\tchar uid_map[sizeof(host_uid_map)];\n\n\t/* loginuid in user namespaces currently isn't writable and in some\n\t   case, not even readable, so consider any failure as ignorable (but try\n\t   anyway, in case we hit a kernel which supports it). */\n\tfd = open(\"/proc/self/uid_map\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tcount = pam_modutil_read(fd, uid_map, sizeof(uid_map));\n\t\tif (count <= 0 || strncmp(uid_map, host_uid_map, count) != 0)\n\t\t\trc = PAM_IGNORE;\n\t\tclose(fd);\n\t}\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDWR);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\trc = PAM_IGNORE;\n\t\t}\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t\treturn rc;\n\t}\n\n\tcount = snprintf(loginuid, sizeof(loginuid), \"%lu\", (unsigned long)uid);\n\tif (pam_modutil_read(fd, buf, sizeof(buf)) == count &&\n\t    memcmp(buf, loginuid, count) == 0) {\n\t\trc = PAM_SUCCESS;\n\t\tgoto done;\t/* already correct */\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == 0 && ftruncate(fd, 0) == 0 &&\n\t    pam_modutil_write(fd, loginuid, count) == count) {\n\t\trc = PAM_SUCCESS;\n\t} else {\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error writing %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t}\n done:\n\tclose(fd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"error: login user-name '%s' does not exist\"",
            "user"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\n_pam_loginuid(pam_handle_t *pamh, int flags UNUSED,\n#ifdef HAVE_LIBAUDIT\n\t      int argc, const char **argv\n#else\n\t      int argc UNUSED, const char **argv UNUSED\n#endif\n)\n{\n        const char *user = NULL;\n\tstruct passwd *pwd;\n\tint ret;\n#ifdef HAVE_LIBAUDIT\n\tint require_auditd = 0;\n#endif\n\n\t/* get user name */\n\tif (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n        /* get user info */\n\tif ((pwd = pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t \"error: login user-name '%s' does not exist\", user);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tret = set_loginuid(pamh, pwd->pw_uid);\n\tswitch (ret) {\n\t\tcase PAM_SUCCESS:\n\t\tcase PAM_IGNORE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpam_syslog(pamh, LOG_ERR, \"set_loginuid failed\");\n\t\t\treturn ret;\n\t}\n\n#ifdef HAVE_LIBAUDIT\n\twhile (argc-- > 0) {\n\t\tif (strcmp(*argv, \"require_auditd\") == 0)\n\t\t\trequire_auditd = 1;\n\t\targv++;\n\t}\n\n\tif (require_auditd) {\n\t\tint rc = check_auditd();\n\t\tif (rc != PAM_SUCCESS)\n\t\t\tpam_syslog(pamh, LOG_ERR, \"required running auditd not detected\");\n\t\treturn rc != PAM_SUCCESS ? rc : ret;\n\t} else\n#endif\n\t\treturn ret;\n}"
  },
  {
    "function_name": "check_auditd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "112-183",
    "snippet": "static int check_auditd(void)\n{\n\tint fd, retval;\n\n\tfd = audit_open();\n\tif (fd < 0) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. You get these error\n\t\t   codes only when the kernel doesn't have audit\n\t\t   compiled in. */\n\t\tif (errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t    errno == EAFNOSUPPORT)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tretval = audit_request_status(fd);\n\tif (retval > 0) {\n\t\tstruct audit_reply rep;\n\t\tint i;\n\t\tint timeout = 30; /* tenths of seconds */\n\t\tfd_set read_mask;\n\n\t\tFD_ZERO(&read_mask);\n\t\tFD_SET(fd, &read_mask);\n\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tstruct timeval t;\n\t\t\tint rc;\n\n\t\t\tt.tv_sec  = 0;\n\t\t\tt.tv_usec = 100000;\n\t\t\tdo {\n\t\t\t\trc = select(fd+1, &read_mask, NULL, NULL, &t);\n\t\t\t} while (rc < 0 && errno == EINTR);\n\n\t\t\trc = audit_get_reply(fd, &rep, GET_REPLY_NONBLOCKING,0);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* If we get done or error, break out */\n\t\t\t\tif (rep.type == NLMSG_DONE ||\n\t\t\t\t\t\trep.type == NLMSG_ERROR)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* If its not status, keep looping */\n\t\t\t\tif (rep.type != AUDIT_GET)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Found it... */\n\t\t\t\tclose(fd);\n\t\t\t\tif (rep.status->pid == 0)\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\telse\n\t\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fd);\n\tif (retval == -ECONNREFUSED) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. ECONNREFUSED is\n\t\t   issued by the kernel when there is \"no on listening\". */\n\t\treturn PAM_SUCCESS;\n\t} else if (retval == -EPERM && getuid() != 0) {\n\t\t/* If we get this, then the kernel supports auditing\n\t\t * but we don't have enough privilege to write to the\n\t\t * socket. Therefore, we have already been authenticated\n\t\t * and we are a common user. Just act as though auditing\n\t\t * is not enabled. Any other error we take seriously. */\n\t\treturn PAM_SUCCESS;\n\t}\n\n\treturn PAM_SESSION_ERR;\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_reply",
          "args": [
            "fd",
            "&rep",
            "GET_REPLY_NONBLOCKING",
            "0"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd+1",
            "&read_mask",
            "NULL",
            "NULL",
            "&t"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "&read_mask"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&read_mask"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_request_status",
          "args": [
            "fd"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_open",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int check_auditd(void)\n{\n\tint fd, retval;\n\n\tfd = audit_open();\n\tif (fd < 0) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. You get these error\n\t\t   codes only when the kernel doesn't have audit\n\t\t   compiled in. */\n\t\tif (errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t    errno == EAFNOSUPPORT)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tretval = audit_request_status(fd);\n\tif (retval > 0) {\n\t\tstruct audit_reply rep;\n\t\tint i;\n\t\tint timeout = 30; /* tenths of seconds */\n\t\tfd_set read_mask;\n\n\t\tFD_ZERO(&read_mask);\n\t\tFD_SET(fd, &read_mask);\n\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tstruct timeval t;\n\t\t\tint rc;\n\n\t\t\tt.tv_sec  = 0;\n\t\t\tt.tv_usec = 100000;\n\t\t\tdo {\n\t\t\t\trc = select(fd+1, &read_mask, NULL, NULL, &t);\n\t\t\t} while (rc < 0 && errno == EINTR);\n\n\t\t\trc = audit_get_reply(fd, &rep, GET_REPLY_NONBLOCKING,0);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* If we get done or error, break out */\n\t\t\t\tif (rep.type == NLMSG_DONE ||\n\t\t\t\t\t\trep.type == NLMSG_ERROR)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* If its not status, keep looping */\n\t\t\t\tif (rep.type != AUDIT_GET)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Found it... */\n\t\t\t\tclose(fd);\n\t\t\t\tif (rep.status->pid == 0)\n\t\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t\telse\n\t\t\t\t\treturn PAM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fd);\n\tif (retval == -ECONNREFUSED) {\n\t\t/* This is here to let people that build their own kernel\n\t\t   and disable the audit system get in. ECONNREFUSED is\n\t\t   issued by the kernel when there is \"no on listening\". */\n\t\treturn PAM_SUCCESS;\n\t} else if (retval == -EPERM && getuid() != 0) {\n\t\t/* If we get this, then the kernel supports auditing\n\t\t * but we don't have enough privilege to write to the\n\t\t * socket. Therefore, we have already been authenticated\n\t\t * and we are a common user. Just act as though auditing\n\t\t * is not enabled. Any other error we take seriously. */\n\t\treturn PAM_SUCCESS;\n\t}\n\n\treturn PAM_SESSION_ERR;\n}"
  },
  {
    "function_name": "set_loginuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_loginuid/pam_loginuid.c",
    "lines": "55-103",
    "snippet": "static int set_loginuid(pam_handle_t *pamh, uid_t uid)\n{\n\tint fd, count, rc = PAM_SESSION_ERR;\n\tchar loginuid[24], buf[24];\n\tstatic const char host_uid_map[] = \"         0          0 4294967295\\n\";\n\tchar uid_map[sizeof(host_uid_map)];\n\n\t/* loginuid in user namespaces currently isn't writable and in some\n\t   case, not even readable, so consider any failure as ignorable (but try\n\t   anyway, in case we hit a kernel which supports it). */\n\tfd = open(\"/proc/self/uid_map\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tcount = pam_modutil_read(fd, uid_map, sizeof(uid_map));\n\t\tif (count <= 0 || strncmp(uid_map, host_uid_map, count) != 0)\n\t\t\trc = PAM_IGNORE;\n\t\tclose(fd);\n\t}\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDWR);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\trc = PAM_IGNORE;\n\t\t}\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t\treturn rc;\n\t}\n\n\tcount = snprintf(loginuid, sizeof(loginuid), \"%lu\", (unsigned long)uid);\n\tif (pam_modutil_read(fd, buf, sizeof(buf)) == count &&\n\t    memcmp(buf, loginuid, count) == 0) {\n\t\trc = PAM_SUCCESS;\n\t\tgoto done;\t/* already correct */\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == 0 && ftruncate(fd, 0) == 0 &&\n\t    pam_modutil_write(fd, loginuid, count) == count) {\n\t\trc = PAM_SUCCESS;\n\t} else {\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error writing %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t}\n done:\n\tclose(fd);\n\treturn rc;\n}",
    "includes": [
      "#include <sys/select.h>",
      "#include <libaudit.h>",
      "#include <fcntl.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <errno.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <syslog.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error writing %s: %m\"",
            "\"/proc/self/loginuid\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fd",
            "loginuid",
            "count"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "0",
            "SEEK_SET"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "loginuid",
            "count"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "loginuid",
            "sizeof(loginuid)",
            "\"%lu\"",
            "(unsigned long)uid"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot open %s: %m\"",
            "\"/proc/self/loginuid\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc/self/loginuid\"",
            "O_NOFOLLOW|O_RDWR"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "uid_map",
            "host_uid_map",
            "count"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "uid_map",
            "sizeof(uid_map)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/proc/self/uid_map\"",
            "O_RDONLY"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <fcntl.h>\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <errno.h>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int set_loginuid(pam_handle_t *pamh, uid_t uid)\n{\n\tint fd, count, rc = PAM_SESSION_ERR;\n\tchar loginuid[24], buf[24];\n\tstatic const char host_uid_map[] = \"         0          0 4294967295\\n\";\n\tchar uid_map[sizeof(host_uid_map)];\n\n\t/* loginuid in user namespaces currently isn't writable and in some\n\t   case, not even readable, so consider any failure as ignorable (but try\n\t   anyway, in case we hit a kernel which supports it). */\n\tfd = open(\"/proc/self/uid_map\", O_RDONLY);\n\tif (fd >= 0) {\n\t\tcount = pam_modutil_read(fd, uid_map, sizeof(uid_map));\n\t\tif (count <= 0 || strncmp(uid_map, host_uid_map, count) != 0)\n\t\t\trc = PAM_IGNORE;\n\t\tclose(fd);\n\t}\n\n\tfd = open(\"/proc/self/loginuid\", O_NOFOLLOW|O_RDWR);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\trc = PAM_IGNORE;\n\t\t}\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Cannot open %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t\treturn rc;\n\t}\n\n\tcount = snprintf(loginuid, sizeof(loginuid), \"%lu\", (unsigned long)uid);\n\tif (pam_modutil_read(fd, buf, sizeof(buf)) == count &&\n\t    memcmp(buf, loginuid, count) == 0) {\n\t\trc = PAM_SUCCESS;\n\t\tgoto done;\t/* already correct */\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == 0 && ftruncate(fd, 0) == 0 &&\n\t    pam_modutil_write(fd, loginuid, count) == count) {\n\t\trc = PAM_SUCCESS;\n\t} else {\n\t\tif (rc != PAM_IGNORE) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error writing %s: %m\",\n\t\t\t\t   \"/proc/self/loginuid\");\n\t\t}\n\t}\n done:\n\tclose(fd);\n\treturn rc;\n}"
  }
]