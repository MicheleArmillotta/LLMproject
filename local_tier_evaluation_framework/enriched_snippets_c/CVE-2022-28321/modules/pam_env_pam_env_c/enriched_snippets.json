[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "888-894",
    "snippet": "int\npam_sm_chauthtok (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n  pam_syslog (pamh, LOG_NOTICE, \"pam_sm_chauthtok called inappropriately\");\n  return PAM_SERVICE_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"pam_sm_chauthtok called inappropriately\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_chauthtok (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n  pam_syslog (pamh, LOG_NOTICE, \"pam_sm_chauthtok called inappropriately\");\n  return PAM_SERVICE_ERR;\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "880-886",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  D((\"Called and Exit\"));\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Called and Exit\")"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  D((\"Called and Exit\"));\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "872-878",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  D((\"Called\"));\n  return handle_env (pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_env",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "handle_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "792-854",
          "snippet": "static int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_USER_READ_ENVFILE 0",
            "#define DEFAULT_READ_ENVFILE    1"
          ],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define DEFAULT_USER_READ_ENVFILE 0\n#define DEFAULT_READ_ENVFILE    1\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Called\")"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n  D((\"Called\"));\n  return handle_env (pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "864-870",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh, int flags UNUSED,\n\t\tint argc, const char **argv)\n{\n  D((\"Called\"));\n  return handle_env (pamh, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_env",
          "args": [
            "pamh",
            "argc",
            "argv"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "handle_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "792-854",
          "snippet": "static int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_USER_READ_ENVFILE 0",
            "#define DEFAULT_READ_ENVFILE    1"
          ],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define DEFAULT_USER_READ_ENVFILE 0\n#define DEFAULT_READ_ENVFILE    1\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Called\")"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_setcred (pam_handle_t *pamh, int flags UNUSED,\n\t\tint argc, const char **argv)\n{\n  D((\"Called\"));\n  return handle_env (pamh, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "856-862",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n  pam_syslog (pamh, LOG_NOTICE, \"pam_sm_acct_mgmt called inappropriately\");\n  return PAM_SERVICE_ERR;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"pam_sm_acct_mgmt called inappropriately\""
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t  int argc UNUSED, const char **argv UNUSED)\n{\n  pam_syslog (pamh, LOG_NOTICE, \"pam_sm_acct_mgmt called inappropriately\");\n  return PAM_SERVICE_ERR;\n}"
  },
  {
    "function_name": "handle_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "792-854",
    "snippet": "static int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_USER_READ_ENVFILE 0",
      "#define DEFAULT_READ_ENVFILE    1"
    ],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "envpath"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_regain_priv",
          "args": [
            "pamh",
            "&privs"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parse_config_file",
          "args": [
            "pamh",
            "ctrl",
            "envpath"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "131-186",
          "snippet": "static int\n_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n\n    D((\"Called.\"));\n\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n\n    D((\"Config file name is: %s\", file));\n\n    /*\n     * Lets try to open the config file, parse it and process\n     * any variables found.\n     */\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    /* _pam_assemble_line will provide a complete line from the config file,\n     * with all comments removed and any escaped newlines fixed up\n     */\n\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n\n      _clean_var(var);\n\n    }  /* while */\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    _clean_var(var);        /* We could have got here prematurely,\n\t\t\t     * this is safe though */\n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define ILLEGAL_VAR  103",
            "#define UNDEFINE_VAR 102",
            "#define DEFINE_VAR   101",
            "#define BAD_LINE     100       /* This must be > the largest PAM_* error code */",
            "#define GOOD_LINE    0",
            "#define BUF_SIZE 8192"
          ],
          "globals_used": [
            "static int  _assemble_line(FILE *, char *, int);",
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define ILLEGAL_VAR  103\n#define UNDEFINE_VAR 102\n#define DEFINE_VAR   101\n#define BAD_LINE     100       /* This must be > the largest PAM_* error code */\n#define GOOD_LINE    0\n#define BUF_SIZE 8192\n\nstatic int  _assemble_line(FILE *, char *, int);\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int\n_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n\n    D((\"Called.\"));\n\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n\n    D((\"Config file name is: %s\", file));\n\n    /*\n     * Lets try to open the config file, parse it and process\n     * any variables found.\n     */\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    /* _pam_assemble_line will provide a complete line from the config file,\n     * with all comments removed and any escaped newlines fixed up\n     */\n\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n\n      _clean_var(var);\n\n    }  /* while */\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    _clean_var(var);        /* We could have got here prematurely,\n\t\t\t     * this is safe though */\n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_drop_priv",
          "args": [
            "pamh",
            "&privs",
            "user_entry"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_MODUTIL_DEF_PRIVS",
          "args": [
            "privs"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "envpath",
            "&statbuf"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_debug/pam_debug.c",
          "lines": "24-35",
          "snippet": "static int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}",
          "includes": [
            "#include \"../../libpam/pam_tokens.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../libpam/pam_tokens.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int state(pam_handle_t *pamh, const char *text)\n{\n    int retval;\n\n    retval = pam_info (pamh, \"%s\", text);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"pam_info failed\"));\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Out of memory\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&envpath",
            "\"%s/%s\"",
            "user_entry->pw_dir",
            "user_env_file"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"No such user!?\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "username"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_get_item_byname",
          "args": [
            "pamh",
            "\"PAM_USER\""
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_get_item_byname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "682-728",
          "snippet": "static const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_parse_env_file",
          "args": [
            "pamh",
            "ctrl",
            "env_file"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_env_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "188-283",
          "snippet": "static int\n_parse_env_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval=PAM_SUCCESS, i, t;\n    char buffer[BUF_SIZE], *key, *mark;\n    FILE *conf;\n\n    D((\"Env file name is: %s\", file));\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open env file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    while (_assemble_line(conf, buffer, BUF_SIZE) > 0) {\n\tD((\"Read line: %s\", buffer));\n\tkey = buffer;\n\n\t/* skip leading white space */\n\tkey += strspn(key, \" \\n\\t\");\n\n\t/* skip blanks lines and comments */\n\tif (key[0] == '#')\n\t    continue;\n\n\t/* skip over \"export \" if present so we can be compat with\n\t   bash type declarations */\n\tif (strncmp(key, \"export \", (size_t) 7) == 0)\n\t    key += 7;\n\n\t/* now find the end of value */\n\tmark = key;\n\twhile(mark[0] != '\\n' && mark[0] != '#' && mark[0] != '\\0')\n\t    mark++;\n\tif (mark[0] != '\\0')\n\t    mark[0] = '\\0';\n\n       /*\n\t* sanity check, the key must be alphanumeric\n\t*/\n\n\tif (key[0] == '=') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"missing key name '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tcontinue;\n\t}\n\n\tfor ( i = 0 ; key[i] != '=' && key[i] != '\\0' ; i++ )\n\t    if (!isalnum(key[i]) && key[i] != '_') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"non-alphanumeric key '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tbreak;\n\t    }\n\t/* non-alphanumeric key, ignore this line */\n\tif (key[i] != '=' && key[i] != '\\0')\n\t    continue;\n\n\t/* now we try to be smart about quotes around the value,\n\t   but not too smart, we can't get all fancy with escaped\n\t   values like bash */\n\tif (key[i] == '=' && (key[++i] == '\\\"' || key[i] == '\\'')) {\n\t    for ( t = i+1 ; key[t] != '\\0' ; t++)\n\t\tif (key[t] != '\\\"' && key[t] != '\\'')\n\t\t    key[i++] = key[t];\n\t\telse if (key[t+1] != '\\0')\n\t\t    key[i++] = key[t];\n\t    key[i] = '\\0';\n\t}\n\n\t/* if this is a request to delete a variable, check that it's\n\t   actually set first, so we don't get a vague error back from\n\t   pam_putenv() */\n\tfor (i = 0; key[i] != '=' && key[i] != '\\0'; i++);\n\n\tif (key[i] == '\\0' && !pam_getenv(pamh,key))\n\t    continue;\n\n\t/* set the env var, if it fails, we break out of the loop */\n\tretval = pam_putenv(pamh, key);\n\tif (retval != PAM_SUCCESS) {\n\t    D((\"error setting env \\\"%s\\\"\", key));\n\t    break;\n\t} else if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"pam_putenv(\\\"%s\\\")\", key);\n\t}\n    }\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    D((\"Exit.\"));\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x01",
            "#define BUF_SIZE 8192"
          ],
          "globals_used": [
            "static int  _assemble_line(FILE *, char *, int);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n#define BUF_SIZE 8192\n\nstatic int  _assemble_line(FILE *, char *, int);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\n_parse_env_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval=PAM_SUCCESS, i, t;\n    char buffer[BUF_SIZE], *key, *mark;\n    FILE *conf;\n\n    D((\"Env file name is: %s\", file));\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open env file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    while (_assemble_line(conf, buffer, BUF_SIZE) > 0) {\n\tD((\"Read line: %s\", buffer));\n\tkey = buffer;\n\n\t/* skip leading white space */\n\tkey += strspn(key, \" \\n\\t\");\n\n\t/* skip blanks lines and comments */\n\tif (key[0] == '#')\n\t    continue;\n\n\t/* skip over \"export \" if present so we can be compat with\n\t   bash type declarations */\n\tif (strncmp(key, \"export \", (size_t) 7) == 0)\n\t    key += 7;\n\n\t/* now find the end of value */\n\tmark = key;\n\twhile(mark[0] != '\\n' && mark[0] != '#' && mark[0] != '\\0')\n\t    mark++;\n\tif (mark[0] != '\\0')\n\t    mark[0] = '\\0';\n\n       /*\n\t* sanity check, the key must be alphanumeric\n\t*/\n\n\tif (key[0] == '=') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"missing key name '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tcontinue;\n\t}\n\n\tfor ( i = 0 ; key[i] != '=' && key[i] != '\\0' ; i++ )\n\t    if (!isalnum(key[i]) && key[i] != '_') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"non-alphanumeric key '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tbreak;\n\t    }\n\t/* non-alphanumeric key, ignore this line */\n\tif (key[i] != '=' && key[i] != '\\0')\n\t    continue;\n\n\t/* now we try to be smart about quotes around the value,\n\t   but not too smart, we can't get all fancy with escaped\n\t   values like bash */\n\tif (key[i] == '=' && (key[++i] == '\\\"' || key[i] == '\\'')) {\n\t    for ( t = i+1 ; key[t] != '\\0' ; t++)\n\t\tif (key[t] != '\\\"' && key[t] != '\\'')\n\t\t    key[i++] = key[t];\n\t\telse if (key[t+1] != '\\0')\n\t\t    key[i++] = key[t];\n\t    key[i] = '\\0';\n\t}\n\n\t/* if this is a request to delete a variable, check that it's\n\t   actually set first, so we don't get a vague error back from\n\t   pam_putenv() */\n\tfor (i = 0; key[i] != '=' && key[i] != '\\0'; i++);\n\n\tif (key[i] == '\\0' && !pam_getenv(pamh,key))\n\t    continue;\n\n\t/* set the env var, if it fails, we break out of the loop */\n\tretval = pam_putenv(pamh, key);\n\tif (retval != PAM_SUCCESS) {\n\t    D((\"error setting env \\\"%s\\\"\", key));\n\t    break;\n\t} else if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"pam_putenv(\\\"%s\\\")\", key);\n\t}\n    }\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    D((\"Exit.\"));\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "&conf_file",
            "&env_file",
            "&readenv",
            "&user_env_file",
            "&user_readenv"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "72-129",
          "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = str;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = str;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = str;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"readenv=\")) != NULL) {\n\t  *readenv = atoi(str);\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_readenv=\")) != NULL) {\n\t  *user_readenv = atoi(str);\n\t} else\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (*user_readenv)\n\tpam_syslog(pamh, LOG_DEBUG, \"deprecated reading of user environment enabled\");\n\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x01",
            "#define DEFAULT_CONF_FILE\t(SCONFIGDIR \"/pam_env.conf\")",
            "#define DEFAULT_USER_READ_ENVFILE 0",
            "#define DEFAULT_USER_ENVFILE    \".pam_environment\"",
            "#define DEFAULT_READ_ENVFILE    1",
            "#define DEFAULT_ETC_ENVFILE     \"/etc/environment\""
          ],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n#define DEFAULT_CONF_FILE\t(SCONFIGDIR \"/pam_env.conf\")\n#define DEFAULT_USER_READ_ENVFILE 0\n#define DEFAULT_USER_ENVFILE    \".pam_environment\"\n#define DEFAULT_READ_ENVFILE    1\n#define DEFAULT_ETC_ENVFILE     \"/etc/environment\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = str;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = str;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = str;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"readenv=\")) != NULL) {\n\t  *readenv = atoi(str);\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_readenv=\")) != NULL) {\n\t  *user_readenv = atoi(str);\n\t} else\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (*user_readenv)\n\tpam_syslog(pamh, LOG_DEBUG, \"deprecated reading of user environment enabled\");\n\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define DEFAULT_USER_READ_ENVFILE 0\n#define DEFAULT_READ_ENVFILE    1\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\nhandle_env (pam_handle_t *pamh, int argc, const char **argv)\n{\n  int retval, ctrl, readenv=DEFAULT_READ_ENVFILE;\n  int user_readenv = DEFAULT_USER_READ_ENVFILE;\n  const char *conf_file = NULL, *env_file = NULL, *user_env_file = NULL;\n\n  /*\n   * this module sets environment variables read in from a file\n   */\n\n  D((\"Called.\"));\n  ctrl = _pam_parse(pamh, argc, argv, &conf_file, &env_file,\n\t\t    &readenv, &user_env_file, &user_readenv);\n\n  retval = _parse_config_file(pamh, ctrl, conf_file);\n\n  if(readenv && retval == PAM_SUCCESS) {\n    retval = _parse_env_file(pamh, ctrl, env_file);\n    if (retval == PAM_IGNORE)\n      retval = PAM_SUCCESS;\n  }\n\n  if(user_readenv && retval == PAM_SUCCESS) {\n    char *envpath = NULL;\n    struct passwd *user_entry = NULL;\n    const char *username;\n    struct stat statbuf;\n\n    username = _pam_get_item_byname(pamh, \"PAM_USER\");\n\n    if (username)\n      user_entry = pam_modutil_getpwnam (pamh, username);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n    }\n    else {\n      if (asprintf(&envpath, \"%s/%s\", user_entry->pw_dir, user_env_file) < 0)\n\t{\n\t  pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n\t  return PAM_BUF_ERR;\n\t}\n      if (stat(envpath, &statbuf) == 0) {\n\tPAM_MODUTIL_DEF_PRIVS(privs);\n\n\tif (pam_modutil_drop_priv(pamh, &privs, user_entry)) {\n\t  retval = PAM_SESSION_ERR;\n\t} else {\n\t  retval = _parse_config_file(pamh, ctrl, envpath);\n\t  if (pam_modutil_regain_priv(pamh, &privs))\n\t    retval = PAM_SESSION_ERR;\n\t}\n        if (retval == PAM_IGNORE)\n          retval = PAM_SUCCESS;\n      }\n      free(envpath);\n    }\n  }\n\n  /* indicate success or failure */\n  D((\"Exit.\"));\n  return retval;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "785-790",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nint\npam_sm_authenticate (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t     int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_IGNORE;\n}"
  },
  {
    "function_name": "_clean_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "763-779",
    "snippet": "static void   _clean_var(VAR *var)\n{\n    if (var->name) {\n      free(var->name);\n    }\n    if (var->defval && (&quote != var->defval)) {\n      free(var->defval);\n    }\n    if (var->override && (&quote != var->override)) {\n      free(var->override);\n    }\n    var->name = NULL;\n    var->value = NULL;    /* never has memory specific to it */\n    var->defval = NULL;\n    var->override = NULL;\n    return;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);",
      "static char quote='\\0';"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "var->override"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic void   _clean_var(VAR *var)\n{\n    if (var->name) {\n      free(var->name);\n    }\n    if (var->defval && (&quote != var->defval)) {\n      free(var->defval);\n    }\n    if (var->override && (&quote != var->override)) {\n      free(var->override);\n    }\n    var->name = NULL;\n    var->value = NULL;    /* never has memory specific to it */\n    var->defval = NULL;\n    var->override = NULL;\n    return;\n}"
  },
  {
    "function_name": "_undefine_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "752-761",
    "snippet": "static int _undefine_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to undefine, this is a simple function */\n\n  D((\"Called and exit.\"));\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"remove variable \\\"%s\\\"\", var->name);\n  }\n  return pam_putenv(pamh, var->name);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x01"
    ],
    "globals_used": [
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "var->name"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"remove variable \\\"%s\\\"\"",
            "var->name"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Called and exit.\")"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int _undefine_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to undefine, this is a simple function */\n\n  D((\"Called and exit.\"));\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"remove variable \\\"%s\\\"\", var->name);\n  }\n  return pam_putenv(pamh, var->name);\n}"
  },
  {
    "function_name": "_define_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "730-750",
    "snippet": "static int _define_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to define, this is a simple function */\n\n  char *envvar;\n  int retval = PAM_SUCCESS;\n\n  D((\"Called.\"));\n  if (asprintf(&envvar, \"%s=%s\", var->name, var->value) < 0) {\n    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  retval = pam_putenv(pamh, envvar);\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"pam_putenv(\\\"%s\\\")\", envvar);\n  }\n  _pam_drop(envvar);\n  D((\"Exit.\"));\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x01"
    ],
    "globals_used": [
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "envvar"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_putenv(\\\"%s\\\")\"",
            "envvar"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "envvar"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&envvar",
            "\"%s=%s\"",
            "var->name",
            "var->value"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int _define_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to define, this is a simple function */\n\n  char *envvar;\n  int retval = PAM_SUCCESS;\n\n  D((\"Called.\"));\n  if (asprintf(&envvar, \"%s=%s\", var->name, var->value) < 0) {\n    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  retval = pam_putenv(pamh, envvar);\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"pam_putenv(\\\"%s\\\")\", envvar);\n  }\n  _pam_drop(envvar);\n  D((\"Exit.\"));\n  return retval;\n}"
  },
  {
    "function_name": "_pam_get_item_byname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "682-728",
    "snippet": "static const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"SHELL\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"No such user!?\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "itemval"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"SHELL\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"HOME\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "item",
            "&itemval"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown PAM_ITEM: <%s>\"",
            "name"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"PAM_RHOST\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"PAM_RUSER\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"PAM_TTY\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"PAM_USER_PROMPT\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"SHELL\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"HOME\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"PAM_USER\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}"
  },
  {
    "function_name": "_expand_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "542-680",
    "snippet": "static int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n  size_t idx;\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n  idx = 0;\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif (idx + 1 < MAX_ENV) {\n\t  tmp[idx++] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  size_t len = strlen(tmpptr);\n\t  if (idx + len < MAX_ENV) {\n\t    strcpy(tmp + idx, tmpptr);\n\t    idx += len;\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t    return PAM_BUF_ERR;\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (idx > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(idx + 1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", idx + 1));\n      pam_syslog (pamh, LOG_CRIT, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)idx+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp, '\\0', sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_ENV  8192",
      "#define BUF_SIZE 8192"
    ],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "'\\0'",
            "sizeof(tmp)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "*value",
            "tmp"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Couldn't malloc %lu bytes for expanded var\"",
            "(unsigned long)idx+1"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "idx + 1"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*value"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*value"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Variable buffer overflow: <%s> + <%s>\"",
            "tmp",
            "tmpptr"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Variable buffer overflow: <%s> + <%s>\"",
            "tmp",
            "tmpptr"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp + idx",
            "tmpptr"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmpptr"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Impossible error, type == <%c>\"",
            "type"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_get_item_byname",
          "args": [
            "pamh",
            "tmpval"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_get_item_byname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "682-728",
          "snippet": "static const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic const char * _pam_get_item_byname(pam_handle_t *pamh, const char *name)\n{\n  /*\n   * This function just allows me to use names as given in the config\n   * file and translate them into the appropriate PAM_ITEM macro\n   */\n\n  int item;\n  const void *itemval;\n\n  D((\"Called.\"));\n  if (strcmp(name, \"PAM_USER\") == 0 || strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0) {\n    item = PAM_USER;\n  } else if (strcmp(name, \"PAM_USER_PROMPT\") == 0) {\n    item = PAM_USER_PROMPT;\n  } else if (strcmp(name, \"PAM_TTY\") == 0) {\n    item = PAM_TTY;\n  } else if (strcmp(name, \"PAM_RUSER\") == 0) {\n    item = PAM_RUSER;\n  } else if (strcmp(name, \"PAM_RHOST\") == 0) {\n    item = PAM_RHOST;\n  } else {\n    D((\"Unknown PAM_ITEM: <%s>\", name));\n    pam_syslog (pamh, LOG_ERR, \"Unknown PAM_ITEM: <%s>\", name);\n    return NULL;\n  }\n\n  if (pam_get_item(pamh, item, &itemval) != PAM_SUCCESS) {\n    D((\"pam_get_item failed\"));\n    return NULL;     /* let pam_get_item() log the error */\n  }\n\n  if (itemval && (strcmp(name, \"HOME\") == 0 || strcmp(name, \"SHELL\") == 0)) {\n    struct passwd *user_entry;\n    user_entry = pam_modutil_getpwnam (pamh, itemval);\n    if (!user_entry) {\n      pam_syslog(pamh, LOG_ERR, \"No such user!?\");\n      return NULL;\n    }\n    return (strcmp(name, \"SHELL\") == 0) ?\n      user_entry->pw_shell :\n      user_entry->pw_dir;\n  }\n\n  D((\"Exit.\"));\n  return itemval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_getenv",
          "args": [
            "pamh",
            "tmpval"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmpval",
            "orig",
            "sizeof(tmpval)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unterminated expandable variable: <%s>\"",
            "orig-2"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig",
            "'}'"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\"",
            "orig"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Variable buffer overflow: <%s> + <%s>\"",
            "tmp",
            "tmpptr"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unrecognized escaped character: <%c> - ignoring\"",
            "*orig"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "MAX_ENV"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define MAX_ENV  8192\n#define BUF_SIZE 8192\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n  size_t idx;\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n  idx = 0;\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif (idx + 1 < MAX_ENV) {\n\t  tmp[idx++] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  size_t len = strlen(tmpptr);\n\t  if (idx + len < MAX_ENV) {\n\t    strcpy(tmp + idx, tmpptr);\n\t    idx += len;\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t    return PAM_BUF_ERR;\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (idx > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(idx + 1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", idx + 1));\n      pam_syslog (pamh, LOG_CRIT, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)idx+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp, '\\0', sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "_check_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "474-540",
    "snippet": "static int _check_var(pam_handle_t *pamh, VAR *var)\n{\n  /*\n   * Examine the variable and determine what action to take.\n   * Returns DEFINE_VAR, UNDEFINE_VAR depending on action to take\n   * or a PAM_* error code if passed back from other routines\n   *\n   * if no DEFAULT provided, the empty string is assumed\n   * if no OVERRIDE provided, the empty string is assumed\n   * if DEFAULT=  and OVERRIDE evaluates to the empty string,\n   *    this variable should be undefined\n   * if DEFAULT=\"\"  and OVERRIDE evaluates to the empty string,\n   *    this variable should be defined with no value\n   * if OVERRIDE=value   and value turns into the empty string, DEFAULT is used\n   *\n   * If DEFINE_VAR is to be returned, the correct value to define will\n   * be pointed to by var->value\n   */\n\n  int retval;\n\n  D((\"Called.\"));\n\n  /*\n   * First thing to do is to expand any arguments, but only\n   * if they are not the special quote values (cause expand_arg\n   * changes memory).\n   */\n\n  if (var->defval && (&quote != var->defval) &&\n      ((retval = _expand_arg(pamh, &(var->defval))) != PAM_SUCCESS)) {\n      return retval;\n  }\n  if (var->override && (&quote != var->override) &&\n      ((retval = _expand_arg(pamh, &(var->override))) != PAM_SUCCESS)) {\n    return retval;\n  }\n\n  /* Now its easy */\n\n  if (var->override && *(var->override)) {\n    /* if there is a non-empty string in var->override, we use it */\n    D((\"OVERRIDE variable <%s> being used: <%s>\", var->name, var->override));\n    var->value = var->override;\n    retval = DEFINE_VAR;\n  } else {\n\n    var->value = var->defval;\n    if (&quote == var->defval) {\n      /*\n       * This means that the empty string was given for defval value\n       * which indicates that a variable should be defined with no value\n       */\n      D((\"An empty variable: <%s>\", var->name));\n      retval = DEFINE_VAR;\n    } else if (var->defval) {\n      D((\"DEFAULT variable <%s> being used: <%s>\", var->name, var->defval));\n      retval = DEFINE_VAR;\n    } else {\n      D((\"UNDEFINE variable <%s>\", var->name));\n      retval = UNDEFINE_VAR;\n    }\n  }\n\n  D((\"Exit.\"));\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define UNDEFINE_VAR 102",
      "#define DEFINE_VAR   101"
    ],
    "globals_used": [
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);",
      "static char quote='\\0';"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_expand_arg",
          "args": [
            "pamh",
            "&(var->override)"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "_expand_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "542-680",
          "snippet": "static int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n  size_t idx;\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n  idx = 0;\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif (idx + 1 < MAX_ENV) {\n\t  tmp[idx++] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  size_t len = strlen(tmpptr);\n\t  if (idx + len < MAX_ENV) {\n\t    strcpy(tmp + idx, tmpptr);\n\t    idx += len;\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t    return PAM_BUF_ERR;\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (idx > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(idx + 1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", idx + 1));\n      pam_syslog (pamh, LOG_CRIT, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)idx+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp, '\\0', sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_ENV  8192",
            "#define BUF_SIZE 8192"
          ],
          "globals_used": [
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define MAX_ENV  8192\n#define BUF_SIZE 8192\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n  size_t idx;\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n  idx = 0;\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif (idx + 1 < MAX_ENV) {\n\t  tmp[idx++] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  size_t len = strlen(tmpptr);\n\t  if (idx + len < MAX_ENV) {\n\t    strcpy(tmp + idx, tmpptr);\n\t    idx += len;\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t    return PAM_BUF_ERR;\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if (idx + 1 < MAX_ENV) {\n\ttmp[idx++] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\treturn PAM_BUF_ERR;\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (idx > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(idx + 1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", idx + 1));\n      pam_syslog (pamh, LOG_CRIT, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)idx+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp, '\\0', sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define UNDEFINE_VAR 102\n#define DEFINE_VAR   101\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic int _check_var(pam_handle_t *pamh, VAR *var)\n{\n  /*\n   * Examine the variable and determine what action to take.\n   * Returns DEFINE_VAR, UNDEFINE_VAR depending on action to take\n   * or a PAM_* error code if passed back from other routines\n   *\n   * if no DEFAULT provided, the empty string is assumed\n   * if no OVERRIDE provided, the empty string is assumed\n   * if DEFAULT=  and OVERRIDE evaluates to the empty string,\n   *    this variable should be undefined\n   * if DEFAULT=\"\"  and OVERRIDE evaluates to the empty string,\n   *    this variable should be defined with no value\n   * if OVERRIDE=value   and value turns into the empty string, DEFAULT is used\n   *\n   * If DEFINE_VAR is to be returned, the correct value to define will\n   * be pointed to by var->value\n   */\n\n  int retval;\n\n  D((\"Called.\"));\n\n  /*\n   * First thing to do is to expand any arguments, but only\n   * if they are not the special quote values (cause expand_arg\n   * changes memory).\n   */\n\n  if (var->defval && (&quote != var->defval) &&\n      ((retval = _expand_arg(pamh, &(var->defval))) != PAM_SUCCESS)) {\n      return retval;\n  }\n  if (var->override && (&quote != var->override) &&\n      ((retval = _expand_arg(pamh, &(var->override))) != PAM_SUCCESS)) {\n    return retval;\n  }\n\n  /* Now its easy */\n\n  if (var->override && *(var->override)) {\n    /* if there is a non-empty string in var->override, we use it */\n    D((\"OVERRIDE variable <%s> being used: <%s>\", var->name, var->override));\n    var->value = var->override;\n    retval = DEFINE_VAR;\n  } else {\n\n    var->value = var->defval;\n    if (&quote == var->defval) {\n      /*\n       * This means that the empty string was given for defval value\n       * which indicates that a variable should be defined with no value\n       */\n      D((\"An empty variable: <%s>\", var->name));\n      retval = DEFINE_VAR;\n    } else if (var->defval) {\n      D((\"DEFAULT variable <%s> being used: <%s>\", var->name, var->defval));\n      retval = DEFINE_VAR;\n    } else {\n      D((\"UNDEFINE variable <%s>\", var->name));\n      retval = UNDEFINE_VAR;\n    }\n  }\n\n  D((\"Exit.\"));\n  return retval;\n}"
  },
  {
    "function_name": "_parse_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "378-472",
    "snippet": "static int\n_parse_line (const pam_handle_t *pamh, const char *buffer, VAR *var)\n{\n  /*\n   * parse buffer into var, legal syntax is\n   * VARIABLE [DEFAULT=[[string]] [OVERRIDE=[value]]\n   *\n   * Any other options defined make this a bad line,\n   * error logged and no var set\n   */\n\n  int length, quoteflg=0;\n  const char *ptr, *tmpptr;\n  char **valptr;\n\n  D((\"Called buffer = <%s>\", buffer));\n\n  length = strcspn(buffer,\" \\t\\n\");\n\n  if ((var->name = malloc(length + 1)) == NULL) {\n    pam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n    return PAM_BUF_ERR;\n  }\n\n  /*\n   * The first thing on the line HAS to be the variable name,\n   * it may be the only thing though.\n   */\n  strncpy(var->name, buffer, length);\n  var->name[length] = '\\0';\n  D((\"var->name = <%s>, length = %d\", var->name, length));\n\n  /*\n   * Now we check for arguments, we only support two kinds and ('cause I am lazy)\n   * each one can actually be listed any number of times\n   */\n\n  ptr = buffer+length;\n  while ((length = strspn(ptr, \" \\t\")) > 0) {\n    ptr += length;                              /* remove leading whitespace */\n    D((ptr));\n    if ((tmpptr = pam_str_skip_prefix(ptr, \"DEFAULT=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Default arg found: <%s>\", ptr));\n      valptr=&(var->defval);\n    } else if ((tmpptr = pam_str_skip_prefix(ptr, \"OVERRIDE=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Override arg found: <%s>\", ptr));\n      valptr=&(var->override);\n    } else {\n      D((\"Unrecognized options: <%s> - ignoring line\", ptr));\n      pam_syslog(pamh, LOG_ERR, \"Unrecognized Option: %s - ignoring line\", ptr);\n      return BAD_LINE;\n    }\n\n    if ('\"' != *ptr) {       /* Escaped quotes not supported */\n      length = strcspn(ptr, \" \\t\\n\");\n      tmpptr = ptr+length;\n    } else {\n      tmpptr = strchr(++ptr, '\"');\n      if (!tmpptr) {\n\tD((\"Unterminated quoted string: %s\", ptr-1));\n\tpam_syslog(pamh, LOG_ERR, \"Unterminated quoted string: %s\", ptr-1);\n\treturn BAD_LINE;\n      }\n      length = tmpptr - ptr;\n      if (*++tmpptr && ' ' != *tmpptr && '\\t' != *tmpptr && '\\n' != *tmpptr) {\n\tD((\"Quotes must cover the entire string: <%s>\", ptr));\n\tpam_syslog(pamh, LOG_ERR, \"Quotes must cover the entire string: <%s>\", ptr);\n\treturn BAD_LINE;\n      }\n      quoteflg++;\n    }\n    if (length) {\n      if ((*valptr = malloc(length + 1)) == NULL) {\n\tD((\"Couldn't malloc %d bytes\", length+1));\n\tpam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n\treturn PAM_BUF_ERR;\n      }\n      (void)strncpy(*valptr,ptr,length);\n      (*valptr)[length]='\\0';\n    } else if (quoteflg--) {\n      *valptr = &quote;      /* a quick hack to handle the empty string */\n    }\n    ptr = tmpptr;         /* Start the search where we stopped */\n  } /* while */\n\n  /*\n   * The line is parsed, all is well.\n   */\n\n  D((\"Exit.\"));\n  ptr = NULL; tmpptr = NULL; valptr = NULL;\n  return GOOD_LINE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define BAD_LINE     100       /* This must be > the largest PAM_* error code */",
      "#define GOOD_LINE    0"
    ],
    "globals_used": [
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);",
      "static char quote='\\0';"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "*valptr",
            "ptr",
            "length"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Couldn't malloc %d bytes\"",
            "length+1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "length + 1"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Quotes must cover the entire string: <%s>\"",
            "ptr"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unterminated quoted string: %s\"",
            "ptr-1"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++ptr",
            "'\"'"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "ptr",
            "\" \\t\\n\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unrecognized Option: %s - ignoring line\"",
            "ptr"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "ptr",
            "\"OVERRIDE=\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "ptr",
            "\"DEFAULT=\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "ptr",
            "\" \\t\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "var->name",
            "buffer",
            "length"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Couldn't malloc %d bytes\"",
            "length+1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "length + 1"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "buffer",
            "\" \\t\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define BAD_LINE     100       /* This must be > the largest PAM_* error code */\n#define GOOD_LINE    0\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic int\n_parse_line (const pam_handle_t *pamh, const char *buffer, VAR *var)\n{\n  /*\n   * parse buffer into var, legal syntax is\n   * VARIABLE [DEFAULT=[[string]] [OVERRIDE=[value]]\n   *\n   * Any other options defined make this a bad line,\n   * error logged and no var set\n   */\n\n  int length, quoteflg=0;\n  const char *ptr, *tmpptr;\n  char **valptr;\n\n  D((\"Called buffer = <%s>\", buffer));\n\n  length = strcspn(buffer,\" \\t\\n\");\n\n  if ((var->name = malloc(length + 1)) == NULL) {\n    pam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n    return PAM_BUF_ERR;\n  }\n\n  /*\n   * The first thing on the line HAS to be the variable name,\n   * it may be the only thing though.\n   */\n  strncpy(var->name, buffer, length);\n  var->name[length] = '\\0';\n  D((\"var->name = <%s>, length = %d\", var->name, length));\n\n  /*\n   * Now we check for arguments, we only support two kinds and ('cause I am lazy)\n   * each one can actually be listed any number of times\n   */\n\n  ptr = buffer+length;\n  while ((length = strspn(ptr, \" \\t\")) > 0) {\n    ptr += length;                              /* remove leading whitespace */\n    D((ptr));\n    if ((tmpptr = pam_str_skip_prefix(ptr, \"DEFAULT=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Default arg found: <%s>\", ptr));\n      valptr=&(var->defval);\n    } else if ((tmpptr = pam_str_skip_prefix(ptr, \"OVERRIDE=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Override arg found: <%s>\", ptr));\n      valptr=&(var->override);\n    } else {\n      D((\"Unrecognized options: <%s> - ignoring line\", ptr));\n      pam_syslog(pamh, LOG_ERR, \"Unrecognized Option: %s - ignoring line\", ptr);\n      return BAD_LINE;\n    }\n\n    if ('\"' != *ptr) {       /* Escaped quotes not supported */\n      length = strcspn(ptr, \" \\t\\n\");\n      tmpptr = ptr+length;\n    } else {\n      tmpptr = strchr(++ptr, '\"');\n      if (!tmpptr) {\n\tD((\"Unterminated quoted string: %s\", ptr-1));\n\tpam_syslog(pamh, LOG_ERR, \"Unterminated quoted string: %s\", ptr-1);\n\treturn BAD_LINE;\n      }\n      length = tmpptr - ptr;\n      if (*++tmpptr && ' ' != *tmpptr && '\\t' != *tmpptr && '\\n' != *tmpptr) {\n\tD((\"Quotes must cover the entire string: <%s>\", ptr));\n\tpam_syslog(pamh, LOG_ERR, \"Quotes must cover the entire string: <%s>\", ptr);\n\treturn BAD_LINE;\n      }\n      quoteflg++;\n    }\n    if (length) {\n      if ((*valptr = malloc(length + 1)) == NULL) {\n\tD((\"Couldn't malloc %d bytes\", length+1));\n\tpam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n\treturn PAM_BUF_ERR;\n      }\n      (void)strncpy(*valptr,ptr,length);\n      (*valptr)[length]='\\0';\n    } else if (quoteflg--) {\n      *valptr = &quote;      /* a quick hack to handle the empty string */\n    }\n    ptr = tmpptr;         /* Start the search where we stopped */\n  } /* while */\n\n  /*\n   * The line is parsed, all is well.\n   */\n\n  D((\"Exit.\"));\n  ptr = NULL; tmpptr = NULL; valptr = NULL;\n  return GOOD_LINE;\n}"
  },
  {
    "function_name": "_assemble_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "290-376",
    "snippet": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _assemble_line(FILE *, char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "os"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "os"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "os"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "p",
            "\" \\n\\t\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"_assemble_line: line too long\")"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "f"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "p",
            "buf_len - used",
            "f"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _assemble_line(FILE *, char *, int);\n\nstatic int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}"
  },
  {
    "function_name": "_parse_env_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "188-283",
    "snippet": "static int\n_parse_env_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval=PAM_SUCCESS, i, t;\n    char buffer[BUF_SIZE], *key, *mark;\n    FILE *conf;\n\n    D((\"Env file name is: %s\", file));\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open env file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    while (_assemble_line(conf, buffer, BUF_SIZE) > 0) {\n\tD((\"Read line: %s\", buffer));\n\tkey = buffer;\n\n\t/* skip leading white space */\n\tkey += strspn(key, \" \\n\\t\");\n\n\t/* skip blanks lines and comments */\n\tif (key[0] == '#')\n\t    continue;\n\n\t/* skip over \"export \" if present so we can be compat with\n\t   bash type declarations */\n\tif (strncmp(key, \"export \", (size_t) 7) == 0)\n\t    key += 7;\n\n\t/* now find the end of value */\n\tmark = key;\n\twhile(mark[0] != '\\n' && mark[0] != '#' && mark[0] != '\\0')\n\t    mark++;\n\tif (mark[0] != '\\0')\n\t    mark[0] = '\\0';\n\n       /*\n\t* sanity check, the key must be alphanumeric\n\t*/\n\n\tif (key[0] == '=') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"missing key name '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tcontinue;\n\t}\n\n\tfor ( i = 0 ; key[i] != '=' && key[i] != '\\0' ; i++ )\n\t    if (!isalnum(key[i]) && key[i] != '_') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"non-alphanumeric key '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tbreak;\n\t    }\n\t/* non-alphanumeric key, ignore this line */\n\tif (key[i] != '=' && key[i] != '\\0')\n\t    continue;\n\n\t/* now we try to be smart about quotes around the value,\n\t   but not too smart, we can't get all fancy with escaped\n\t   values like bash */\n\tif (key[i] == '=' && (key[++i] == '\\\"' || key[i] == '\\'')) {\n\t    for ( t = i+1 ; key[t] != '\\0' ; t++)\n\t\tif (key[t] != '\\\"' && key[t] != '\\'')\n\t\t    key[i++] = key[t];\n\t\telse if (key[t+1] != '\\0')\n\t\t    key[i++] = key[t];\n\t    key[i] = '\\0';\n\t}\n\n\t/* if this is a request to delete a variable, check that it's\n\t   actually set first, so we don't get a vague error back from\n\t   pam_putenv() */\n\tfor (i = 0; key[i] != '=' && key[i] != '\\0'; i++);\n\n\tif (key[i] == '\\0' && !pam_getenv(pamh,key))\n\t    continue;\n\n\t/* set the env var, if it fails, we break out of the loop */\n\tretval = pam_putenv(pamh, key);\n\tif (retval != PAM_SUCCESS) {\n\t    D((\"error setting env \\\"%s\\\"\", key));\n\t    break;\n\t} else if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"pam_putenv(\\\"%s\\\")\", key);\n\t}\n    }\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    D((\"Exit.\"));\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x01",
      "#define BUF_SIZE 8192"
    ],
    "globals_used": [
      "static int  _assemble_line(FILE *, char *, int);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "conf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"pam_putenv(\\\"%s\\\")\"",
            "key"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_putenv",
          "args": [
            "pamh",
            "key"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_getenv",
          "args": [
            "pamh",
            "key"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"non-alphanumeric key '%s' in %s', ignoring\"",
            "key",
            "file"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "key[i]"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"missing key name '%s' in %s', ignoring\"",
            "key",
            "file"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "key",
            "\"export \"",
            "(size_t) 7"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "key",
            "\" \\n\\t\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_assemble_line",
          "args": [
            "conf",
            "buffer",
            "BUF_SIZE"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "_assemble_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "290-376",
          "snippet": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _assemble_line(FILE *, char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _assemble_line(FILE *, char *, int);\n\nstatic int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open env file: %s: %m\"",
            "file"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n#define BUF_SIZE 8192\n\nstatic int  _assemble_line(FILE *, char *, int);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\n_parse_env_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval=PAM_SUCCESS, i, t;\n    char buffer[BUF_SIZE], *key, *mark;\n    FILE *conf;\n\n    D((\"Env file name is: %s\", file));\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open env file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    while (_assemble_line(conf, buffer, BUF_SIZE) > 0) {\n\tD((\"Read line: %s\", buffer));\n\tkey = buffer;\n\n\t/* skip leading white space */\n\tkey += strspn(key, \" \\n\\t\");\n\n\t/* skip blanks lines and comments */\n\tif (key[0] == '#')\n\t    continue;\n\n\t/* skip over \"export \" if present so we can be compat with\n\t   bash type declarations */\n\tif (strncmp(key, \"export \", (size_t) 7) == 0)\n\t    key += 7;\n\n\t/* now find the end of value */\n\tmark = key;\n\twhile(mark[0] != '\\n' && mark[0] != '#' && mark[0] != '\\0')\n\t    mark++;\n\tif (mark[0] != '\\0')\n\t    mark[0] = '\\0';\n\n       /*\n\t* sanity check, the key must be alphanumeric\n\t*/\n\n\tif (key[0] == '=') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"missing key name '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tcontinue;\n\t}\n\n\tfor ( i = 0 ; key[i] != '=' && key[i] != '\\0' ; i++ )\n\t    if (!isalnum(key[i]) && key[i] != '_') {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t           \"non-alphanumeric key '%s' in %s', ignoring\",\n\t\t           key, file);\n\t\tbreak;\n\t    }\n\t/* non-alphanumeric key, ignore this line */\n\tif (key[i] != '=' && key[i] != '\\0')\n\t    continue;\n\n\t/* now we try to be smart about quotes around the value,\n\t   but not too smart, we can't get all fancy with escaped\n\t   values like bash */\n\tif (key[i] == '=' && (key[++i] == '\\\"' || key[i] == '\\'')) {\n\t    for ( t = i+1 ; key[t] != '\\0' ; t++)\n\t\tif (key[t] != '\\\"' && key[t] != '\\'')\n\t\t    key[i++] = key[t];\n\t\telse if (key[t+1] != '\\0')\n\t\t    key[i++] = key[t];\n\t    key[i] = '\\0';\n\t}\n\n\t/* if this is a request to delete a variable, check that it's\n\t   actually set first, so we don't get a vague error back from\n\t   pam_putenv() */\n\tfor (i = 0; key[i] != '=' && key[i] != '\\0'; i++);\n\n\tif (key[i] == '\\0' && !pam_getenv(pamh,key))\n\t    continue;\n\n\t/* set the env var, if it fails, we break out of the loop */\n\tretval = pam_putenv(pamh, key);\n\tif (retval != PAM_SUCCESS) {\n\t    D((\"error setting env \\\"%s\\\"\", key));\n\t    break;\n\t} else if (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"pam_putenv(\\\"%s\\\")\", key);\n\t}\n    }\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    D((\"Exit.\"));\n    return retval;\n}"
  },
  {
    "function_name": "_parse_config_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "131-186",
    "snippet": "static int\n_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n\n    D((\"Called.\"));\n\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n\n    D((\"Config file name is: %s\", file));\n\n    /*\n     * Lets try to open the config file, parse it and process\n     * any variables found.\n     */\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    /* _pam_assemble_line will provide a complete line from the config file,\n     * with all comments removed and any escaped newlines fixed up\n     */\n\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n\n      _clean_var(var);\n\n    }  /* while */\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    _clean_var(var);        /* We could have got here prematurely,\n\t\t\t     * this is safe though */\n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define ILLEGAL_VAR  103",
      "#define UNDEFINE_VAR 102",
      "#define DEFINE_VAR   101",
      "#define BAD_LINE     100       /* This must be > the largest PAM_* error code */",
      "#define GOOD_LINE    0",
      "#define BUF_SIZE 8192"
    ],
    "globals_used": [
      "static int  _assemble_line(FILE *, char *, int);",
      "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
      "static int  _check_var(pam_handle_t *, VAR *);",
      "static void _clean_var(VAR *);",
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
      "static int  _define_var(pam_handle_t *, int, VAR *);",
      "static int  _undefine_var(pam_handle_t *, int, VAR *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"Exit.\")"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_clean_var",
          "args": [
            "var"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "_clean_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "763-779",
          "snippet": "static void   _clean_var(VAR *var)\n{\n    if (var->name) {\n      free(var->name);\n    }\n    if (var->defval && (&quote != var->defval)) {\n      free(var->defval);\n    }\n    if (var->override && (&quote != var->override)) {\n      free(var->override);\n    }\n    var->name = NULL;\n    var->value = NULL;    /* never has memory specific to it */\n    var->defval = NULL;\n    var->override = NULL;\n    return;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);",
            "static char quote='\\0';"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic void   _clean_var(VAR *var)\n{\n    if (var->name) {\n      free(var->name);\n    }\n    if (var->defval && (&quote != var->defval)) {\n      free(var->defval);\n    }\n    if (var->override && (&quote != var->override)) {\n      free(var->override);\n    }\n    var->name = NULL;\n    var->value = NULL;    /* never has memory specific to it */\n    var->defval = NULL;\n    var->override = NULL;\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "conf"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_undefine_var",
          "args": [
            "pamh",
            "ctrl",
            "var"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_undefine_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "752-761",
          "snippet": "static int _undefine_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to undefine, this is a simple function */\n\n  D((\"Called and exit.\"));\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"remove variable \\\"%s\\\"\", var->name);\n  }\n  return pam_putenv(pamh, var->name);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x01"
          ],
          "globals_used": [
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int _undefine_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to undefine, this is a simple function */\n\n  D((\"Called and exit.\"));\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"remove variable \\\"%s\\\"\", var->name);\n  }\n  return pam_putenv(pamh, var->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_define_var",
          "args": [
            "pamh",
            "ctrl",
            "var"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "_define_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "730-750",
          "snippet": "static int _define_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to define, this is a simple function */\n\n  char *envvar;\n  int retval = PAM_SUCCESS;\n\n  D((\"Called.\"));\n  if (asprintf(&envvar, \"%s=%s\", var->name, var->value) < 0) {\n    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  retval = pam_putenv(pamh, envvar);\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"pam_putenv(\\\"%s\\\")\", envvar);\n  }\n  _pam_drop(envvar);\n  D((\"Exit.\"));\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PAM_DEBUG_ARG       0x01"
          ],
          "globals_used": [
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int _define_var(pam_handle_t *pamh, int ctrl, VAR *var)\n{\n  /* We have a variable to define, this is a simple function */\n\n  char *envvar;\n  int retval = PAM_SUCCESS;\n\n  D((\"Called.\"));\n  if (asprintf(&envvar, \"%s=%s\", var->name, var->value) < 0) {\n    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  retval = pam_putenv(pamh, envvar);\n  if (ctrl & PAM_DEBUG_ARG) {\n    pam_syslog(pamh, LOG_DEBUG, \"pam_putenv(\\\"%s\\\")\", envvar);\n  }\n  _pam_drop(envvar);\n  D((\"Exit.\"));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_check_var",
          "args": [
            "pamh",
            "var"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "_check_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "474-540",
          "snippet": "static int _check_var(pam_handle_t *pamh, VAR *var)\n{\n  /*\n   * Examine the variable and determine what action to take.\n   * Returns DEFINE_VAR, UNDEFINE_VAR depending on action to take\n   * or a PAM_* error code if passed back from other routines\n   *\n   * if no DEFAULT provided, the empty string is assumed\n   * if no OVERRIDE provided, the empty string is assumed\n   * if DEFAULT=  and OVERRIDE evaluates to the empty string,\n   *    this variable should be undefined\n   * if DEFAULT=\"\"  and OVERRIDE evaluates to the empty string,\n   *    this variable should be defined with no value\n   * if OVERRIDE=value   and value turns into the empty string, DEFAULT is used\n   *\n   * If DEFINE_VAR is to be returned, the correct value to define will\n   * be pointed to by var->value\n   */\n\n  int retval;\n\n  D((\"Called.\"));\n\n  /*\n   * First thing to do is to expand any arguments, but only\n   * if they are not the special quote values (cause expand_arg\n   * changes memory).\n   */\n\n  if (var->defval && (&quote != var->defval) &&\n      ((retval = _expand_arg(pamh, &(var->defval))) != PAM_SUCCESS)) {\n      return retval;\n  }\n  if (var->override && (&quote != var->override) &&\n      ((retval = _expand_arg(pamh, &(var->override))) != PAM_SUCCESS)) {\n    return retval;\n  }\n\n  /* Now its easy */\n\n  if (var->override && *(var->override)) {\n    /* if there is a non-empty string in var->override, we use it */\n    D((\"OVERRIDE variable <%s> being used: <%s>\", var->name, var->override));\n    var->value = var->override;\n    retval = DEFINE_VAR;\n  } else {\n\n    var->value = var->defval;\n    if (&quote == var->defval) {\n      /*\n       * This means that the empty string was given for defval value\n       * which indicates that a variable should be defined with no value\n       */\n      D((\"An empty variable: <%s>\", var->name));\n      retval = DEFINE_VAR;\n    } else if (var->defval) {\n      D((\"DEFAULT variable <%s> being used: <%s>\", var->name, var->defval));\n      retval = DEFINE_VAR;\n    } else {\n      D((\"UNDEFINE variable <%s>\", var->name));\n      retval = UNDEFINE_VAR;\n    }\n  }\n\n  D((\"Exit.\"));\n  return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define UNDEFINE_VAR 102",
            "#define DEFINE_VAR   101"
          ],
          "globals_used": [
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);",
            "static char quote='\\0';"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define UNDEFINE_VAR 102\n#define DEFINE_VAR   101\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic int _check_var(pam_handle_t *pamh, VAR *var)\n{\n  /*\n   * Examine the variable and determine what action to take.\n   * Returns DEFINE_VAR, UNDEFINE_VAR depending on action to take\n   * or a PAM_* error code if passed back from other routines\n   *\n   * if no DEFAULT provided, the empty string is assumed\n   * if no OVERRIDE provided, the empty string is assumed\n   * if DEFAULT=  and OVERRIDE evaluates to the empty string,\n   *    this variable should be undefined\n   * if DEFAULT=\"\"  and OVERRIDE evaluates to the empty string,\n   *    this variable should be defined with no value\n   * if OVERRIDE=value   and value turns into the empty string, DEFAULT is used\n   *\n   * If DEFINE_VAR is to be returned, the correct value to define will\n   * be pointed to by var->value\n   */\n\n  int retval;\n\n  D((\"Called.\"));\n\n  /*\n   * First thing to do is to expand any arguments, but only\n   * if they are not the special quote values (cause expand_arg\n   * changes memory).\n   */\n\n  if (var->defval && (&quote != var->defval) &&\n      ((retval = _expand_arg(pamh, &(var->defval))) != PAM_SUCCESS)) {\n      return retval;\n  }\n  if (var->override && (&quote != var->override) &&\n      ((retval = _expand_arg(pamh, &(var->override))) != PAM_SUCCESS)) {\n    return retval;\n  }\n\n  /* Now its easy */\n\n  if (var->override && *(var->override)) {\n    /* if there is a non-empty string in var->override, we use it */\n    D((\"OVERRIDE variable <%s> being used: <%s>\", var->name, var->override));\n    var->value = var->override;\n    retval = DEFINE_VAR;\n  } else {\n\n    var->value = var->defval;\n    if (&quote == var->defval) {\n      /*\n       * This means that the empty string was given for defval value\n       * which indicates that a variable should be defined with no value\n       */\n      D((\"An empty variable: <%s>\", var->name));\n      retval = DEFINE_VAR;\n    } else if (var->defval) {\n      D((\"DEFAULT variable <%s> being used: <%s>\", var->name, var->defval));\n      retval = DEFINE_VAR;\n    } else {\n      D((\"UNDEFINE variable <%s>\", var->name));\n      retval = UNDEFINE_VAR;\n    }\n  }\n\n  D((\"Exit.\"));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_parse_line",
          "args": [
            "pamh",
            "buffer",
            "var"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "378-472",
          "snippet": "static int\n_parse_line (const pam_handle_t *pamh, const char *buffer, VAR *var)\n{\n  /*\n   * parse buffer into var, legal syntax is\n   * VARIABLE [DEFAULT=[[string]] [OVERRIDE=[value]]\n   *\n   * Any other options defined make this a bad line,\n   * error logged and no var set\n   */\n\n  int length, quoteflg=0;\n  const char *ptr, *tmpptr;\n  char **valptr;\n\n  D((\"Called buffer = <%s>\", buffer));\n\n  length = strcspn(buffer,\" \\t\\n\");\n\n  if ((var->name = malloc(length + 1)) == NULL) {\n    pam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n    return PAM_BUF_ERR;\n  }\n\n  /*\n   * The first thing on the line HAS to be the variable name,\n   * it may be the only thing though.\n   */\n  strncpy(var->name, buffer, length);\n  var->name[length] = '\\0';\n  D((\"var->name = <%s>, length = %d\", var->name, length));\n\n  /*\n   * Now we check for arguments, we only support two kinds and ('cause I am lazy)\n   * each one can actually be listed any number of times\n   */\n\n  ptr = buffer+length;\n  while ((length = strspn(ptr, \" \\t\")) > 0) {\n    ptr += length;                              /* remove leading whitespace */\n    D((ptr));\n    if ((tmpptr = pam_str_skip_prefix(ptr, \"DEFAULT=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Default arg found: <%s>\", ptr));\n      valptr=&(var->defval);\n    } else if ((tmpptr = pam_str_skip_prefix(ptr, \"OVERRIDE=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Override arg found: <%s>\", ptr));\n      valptr=&(var->override);\n    } else {\n      D((\"Unrecognized options: <%s> - ignoring line\", ptr));\n      pam_syslog(pamh, LOG_ERR, \"Unrecognized Option: %s - ignoring line\", ptr);\n      return BAD_LINE;\n    }\n\n    if ('\"' != *ptr) {       /* Escaped quotes not supported */\n      length = strcspn(ptr, \" \\t\\n\");\n      tmpptr = ptr+length;\n    } else {\n      tmpptr = strchr(++ptr, '\"');\n      if (!tmpptr) {\n\tD((\"Unterminated quoted string: %s\", ptr-1));\n\tpam_syslog(pamh, LOG_ERR, \"Unterminated quoted string: %s\", ptr-1);\n\treturn BAD_LINE;\n      }\n      length = tmpptr - ptr;\n      if (*++tmpptr && ' ' != *tmpptr && '\\t' != *tmpptr && '\\n' != *tmpptr) {\n\tD((\"Quotes must cover the entire string: <%s>\", ptr));\n\tpam_syslog(pamh, LOG_ERR, \"Quotes must cover the entire string: <%s>\", ptr);\n\treturn BAD_LINE;\n      }\n      quoteflg++;\n    }\n    if (length) {\n      if ((*valptr = malloc(length + 1)) == NULL) {\n\tD((\"Couldn't malloc %d bytes\", length+1));\n\tpam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n\treturn PAM_BUF_ERR;\n      }\n      (void)strncpy(*valptr,ptr,length);\n      (*valptr)[length]='\\0';\n    } else if (quoteflg--) {\n      *valptr = &quote;      /* a quick hack to handle the empty string */\n    }\n    ptr = tmpptr;         /* Start the search where we stopped */\n  } /* while */\n\n  /*\n   * The line is parsed, all is well.\n   */\n\n  D((\"Exit.\"));\n  ptr = NULL; tmpptr = NULL; valptr = NULL;\n  return GOOD_LINE;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BAD_LINE     100       /* This must be > the largest PAM_* error code */",
            "#define GOOD_LINE    0"
          ],
          "globals_used": [
            "static int  _parse_line(const pam_handle_t *, const char *, VAR *);",
            "static int  _check_var(pam_handle_t *, VAR *);",
            "static void _clean_var(VAR *);",
            "static int  _expand_arg(pam_handle_t *, char **);",
            "static const char * _pam_get_item_byname(pam_handle_t *, const char *);",
            "static int  _define_var(pam_handle_t *, int, VAR *);",
            "static int  _undefine_var(pam_handle_t *, int, VAR *);",
            "static char quote='\\0';"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define BAD_LINE     100       /* This must be > the largest PAM_* error code */\n#define GOOD_LINE    0\n\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\nstatic char quote='\\0';\n\nstatic int\n_parse_line (const pam_handle_t *pamh, const char *buffer, VAR *var)\n{\n  /*\n   * parse buffer into var, legal syntax is\n   * VARIABLE [DEFAULT=[[string]] [OVERRIDE=[value]]\n   *\n   * Any other options defined make this a bad line,\n   * error logged and no var set\n   */\n\n  int length, quoteflg=0;\n  const char *ptr, *tmpptr;\n  char **valptr;\n\n  D((\"Called buffer = <%s>\", buffer));\n\n  length = strcspn(buffer,\" \\t\\n\");\n\n  if ((var->name = malloc(length + 1)) == NULL) {\n    pam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n    return PAM_BUF_ERR;\n  }\n\n  /*\n   * The first thing on the line HAS to be the variable name,\n   * it may be the only thing though.\n   */\n  strncpy(var->name, buffer, length);\n  var->name[length] = '\\0';\n  D((\"var->name = <%s>, length = %d\", var->name, length));\n\n  /*\n   * Now we check for arguments, we only support two kinds and ('cause I am lazy)\n   * each one can actually be listed any number of times\n   */\n\n  ptr = buffer+length;\n  while ((length = strspn(ptr, \" \\t\")) > 0) {\n    ptr += length;                              /* remove leading whitespace */\n    D((ptr));\n    if ((tmpptr = pam_str_skip_prefix(ptr, \"DEFAULT=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Default arg found: <%s>\", ptr));\n      valptr=&(var->defval);\n    } else if ((tmpptr = pam_str_skip_prefix(ptr, \"OVERRIDE=\")) != NULL) {\n      ptr = tmpptr;\n      D((\"Override arg found: <%s>\", ptr));\n      valptr=&(var->override);\n    } else {\n      D((\"Unrecognized options: <%s> - ignoring line\", ptr));\n      pam_syslog(pamh, LOG_ERR, \"Unrecognized Option: %s - ignoring line\", ptr);\n      return BAD_LINE;\n    }\n\n    if ('\"' != *ptr) {       /* Escaped quotes not supported */\n      length = strcspn(ptr, \" \\t\\n\");\n      tmpptr = ptr+length;\n    } else {\n      tmpptr = strchr(++ptr, '\"');\n      if (!tmpptr) {\n\tD((\"Unterminated quoted string: %s\", ptr-1));\n\tpam_syslog(pamh, LOG_ERR, \"Unterminated quoted string: %s\", ptr-1);\n\treturn BAD_LINE;\n      }\n      length = tmpptr - ptr;\n      if (*++tmpptr && ' ' != *tmpptr && '\\t' != *tmpptr && '\\n' != *tmpptr) {\n\tD((\"Quotes must cover the entire string: <%s>\", ptr));\n\tpam_syslog(pamh, LOG_ERR, \"Quotes must cover the entire string: <%s>\", ptr);\n\treturn BAD_LINE;\n      }\n      quoteflg++;\n    }\n    if (length) {\n      if ((*valptr = malloc(length + 1)) == NULL) {\n\tD((\"Couldn't malloc %d bytes\", length+1));\n\tpam_syslog(pamh, LOG_CRIT, \"Couldn't malloc %d bytes\", length+1);\n\treturn PAM_BUF_ERR;\n      }\n      (void)strncpy(*valptr,ptr,length);\n      (*valptr)[length]='\\0';\n    } else if (quoteflg--) {\n      *valptr = &quote;      /* a quick hack to handle the empty string */\n    }\n    ptr = tmpptr;         /* Start the search where we stopped */\n  } /* while */\n\n  /*\n   * The line is parsed, all is well.\n   */\n\n  D((\"Exit.\"));\n  ptr = NULL; tmpptr = NULL; valptr = NULL;\n  return GOOD_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_assemble_line",
          "args": [
            "conf",
            "buffer",
            "BUF_SIZE"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "_assemble_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
          "lines": "290-376",
          "snippet": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _assemble_line(FILE *, char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int  _assemble_line(FILE *, char *, int);\n\nstatic int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    int whitespace;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\tif (p[0] == '\\0') {\n\t    D((\"_assemble_line: corrupted or binary file\"));\n\t    return -1;\n\t}\n\tif (p[strlen(p)-1] != '\\n' && !feof(f)) {\n\t    D((\"_assemble_line: line too long\"));\n\t    return -1;\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\twhitespace = strspn(p, \" \\n\\t\");\n\ts = p + whitespace;\n\tif (*s && (*s != '#')) {\n\t    used += whitespace;\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unable to open config file: %s: %m\"",
            "file"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define ILLEGAL_VAR  103\n#define UNDEFINE_VAR 102\n#define DEFINE_VAR   101\n#define BAD_LINE     100       /* This must be > the largest PAM_* error code */\n#define GOOD_LINE    0\n#define BUF_SIZE 8192\n\nstatic int  _assemble_line(FILE *, char *, int);\nstatic int  _parse_line(const pam_handle_t *, const char *, VAR *);\nstatic int  _check_var(pam_handle_t *, VAR *);\nstatic void _clean_var(VAR *);\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\nstatic int  _define_var(pam_handle_t *, int, VAR *);\nstatic int  _undefine_var(pam_handle_t *, int, VAR *);\n\nstatic int\n_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n\n    D((\"Called.\"));\n\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n\n    D((\"Config file name is: %s\", file));\n\n    /*\n     * Lets try to open the config file, parse it and process\n     * any variables found.\n     */\n\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n\n    /* _pam_assemble_line will provide a complete line from the config file,\n     * with all comments removed and any escaped newlines fixed up\n     */\n\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n\n      _clean_var(var);\n\n    }  /* while */\n\n    (void) fclose(conf);\n\n    /* tidy up */\n    _clean_var(var);        /* We could have got here prematurely,\n\t\t\t     * this is safe though */\n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}"
  },
  {
    "function_name": "_pam_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_env/pam_env.c",
    "lines": "72-129",
    "snippet": "static int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = str;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = str;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = str;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"readenv=\")) != NULL) {\n\t  *readenv = atoi(str);\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_readenv=\")) != NULL) {\n\t  *user_readenv = atoi(str);\n\t} else\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (*user_readenv)\n\tpam_syslog(pamh, LOG_DEBUG, \"deprecated reading of user environment enabled\");\n\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PAM_DEBUG_ARG       0x01",
      "#define DEFAULT_CONF_FILE\t(SCONFIGDIR \"/pam_env.conf\")",
      "#define DEFAULT_USER_READ_ENVFILE 0",
      "#define DEFAULT_USER_ENVFILE    \".pam_environment\"",
      "#define DEFAULT_READ_ENVFILE    1",
      "#define DEFAULT_ETC_ENVFILE     \"/etc/environment\""
    ],
    "globals_used": [
      "static int  _expand_arg(pam_handle_t *, char **);",
      "static const char * _pam_get_item_byname(pam_handle_t *, const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"deprecated reading of user environment enabled\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"user_readenv=\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"readenv=\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"new User Env File: %s\", *user_envfile)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"user_envfile= specification missing argument - ignored\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"user_envfile=\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"envfile= specification missing argument - ignored\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"envfile=\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"conffile= specification missing argument - ignored\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"conffile=\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define PAM_DEBUG_ARG       0x01\n#define DEFAULT_CONF_FILE\t(SCONFIGDIR \"/pam_env.conf\")\n#define DEFAULT_USER_READ_ENVFILE 0\n#define DEFAULT_USER_ENVFILE    \".pam_environment\"\n#define DEFAULT_READ_ENVFILE    1\n#define DEFAULT_ETC_ENVFILE     \"/etc/environment\"\n\nstatic int  _expand_arg(pam_handle_t *, char **);\nstatic const char * _pam_get_item_byname(pam_handle_t *, const char *);\n\nstatic int\n_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\tconst char *str;\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if ((str = pam_str_skip_prefix(*argv, \"conffile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = str;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = str;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_envfile=\")) != NULL) {\n\t  if (str[0] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = str;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if ((str = pam_str_skip_prefix(*argv, \"readenv=\")) != NULL) {\n\t  *readenv = atoi(str);\n\t} else if ((str = pam_str_skip_prefix(*argv, \"user_readenv=\")) != NULL) {\n\t  *user_readenv = atoi(str);\n\t} else\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n\n    if (*user_readenv)\n\tpam_syslog(pamh, LOG_DEBUG, \"deprecated reading of user environment enabled\");\n\n    return ctrl;\n}"
  }
]