[
  {
    "function_name": "compare_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
    "lines": "126-141",
    "snippet": "static int\ncompare_password(const char *newpass, const char *oldpass)\n{\n  char *outval;\n#ifdef HAVE_CRYPT_R\n  struct crypt_data output;\n\n  output.initialized = 0;\n\n  outval = crypt_r (newpass, oldpass, &output);\n#else\n  outval = crypt (newpass, oldpass);\n#endif\n\n  return outval != NULL && strcmp(outval, oldpass) == 0;\n}",
    "includes": [
      "#include \"opasswd.h\"",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <crypt.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <time.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char *oldpass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "outval",
            "oldpass"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt",
          "args": [
            "newpass",
            "oldpass"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "bigcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt.c",
          "lines": "51-163",
          "snippet": "char *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}",
          "includes": [
            "#include \"bigcrypt.h\"",
            "#include <crypt.h>",
            "#include <security/_pam_macros.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)",
            "#define ESEGMENT_SIZE      11",
            "#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)",
            "#define SALT_SIZE          2",
            "#define SEGMENT_SIZE       8",
            "#define MAX_PASS_LEN       16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bigcrypt.h\"\n#include <crypt.h>\n#include <security/_pam_macros.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)\n#define ESEGMENT_SIZE      11\n#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)\n#define SALT_SIZE          2\n#define SEGMENT_SIZE       8\n#define MAX_PASS_LEN       16\n\nchar *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypt_r",
          "args": [
            "newpass",
            "oldpass",
            "&output"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nconst char *oldpass;\n\nstatic int\ncompare_password(const char *newpass, const char *oldpass)\n{\n  char *outval;\n#ifdef HAVE_CRYPT_R\n  struct crypt_data output;\n\n  output.initialized = 0;\n\n  outval = crypt_r (newpass, oldpass, &output);\n#else\n  outval = crypt (newpass, oldpass);\n#endif\n\n  return outval != NULL && strcmp(outval, oldpass) == 0;\n}"
  },
  {
    "function_name": "parse_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
    "lines": "104-124",
    "snippet": "static int\nparse_entry (char *line, opwd *data)\n{\n  const char delimiters[] = \":\";\n  char *endptr;\n  char *count;\n\n  data->user = strsep (&line, delimiters);\n  data->uid = strsep (&line, delimiters);\n  count = strsep (&line, delimiters);\n  if (count == NULL)\n      return 1;\n\n  data->count = strtol (count, &endptr, 10);\n  if (endptr != NULL && *endptr != '\\0')\n      return 1;\n\n  data->old_passwords = strsep (&line, delimiters);\n\n  return 0;\n}",
    "includes": [
      "#include \"opasswd.h\"",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <crypt.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <time.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&line",
            "delimiters"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "count",
            "&endptr",
            "10"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&line",
            "delimiters"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&line",
            "delimiters"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&line",
            "delimiters"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nstatic int\nparse_entry (char *line, opwd *data)\n{\n  const char delimiters[] = \":\";\n  char *endptr;\n  char *count;\n\n  data->user = strsep (&line, delimiters);\n  data->uid = strsep (&line, delimiters);\n  count = strsep (&line, delimiters);\n  if (count == NULL)\n      return 1;\n\n  data->count = strtol (count, &endptr, 10);\n  if (endptr != NULL && *endptr != '\\0')\n      return 1;\n\n  data->old_passwords = strsep (&line, delimiters);\n\n  return 0;\n}"
  },
  {
    "function_name": "helper_log_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_pwhistory/opasswd.c",
    "lines": "91-101",
    "snippet": "void\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}",
    "includes": [
      "#include \"opasswd.h\"",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <crypt.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <time.h>",
      "#include <shadow.h>",
      "#include <pwd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsyslog",
          "args": [
            "err",
            "format",
            "args"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "HELPER_COMPILE",
            "LOG_CONS | LOG_PID",
            "LOG_AUTHPRIV"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "format"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"opasswd.h\"\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <crypt.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <time.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <config.h>\n\nvoid\nhelper_log_err(int err, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  openlog(HELPER_COMPILE, LOG_CONS | LOG_PID, LOG_AUTHPRIV);\n  vsyslog(err, format, args);\n  va_end(args);\n  closelog();\n}"
  }
]