[
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "738-771",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n\tstruct options opts;\n\tint rv, fd = -1;\n\tstruct tally_data tallies;\n\n\tmemset(&tallies, 0, sizeof(tallies));\n\n\trv = args_parse(pamh, argc, argv, flags, &opts);\n\n\tif (rv != PAM_SUCCESS)\n\t\tgoto err;\n\n\topts.action = FAILLOCK_ACTION_AUTHSUCC;\n\n\tif ((rv=get_pam_user(pamh, &opts)) != PAM_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\tif (!(opts.flags & FAILLOCK_FLAG_LOCAL_ONLY) ||\n\t\tcheck_local_user (pamh, opts.user) != 0) {\n\t\tcheck_tally(pamh, &opts, &tallies, &fd); /* for auditing */\n\t\treset_tally(pamh, &opts, &fd);\n\t}\n\n\ttally_cleanup(&tallies, fd);\n\nerr:\n\topts_cleanup(&opts);\n\n\treturn rv;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20",
      "#define FAILLOCK_ACTION_AUTHSUCC 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opts_cleanup",
          "args": [
            "&opts"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "opts_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "661-666",
          "snippet": "static void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tally_cleanup",
          "args": [
            "&tallies",
            "fd"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "tally_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "651-659",
          "snippet": "static void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_tally",
          "args": [
            "pamh",
            "&opts",
            "&fd"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "491-505",
          "snippet": "static void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_tally",
          "args": [
            "pamh",
            "&opts",
            "&tallies",
            "&fd"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "check_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "411-489",
          "snippet": "static int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_UNLOCKED\t\t0x10",
            "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1",
            "#define FAILLOCK_ACTION_PREAUTH  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_UNLOCKED\t\t0x10\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_local_user",
          "args": [
            "pamh",
            "opts.user"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "check_local_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "365-369",
          "snippet": "static int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pam_user",
          "args": [
            "pamh",
            "&opts"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "get_pam_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "371-409",
          "snippet": "static int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_AUDIT\t\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n\nstatic int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "args_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "flags",
            "&opts"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "args_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "108-185",
          "snippet": "static int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023",
            "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
            "#define FAILLOCK_FLAG_SILENT\t\t0x4",
            "#define FAILLOCK_ACTION_AUTHFAIL 2",
            "#define FAILLOCK_ACTION_AUTHSUCC 1",
            "#define FAILLOCK_ACTION_PREAUTH  0"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_ACTION_AUTHFAIL 2\n#define FAILLOCK_ACTION_AUTHSUCC 1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\n\nstatic int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tallies",
            "0",
            "sizeof(tallies)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20\n#define FAILLOCK_ACTION_AUTHSUCC 1\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t int argc, const char **argv)\n{\n\tstruct options opts;\n\tint rv, fd = -1;\n\tstruct tally_data tallies;\n\n\tmemset(&tallies, 0, sizeof(tallies));\n\n\trv = args_parse(pamh, argc, argv, flags, &opts);\n\n\tif (rv != PAM_SUCCESS)\n\t\tgoto err;\n\n\topts.action = FAILLOCK_ACTION_AUTHSUCC;\n\n\tif ((rv=get_pam_user(pamh, &opts)) != PAM_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\tif (!(opts.flags & FAILLOCK_FLAG_LOCAL_ONLY) ||\n\t\tcheck_local_user (pamh, opts.user) != 0) {\n\t\tcheck_tally(pamh, &opts, &tallies, &fd); /* for auditing */\n\t\treset_tally(pamh, &opts, &fd);\n\t}\n\n\ttally_cleanup(&tallies, fd);\n\nerr:\n\topts_cleanup(&opts);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "729-734",
    "snippet": "int\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t       int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t       int argc UNUSED, const char **argv UNUSED)\n{\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "670-725",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n\tstruct options opts;\n\tint rv, fd = -1;\n\tstruct tally_data tallies;\n\n\tmemset(&tallies, 0, sizeof(tallies));\n\n\trv = args_parse(pamh, argc, argv, flags, &opts);\n\tif (rv != PAM_SUCCESS)\n\t\tgoto err;\n\n\tif (!(opts.flags & FAILLOCK_FLAG_NO_DELAY)) {\n\t\tpam_fail_delay(pamh, 2000000);\t/* 2 sec delay on failure */\n\t}\n\n\tif ((rv=get_pam_user(pamh, &opts)) != PAM_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\tif (!(opts.flags & FAILLOCK_FLAG_LOCAL_ONLY) ||\n\t\tcheck_local_user (pamh, opts.user) != 0) {\n\t\tswitch (opts.action) {\n\t\t\tcase FAILLOCK_ACTION_PREAUTH:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_AUTH_ERR && !(opts.flags & FAILLOCK_FLAG_SILENT)) {\n\t\t\t\t\tfaillock_message(pamh, &opts);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FAILLOCK_ACTION_AUTHSUCC:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_SUCCESS) {\n\t\t\t\t\treset_tally(pamh, &opts, &fd);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FAILLOCK_ACTION_AUTHFAIL:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_SUCCESS) {\n\t\t\t\t\trv = PAM_IGNORE; /* this return value should be ignored */\n\t\t\t\t\twrite_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\ttally_cleanup(&tallies, fd);\n\nerr:\n\topts_cleanup(&opts);\n\n\treturn rv;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_NO_DELAY\t\t0x40",
      "#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20",
      "#define FAILLOCK_FLAG_SILENT\t\t0x4",
      "#define FAILLOCK_ACTION_AUTHFAIL 2",
      "#define FAILLOCK_ACTION_AUTHSUCC 1",
      "#define FAILLOCK_ACTION_PREAUTH  0"
    ],
    "globals_used": [
      "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "opts_cleanup",
          "args": [
            "&opts"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "opts_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "661-666",
          "snippet": "static void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tally_cleanup",
          "args": [
            "&tallies",
            "fd"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "tally_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "651-659",
          "snippet": "static void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tally",
          "args": [
            "pamh",
            "&opts",
            "&tallies",
            "&fd"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "write_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "507-612",
          "snippet": "static int\nwrite_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tstruct tally *records;\n\tunsigned int i;\n\tint failures;\n\tunsigned int oldest;\n\tuint64_t oldtime;\n\tconst void *source = NULL;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\tif (*fd == -1) {\n\t\tif (errno == EACCES) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\toldtime = 0;\n\toldest = 0;\n\tfailures = 0;\n\n\tfor (i = 0; i < tallies->count; ++i) {\n\t\tif (oldtime == 0 || tallies->records[i].time < oldtime) {\n\t\t\toldtime = tallies->records[i].time;\n\t\t\toldest = i;\n\t\t}\n\t\tif (opts->flags & FAILLOCK_FLAG_UNLOCKED ||\n\t\t\topts->now - tallies->records[i].time >= opts->fail_interval ) {\n\t\t\ttallies->records[i].status &= ~TALLY_STATUS_VALID;\n\t\t} else {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\tif (oldest >= tallies->count || (tallies->records[oldest].status & TALLY_STATUS_VALID)) {\n\t\toldest = tallies->count;\n\n\t\tif ((records=realloc(tallies->records, (oldest+1) * sizeof (*tallies->records))) == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory for tally records: %m\");\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\t++tallies->count;\n\t\ttallies->records = records;\n\t}\n\n\tmemset(&tallies->records[oldest], 0, sizeof (*tallies->records));\n\n\ttallies->records[oldest].status = TALLY_STATUS_VALID;\n\tif (pam_get_item(pamh, PAM_RHOST, &source) != PAM_SUCCESS || source == NULL) {\n\t\tif (pam_get_item(pamh, PAM_TTY, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\tif (pam_get_item(pamh, PAM_SERVICE, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\t\tsource = \"\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttallies->records[oldest].status |= TALLY_STATUS_TTY;\n\t\t}\n\t}\n\telse {\n\t\ttallies->records[oldest].status |= TALLY_STATUS_RHOST;\n\t}\n\n\tstrncpy(tallies->records[oldest].source, source, sizeof(tallies->records[oldest].source));\n\t/* source does not have to be null terminated */\n\n\ttallies->records[oldest].time = opts->now;\n\n\t++failures;\n\n\tif (opts->deny && failures == opts->deny) {\n#ifdef HAVE_LIBAUDIT\n\t\tchar buf[64];\n\t\tint audit_fd;\n\n\t\taudit_fd = audit_open();\n\t\t/* If there is an error & audit support is in the kernel report error */\n\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\terrno == EAFNOSUPPORT))\n\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\taudit_log_user_message(audit_fd, AUDIT_ANOM_LOGIN_FAILURES, buf,\n\t\t\tNULL, NULL, NULL, 1);\n\n\t\tif (!opts->is_admin || (opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_LOCK, buf,\n\t\t\t\tNULL, NULL, NULL, 1);\n\t\t}\n\t\tclose(audit_fd);\n#endif\n\t\tif (!(opts->flags & FAILLOCK_FLAG_NO_LOG_INFO)) {\n\t\t\tpam_syslog(pamh, LOG_INFO, \"Consecutive login failures for user %s account temporarily locked\",\n\t\t\t\topts->user);\n\t\t}\n\t}\n\n\tif (update_tally(*fd, tallies) == 0)\n\t\treturn PAM_SUCCESS;\n\n\treturn PAM_SYSTEM_ERR;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_UNLOCKED\t\t0x10",
            "#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8",
            "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_UNLOCKED\t\t0x10\n#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n\nstatic int\nwrite_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tstruct tally *records;\n\tunsigned int i;\n\tint failures;\n\tunsigned int oldest;\n\tuint64_t oldtime;\n\tconst void *source = NULL;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\tif (*fd == -1) {\n\t\tif (errno == EACCES) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\toldtime = 0;\n\toldest = 0;\n\tfailures = 0;\n\n\tfor (i = 0; i < tallies->count; ++i) {\n\t\tif (oldtime == 0 || tallies->records[i].time < oldtime) {\n\t\t\toldtime = tallies->records[i].time;\n\t\t\toldest = i;\n\t\t}\n\t\tif (opts->flags & FAILLOCK_FLAG_UNLOCKED ||\n\t\t\topts->now - tallies->records[i].time >= opts->fail_interval ) {\n\t\t\ttallies->records[i].status &= ~TALLY_STATUS_VALID;\n\t\t} else {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\tif (oldest >= tallies->count || (tallies->records[oldest].status & TALLY_STATUS_VALID)) {\n\t\toldest = tallies->count;\n\n\t\tif ((records=realloc(tallies->records, (oldest+1) * sizeof (*tallies->records))) == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory for tally records: %m\");\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\t++tallies->count;\n\t\ttallies->records = records;\n\t}\n\n\tmemset(&tallies->records[oldest], 0, sizeof (*tallies->records));\n\n\ttallies->records[oldest].status = TALLY_STATUS_VALID;\n\tif (pam_get_item(pamh, PAM_RHOST, &source) != PAM_SUCCESS || source == NULL) {\n\t\tif (pam_get_item(pamh, PAM_TTY, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\tif (pam_get_item(pamh, PAM_SERVICE, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\t\tsource = \"\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttallies->records[oldest].status |= TALLY_STATUS_TTY;\n\t\t}\n\t}\n\telse {\n\t\ttallies->records[oldest].status |= TALLY_STATUS_RHOST;\n\t}\n\n\tstrncpy(tallies->records[oldest].source, source, sizeof(tallies->records[oldest].source));\n\t/* source does not have to be null terminated */\n\n\ttallies->records[oldest].time = opts->now;\n\n\t++failures;\n\n\tif (opts->deny && failures == opts->deny) {\n#ifdef HAVE_LIBAUDIT\n\t\tchar buf[64];\n\t\tint audit_fd;\n\n\t\taudit_fd = audit_open();\n\t\t/* If there is an error & audit support is in the kernel report error */\n\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\terrno == EAFNOSUPPORT))\n\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\taudit_log_user_message(audit_fd, AUDIT_ANOM_LOGIN_FAILURES, buf,\n\t\t\tNULL, NULL, NULL, 1);\n\n\t\tif (!opts->is_admin || (opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_LOCK, buf,\n\t\t\t\tNULL, NULL, NULL, 1);\n\t\t}\n\t\tclose(audit_fd);\n#endif\n\t\tif (!(opts->flags & FAILLOCK_FLAG_NO_LOG_INFO)) {\n\t\t\tpam_syslog(pamh, LOG_INFO, \"Consecutive login failures for user %s account temporarily locked\",\n\t\t\t\topts->user);\n\t\t}\n\t}\n\n\tif (update_tally(*fd, tallies) == 0)\n\t\treturn PAM_SUCCESS;\n\n\treturn PAM_SYSTEM_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_tally",
          "args": [
            "pamh",
            "&opts",
            "&tallies",
            "&fd"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "check_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "411-489",
          "snippet": "static int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_UNLOCKED\t\t0x10",
            "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1",
            "#define FAILLOCK_ACTION_PREAUTH  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_UNLOCKED\t\t0x10\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_tally",
          "args": [
            "pamh",
            "&opts",
            "&fd"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "491-505",
          "snippet": "static void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "faillock_message",
          "args": [
            "pamh",
            "&opts"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "faillock_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "614-649",
          "snippet": "static void\nfaillock_message(pam_handle_t *pamh, struct options *opts)\n{\n\tint64_t left;\n\n\tif (!(opts->flags & FAILLOCK_FLAG_SILENT)) {\n\t\tif (opts->is_admin) {\n\t\t\tleft = opts->latest_time + opts->root_unlock_time - opts->now;\n\t\t}\n\t\telse {\n\t\t\tleft = opts->latest_time + opts->unlock_time - opts->now;\n\t\t}\n\n\t\tpam_info(pamh, _(\"The account is locked due to %u failed logins.\"),\n\t\t\t(unsigned int)opts->failures);\n\t\tif (left > 0) {\n\t\t\tleft = (left + 59)/60; /* minutes */\n\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tpam_info(\n\t\t\t\tpamh,\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t\t\"(%d minute left to unlock)\",\n\t\t\t\t\t\"(%d minutes left to unlock)\",\n\t\t\t\t\t(int)left),\n\t\t\t\t(int)left);\n#else\n\t\t\tif (left == 1)\n\t\t\t\tpam_info(pamh, _(\"(%d minute left to unlock)\"), (int)left);\n\t\t\telse\n\t\t\t\t/* TRANSLATORS: only used if dngettext is not supported. */\n\t\t\t\tpam_info(pamh, _(\"(%d minutes left to unlock)\"), (int)left);\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_SILENT\t\t0x4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n\nstatic void\nfaillock_message(pam_handle_t *pamh, struct options *opts)\n{\n\tint64_t left;\n\n\tif (!(opts->flags & FAILLOCK_FLAG_SILENT)) {\n\t\tif (opts->is_admin) {\n\t\t\tleft = opts->latest_time + opts->root_unlock_time - opts->now;\n\t\t}\n\t\telse {\n\t\t\tleft = opts->latest_time + opts->unlock_time - opts->now;\n\t\t}\n\n\t\tpam_info(pamh, _(\"The account is locked due to %u failed logins.\"),\n\t\t\t(unsigned int)opts->failures);\n\t\tif (left > 0) {\n\t\t\tleft = (left + 59)/60; /* minutes */\n\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tpam_info(\n\t\t\t\tpamh,\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t\t\"(%d minute left to unlock)\",\n\t\t\t\t\t\"(%d minutes left to unlock)\",\n\t\t\t\t\t(int)left),\n\t\t\t\t(int)left);\n#else\n\t\t\tif (left == 1)\n\t\t\t\tpam_info(pamh, _(\"(%d minute left to unlock)\"), (int)left);\n\t\t\telse\n\t\t\t\t/* TRANSLATORS: only used if dngettext is not supported. */\n\t\t\t\tpam_info(pamh, _(\"(%d minutes left to unlock)\"), (int)left);\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_local_user",
          "args": [
            "pamh",
            "opts.user"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "check_local_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "365-369",
          "snippet": "static int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pam_user",
          "args": [
            "pamh",
            "&opts"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "get_pam_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "371-409",
          "snippet": "static int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_FLAG_AUDIT\t\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n\nstatic int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_fail_delay",
          "args": [
            "pamh",
            "2000000"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args_parse",
          "args": [
            "pamh",
            "argc",
            "argv",
            "flags",
            "&opts"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "args_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "108-185",
          "snippet": "static int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023",
            "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
            "#define FAILLOCK_FLAG_SILENT\t\t0x4",
            "#define FAILLOCK_ACTION_AUTHFAIL 2",
            "#define FAILLOCK_ACTION_AUTHSUCC 1",
            "#define FAILLOCK_ACTION_PREAUTH  0"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_ACTION_AUTHFAIL 2\n#define FAILLOCK_ACTION_AUTHSUCC 1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\n\nstatic int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tallies",
            "0",
            "sizeof(tallies)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_NO_DELAY\t\t0x40\n#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_ACTION_AUTHFAIL 2\n#define FAILLOCK_ACTION_AUTHSUCC 1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n\tstruct options opts;\n\tint rv, fd = -1;\n\tstruct tally_data tallies;\n\n\tmemset(&tallies, 0, sizeof(tallies));\n\n\trv = args_parse(pamh, argc, argv, flags, &opts);\n\tif (rv != PAM_SUCCESS)\n\t\tgoto err;\n\n\tif (!(opts.flags & FAILLOCK_FLAG_NO_DELAY)) {\n\t\tpam_fail_delay(pamh, 2000000);\t/* 2 sec delay on failure */\n\t}\n\n\tif ((rv=get_pam_user(pamh, &opts)) != PAM_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\tif (!(opts.flags & FAILLOCK_FLAG_LOCAL_ONLY) ||\n\t\tcheck_local_user (pamh, opts.user) != 0) {\n\t\tswitch (opts.action) {\n\t\t\tcase FAILLOCK_ACTION_PREAUTH:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_AUTH_ERR && !(opts.flags & FAILLOCK_FLAG_SILENT)) {\n\t\t\t\t\tfaillock_message(pamh, &opts);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FAILLOCK_ACTION_AUTHSUCC:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_SUCCESS) {\n\t\t\t\t\treset_tally(pamh, &opts, &fd);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FAILLOCK_ACTION_AUTHFAIL:\n\t\t\t\trv = check_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\tif (rv == PAM_SUCCESS) {\n\t\t\t\t\trv = PAM_IGNORE; /* this return value should be ignored */\n\t\t\t\t\twrite_tally(pamh, &opts, &tallies, &fd);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\ttally_cleanup(&tallies, fd);\n\nerr:\n\topts_cleanup(&opts);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "opts_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "661-666",
    "snippet": "static void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "opts->admin_group"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}"
  },
  {
    "function_name": "tally_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "651-659",
    "snippet": "static void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tallies->records"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\ntally_cleanup(struct tally_data *tallies, int fd)\n{\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n\n\tfree(tallies->records);\n}"
  },
  {
    "function_name": "faillock_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "614-649",
    "snippet": "static void\nfaillock_message(pam_handle_t *pamh, struct options *opts)\n{\n\tint64_t left;\n\n\tif (!(opts->flags & FAILLOCK_FLAG_SILENT)) {\n\t\tif (opts->is_admin) {\n\t\t\tleft = opts->latest_time + opts->root_unlock_time - opts->now;\n\t\t}\n\t\telse {\n\t\t\tleft = opts->latest_time + opts->unlock_time - opts->now;\n\t\t}\n\n\t\tpam_info(pamh, _(\"The account is locked due to %u failed logins.\"),\n\t\t\t(unsigned int)opts->failures);\n\t\tif (left > 0) {\n\t\t\tleft = (left + 59)/60; /* minutes */\n\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tpam_info(\n\t\t\t\tpamh,\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t\t\"(%d minute left to unlock)\",\n\t\t\t\t\t\"(%d minutes left to unlock)\",\n\t\t\t\t\t(int)left),\n\t\t\t\t(int)left);\n#else\n\t\t\tif (left == 1)\n\t\t\t\tpam_info(pamh, _(\"(%d minute left to unlock)\"), (int)left);\n\t\t\telse\n\t\t\t\t/* TRANSLATORS: only used if dngettext is not supported. */\n\t\t\t\tpam_info(pamh, _(\"(%d minutes left to unlock)\"), (int)left);\n#endif\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_SILENT\t\t0x4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"(%d minutes left to unlock)\")",
            "(int)left"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(%d minutes left to unlock)\""
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "opts_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "661-666",
          "snippet": "static void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nopts_cleanup(struct options *opts)\n{\n\tfree(opts->dir);\n\tfree(opts->admin_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"(%d minute left to unlock)\")",
            "(int)left"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "dngettext(PACKAGE,\n\t\t\t\t\t\"(%d minute left to unlock)\",\n\t\t\t\t\t\"(%d minutes left to unlock)\",\n\t\t\t\t\t(int)left)",
            "(int)left"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dngettext",
          "args": [
            "PACKAGE",
            "\"(%d minute left to unlock)\"",
            "\"(%d minutes left to unlock)\"",
            "(int)left"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"The account is locked due to %u failed logins.\")",
            "(unsigned int)opts->failures"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n\nstatic void\nfaillock_message(pam_handle_t *pamh, struct options *opts)\n{\n\tint64_t left;\n\n\tif (!(opts->flags & FAILLOCK_FLAG_SILENT)) {\n\t\tif (opts->is_admin) {\n\t\t\tleft = opts->latest_time + opts->root_unlock_time - opts->now;\n\t\t}\n\t\telse {\n\t\t\tleft = opts->latest_time + opts->unlock_time - opts->now;\n\t\t}\n\n\t\tpam_info(pamh, _(\"The account is locked due to %u failed logins.\"),\n\t\t\t(unsigned int)opts->failures);\n\t\tif (left > 0) {\n\t\t\tleft = (left + 59)/60; /* minutes */\n\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n\t\t\tpam_info(\n\t\t\t\tpamh,\n\t\t\t\tdngettext(PACKAGE,\n\t\t\t\t\t\"(%d minute left to unlock)\",\n\t\t\t\t\t\"(%d minutes left to unlock)\",\n\t\t\t\t\t(int)left),\n\t\t\t\t(int)left);\n#else\n\t\t\tif (left == 1)\n\t\t\t\tpam_info(pamh, _(\"(%d minute left to unlock)\"), (int)left);\n\t\t\telse\n\t\t\t\t/* TRANSLATORS: only used if dngettext is not supported. */\n\t\t\t\tpam_info(pamh, _(\"(%d minutes left to unlock)\"), (int)left);\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "write_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "507-612",
    "snippet": "static int\nwrite_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tstruct tally *records;\n\tunsigned int i;\n\tint failures;\n\tunsigned int oldest;\n\tuint64_t oldtime;\n\tconst void *source = NULL;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\tif (*fd == -1) {\n\t\tif (errno == EACCES) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\toldtime = 0;\n\toldest = 0;\n\tfailures = 0;\n\n\tfor (i = 0; i < tallies->count; ++i) {\n\t\tif (oldtime == 0 || tallies->records[i].time < oldtime) {\n\t\t\toldtime = tallies->records[i].time;\n\t\t\toldest = i;\n\t\t}\n\t\tif (opts->flags & FAILLOCK_FLAG_UNLOCKED ||\n\t\t\topts->now - tallies->records[i].time >= opts->fail_interval ) {\n\t\t\ttallies->records[i].status &= ~TALLY_STATUS_VALID;\n\t\t} else {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\tif (oldest >= tallies->count || (tallies->records[oldest].status & TALLY_STATUS_VALID)) {\n\t\toldest = tallies->count;\n\n\t\tif ((records=realloc(tallies->records, (oldest+1) * sizeof (*tallies->records))) == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory for tally records: %m\");\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\t++tallies->count;\n\t\ttallies->records = records;\n\t}\n\n\tmemset(&tallies->records[oldest], 0, sizeof (*tallies->records));\n\n\ttallies->records[oldest].status = TALLY_STATUS_VALID;\n\tif (pam_get_item(pamh, PAM_RHOST, &source) != PAM_SUCCESS || source == NULL) {\n\t\tif (pam_get_item(pamh, PAM_TTY, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\tif (pam_get_item(pamh, PAM_SERVICE, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\t\tsource = \"\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttallies->records[oldest].status |= TALLY_STATUS_TTY;\n\t\t}\n\t}\n\telse {\n\t\ttallies->records[oldest].status |= TALLY_STATUS_RHOST;\n\t}\n\n\tstrncpy(tallies->records[oldest].source, source, sizeof(tallies->records[oldest].source));\n\t/* source does not have to be null terminated */\n\n\ttallies->records[oldest].time = opts->now;\n\n\t++failures;\n\n\tif (opts->deny && failures == opts->deny) {\n#ifdef HAVE_LIBAUDIT\n\t\tchar buf[64];\n\t\tint audit_fd;\n\n\t\taudit_fd = audit_open();\n\t\t/* If there is an error & audit support is in the kernel report error */\n\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\terrno == EAFNOSUPPORT))\n\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\taudit_log_user_message(audit_fd, AUDIT_ANOM_LOGIN_FAILURES, buf,\n\t\t\tNULL, NULL, NULL, 1);\n\n\t\tif (!opts->is_admin || (opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_LOCK, buf,\n\t\t\t\tNULL, NULL, NULL, 1);\n\t\t}\n\t\tclose(audit_fd);\n#endif\n\t\tif (!(opts->flags & FAILLOCK_FLAG_NO_LOG_INFO)) {\n\t\t\tpam_syslog(pamh, LOG_INFO, \"Consecutive login failures for user %s account temporarily locked\",\n\t\t\t\topts->user);\n\t\t}\n\t}\n\n\tif (update_tally(*fd, tallies) == 0)\n\t\treturn PAM_SUCCESS;\n\n\treturn PAM_SYSTEM_ERR;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_UNLOCKED\t\t0x10",
      "#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8",
      "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_tally",
          "args": [
            "*fd",
            "tallies"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "update_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "150-176",
          "snippet": "int\nupdate_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = tallies->records;\n\tunsigned int count = tallies->count;\n\tssize_t chunk;\n\n\tif (tallies->count > MAX_RECORDS) {\n\t\tdata = tallies->records + (count - MAX_RECORDS);\n\t\tcount = MAX_RECORDS;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n\t\treturn -1;\n\t}\n\n\tchunk = pam_modutil_write(fd, data, count * sizeof(struct tally));\n\n\tif (chunk != (ssize_t)(count * sizeof(struct tally))) {\n\t\treturn -1;\n\t}\n\n\tif (ftruncate(fd, count * sizeof(struct tally)) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_RECORDS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define MAX_RECORDS 1024\n\nint\nupdate_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = tallies->records;\n\tunsigned int count = tallies->count;\n\tssize_t chunk;\n\n\tif (tallies->count > MAX_RECORDS) {\n\t\tdata = tallies->records + (count - MAX_RECORDS);\n\t\tcount = MAX_RECORDS;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) == (off_t)-1) {\n\t\treturn -1;\n\t}\n\n\tchunk = pam_modutil_write(fd, data, count * sizeof(struct tally));\n\n\tif (chunk != (ssize_t)(count * sizeof(struct tally))) {\n\t\treturn -1;\n\t}\n\n\tif (ftruncate(fd, count * sizeof(struct tally)) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Consecutive login failures for user %s account temporarily locked\"",
            "opts->user"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "audit_fd"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_user_message",
          "args": [
            "audit_fd",
            "AUDIT_RESP_ACCT_LOCK",
            "buf",
            "NULL",
            "NULL",
            "NULL",
            "1"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_user_message",
          "args": [
            "audit_fd",
            "AUDIT_ANOM_LOGIN_FAILURES",
            "buf",
            "NULL",
            "NULL",
            "NULL",
            "1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"pam_faillock uid=%u \"",
            "opts->uid"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_open",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tallies->records[oldest].source",
            "source",
            "sizeof(tallies->records[oldest].source)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&source"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&source"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&source"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tallies->records[oldest]",
            "0",
            "sizeof (*tallies->records)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Error allocating memory for tally records: %m\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "tallies->records",
            "(oldest+1) * sizeof (*tallies->records)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error opening the tally file for %s: %m\"",
            "opts->user"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_tally",
          "args": [
            "opts->dir",
            "opts->user",
            "opts->uid",
            "1"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "open_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "53-110",
          "snippet": "int\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nint\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_UNLOCKED\t\t0x10\n#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n\nstatic int\nwrite_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tstruct tally *records;\n\tunsigned int i;\n\tint failures;\n\tunsigned int oldest;\n\tuint64_t oldtime;\n\tconst void *source = NULL;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\tif (*fd == -1) {\n\t\tif (errno == EACCES) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\toldtime = 0;\n\toldest = 0;\n\tfailures = 0;\n\n\tfor (i = 0; i < tallies->count; ++i) {\n\t\tif (oldtime == 0 || tallies->records[i].time < oldtime) {\n\t\t\toldtime = tallies->records[i].time;\n\t\t\toldest = i;\n\t\t}\n\t\tif (opts->flags & FAILLOCK_FLAG_UNLOCKED ||\n\t\t\topts->now - tallies->records[i].time >= opts->fail_interval ) {\n\t\t\ttallies->records[i].status &= ~TALLY_STATUS_VALID;\n\t\t} else {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\tif (oldest >= tallies->count || (tallies->records[oldest].status & TALLY_STATUS_VALID)) {\n\t\toldest = tallies->count;\n\n\t\tif ((records=realloc(tallies->records, (oldest+1) * sizeof (*tallies->records))) == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory for tally records: %m\");\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\t++tallies->count;\n\t\ttallies->records = records;\n\t}\n\n\tmemset(&tallies->records[oldest], 0, sizeof (*tallies->records));\n\n\ttallies->records[oldest].status = TALLY_STATUS_VALID;\n\tif (pam_get_item(pamh, PAM_RHOST, &source) != PAM_SUCCESS || source == NULL) {\n\t\tif (pam_get_item(pamh, PAM_TTY, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\tif (pam_get_item(pamh, PAM_SERVICE, &source) != PAM_SUCCESS || source == NULL) {\n\t\t\t\tsource = \"\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttallies->records[oldest].status |= TALLY_STATUS_TTY;\n\t\t}\n\t}\n\telse {\n\t\ttallies->records[oldest].status |= TALLY_STATUS_RHOST;\n\t}\n\n\tstrncpy(tallies->records[oldest].source, source, sizeof(tallies->records[oldest].source));\n\t/* source does not have to be null terminated */\n\n\ttallies->records[oldest].time = opts->now;\n\n\t++failures;\n\n\tif (opts->deny && failures == opts->deny) {\n#ifdef HAVE_LIBAUDIT\n\t\tchar buf[64];\n\t\tint audit_fd;\n\n\t\taudit_fd = audit_open();\n\t\t/* If there is an error & audit support is in the kernel report error */\n\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\terrno == EAFNOSUPPORT))\n\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\taudit_log_user_message(audit_fd, AUDIT_ANOM_LOGIN_FAILURES, buf,\n\t\t\tNULL, NULL, NULL, 1);\n\n\t\tif (!opts->is_admin || (opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_LOCK, buf,\n\t\t\t\tNULL, NULL, NULL, 1);\n\t\t}\n\t\tclose(audit_fd);\n#endif\n\t\tif (!(opts->flags & FAILLOCK_FLAG_NO_LOG_INFO)) {\n\t\t\tpam_syslog(pamh, LOG_INFO, \"Consecutive login failures for user %s account temporarily locked\",\n\t\t\t\topts->user);\n\t\t}\n\t}\n\n\tif (update_tally(*fd, tallies) == 0)\n\t\treturn PAM_SUCCESS;\n\n\treturn PAM_SYSTEM_ERR;\n}"
  },
  {
    "function_name": "reset_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "491-505",
    "snippet": "static void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error clearing the tally file for %s: %m\"",
            "opts->user"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "*fd",
            "0"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_tally",
          "args": [
            "opts->dir",
            "opts->user",
            "opts->uid",
            "1"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "open_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "53-110",
          "snippet": "int\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nint\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void\nreset_tally(pam_handle_t *pamh, struct options *opts, int *fd)\n{\n\tint rv;\n\n\tif (*fd == -1) {\n\t\t*fd = open_tally(opts->dir, opts->user, opts->uid, 1);\n\t}\n\telse {\n\t\twhile ((rv=ftruncate(*fd, 0)) == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Error clearing the tally file for %s: %m\", opts->user);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_tally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "411-489",
    "snippet": "static int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_UNLOCKED\t\t0x10",
      "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1",
      "#define FAILLOCK_ACTION_PREAUTH  0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_user_message",
          "args": [
            "audit_fd",
            "AUDIT_RESP_ACCT_UNLOCK_TIMED",
            "buf",
            "rhost",
            "NULL",
            "tty",
            "1"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"pam_faillock uid=%u \"",
            "opts->uid"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&rhost"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&tty"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_open",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error reading the tally file for %s: %m\"",
            "opts->user"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_tally",
          "args": [
            "tfd",
            "tallies"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "read_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "115-148",
          "snippet": "int\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_RECORDS 1024",
            "#define CHUNK_SIZE (64 * sizeof(struct tally))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define MAX_RECORDS 1024\n#define CHUNK_SIZE (64 * sizeof(struct tally))\n\nint\nread_tally(int fd, struct tally_data *tallies)\n{\n\tvoid *data = NULL, *newdata;\n\tunsigned int count = 0;\n\tssize_t chunk = 0;\n\n\tdo {\n\t\tnewdata = realloc(data, count * sizeof(struct tally) + CHUNK_SIZE);\n\t\tif (newdata == NULL) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = newdata;\n\n\t\tchunk = pam_modutil_read(fd, (char *)data + count * sizeof(struct tally), CHUNK_SIZE);\n\t\tif (chunk < 0) {\n\t\t\tfree(data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += chunk/sizeof(struct tally);\n\n\t\tif (count >= MAX_RECORDS)\n\t\t\tbreak;\n\t}\n\twhile (chunk == CHUNK_SIZE);\n\n\ttallies->records = data;\n\ttallies->count = count;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error opening the tally file for %s: %m\"",
            "opts->user"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_tally",
          "args": [
            "opts->dir",
            "opts->user",
            "opts->uid",
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "open_tally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/faillock.c",
          "lines": "53-110",
          "snippet": "int\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include <security/pam_modutil.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include <security/pam_modutil.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\nint\nopen_tally (const char *dir, const char *user, uid_t uid, int create)\n{\n\tchar *path;\n\tint flags = O_RDWR;\n\tint fd;\n\n\tif (dir == NULL || strstr(user, \"../\") != NULL)\n\t/* just a defensive programming as the user must be a\n\t * valid user on the system anyway\n\t */\n\t\treturn -1;\n\tpath = malloc(strlen(dir) + strlen(user) + 2);\n\tif (path == NULL)\n\t\treturn -1;\n\n\tstrcpy(path, dir);\n\tif (*dir && dir[strlen(dir) - 1] != '/') {\n\t\tstrcat(path, \"/\");\n\t}\n\tstrcat(path, user);\n\n\tif (create) {\n\t\tflags |= O_CREAT;\n\t\tif (access(dir, F_OK) != 0) {\n\t\t\tmkdir(dir, 0755);\n\t\t}\n\t}\n\n\tfd = open(path, flags, 0660);\n\n\tfree(path);\n\n\tif (fd != -1) {\n\t\tstruct stat st;\n\n\t\twhile (flock(fd, LOCK_EX) == -1 && errno == EINTR);\n\t\tif (fstat(fd, &st) == 0) {\n\t\t\tif (st.st_uid != uid) {\n\t\t\t\tignore_return(fchown(fd, uid, -1));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If umask is set to 022, as will probably in most systems, then the\n\t\t\t * group will not be able to write to the file. So, change the file\n\t\t\t * permissions just in case.\n\t\t\t * Note: owners of this file are user:root, so if the permissions are\n\t\t\t * not changed the root process writing to this file will require\n\t\t\t * CAP_DAC_OVERRIDE.\n\t\t\t */\n\t\t\tif (!(st.st_mode & S_IWGRP)) {\n\t\t\t\tignore_return(fchmod(fd, 0660));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_UNLOCKED\t\t0x10\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic int\ncheck_tally(pam_handle_t *pamh, struct options *opts, struct tally_data *tallies, int *fd)\n{\n\tint tfd;\n\tunsigned int i;\n\tuint64_t latest_time;\n\tint failures;\n\n\topts->now = time(NULL);\n\n\ttfd = open_tally(opts->dir, opts->user, opts->uid, 0);\n\n\t*fd = tfd;\n\n\tif (tfd == -1) {\n\t\tif (errno == EACCES || errno == ENOENT) {\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\tpam_syslog(pamh, LOG_ERR, \"Error opening the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (read_tally(tfd, tallies) != 0) {\n\t\tpam_syslog(pamh, LOG_ERR, \"Error reading the tally file for %s: %m\", opts->user);\n\t\treturn PAM_SYSTEM_ERR;\n\t}\n\n\tif (opts->is_admin && !(opts->flags & FAILLOCK_FLAG_DENY_ROOT)) {\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tlatest_time = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\ttallies->records[i].time > latest_time)\n\t\t\tlatest_time = tallies->records[i].time;\n\t}\n\n\topts->latest_time = latest_time;\n\n\tfailures = 0;\n\tfor (i = 0; i < tallies->count; i++) {\n\t\tif ((tallies->records[i].status & TALLY_STATUS_VALID) &&\n\t\t\tlatest_time - tallies->records[i].time < opts->fail_interval) {\n\t\t\t++failures;\n\t\t}\n\t}\n\n\topts->failures = failures;\n\n\tif (opts->deny && failures >= opts->deny) {\n\t\tif ((!opts->is_admin && opts->unlock_time && latest_time + opts->unlock_time < opts->now) ||\n\t\t\t(opts->is_admin && opts->root_unlock_time && latest_time + opts->root_unlock_time < opts->now)) {\n#ifdef HAVE_LIBAUDIT\n\t\t\tif (opts->action != FAILLOCK_ACTION_PREAUTH) { /* do not audit in preauth */\n\t\t\t\tchar buf[64];\n\t\t\t\tint audit_fd;\n\t\t\t\tconst void *rhost = NULL, *tty = NULL;\n\n\t\t\t\taudit_fd = audit_open();\n\t\t\t\t/* If there is an error & audit support is in the kernel report error */\n\t\t\t\tif ((audit_fd < 0) && !(errno == EINVAL || errno == EPROTONOSUPPORT ||\n\t\t\t\t\terrno == EAFNOSUPPORT))\n\t\t\t\t\treturn PAM_SYSTEM_ERR;\n\n\t\t\t\t(void)pam_get_item(pamh, PAM_TTY, &tty);\n\t\t\t\t(void)pam_get_item(pamh, PAM_RHOST, &rhost);\n\t\t\t\tsnprintf(buf, sizeof(buf), \"pam_faillock uid=%u \", opts->uid);\n\t\t\t\taudit_log_user_message(audit_fd, AUDIT_RESP_ACCT_UNLOCK_TIMED, buf,\n\t\t\t\t\trhost, NULL, tty, 1);\n\t\t\t}\n#endif\n\t\t\topts->flags |= FAILLOCK_FLAG_UNLOCKED;\n\t\t\treturn PAM_SUCCESS;\n\t\t}\n\t\treturn PAM_AUTH_ERR;\n\t}\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "get_pam_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "371-409",
    "snippet": "static int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_FLAG_AUDIT\t\t0x2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_uid_nam",
          "args": [
            "pamh",
            "pwd->pw_uid",
            "opts->admin_group"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"User unknown\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"User unknown: %s\"",
            "user"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n\nstatic int\nget_pam_user(pam_handle_t *pamh, struct options *opts)\n{\n\tconst char *user;\n\tint rv;\n\tstruct passwd *pwd;\n\n\tif ((rv=pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {\n\t\treturn rv == PAM_CONV_AGAIN ? PAM_INCOMPLETE : rv;\n\t}\n\n\tif (*user == '\\0') {\n\t\treturn PAM_IGNORE;\n\t}\n\n\tif ((pwd=pam_modutil_getpwnam(pamh, user)) == NULL) {\n\t\tif (opts->flags & FAILLOCK_FLAG_AUDIT) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown: %s\", user);\n\t\t}\n\t\telse {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"User unknown\");\n\t\t}\n\t\treturn PAM_IGNORE;\n\t}\n\topts->user = user;\n\topts->uid = pwd->pw_uid;\n\n\tif (pwd->pw_uid == 0) {\n\t\topts->is_admin = 1;\n\t\treturn PAM_SUCCESS;\n\t}\n\n\tif (opts->admin_group && *opts->admin_group) {\n\t\topts->is_admin = pam_modutil_user_in_group_uid_nam(pamh,\n\t\t\tpwd->pw_uid, opts->admin_group);\n\t}\n\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "check_local_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "365-369",
    "snippet": "static int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_check_user_in_passwd",
          "args": [
            "pamh",
            "user",
            "NULL"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int\ncheck_local_user (pam_handle_t *pamh, const char *user)\n{\n\treturn pam_modutil_check_user_in_passwd(pamh, user, NULL) == PAM_SUCCESS;\n}"
  },
  {
    "function_name": "set_conf_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "277-363",
    "snippet": "static void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
      "#define FAILLOCK_FLAG_NO_DELAY\t\t0x40",
      "#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20",
      "#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8",
      "#define FAILLOCK_FLAG_SILENT\t\t0x4",
      "#define FAILLOCK_FLAG_AUDIT\t\t0x2",
      "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1"
    ],
    "globals_used": [
      "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown option: %s\"",
            "name"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"nodelay\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"local_users_only\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"no_log_info\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"silent\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"audit\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"even_deny_root\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Error allocating memory: %m\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "value"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "opts->admin_group"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"admin_group\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Bad number supplied for root_unlock_time argument\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "value",
            "\"%u\"",
            "&temp"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"never\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"root_unlock_time\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Bad number supplied for unlock_time argument\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "value",
            "\"%u\"",
            "&temp"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"never\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"unlock_time\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Bad number supplied for fail_interval argument\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "value",
            "\"%u\"",
            "&temp"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"fail_interval\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Bad number supplied for deny argument\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "value",
            "\"%hu\"",
            "&opts->deny"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"deny\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "value"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Tally directory is not absolute path (%s); keeping default\"",
            "value"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"dir\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_NO_DELAY\t\t0x40\n#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20\n#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}"
  },
  {
    "function_name": "read_config_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "188-275",
    "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_CONF_MAX_LINELEN 1023"
    ],
    "globals_used": [
      "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
      "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
      "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_conf_opt",
          "args": [
            "pamh",
            "opts",
            "name",
            "ptr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "set_conf_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "277-363",
          "snippet": "static void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
            "#define FAILLOCK_FLAG_NO_DELAY\t\t0x40",
            "#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20",
            "#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8",
            "#define FAILLOCK_FLAG_SILENT\t\t0x4",
            "#define FAILLOCK_FLAG_AUDIT\t\t0x2",
            "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1"
          ],
          "globals_used": [
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_NO_DELAY\t\t0x40\n#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20\n#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*ptr"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*ptr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*ptr"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*(ptr-1)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "linebuf",
            "'#'"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "f"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "linebuf"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "linebuf",
            "sizeof(linebuf)",
            "f"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "VENDOR_FAILLOCK_DEFAULT_CONF",
            "\"r\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "cfgfile",
            "\"r\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
  },
  {
    "function_name": "args_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
    "lines": "108-185",
    "snippet": "static int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}",
    "includes": [
      "#include \"faillock.h\"",
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <libaudit.h>",
      "#include <ctype.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FAILLOCK_CONF_MAX_LINELEN 1023",
      "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
      "#define FAILLOCK_FLAG_SILENT\t\t0x4",
      "#define FAILLOCK_ACTION_AUTHFAIL 2",
      "#define FAILLOCK_ACTION_AUTHSUCC 1",
      "#define FAILLOCK_ACTION_PREAUTH  0"
    ],
    "globals_used": [
      "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"Error allocating memory: %m\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_conf_opt",
          "args": [
            "pamh",
            "opts",
            "buf",
            "val"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "set_conf_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "277-363",
          "snippet": "static void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_TIME_INTERVAL 604800 /* 7 days */",
            "#define FAILLOCK_FLAG_NO_DELAY\t\t0x40",
            "#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20",
            "#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8",
            "#define FAILLOCK_FLAG_SILENT\t\t0x4",
            "#define FAILLOCK_FLAG_AUDIT\t\t0x2",
            "#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1"
          ],
          "globals_used": [
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_NO_DELAY\t\t0x40\n#define FAILLOCK_FLAG_LOCAL_ONLY\t0x20\n#define FAILLOCK_FLAG_NO_LOG_INFO\t0x8\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_FLAG_AUDIT\t\t0x2\n#define FAILLOCK_FLAG_DENY_ROOT\t\t0x1\n\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic void\nset_conf_opt(pam_handle_t *pamh, struct options *opts, const char *name, const char *value)\n{\n\tif (strcmp(name, \"dir\") == 0) {\n\t\tif (value[0] != '/') {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Tally directory is not absolute path (%s); keeping default\", value);\n\t\t} else {\n\t\t\tfree(opts->dir);\n\t\t\topts->dir = strdup(value);\n\t\t}\n\t}\n\telse if (strcmp(name, \"deny\") == 0) {\n\t\tif (sscanf(value, \"%hu\", &opts->deny) != 1) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for deny argument\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"fail_interval\") == 0) {\n\t\tunsigned int temp;\n\t\tif (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for fail_interval argument\");\n\t\t} else {\n\t\t\topts->fail_interval = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for unlock_time argument\");\n\t\t}\n\t\telse {\n\t\t\topts->unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"root_unlock_time\") == 0) {\n\t\tunsigned int temp;\n\n\t\tif (strcmp(value, \"never\") == 0) {\n\t\t\topts->root_unlock_time = 0;\n\t\t}\n\t\telse if (sscanf(value, \"%u\", &temp) != 1 ||\n\t\t\ttemp > MAX_TIME_INTERVAL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\"Bad number supplied for root_unlock_time argument\");\n\t\t} else {\n\t\t\topts->root_unlock_time = temp;\n\t\t}\n\t}\n\telse if (strcmp(name, \"admin_group\") == 0) {\n\t\tfree(opts->admin_group);\n\t\topts->admin_group = strdup(value);\n\t\tif (opts->admin_group == NULL) {\n\t\t\topts->fatal_error = 1;\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\t}\n\t}\n\telse if (strcmp(name, \"even_deny_root\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_DENY_ROOT;\n\t}\n\telse if (strcmp(name, \"audit\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_AUDIT;\n\t}\n\telse if (strcmp(name, \"silent\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\t}\n\telse if (strcmp(name, \"no_log_info\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_LOG_INFO;\n\t}\n\telse if (strcmp(name, \"local_users_only\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_LOCAL_ONLY;\n\t}\n\telse if (strcmp(name, \"nodelay\") == 0) {\n\t\topts->flags |= FAILLOCK_FLAG_NO_DELAY;\n\t}\n\telse {\n\t\tpam_syslog(pamh, LOG_ERR, \"Unknown option: %s\", name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'='"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "argv[i]",
            "sizeof(buf) - 1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"authsucc\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"authfail\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"preauth\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Configuration file missing or broken\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_config_file",
          "args": [
            "pamh",
            "opts",
            "conf"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_faillock/pam_faillock.c",
          "lines": "188-275",
          "snippet": "static int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}",
          "includes": [
            "#include \"faillock.h\"",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <libaudit.h>",
            "#include <ctype.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FAILLOCK_CONF_MAX_LINELEN 1023"
          ],
          "globals_used": [
            "static const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;",
            "static int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);",
            "static void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\nstatic int read_config_file(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *cfgfile\n);\nstatic void set_conf_opt(\n\tpam_handle_t *pamh,\n\tstruct options *opts,\n\tconst char *name,\n\tconst char *value\n);\n\nstatic int\nread_config_file(pam_handle_t *pamh, struct options *opts, const char *cfgfile)\n{\n\tFILE *f;\n\tchar linebuf[FAILLOCK_CONF_MAX_LINELEN+1];\n\n\tf = fopen(cfgfile, \"r\");\n#ifdef VENDOR_FAILLOCK_DEFAULT_CONF\n\tif (f == NULL && errno == ENOENT && cfgfile == default_faillock_conf) {\n\t  /*\n\t   * If the default configuration file in /etc does not exist,\n\t   * try the vendor configuration file as fallback.\n\t   */\n\t  f = fopen(VENDOR_FAILLOCK_DEFAULT_CONF, \"r\");\n\t}\n#endif\n\tif (f == NULL) {\n\t\t/* ignore non-existent default config file */\n\t\tif (errno == ENOENT && cfgfile == default_faillock_conf)\n\t\t\treturn PAM_SUCCESS;\n\t\treturn PAM_SERVICE_ERR;\n\t}\n\n\twhile (fgets(linebuf, sizeof(linebuf), f) != NULL) {\n\t\tsize_t len;\n\t\tchar *ptr;\n\t\tchar *name;\n\t\tint eq;\n\n\t\tlen = strlen(linebuf);\n\t\t/* len cannot be 0 unless there is a bug in fgets */\n\t\tif (len && linebuf[len - 1] != '\\n' && !feof(f)) {\n\t\t\t(void) fclose(f);\n\t\t\treturn PAM_SERVICE_ERR;\n\t\t}\n\n\t\tif ((ptr=strchr(linebuf, '#')) != NULL) {\n\t\t\t*ptr = '\\0';\n\t\t} else {\n\t\t\tptr = linebuf + len;\n\t\t}\n\n\t\t/* drop terminating whitespace including the \\n */\n\t\twhile (ptr > linebuf) {\n\t\t\tif (!isspace(*(ptr-1))) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t--ptr;\n\t\t}\n\n\t\t/* skip initial whitespace */\n\t\tfor (ptr = linebuf; isspace(*ptr); ptr++);\n\t\tif (*ptr == '\\0')\n\t\t\tcontinue;\n\n\t\t/* grab the key name */\n\t\teq = 0;\n\t\tname = ptr;\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (isspace(*ptr) || *ptr == '=') {\n\t\t\t\teq = *ptr == '=';\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* grab the key value */\n\t\twhile (*ptr != '\\0') {\n\t\t\tif (*ptr != '=' || eq) {\n\t\t\t\tif (!isspace(*ptr)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq = 1;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\n\t\t/* set the key:value pair on opts */\n\t\tset_conf_opt(pamh, opts, name, ptr);\n\t}\n\n\t(void)fclose(f);\n\treturn PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"conf=\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "FAILLOCK_DEFAULT_TALLYDIR"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "opts",
            "0",
            "sizeof(*opts)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faillock.h\"\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <libaudit.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define FAILLOCK_CONF_MAX_LINELEN 1023\n#define MAX_TIME_INTERVAL 604800 /* 7 days */\n#define FAILLOCK_FLAG_SILENT\t\t0x4\n#define FAILLOCK_ACTION_AUTHFAIL 2\n#define FAILLOCK_ACTION_AUTHSUCC 1\n#define FAILLOCK_ACTION_PREAUTH  0\n\nstatic const char default_faillock_conf[] = FAILLOCK_DEFAULT_CONF;\n\nstatic int\nargs_parse(pam_handle_t *pamh, int argc, const char **argv,\n\t\tint flags, struct options *opts)\n{\n\tint i;\n\tint config_arg_index = -1;\n\tint rv;\n\tconst char *conf = default_faillock_conf;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\topts->dir = strdup(FAILLOCK_DEFAULT_TALLYDIR);\n\topts->deny = 3;\n\topts->fail_interval = 900;\n\topts->unlock_time = 600;\n\topts->root_unlock_time = MAX_TIME_INTERVAL+1;\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tconst char *str = pam_str_skip_prefix(argv[i], \"conf=\");\n\n\t\tif (str != NULL) {\n\t\t\tconf = str;\n\t\t\tconfig_arg_index = i;\n\t\t}\n\t}\n\n\tif ((rv = read_config_file(pamh, opts, conf)) != PAM_SUCCESS) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\"Configuration file missing or broken\");\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (i == config_arg_index) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strcmp(argv[i], \"preauth\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_PREAUTH;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authfail\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHFAIL;\n\t\t}\n\t\telse if (strcmp(argv[i], \"authsucc\") == 0) {\n\t\t\topts->action = FAILLOCK_ACTION_AUTHSUCC;\n\t\t}\n\t\telse {\n\t\t\tchar buf[FAILLOCK_CONF_MAX_LINELEN + 1];\n\t\t\tchar *val;\n\n\t\t\tstrncpy(buf, argv[i], sizeof(buf) - 1);\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\t\tval = strchr(buf, '=');\n\t\t\tif (val != NULL) {\n\t\t\t\t*val = '\\0';\n\t\t\t\t++val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = buf + sizeof(buf) - 1;\n\t\t\t}\n\t\t\tset_conf_opt(pamh, opts, buf, val);\n\t\t}\n\t}\n\n\tif (opts->root_unlock_time == MAX_TIME_INTERVAL+1)\n\t\topts->root_unlock_time = opts->unlock_time;\n\tif (flags & PAM_SILENT)\n\t\topts->flags |= FAILLOCK_FLAG_SILENT;\n\n\tif (opts->dir == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error allocating memory: %m\");\n\t\topts->fatal_error = 1;\n\t}\n\n\tif (opts->fatal_error)\n\t\treturn PAM_BUF_ERR;\n\treturn PAM_SUCCESS;\n}"
  }
]