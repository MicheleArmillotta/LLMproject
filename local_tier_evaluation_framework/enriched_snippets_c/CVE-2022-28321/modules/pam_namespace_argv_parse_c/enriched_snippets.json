[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
    "lines": "147-171",
    "snippet": "int main(int argc, char **argv)\n{\n\tint\tac, ret;\n\tchar\t**av, **cpp;\n\tchar\tbuf[256];\n\n\twhile (!feof(stdin)) {\n\t\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\t\tbreak;\n\t\tret = argv_parse(buf, &ac, &av);\n\t\tif (ret != 0) {\n\t\t\tprintf(\"Argv_parse returned %d!\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"Argv_parse returned %d arguments...\\n\", ac);\n\t\tfor (cpp = av; *cpp; cpp++) {\n\t\t\tif (cpp != av)\n\t\t\t\tprintf(\", \");\n\t\t\tprintf(\"'%s'\", *cpp);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\targv_free(av);\n\t}\n\texit(0);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"argv_parse.h\"",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "av"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"'%s'\"",
            "*cpp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", \""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Argv_parse returned %d arguments...\\n\"",
            "ac"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Argv_parse returned %d!\\n\"",
            "ret"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_parse",
          "args": [
            "buf",
            "&ac",
            "&av"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "argv_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "43-129",
          "snippet": "int argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define STATE_QUOTED\t\t3",
            "#define STATE_TOKEN\t\t2",
            "#define STATE_WHITESPACE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define STATE_QUOTED\t\t3\n#define STATE_TOKEN\t\t2\n#define STATE_WHITESPACE\t1\n\nint argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "stdin"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "stdin"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n\tint\tac, ret;\n\tchar\t**av, **cpp;\n\tchar\tbuf[256];\n\n\twhile (!feof(stdin)) {\n\t\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\t\tbreak;\n\t\tret = argv_parse(buf, &ac, &av);\n\t\tif (ret != 0) {\n\t\t\tprintf(\"Argv_parse returned %d!\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"Argv_parse returned %d arguments...\\n\", ac);\n\t\tfor (cpp = av; *cpp; cpp++) {\n\t\t\tif (cpp != av)\n\t\t\t\tprintf(\", \");\n\t\t\tprintf(\"'%s'\", *cpp);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\targv_free(av);\n\t}\n\texit(0);\n}"
  },
  {
    "function_name": "argv_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
    "lines": "131-138",
    "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"argv_parse.h\"",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
  },
  {
    "function_name": "argv_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
    "lines": "43-129",
    "snippet": "int argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"argv_parse.h\"",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define STATE_QUOTED\t\t3",
      "#define STATE_TOKEN\t\t2",
      "#define STATE_WHITESPACE\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "argv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_namespace/argv_parse.c",
          "lines": "131-138",
          "snippet": "void argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"argv_parse.h\"",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid argv_free(char **argv)\n{\n\tif (argv) {\n\t\tif (*argv)\n\t\t\tfree(*argv);\n\t\tfree(argv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char *)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(int) ch"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "argv",
            "(max_argc+1)*sizeof(char *)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(int) ch"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(in_buf)+1"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "in_buf"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"argv_parse.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define STATE_QUOTED\t\t3\n#define STATE_TOKEN\t\t2\n#define STATE_WHITESPACE\t1\n\nint argv_parse(const char *in_buf, int *ret_argc, char ***ret_argv)\n{\n\tint\targc = 0, max_argc = 0;\n\tchar \t**argv, **new_argv, *buf, ch;\n\tconst char *cp = NULL;\n\tchar    *outcp = NULL;\n\tint\tstate = STATE_WHITESPACE;\n\n\tbuf = malloc(strlen(in_buf)+1);\n\tif (!buf)\n\t\treturn -1;\n\n\targv = NULL;\n\toutcp = buf;\n\tfor (cp = in_buf; (ch = *cp); cp++) {\n\t\tif (state == STATE_WHITESPACE) {\n\t\t\tif (isspace((int) ch))\n\t\t\t\tcontinue;\n\t\t\t/* Not whitespace, so start a new token */\n\t\t\tstate = STATE_TOKEN;\n\t\t\tif (argc >= max_argc) {\n\t\t\t\tmax_argc += 3;\n\t\t\t\tnew_argv = realloc(argv,\n\t\t\t\t\t\t  (max_argc+1)*sizeof(char *));\n\t\t\t\tif (!new_argv) {\n\t\t\t\t\tif (argv) free(argv);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\targv = new_argv;\n\t\t\t}\n\t\t\targv[argc++] = outcp;\n\t\t}\n\t\tif (state == STATE_QUOTED) {\n\t\t\tif (ch == '\"')\n\t\t\t\tstate = STATE_TOKEN;\n\t\t\telse\n\t\t\t\t*outcp++ = ch;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Must be processing characters in a word */\n\t\tif (isspace((int) ch)) {\n\t\t\t/*\n\t\t\t * Terminate the current word and start\n\t\t\t * looking for the beginning of the next word.\n\t\t\t */\n\t\t\t*outcp++ = 0;\n\t\t\tstate = STATE_WHITESPACE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tstate = STATE_QUOTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\tch = *++cp;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\0':\n\t\t\t\tch = '\\\\'; cp--; break;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n'; break;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t'; break;\n\t\t\tcase 'b':\n\t\t\t\tch = '\\b'; break;\n\t\t\t}\n\t\t}\n\t\t*outcp++ = ch;\n\t}\n\tif (state != STATE_WHITESPACE)\n\t\t*outcp++ = '\\0';\n\tif (ret_argv) {\n\t\tif (argv == NULL) {\n\t\t\tfree(buf);\n\t\t\tif ((argv=malloc(sizeof(char *))) == NULL)\n\t\t\t\treturn -1;\n\t\t}\n\t\targv[argc] = NULL;\n\t\t*ret_argv = argv;\n\t} else {\n\t\tfree(buf);\n\t\tfree(argv);\n\t}\n\tif (ret_argc)\n\t\t*ret_argc = argc;\n\treturn 0;\n}"
  }
]