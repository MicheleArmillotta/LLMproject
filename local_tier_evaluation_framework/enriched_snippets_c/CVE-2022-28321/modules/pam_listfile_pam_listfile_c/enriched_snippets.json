[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "392-397",
    "snippet": "int\npam_sm_chauthtok (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
          "lines": "47-362",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <assert.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLY_TYPE_GROUP\t3",
            "#define APPLY_TYPE_USER\t\t2",
            "#define APPLY_TYPE_NONE\t\t1",
            "#define APPLY_TYPE_NULL\t\t0",
            "#define EI_SHELL (1 << 1)",
            "#define EI_GROUP (1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define APPLY_TYPE_GROUP\t3\n#define APPLY_TYPE_USER\t\t2\n#define APPLY_TYPE_NONE\t\t1\n#define APPLY_TYPE_NULL\t\t0\n#define EI_SHELL (1 << 1)\n#define EI_GROUP (1 << 0)\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_chauthtok (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "385-390",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh, int flags,\n\t\t      int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
          "lines": "47-362",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <assert.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLY_TYPE_GROUP\t3",
            "#define APPLY_TYPE_USER\t\t2",
            "#define APPLY_TYPE_NONE\t\t1",
            "#define APPLY_TYPE_NULL\t\t0",
            "#define EI_SHELL (1 << 1)",
            "#define EI_GROUP (1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define APPLY_TYPE_GROUP\t3\n#define APPLY_TYPE_USER\t\t2\n#define APPLY_TYPE_NONE\t\t1\n#define APPLY_TYPE_NULL\t\t0\n#define EI_SHELL (1 << 1)\n#define EI_GROUP (1 << 0)\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_close_session (pam_handle_t *pamh, int flags,\n\t\t      int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "378-383",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
          "lines": "47-362",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <assert.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLY_TYPE_GROUP\t3",
            "#define APPLY_TYPE_USER\t\t2",
            "#define APPLY_TYPE_NONE\t\t1",
            "#define APPLY_TYPE_NULL\t\t0",
            "#define EI_SHELL (1 << 1)",
            "#define EI_GROUP (1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define APPLY_TYPE_GROUP\t3\n#define APPLY_TYPE_USER\t\t2\n#define APPLY_TYPE_NONE\t\t1\n#define APPLY_TYPE_NULL\t\t0\n#define EI_SHELL (1 << 1)\n#define EI_GROUP (1 << 0)\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags,\n\t\t     int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "371-376",
    "snippet": "int\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
          "lines": "47-362",
          "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <assert.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLY_TYPE_GROUP\t3",
            "#define APPLY_TYPE_USER\t\t2",
            "#define APPLY_TYPE_NONE\t\t1",
            "#define APPLY_TYPE_NULL\t\t0",
            "#define EI_SHELL (1 << 1)",
            "#define EI_GROUP (1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define APPLY_TYPE_GROUP\t3\n#define APPLY_TYPE_USER\t\t2\n#define APPLY_TYPE_NONE\t\t1\n#define APPLY_TYPE_NULL\t\t0\n#define EI_SHELL (1 << 1)\n#define EI_GROUP (1 << 0)\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt (pam_handle_t *pamh, int flags,\n\t\t  int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "364-369",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_listfile/pam_listfile.c",
    "lines": "47-362",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <assert.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define APPLY_TYPE_GROUP\t3",
      "#define APPLY_TYPE_USER\t\t2",
      "#define APPLY_TYPE_NONE\t\t1",
      "#define APPLY_TYPE_NULL\t\t0",
      "#define EI_SHELL (1 << 1)",
      "#define EI_GROUP (1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"Refused user %s for service %s\"",
            "user_name",
            "(const char *)service"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user_name",
            "NULL"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_SERVICE",
            "&service"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Returning PAM_AUTH_ERR, retval = %d\"",
            "retval"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Returning PAM_SUCCESS, retval = %d\"",
            "retval"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifname"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "inf"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a",
            "citemp"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "citemp",
            "aline"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "a",
            "\"/dev/\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aline"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "aline",
            "sizeof(aline)",
            "inf"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "PAM_AUTH_ERR != 0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "PAM_SUCCESS == 0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Error opening %s\"",
            "ifname"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "ifname",
            "\"r\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"%s is either world writable or not a normal file\"",
            "ifname"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "fileinfo.st_mode"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Couldn't open %s\"",
            "ifname"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "ifname",
            "&fileinfo"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Got file = %s, item = %d, value = %s, sense = %d\"",
            "ifname",
            "citem",
            "citemp",
            "sense"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Internal weirdness, unknown extended item %d\"",
            "extitem"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"getpwnam(%s) failed\"",
            "citemp"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "citemp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "citemp"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "citemp",
            "\"/dev/\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&citemp",
            "NULL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "citem",
            "&void_citemp"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"don't apply: %s not a member of group %s\"",
            "user_name",
            "apply_val"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_user_in_group_nam_nam",
          "args": [
            "pamh",
            "user_name",
            "apply_val"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"don't apply: apply=%s, user=%s\"",
            "apply_val",
            "user_name"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user_name",
            "apply_val"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user_name",
            "NULL"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Non-sense use for apply= parameter\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Non-sense use for apply= parameter\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Invalid usage for apply= parameter\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown sense or sense not specified\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"List filename not specified\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown item or item not specified\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown option: %s\"",
            "mybuf"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mybuf",
            "\"apply\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"shell\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"group\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"ruser\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"rhost\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"tty\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"user\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mybuf",
            "\"item\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ifname",
            "myval"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(myval)+1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "myval"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mybuf",
            "\"file\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"deny\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"allow\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mybuf",
            "\"sense\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"fail\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "myval",
            "\"succeed\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mybuf",
            "\"onerr\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "myval",
            "junk + 1",
            "sizeof(myval) - 1"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "mybuf",
            "argv[i]",
            "LESSER(junk - argv[i], (int)sizeof(mybuf) - 1)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LESSER",
          "args": [
            "junk - argv[i]",
            "(int)sizeof(mybuf) - 1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Bad option: \\\"%s\\\"\"",
            "argv[i]"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[i]",
            "'='"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "myval",
            "'\\0'",
            "sizeof(myval)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mybuf",
            "'\\0'",
            "sizeof(mybuf)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"quiet\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define APPLY_TYPE_GROUP\t3\n#define APPLY_TYPE_USER\t\t2\n#define APPLY_TYPE_NONE\t\t1\n#define APPLY_TYPE_NULL\t\t0\n#define EI_SHELL (1 << 1)\n#define EI_GROUP (1 << 0)\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval, i, citem=0, extitem=0, onerr=PAM_SERVICE_ERR, sense=2, quiet=0;\n    const void *void_citemp;\n    const char *citemp;\n    char *ifname=NULL;\n    char aline[256];\n    char mybuf[256],myval[256];\n    struct stat fileinfo;\n    FILE *inf;\n    const char *apply_val;\n    int apply_type;\n\n    /* Stuff for \"extended\" items */\n    struct passwd *userinfo;\n\n    apply_type=APPLY_TYPE_NULL;\n    apply_val=\"\";\n\n    for(i=0; i < argc; i++) {\n\t{\n\t    const char *junk;\n\n\t    /* option quiet has no value */\n\t    if(!strcmp(argv[i],\"quiet\")) {\n\t\tquiet = 1;\n\t\tcontinue;\n\t    }\n\n\t    memset(mybuf,'\\0',sizeof(mybuf));\n\t    memset(myval,'\\0',sizeof(myval));\n\t    junk = strchr(argv[i], '=');\n\t    if((junk == NULL) || (junk - argv[i]) >= (int) sizeof(mybuf)) {\n\t\tpam_syslog(pamh,LOG_ERR, \"Bad option: \\\"%s\\\"\",\n\t\t\t argv[i]);\n\t\tcontinue;\n\t    }\n\t    strncpy(mybuf, argv[i],\n\t\t    LESSER(junk - argv[i], (int)sizeof(mybuf) - 1));\n\t    strncpy(myval, junk + 1, sizeof(myval) - 1);\n\t}\n\tif(!strcmp(mybuf,\"onerr\"))\n\t    if(!strcmp(myval,\"succeed\"))\n\t\tonerr = PAM_SUCCESS;\n\t    else if(!strcmp(myval,\"fail\"))\n\t\tonerr = PAM_SERVICE_ERR;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn PAM_SERVICE_ERR;\n\t    }\n\telse if(!strcmp(mybuf,\"sense\"))\n\t    if(!strcmp(myval,\"allow\"))\n\t\tsense=0;\n\t    else if(!strcmp(myval,\"deny\"))\n\t\tsense=1;\n\t    else {\n\t        if (ifname) free (ifname);\n\t\treturn onerr;\n\t    }\n\telse if(!strcmp(mybuf,\"file\")) {\n\t    if (ifname) free (ifname);\n\t    ifname = (char *)malloc(strlen(myval)+1);\n\t    if (!ifname)\n\t\treturn PAM_BUF_ERR;\n\t    strcpy(ifname,myval);\n\t} else if(!strcmp(mybuf,\"item\"))\n\t    if(!strcmp(myval,\"user\"))\n\t\tcitem = PAM_USER;\n\t    else if(!strcmp(myval,\"tty\"))\n\t\tcitem = PAM_TTY;\n\t    else if(!strcmp(myval,\"rhost\"))\n\t\tcitem = PAM_RHOST;\n\t    else if(!strcmp(myval,\"ruser\"))\n\t\tcitem = PAM_RUSER;\n\t    else { /* These items are related to the user, but are not\n\t\t      directly gettable with pam_get_item */\n\t\tcitem = PAM_USER;\n\t\tif(!strcmp(myval,\"group\"))\n\t\t    extitem = EI_GROUP;\n\t\telse if(!strcmp(myval,\"shell\"))\n\t\t    extitem = EI_SHELL;\n\t\telse\n\t\t    citem = 0;\n\t    } else if(!strcmp(mybuf,\"apply\")) {\n\t\tapply_type=APPLY_TYPE_NONE;\n\t\tif (myval[0]=='@') {\n\t\t    apply_type=APPLY_TYPE_GROUP;\n\t\t    apply_val=myval+1;\n\t\t} else {\n\t\t    apply_type=APPLY_TYPE_USER;\n\t\t    apply_val=myval;\n\t\t}\n\t    } else {\n\t\tfree(ifname);\n\t\tpam_syslog(pamh,LOG_ERR, \"Unknown option: %s\",mybuf);\n\t\treturn onerr;\n\t    }\n    }\n\n    if(!citem) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown item or item not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(!ifname) {\n\tpam_syslog(pamh,LOG_ERR, \"List filename not specified\");\n\treturn onerr;\n    } else if(sense == 2) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Unknown sense or sense not specified\");\n\tfree(ifname);\n\treturn onerr;\n    } else if(\n\t      (apply_type==APPLY_TYPE_NONE) ||\n\t      ((apply_type!=APPLY_TYPE_NULL) && (*apply_val=='\\0'))\n              ) {\n\tpam_syslog(pamh,LOG_ERR,\n\t\t  \"Invalid usage for apply= parameter\");\n        free (ifname);\n\treturn onerr;\n    }\n\n    /* Check if it makes sense to use the apply= parameter */\n    if (apply_type != APPLY_TYPE_NULL) {\n\tif((citem==PAM_USER) || (citem==PAM_RUSER)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n\tif(extitem && (extitem==EI_GROUP)) {\n\t    pam_syslog(pamh,LOG_WARNING,\n\t\t      \"Non-sense use for apply= parameter\");\n\t    apply_type=APPLY_TYPE_NULL;\n\t}\n    }\n\n    /* Short-circuit - test if this session apply for this user */\n    {\n\tconst char *user_name;\n\tint rval;\n\n\trval=pam_get_user(pamh,&user_name,NULL);\n\tif(rval==PAM_SUCCESS && user_name[0]) {\n\t    /* Got it ? Valid ? */\n\t    if(apply_type==APPLY_TYPE_USER) {\n\t\tif(strcmp(user_name, apply_val)) {\n\t\t    /* Does not apply to this user */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\t\t\t      \"don't apply: apply=%s, user=%s\",\n\t\t\t     apply_val,user_name);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    } else if(apply_type==APPLY_TYPE_GROUP) {\n\t\tif(!pam_modutil_user_in_group_nam_nam(pamh,user_name,apply_val)) {\n\t\t    /* Not a member of apply= group */\n#ifdef PAM_DEBUG\n\t\t    pam_syslog(pamh,LOG_DEBUG,\n\n\t\t\t     \"don't apply: %s not a member of group %s\",\n\t\t\t     user_name,apply_val);\n#endif /* PAM_DEBUG */\n\t\t    free(ifname);\n\t\t    return PAM_IGNORE;\n\t\t}\n\t    }\n\t}\n    }\n\n    retval = pam_get_item(pamh,citem,&void_citemp);\n    citemp = void_citemp;\n    if(retval != PAM_SUCCESS) {\n\tfree(ifname);\n\treturn onerr;\n    }\n    if((citem == PAM_USER) && !citemp) {\n\tretval = pam_get_user(pamh,&citemp,NULL);\n\tif (retval != PAM_SUCCESS) {\n\t    free(ifname);\n\t    return PAM_SERVICE_ERR;\n\t}\n    }\n    if((citem == PAM_TTY) && citemp) {\n        /* Normalize the TTY name. */\n        const char *str = pam_str_skip_prefix(citemp, \"/dev/\");\n        if (str != NULL)\n            citemp = str;\n    }\n\n    if(!citemp || (strlen(citemp) == 0)) {\n\tfree(ifname);\n\t/* The item was NULL - we are sure not to match */\n\treturn sense?PAM_SUCCESS:PAM_AUTH_ERR;\n    }\n\n    if(extitem) {\n\tswitch(extitem) {\n\t    case EI_GROUP:\n\t\t/* Just ignore, call pam_modutil_in_group... later */\n\t\tbreak;\n\t    case EI_SHELL:\n\t\t/* Assume that we have already gotten PAM_USER in\n\t\t   pam_get_item() - a valid assumption since citem\n\t\t   gets set to PAM_USER in the extitem switch */\n\t\tuserinfo = pam_modutil_getpwnam(pamh, citemp);\n\t\tif (userinfo == NULL) {\n\t\t    pam_syslog(pamh, LOG_NOTICE, \"getpwnam(%s) failed\",\n\t\t\t     citemp);\n\t\t    free(ifname);\n\t\t    return onerr;\n\t\t}\n\t\tcitemp = userinfo->pw_shell;\n\t\tbreak;\n\t    default:\n\t\tpam_syslog(pamh,LOG_ERR,\n\n\t\t\t \"Internal weirdness, unknown extended item %d\",\n\t\t\t extitem);\n\t\tfree(ifname);\n\t\treturn onerr;\n\t}\n    }\n#ifdef PAM_DEBUG\n    pam_syslog(pamh,LOG_INFO,\n\n\t     \"Got file = %s, item = %d, value = %s, sense = %d\",\n\t     ifname, citem, citemp, sense);\n#endif\n    if(lstat(ifname,&fileinfo)) {\n\tif(!quiet)\n\t\tpam_syslog(pamh,LOG_ERR, \"Couldn't open %s\",ifname);\n\tfree(ifname);\n\treturn onerr;\n    }\n\n    if((fileinfo.st_mode & S_IWOTH)\n       || !S_ISREG(fileinfo.st_mode)) {\n\t/* If the file is world writable or is not a\n\t   normal file, return error */\n\tpam_syslog(pamh,LOG_ERR,\n\t\t \"%s is either world writable or not a normal file\",\n\t\t ifname);\n\tfree(ifname);\n\treturn PAM_AUTH_ERR;\n    }\n\n    inf = fopen(ifname,\"r\");\n    if(inf == NULL) { /* Check that we opened it successfully */\n\tif (onerr == PAM_SERVICE_ERR) {\n\t    /* Only report if it's an error... */\n\t    pam_syslog(pamh,LOG_ERR,  \"Error opening %s\", ifname);\n\t}\n\tfree(ifname);\n\treturn onerr;\n    }\n    /* There should be no more errors from here on */\n    retval=PAM_AUTH_ERR;\n    /* This loop assumes that PAM_SUCCESS == 0\n       and PAM_AUTH_ERR != 0 */\n#ifdef PAM_DEBUG\n    assert(PAM_SUCCESS == 0);\n    assert(PAM_AUTH_ERR != 0);\n#endif\n    while((fgets(aline,sizeof(aline),inf) != NULL)\n\t  && retval) {\n\tconst char *a = aline;\n\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\n')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(strlen(aline) == 0)\n\t    continue;\n\tif(aline[strlen(aline) - 1] == '\\r')\n\t    aline[strlen(aline) - 1] = '\\0';\n\tif(citem == PAM_TTY) {\n\t    const char *str = pam_str_skip_prefix(a, \"/dev/\");\n\t    if (str != NULL)\n\t\ta = str;\n\t}\n\tif (extitem == EI_GROUP) {\n\t    retval = !pam_modutil_user_in_group_nam_nam(pamh,\n\t\tcitemp, aline);\n\t} else {\n\t    retval = strcmp(a, citemp);\n\t}\n    }\n\n    fclose(inf);\n    free(ifname);\n    if ((sense && retval) || (!sense && !retval)) {\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_SUCCESS, retval = %d\", retval);\n#endif\n\treturn PAM_SUCCESS;\n    }\n    else {\n\tconst void *service;\n\tconst char *user_name;\n#ifdef PAM_DEBUG\n\tpam_syslog(pamh,LOG_INFO,\n\t\t \"Returning PAM_AUTH_ERR, retval = %d\", retval);\n#endif\n\t(void) pam_get_item(pamh, PAM_SERVICE, &service);\n\t(void) pam_get_user(pamh, &user_name, NULL);\n\tif (!quiet)\n\t    pam_syslog (pamh, LOG_NOTICE, \"Refused user %s for service %s\",\n\t                user_name, (const char *)service);\n\treturn PAM_AUTH_ERR;\n    }\n}"
  }
]