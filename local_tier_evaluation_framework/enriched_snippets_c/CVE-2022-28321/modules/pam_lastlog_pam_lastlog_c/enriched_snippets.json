[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "787-802",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh, int flags,\n\t\t      int argc, const char **argv)\n{\n    const char *terminal_line;\n\n    if (!(_pam_session_parse(pamh, flags, argc, argv) & LASTLOG_WTMP))\n\treturn PAM_SUCCESS;\n\n    terminal_line = get_tty(pamh);\n\n    /* Wipe out utmp logout entry */\n    logwtmp(terminal_line, \"\", \"\");\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logwtmp",
          "args": [
            "terminal_line",
            "\"\"",
            "\"\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tty",
          "args": [
            "pamh"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "get_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "172-193",
          "snippet": "static const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_TERM     \"\"  /* \"tt???\" */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define DEFAULT_TERM     \"\"  /* \"tt???\" */\n\nstatic const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pam_session_parse",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_session_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "127-170",
          "snippet": "static int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */",
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */",
            "#define LASTLOG_BTMP        0200  /* display failed login info from btmp */",
            "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */",
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
            "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
            "#define LASTLOG_LINE          04  /* display the last terminal used */",
            "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
            "#define LASTLOG_DATE          01  /* display the date of the last login */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n#define LASTLOG_BTMP        0200  /* display failed login info from btmp */\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n\nstatic int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n\nint\npam_sm_close_session (pam_handle_t *pamh, int flags,\n\t\t      int argc, const char **argv)\n{\n    const char *terminal_line;\n\n    if (!(_pam_session_parse(pamh, flags, argc, argv) & LASTLOG_WTMP))\n\treturn PAM_SUCCESS;\n\n    terminal_line = get_tty(pamh);\n\n    /* Wipe out utmp logout entry */\n    logwtmp(terminal_line, \"\", \"\");\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "737-785",
    "snippet": "int\npam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const void *user;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n\n    /*\n     * this module gets the uid of the PAM_USER. Uses it to display\n     * last login info and then updates the lastlog for that user.\n     */\n\n    ctrl = _pam_session_parse(pamh, flags, argc, argv);\n\n    /* which user? */\n\n    retval = pam_get_item(pamh, PAM_USER, &user);\n    if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0') {\n\tpam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n\tD((\"couldn't identify user %s\", user));\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    /* process the current login attempt (indicate last) */\n\n    retval = last_login_date(pamh, ctrl, uid, user, &lltime);\n\n    if ((ctrl & LASTLOG_BTMP) && retval == PAM_SUCCESS) {\n\t    retval = last_login_failed(pamh, ctrl, user, lltime);\n    }\n\n    /* indicate success or failure */\n\n    uid = -1;                                           /* forget this */\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_BTMP        0200  /* display failed login info from btmp */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "last_login_failed",
          "args": [
            "pamh",
            "ctrl",
            "user",
            "lltime"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "528-649",
          "snippet": "static int\nlast_login_failed(pam_handle_t *pamh, int announce, const char *user, time_t lltime)\n{\n    int retval;\n    int fd;\n    struct utmp ut;\n    struct utmp utuser;\n    int failed = 0;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    if (strlen(user) > UT_NAMESIZE) {\n\tpam_syslog(pamh, LOG_WARNING, \"username too long, output might be inaccurate\");\n    }\n\n    /* obtain the failed login attempt records from btmp */\n    fd = open(_PATH_BTMP, O_RDONLY);\n    if (fd < 0) {\n        int save_errno = errno;\n\tpam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_BTMP);\n\tD((\"unable to open %s file\", _PATH_BTMP));\n        if (save_errno == ENOENT)\n\t  return PAM_SUCCESS;\n\telse\n\t  return PAM_SERVICE_ERR;\n    }\n\n    while ((retval=pam_modutil_read(fd, (void *)&ut,\n\t\t\t sizeof(ut))) == sizeof(ut)) {\n\tif (ut.ut_tv.tv_sec >= lltime && strncmp(ut.ut_user, user, UT_NAMESIZE) == 0) {\n\t    memcpy(&utuser, &ut, sizeof(utuser));\n\t    failed++;\n\t}\n    }\n\n    if (retval != 0)\n\tpam_syslog(pamh, LOG_ERR, \"corruption detected in %s\", _PATH_BTMP);\n    retval = PAM_SUCCESS;\n\n    if (failed) {\n\t/* we want the date? */\n\tif (announce & LASTLOG_DATE) {\n\t    struct tm *tm, tm_buf;\n\t    time_t lf_time;\n\n\t    lf_time = utuser.ut_tv.tv_sec;\n\t    tm = localtime_r (&lf_time, &tm_buf);\n\t    strftime (the_time, sizeof (the_time),\n\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t_(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\n\t    date = the_time;\n\t}\n\n\t/* we want & have the host? */\n\tif ((announce & LASTLOG_HOST)\n\t\t&& (utuser.ut_host[0] != '\\0')) {\n\t    /* TRANSLATORS: \" from <host>\" */\n\t    if (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t    utuser.ut_host) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\t/* we want and have the terminal? */\n\tif ((announce & LASTLOG_LINE)\n\t\t&& (utuser.ut_line[0] != '\\0')) {\n\t    /* TRANSLATORS: \" on <terminal>\" */\n\t    if (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\tutuser.ut_line) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\tif (line != NULL || date != NULL || host != NULL) {\n\t    /* TRANSLATORS: \"Last failed login: <date> from <host> on <terminal>\" */\n\t    pam_info(pamh, _(\"Last failed login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t}\n\n\t_pam_drop(line);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n        retval = asprintf (&line, dngettext(PACKAGE,\n\t\t\"There was %d failed login attempt since the last successful login.\",\n\t\t\"There were %d failed login attempts since the last successful login.\",\n\t\tfailed),\n\t    failed);\n#else\n\tif (failed == 1)\n\t    retval = asprintf(&line,\n\t\t_(\"There was %d failed login attempt since the last successful login.\"),\n\t\tfailed);\n\telse\n\t    retval = asprintf(&line,\n\t\t/* TRANSLATORS: only used if dngettext is not supported */\n\t\t_(\"There were %d failed login attempts since the last successful login.\"),\n\t\tfailed);\n#endif\n\tif (retval >= 0)\n\t\tretval = pam_info(pamh, \"%s\", line);\n\telse {\n\t\tretval = PAM_BUF_ERR;\n\t\tline = NULL;\n\t}\n    }\n\ncleanup:\n    free(host);\n    free(line);\n    close(fd);\n    D((\"all done with btmp\"));\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_LINE          04  /* display the last terminal used */",
            "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
            "#define LASTLOG_DATE          01  /* display the date of the last login */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n\nstatic int\nlast_login_failed(pam_handle_t *pamh, int announce, const char *user, time_t lltime)\n{\n    int retval;\n    int fd;\n    struct utmp ut;\n    struct utmp utuser;\n    int failed = 0;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    if (strlen(user) > UT_NAMESIZE) {\n\tpam_syslog(pamh, LOG_WARNING, \"username too long, output might be inaccurate\");\n    }\n\n    /* obtain the failed login attempt records from btmp */\n    fd = open(_PATH_BTMP, O_RDONLY);\n    if (fd < 0) {\n        int save_errno = errno;\n\tpam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_BTMP);\n\tD((\"unable to open %s file\", _PATH_BTMP));\n        if (save_errno == ENOENT)\n\t  return PAM_SUCCESS;\n\telse\n\t  return PAM_SERVICE_ERR;\n    }\n\n    while ((retval=pam_modutil_read(fd, (void *)&ut,\n\t\t\t sizeof(ut))) == sizeof(ut)) {\n\tif (ut.ut_tv.tv_sec >= lltime && strncmp(ut.ut_user, user, UT_NAMESIZE) == 0) {\n\t    memcpy(&utuser, &ut, sizeof(utuser));\n\t    failed++;\n\t}\n    }\n\n    if (retval != 0)\n\tpam_syslog(pamh, LOG_ERR, \"corruption detected in %s\", _PATH_BTMP);\n    retval = PAM_SUCCESS;\n\n    if (failed) {\n\t/* we want the date? */\n\tif (announce & LASTLOG_DATE) {\n\t    struct tm *tm, tm_buf;\n\t    time_t lf_time;\n\n\t    lf_time = utuser.ut_tv.tv_sec;\n\t    tm = localtime_r (&lf_time, &tm_buf);\n\t    strftime (the_time, sizeof (the_time),\n\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t_(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\n\t    date = the_time;\n\t}\n\n\t/* we want & have the host? */\n\tif ((announce & LASTLOG_HOST)\n\t\t&& (utuser.ut_host[0] != '\\0')) {\n\t    /* TRANSLATORS: \" from <host>\" */\n\t    if (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t    utuser.ut_host) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\t/* we want and have the terminal? */\n\tif ((announce & LASTLOG_LINE)\n\t\t&& (utuser.ut_line[0] != '\\0')) {\n\t    /* TRANSLATORS: \" on <terminal>\" */\n\t    if (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\tutuser.ut_line) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\tif (line != NULL || date != NULL || host != NULL) {\n\t    /* TRANSLATORS: \"Last failed login: <date> from <host> on <terminal>\" */\n\t    pam_info(pamh, _(\"Last failed login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t}\n\n\t_pam_drop(line);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n        retval = asprintf (&line, dngettext(PACKAGE,\n\t\t\"There was %d failed login attempt since the last successful login.\",\n\t\t\"There were %d failed login attempts since the last successful login.\",\n\t\tfailed),\n\t    failed);\n#else\n\tif (failed == 1)\n\t    retval = asprintf(&line,\n\t\t_(\"There was %d failed login attempt since the last successful login.\"),\n\t\tfailed);\n\telse\n\t    retval = asprintf(&line,\n\t\t/* TRANSLATORS: only used if dngettext is not supported */\n\t\t_(\"There were %d failed login attempts since the last successful login.\"),\n\t\tfailed);\n#endif\n\tif (retval >= 0)\n\t\tretval = pam_info(pamh, \"%s\", line);\n\telse {\n\t\tretval = PAM_BUF_ERR;\n\t\tline = NULL;\n\t}\n    }\n\ncleanup:\n    free(host);\n    free(line);\n    close(fd);\n    D((\"all done with btmp\"));\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_login_date",
          "args": [
            "pamh",
            "ctrl",
            "uid",
            "user",
            "&lltime"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "494-526",
          "snippet": "static int\nlast_login_date(pam_handle_t *pamh, int announce, uid_t uid, const char *user, time_t *lltime)\n{\n    int retval;\n    int last_fd;\n\n    if (uid > get_lastlog_uid_max(pamh)) {\n\treturn PAM_SUCCESS;\n    }\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, announce, uid);\n    if (last_fd < 0) {\n        return PAM_SERVICE_ERR;\n    }\n\n    retval = last_login_read(pamh, announce, last_fd, uid, lltime);\n    if (retval != PAM_SUCCESS)\n      {\n\tclose(last_fd);\n\tD((\"error while reading lastlog file\"));\n\treturn retval;\n      }\n\n    if (announce & LASTLOG_UPDATE) {\n\tretval = last_login_write(pamh, announce, last_fd, uid, user);\n    }\n\n    close(last_fd);\n    D((\"all done with last login\"));\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_date(pam_handle_t *pamh, int announce, uid_t uid, const char *user, time_t *lltime)\n{\n    int retval;\n    int last_fd;\n\n    if (uid > get_lastlog_uid_max(pamh)) {\n\treturn PAM_SUCCESS;\n    }\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, announce, uid);\n    if (last_fd < 0) {\n        return PAM_SERVICE_ERR;\n    }\n\n    retval = last_login_read(pamh, announce, last_fd, uid, lltime);\n    if (retval != PAM_SUCCESS)\n      {\n\tclose(last_fd);\n\tD((\"error while reading lastlog file\"));\n\treturn retval;\n      }\n\n    if (announce & LASTLOG_UPDATE) {\n\tretval = last_login_write(pamh, announce, last_fd, uid, user);\n    }\n\n    close(last_fd);\n    D((\"all done with last login\"));\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"couldn't identify user %s\", user)"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user unknown\""
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&user"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_session_parse",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_session_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "127-170",
          "snippet": "static int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */",
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */",
            "#define LASTLOG_BTMP        0200  /* display failed login info from btmp */",
            "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */",
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
            "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
            "#define LASTLOG_LINE          04  /* display the last terminal used */",
            "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
            "#define LASTLOG_DATE          01  /* display the date of the last login */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n#define LASTLOG_BTMP        0200  /* display failed login info from btmp */\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n\nstatic int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_BTMP        0200  /* display failed login info from btmp */\n\nint\npam_sm_open_session(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const void *user;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n\n    /*\n     * this module gets the uid of the PAM_USER. Uses it to display\n     * last login info and then updates the lastlog for that user.\n     */\n\n    ctrl = _pam_session_parse(pamh, flags, argc, argv);\n\n    /* which user? */\n\n    retval = pam_get_item(pamh, PAM_USER, &user);\n    if (retval != PAM_SUCCESS || user == NULL || *(const char *)user == '\\0') {\n\tpam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n\tD((\"couldn't identify user %s\", user));\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    /* process the current login attempt (indicate last) */\n\n    retval = last_login_date(pamh, ctrl, uid, user, &lltime);\n\n    if ((ctrl & LASTLOG_BTMP) && retval == PAM_SUCCESS) {\n\t    retval = last_login_failed(pamh, ctrl, user, lltime);\n    }\n\n    /* indicate success or failure */\n\n    uid = -1;                                           /* forget this */\n\n    return retval;\n}"
  },
  {
    "function_name": "pam_sm_acct_mgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "728-733",
    "snippet": "int\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_sm_authenticate",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "pam_sm_authenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "652-719",
          "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const char *user = NULL;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n    time_t inactive_days = 0;\n    int last_fd;\n\n    /*\n     * Lock out the user if he did not login recently enough.\n     */\n\n    ctrl = _pam_auth_parse(pamh, flags, argc, argv, &inactive_days);\n\n    /* which user? */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    if (uid == 0 || uid > get_lastlog_uid_max(pamh))\n\treturn PAM_SUCCESS;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, ctrl, uid);\n    if (last_fd < 0) {\n\treturn PAM_IGNORE;\n    }\n\n    retval = last_login_read(pamh, ctrl|LASTLOG_QUIET, last_fd, uid, &lltime);\n    close(last_fd);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"error while reading lastlog file\"));\n\treturn PAM_IGNORE;\n    }\n\n    if (lltime == 0) { /* user never logged in before */\n        if (ctrl & LASTLOG_DEBUG)\n            pam_syslog(pamh, LOG_DEBUG, \"user never logged in - pass\");\n        return PAM_SUCCESS;\n    }\n\n    lltime = (time(NULL) - lltime) / (24*60*60);\n\n    if (lltime > inactive_days) {\n        pam_syslog(pamh, LOG_INFO, \"user %s inactive for %ld days - denied\",\n\t\t   user, (long) lltime);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const char *user = NULL;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n    time_t inactive_days = 0;\n    int last_fd;\n\n    /*\n     * Lock out the user if he did not login recently enough.\n     */\n\n    ctrl = _pam_auth_parse(pamh, flags, argc, argv, &inactive_days);\n\n    /* which user? */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    if (uid == 0 || uid > get_lastlog_uid_max(pamh))\n\treturn PAM_SUCCESS;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, ctrl, uid);\n    if (last_fd < 0) {\n\treturn PAM_IGNORE;\n    }\n\n    retval = last_login_read(pamh, ctrl|LASTLOG_QUIET, last_fd, uid, &lltime);\n    close(last_fd);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"error while reading lastlog file\"));\n\treturn PAM_IGNORE;\n    }\n\n    if (lltime == 0) { /* user never logged in before */\n        if (ctrl & LASTLOG_DEBUG)\n            pam_syslog(pamh, LOG_DEBUG, \"user never logged in - pass\");\n        return PAM_SUCCESS;\n    }\n\n    lltime = (time(NULL) - lltime) / (24*60*60);\n\n    if (lltime > inactive_days) {\n        pam_syslog(pamh, LOG_INFO, \"user %s inactive for %ld days - denied\",\n\t\t   user, (long) lltime);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\nint\npam_sm_acct_mgmt(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    return pam_sm_authenticate(pamh, flags, argc, argv);\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "721-726",
    "snippet": "int\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t    int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\nint\npam_sm_setcred(pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t    int argc UNUSED, const char **argv UNUSED)\n{\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "652-719",
    "snippet": "int\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const char *user = NULL;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n    time_t inactive_days = 0;\n    int last_fd;\n\n    /*\n     * Lock out the user if he did not login recently enough.\n     */\n\n    ctrl = _pam_auth_parse(pamh, flags, argc, argv, &inactive_days);\n\n    /* which user? */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    if (uid == 0 || uid > get_lastlog_uid_max(pamh))\n\treturn PAM_SUCCESS;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, ctrl, uid);\n    if (last_fd < 0) {\n\treturn PAM_IGNORE;\n    }\n\n    retval = last_login_read(pamh, ctrl|LASTLOG_QUIET, last_fd, uid, &lltime);\n    close(last_fd);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"error while reading lastlog file\"));\n\treturn PAM_IGNORE;\n    }\n\n    if (lltime == 0) { /* user never logged in before */\n        if (ctrl & LASTLOG_DEBUG)\n            pam_syslog(pamh, LOG_DEBUG, \"user never logged in - pass\");\n        return PAM_SUCCESS;\n    }\n\n    lltime = (time(NULL) - lltime) / (24*60*60);\n\n    if (lltime > inactive_days) {\n        pam_syslog(pamh, LOG_INFO, \"user %s inactive for %ld days - denied\",\n\t\t   user, (long) lltime);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_QUIET        040  /* keep quiet about things */",
      "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"user %s inactive for %ld days - denied\"",
            "user",
            "(long) lltime"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user never logged in - pass\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"error while reading lastlog file\")"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "last_fd"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_login_read",
          "args": [
            "pamh",
            "ctrl|LASTLOG_QUIET",
            "last_fd",
            "uid",
            "&lltime"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "264-369",
          "snippet": "static int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
            "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
            "#define LASTLOG_LINE          04  /* display the last terminal used */",
            "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
            "#define LASTLOG_DATE          01  /* display the date of the last login */",
            "#define LASTLOG_IGNORE_LOCK_TIME     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n#define LASTLOG_IGNORE_LOCK_TIME     1\n\nstatic int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_login_open",
          "args": [
            "pamh",
            "ctrl",
            "uid"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lastlog_uid_max",
          "args": [
            "pamh"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "get_lastlog_uid_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "197-224",
          "snippet": "static uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user unknown\""
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_auth_parse",
          "args": [
            "pamh",
            "flags",
            "argc",
            "argv",
            "&inactive_days"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_auth_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "88-125",
          "snippet": "static int\n_pam_auth_parse(pam_handle_t *pamh, int flags, int argc, const char **argv,\n    time_t *inactive)\n{\n    int ctrl = 0;\n\n    *inactive = DEFAULT_INACTIVE_DAYS;\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n    }\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n        const char *str;\n        char *ep = NULL;\n        long l;\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"inactive=\")) != NULL) {\n            l = strtol(str, &ep, 10);\n            if (ep != str && l > 0 && l < MAX_INACTIVE_DAYS)\n                *inactive = l;\n            else {\n                pam_syslog(pamh, LOG_ERR, \"bad option value: %s\", *argv);\n            }\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
            "#define MAX_INACTIVE_DAYS 100000",
            "#define DEFAULT_INACTIVE_DAYS 90"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define MAX_INACTIVE_DAYS 100000\n#define DEFAULT_INACTIVE_DAYS 90\n\nstatic int\n_pam_auth_parse(pam_handle_t *pamh, int flags, int argc, const char **argv,\n    time_t *inactive)\n{\n    int ctrl = 0;\n\n    *inactive = DEFAULT_INACTIVE_DAYS;\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n    }\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n        const char *str;\n        char *ep = NULL;\n        long l;\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"inactive=\")) != NULL) {\n            l = strtol(str, &ep, 10);\n            if (ep != str && l > 0 && l < MAX_INACTIVE_DAYS)\n                *inactive = l;\n            else {\n                pam_syslog(pamh, LOG_ERR, \"bad option value: %s\", *argv);\n            }\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n\nint\npam_sm_authenticate(pam_handle_t *pamh, int flags,\n\t\t    int argc, const char **argv)\n{\n    int retval, ctrl;\n    const char *user = NULL;\n    const struct passwd *pwd;\n    uid_t uid;\n    time_t lltime = 0;\n    time_t inactive_days = 0;\n    int last_fd;\n\n    /*\n     * Lock out the user if he did not login recently enough.\n     */\n\n    ctrl = _pam_auth_parse(pamh, flags, argc, argv, &inactive_days);\n\n    /* which user? */\n\n    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {\n        pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n        return PAM_USER_UNKNOWN;\n    }\n\n    /* what uid? */\n\n    pwd = pam_modutil_getpwnam (pamh, user);\n    if (pwd == NULL) {\n        pam_syslog(pamh, LOG_NOTICE, \"user unknown\");\n\treturn PAM_USER_UNKNOWN;\n    }\n    uid = pwd->pw_uid;\n    pwd = NULL;                                         /* tidy up */\n\n    if (uid == 0 || uid > get_lastlog_uid_max(pamh))\n\treturn PAM_SUCCESS;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, ctrl, uid);\n    if (last_fd < 0) {\n\treturn PAM_IGNORE;\n    }\n\n    retval = last_login_read(pamh, ctrl|LASTLOG_QUIET, last_fd, uid, &lltime);\n    close(last_fd);\n\n    if (retval != PAM_SUCCESS) {\n\tD((\"error while reading lastlog file\"));\n\treturn PAM_IGNORE;\n    }\n\n    if (lltime == 0) { /* user never logged in before */\n        if (ctrl & LASTLOG_DEBUG)\n            pam_syslog(pamh, LOG_DEBUG, \"user never logged in - pass\");\n        return PAM_SUCCESS;\n    }\n\n    lltime = (time(NULL) - lltime) / (24*60*60);\n\n    if (lltime > inactive_days) {\n        pam_syslog(pamh, LOG_INFO, \"user %s inactive for %ld days - denied\",\n\t\t   user, (long) lltime);\n        return PAM_AUTH_ERR;\n    }\n\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "last_login_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "528-649",
    "snippet": "static int\nlast_login_failed(pam_handle_t *pamh, int announce, const char *user, time_t lltime)\n{\n    int retval;\n    int fd;\n    struct utmp ut;\n    struct utmp utuser;\n    int failed = 0;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    if (strlen(user) > UT_NAMESIZE) {\n\tpam_syslog(pamh, LOG_WARNING, \"username too long, output might be inaccurate\");\n    }\n\n    /* obtain the failed login attempt records from btmp */\n    fd = open(_PATH_BTMP, O_RDONLY);\n    if (fd < 0) {\n        int save_errno = errno;\n\tpam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_BTMP);\n\tD((\"unable to open %s file\", _PATH_BTMP));\n        if (save_errno == ENOENT)\n\t  return PAM_SUCCESS;\n\telse\n\t  return PAM_SERVICE_ERR;\n    }\n\n    while ((retval=pam_modutil_read(fd, (void *)&ut,\n\t\t\t sizeof(ut))) == sizeof(ut)) {\n\tif (ut.ut_tv.tv_sec >= lltime && strncmp(ut.ut_user, user, UT_NAMESIZE) == 0) {\n\t    memcpy(&utuser, &ut, sizeof(utuser));\n\t    failed++;\n\t}\n    }\n\n    if (retval != 0)\n\tpam_syslog(pamh, LOG_ERR, \"corruption detected in %s\", _PATH_BTMP);\n    retval = PAM_SUCCESS;\n\n    if (failed) {\n\t/* we want the date? */\n\tif (announce & LASTLOG_DATE) {\n\t    struct tm *tm, tm_buf;\n\t    time_t lf_time;\n\n\t    lf_time = utuser.ut_tv.tv_sec;\n\t    tm = localtime_r (&lf_time, &tm_buf);\n\t    strftime (the_time, sizeof (the_time),\n\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t_(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\n\t    date = the_time;\n\t}\n\n\t/* we want & have the host? */\n\tif ((announce & LASTLOG_HOST)\n\t\t&& (utuser.ut_host[0] != '\\0')) {\n\t    /* TRANSLATORS: \" from <host>\" */\n\t    if (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t    utuser.ut_host) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\t/* we want and have the terminal? */\n\tif ((announce & LASTLOG_LINE)\n\t\t&& (utuser.ut_line[0] != '\\0')) {\n\t    /* TRANSLATORS: \" on <terminal>\" */\n\t    if (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\tutuser.ut_line) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\tif (line != NULL || date != NULL || host != NULL) {\n\t    /* TRANSLATORS: \"Last failed login: <date> from <host> on <terminal>\" */\n\t    pam_info(pamh, _(\"Last failed login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t}\n\n\t_pam_drop(line);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n        retval = asprintf (&line, dngettext(PACKAGE,\n\t\t\"There was %d failed login attempt since the last successful login.\",\n\t\t\"There were %d failed login attempts since the last successful login.\",\n\t\tfailed),\n\t    failed);\n#else\n\tif (failed == 1)\n\t    retval = asprintf(&line,\n\t\t_(\"There was %d failed login attempt since the last successful login.\"),\n\t\tfailed);\n\telse\n\t    retval = asprintf(&line,\n\t\t/* TRANSLATORS: only used if dngettext is not supported */\n\t\t_(\"There were %d failed login attempts since the last successful login.\"),\n\t\tfailed);\n#endif\n\tif (retval >= 0)\n\t\tretval = pam_info(pamh, \"%s\", line);\n\telse {\n\t\tretval = PAM_BUF_ERR;\n\t\tline = NULL;\n\t}\n    }\n\ncleanup:\n    free(host);\n    free(line);\n    close(fd);\n    D((\"all done with btmp\"));\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_LINE          04  /* display the last terminal used */",
      "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
      "#define LASTLOG_DATE          01  /* display the date of the last login */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"all done with btmp\")"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "line"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "/* TRANSLATORS: only used if dngettext is not supported */_(\"There were %d failed login attempts since the last successful login.\")",
            "failed"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"There were %d failed login attempts since the last successful login.\""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "get_lastlog_uid_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "197-224",
          "snippet": "static uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "_(\"There was %d failed login attempt since the last successful login.\")",
            "failed"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "dngettext(PACKAGE,\n\t\t\"There was %d failed login attempt since the last successful login.\",\n\t\t\"There were %d failed login attempts since the last successful login.\",\n\t\tfailed)",
            "failed"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dngettext",
          "args": [
            "PACKAGE",
            "\"There was %d failed login attempt since the last successful login.\"",
            "\"There were %d failed login attempts since the last successful login.\"",
            "failed"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "line"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Last failed login:%s%s%s\")",
            "date ? date : \"\"",
            "host ? host : \"\"",
            "line ? line : \"\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "_(\" on %.*s\")",
            "UT_LINESIZE",
            "utuser.ut_line"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&host",
            "_(\" from %.*s\")",
            "UT_HOSTSIZE",
            "utuser.ut_host"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "the_time",
            "sizeof (the_time)",
            "/* TRANSLATORS: \"strftime options for date of last login\" */_(\" %a %b %e %H:%M:%S %Z %Y\")",
            "tm"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&lf_time",
            "&tm_buf"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"corruption detected in %s\"",
            "_PATH_BTMP"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&utuser",
            "&ut",
            "sizeof(utuser)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ut.ut_user",
            "user",
            "UT_NAMESIZE"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "fd",
            "(void *)&ut",
            "sizeof(ut)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to open %s: %m\"",
            "_PATH_BTMP"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_BTMP",
            "O_RDONLY"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"username too long, output might be inaccurate\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n\nstatic int\nlast_login_failed(pam_handle_t *pamh, int announce, const char *user, time_t lltime)\n{\n    int retval;\n    int fd;\n    struct utmp ut;\n    struct utmp utuser;\n    int failed = 0;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    if (strlen(user) > UT_NAMESIZE) {\n\tpam_syslog(pamh, LOG_WARNING, \"username too long, output might be inaccurate\");\n    }\n\n    /* obtain the failed login attempt records from btmp */\n    fd = open(_PATH_BTMP, O_RDONLY);\n    if (fd < 0) {\n        int save_errno = errno;\n\tpam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_BTMP);\n\tD((\"unable to open %s file\", _PATH_BTMP));\n        if (save_errno == ENOENT)\n\t  return PAM_SUCCESS;\n\telse\n\t  return PAM_SERVICE_ERR;\n    }\n\n    while ((retval=pam_modutil_read(fd, (void *)&ut,\n\t\t\t sizeof(ut))) == sizeof(ut)) {\n\tif (ut.ut_tv.tv_sec >= lltime && strncmp(ut.ut_user, user, UT_NAMESIZE) == 0) {\n\t    memcpy(&utuser, &ut, sizeof(utuser));\n\t    failed++;\n\t}\n    }\n\n    if (retval != 0)\n\tpam_syslog(pamh, LOG_ERR, \"corruption detected in %s\", _PATH_BTMP);\n    retval = PAM_SUCCESS;\n\n    if (failed) {\n\t/* we want the date? */\n\tif (announce & LASTLOG_DATE) {\n\t    struct tm *tm, tm_buf;\n\t    time_t lf_time;\n\n\t    lf_time = utuser.ut_tv.tv_sec;\n\t    tm = localtime_r (&lf_time, &tm_buf);\n\t    strftime (the_time, sizeof (the_time),\n\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t_(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\n\t    date = the_time;\n\t}\n\n\t/* we want & have the host? */\n\tif ((announce & LASTLOG_HOST)\n\t\t&& (utuser.ut_host[0] != '\\0')) {\n\t    /* TRANSLATORS: \" from <host>\" */\n\t    if (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t    utuser.ut_host) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\t/* we want and have the terminal? */\n\tif ((announce & LASTLOG_LINE)\n\t\t&& (utuser.ut_line[0] != '\\0')) {\n\t    /* TRANSLATORS: \" on <terminal>\" */\n\t    if (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\tutuser.ut_line) < 0) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\tretval = PAM_BUF_ERR;\n\t\tgoto cleanup;\n\t    }\n\t}\n\n\tif (line != NULL || date != NULL || host != NULL) {\n\t    /* TRANSLATORS: \"Last failed login: <date> from <host> on <terminal>\" */\n\t    pam_info(pamh, _(\"Last failed login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t}\n\n\t_pam_drop(line);\n#if defined HAVE_DNGETTEXT && defined ENABLE_NLS\n        retval = asprintf (&line, dngettext(PACKAGE,\n\t\t\"There was %d failed login attempt since the last successful login.\",\n\t\t\"There were %d failed login attempts since the last successful login.\",\n\t\tfailed),\n\t    failed);\n#else\n\tif (failed == 1)\n\t    retval = asprintf(&line,\n\t\t_(\"There was %d failed login attempt since the last successful login.\"),\n\t\tfailed);\n\telse\n\t    retval = asprintf(&line,\n\t\t/* TRANSLATORS: only used if dngettext is not supported */\n\t\t_(\"There were %d failed login attempts since the last successful login.\"),\n\t\tfailed);\n#endif\n\tif (retval >= 0)\n\t\tretval = pam_info(pamh, \"%s\", line);\n\telse {\n\t\tretval = PAM_BUF_ERR;\n\t\tline = NULL;\n\t}\n    }\n\ncleanup:\n    free(host);\n    free(line);\n    close(fd);\n    D((\"all done with btmp\"));\n\n    return retval;\n}"
  },
  {
    "function_name": "last_login_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "494-526",
    "snippet": "static int\nlast_login_date(pam_handle_t *pamh, int announce, uid_t uid, const char *user, time_t *lltime)\n{\n    int retval;\n    int last_fd;\n\n    if (uid > get_lastlog_uid_max(pamh)) {\n\treturn PAM_SUCCESS;\n    }\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, announce, uid);\n    if (last_fd < 0) {\n        return PAM_SERVICE_ERR;\n    }\n\n    retval = last_login_read(pamh, announce, last_fd, uid, lltime);\n    if (retval != PAM_SUCCESS)\n      {\n\tclose(last_fd);\n\tD((\"error while reading lastlog file\"));\n\treturn retval;\n      }\n\n    if (announce & LASTLOG_UPDATE) {\n\tretval = last_login_write(pamh, announce, last_fd, uid, user);\n    }\n\n    close(last_fd);\n    D((\"all done with last login\"));\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"all done with last login\")"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "last_fd"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_login_write",
          "args": [
            "pamh",
            "announce",
            "last_fd",
            "uid",
            "user"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "371-492",
          "snippet": "static int\nlast_login_write(pam_handle_t *pamh, int announce, int last_fd,\n\t\t uid_t uid, const char *user)\n{\n    static struct rlimit no_limit = {\n\tRLIM_INFINITY,\n\tRLIM_INFINITY\n    };\n    struct rlimit old_limit;\n    int setrlimit_res;\n    struct flock last_lock;\n    struct lastlog last_login;\n    time_t ll_time;\n    const void *void_remote_host = NULL;\n    const char *remote_host;\n    const char *terminal_line;\n    int retval = PAM_SUCCESS;\n\n    /* rewind */\n    if (lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    memset(&last_login, 0, sizeof(last_login));\n\n    /* set this login date */\n    D((\"set the most recent login time\"));\n    (void) time(&ll_time);    /* set the time */\n    last_login.ll_time = ll_time;\n\n    /* set the remote host */\n    if (pam_get_item(pamh, PAM_RHOST, &void_remote_host) != PAM_SUCCESS\n\t|| void_remote_host == NULL) {\n\tremote_host = DEFAULT_HOST;\n    } else {\n\tremote_host = void_remote_host;\n    }\n\n    /* copy to last_login */\n    strncat(last_login.ll_host, remote_host, sizeof(last_login.ll_host)-1);\n\n    /* set the terminal line */\n    terminal_line = get_tty(pamh);\n\n    /* copy to last_login */\n    strncat(last_login.ll_line, terminal_line, sizeof(last_login.ll_line)-1);\n    terminal_line = NULL;\n\n    D((\"locking lastlog file\"));\n\n    /* now we try to lock this file-record exclusively; non-blocking */\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_WRLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n\tD((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING, \"file %s is locked/write\", _PATH_LASTLOG);\n        sleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    /*\n     * Failing to set the 'fsize' limit is not a fatal error. We try to write\n     * lastlog anyway, under the risk of dying due to a SIGXFSZ.\n     */\n    D((\"setting limit for 'fsize'\"));\n\n    if ((announce & LASTLOG_UNLIMITED) == 0) {    /* don't set to unlimited */\n\tsetrlimit_res = -1;\n    } else if (getrlimit(RLIMIT_FSIZE, &old_limit) == 0) {\n\tif (old_limit.rlim_cur == RLIM_INFINITY) {    /* already unlimited */\n\t    setrlimit_res = -1;\n\t} else {\n\t    setrlimit_res = setrlimit(RLIMIT_FSIZE, &no_limit);\n\t    if (setrlimit_res != 0)\n\t\tpam_syslog(pamh, LOG_WARNING, \"Could not set limit for 'fsize': %m\");\n\t}\n    } else {\n\tsetrlimit_res = -1;\n\tif (errno == EINVAL) {\n\t    pam_syslog(pamh, LOG_INFO, \"Limit for 'fsize' not supported: %m\");\n\t} else {\n\t    pam_syslog(pamh, LOG_WARNING, \"Could not get limit for 'fsize': %m\");\n\t}\n    }\n\n    D((\"writing to the lastlog file\"));\n    if (pam_modutil_write (last_fd, (char *) &last_login,\n\t\t\t   sizeof (last_login)) != sizeof(last_login)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to write %s: %m\", _PATH_LASTLOG);\n\tretval = PAM_SERVICE_ERR;\n    }\n\n    /*\n     * Failing to restore the 'fsize' limit is a fatal error.\n     */\n    D((\"restoring limit for 'fsize'\"));\n    if (setrlimit_res == 0) {\n\tsetrlimit_res = setrlimit(RLIMIT_FSIZE, &old_limit);\n\tif (setrlimit_res != 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not restore limit for 'fsize': %m\");\n\t    retval = PAM_SERVICE_ERR;\n\t}\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n    D((\"unlocked\"));\n\n    if (announce & LASTLOG_WTMP) {\n\t/* write wtmp entry for user */\n\tlogwtmp(last_login.ll_line, user, remote_host);\n    }\n\n    /* cleanup */\n    memset(&last_login, 0, sizeof(last_login));\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */",
            "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */",
            "#define DEFAULT_HOST     \"\"  /* \"[no.where]\" */",
            "#define LASTLOG_IGNORE_LOCK_TIME     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n#define DEFAULT_HOST     \"\"  /* \"[no.where]\" */\n#define LASTLOG_IGNORE_LOCK_TIME     1\n\nstatic int\nlast_login_write(pam_handle_t *pamh, int announce, int last_fd,\n\t\t uid_t uid, const char *user)\n{\n    static struct rlimit no_limit = {\n\tRLIM_INFINITY,\n\tRLIM_INFINITY\n    };\n    struct rlimit old_limit;\n    int setrlimit_res;\n    struct flock last_lock;\n    struct lastlog last_login;\n    time_t ll_time;\n    const void *void_remote_host = NULL;\n    const char *remote_host;\n    const char *terminal_line;\n    int retval = PAM_SUCCESS;\n\n    /* rewind */\n    if (lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    memset(&last_login, 0, sizeof(last_login));\n\n    /* set this login date */\n    D((\"set the most recent login time\"));\n    (void) time(&ll_time);    /* set the time */\n    last_login.ll_time = ll_time;\n\n    /* set the remote host */\n    if (pam_get_item(pamh, PAM_RHOST, &void_remote_host) != PAM_SUCCESS\n\t|| void_remote_host == NULL) {\n\tremote_host = DEFAULT_HOST;\n    } else {\n\tremote_host = void_remote_host;\n    }\n\n    /* copy to last_login */\n    strncat(last_login.ll_host, remote_host, sizeof(last_login.ll_host)-1);\n\n    /* set the terminal line */\n    terminal_line = get_tty(pamh);\n\n    /* copy to last_login */\n    strncat(last_login.ll_line, terminal_line, sizeof(last_login.ll_line)-1);\n    terminal_line = NULL;\n\n    D((\"locking lastlog file\"));\n\n    /* now we try to lock this file-record exclusively; non-blocking */\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_WRLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n\tD((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING, \"file %s is locked/write\", _PATH_LASTLOG);\n        sleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    /*\n     * Failing to set the 'fsize' limit is not a fatal error. We try to write\n     * lastlog anyway, under the risk of dying due to a SIGXFSZ.\n     */\n    D((\"setting limit for 'fsize'\"));\n\n    if ((announce & LASTLOG_UNLIMITED) == 0) {    /* don't set to unlimited */\n\tsetrlimit_res = -1;\n    } else if (getrlimit(RLIMIT_FSIZE, &old_limit) == 0) {\n\tif (old_limit.rlim_cur == RLIM_INFINITY) {    /* already unlimited */\n\t    setrlimit_res = -1;\n\t} else {\n\t    setrlimit_res = setrlimit(RLIMIT_FSIZE, &no_limit);\n\t    if (setrlimit_res != 0)\n\t\tpam_syslog(pamh, LOG_WARNING, \"Could not set limit for 'fsize': %m\");\n\t}\n    } else {\n\tsetrlimit_res = -1;\n\tif (errno == EINVAL) {\n\t    pam_syslog(pamh, LOG_INFO, \"Limit for 'fsize' not supported: %m\");\n\t} else {\n\t    pam_syslog(pamh, LOG_WARNING, \"Could not get limit for 'fsize': %m\");\n\t}\n    }\n\n    D((\"writing to the lastlog file\"));\n    if (pam_modutil_write (last_fd, (char *) &last_login,\n\t\t\t   sizeof (last_login)) != sizeof(last_login)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to write %s: %m\", _PATH_LASTLOG);\n\tretval = PAM_SERVICE_ERR;\n    }\n\n    /*\n     * Failing to restore the 'fsize' limit is a fatal error.\n     */\n    D((\"restoring limit for 'fsize'\"));\n    if (setrlimit_res == 0) {\n\tsetrlimit_res = setrlimit(RLIMIT_FSIZE, &old_limit);\n\tif (setrlimit_res != 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not restore limit for 'fsize': %m\");\n\t    retval = PAM_SERVICE_ERR;\n\t}\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n    D((\"unlocked\"));\n\n    if (announce & LASTLOG_WTMP) {\n\t/* write wtmp entry for user */\n\tlogwtmp(last_login.ll_line, user, remote_host);\n    }\n\n    /* cleanup */\n    memset(&last_login, 0, sizeof(last_login));\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "last_fd"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_login_read",
          "args": [
            "pamh",
            "announce",
            "last_fd",
            "uid",
            "lltime"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "264-369",
          "snippet": "static int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_QUIET        040  /* keep quiet about things */",
            "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
            "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
            "#define LASTLOG_LINE          04  /* display the last terminal used */",
            "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
            "#define LASTLOG_DATE          01  /* display the date of the last login */",
            "#define LASTLOG_IGNORE_LOCK_TIME     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n#define LASTLOG_IGNORE_LOCK_TIME     1\n\nstatic int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_login_open",
          "args": [
            "pamh",
            "announce",
            "uid"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lastlog_uid_max",
          "args": [
            "pamh"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "get_lastlog_uid_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "197-224",
          "snippet": "static uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_date(pam_handle_t *pamh, int announce, uid_t uid, const char *user, time_t *lltime)\n{\n    int retval;\n    int last_fd;\n\n    if (uid > get_lastlog_uid_max(pamh)) {\n\treturn PAM_SUCCESS;\n    }\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = last_login_open(pamh, announce, uid);\n    if (last_fd < 0) {\n        return PAM_SERVICE_ERR;\n    }\n\n    retval = last_login_read(pamh, announce, last_fd, uid, lltime);\n    if (retval != PAM_SUCCESS)\n      {\n\tclose(last_fd);\n\tD((\"error while reading lastlog file\"));\n\treturn retval;\n      }\n\n    if (announce & LASTLOG_UPDATE) {\n\tretval = last_login_write(pamh, announce, last_fd, uid, user);\n    }\n\n    close(last_fd);\n    D((\"all done with last login\"));\n\n    return retval;\n}"
  },
  {
    "function_name": "last_login_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "371-492",
    "snippet": "static int\nlast_login_write(pam_handle_t *pamh, int announce, int last_fd,\n\t\t uid_t uid, const char *user)\n{\n    static struct rlimit no_limit = {\n\tRLIM_INFINITY,\n\tRLIM_INFINITY\n    };\n    struct rlimit old_limit;\n    int setrlimit_res;\n    struct flock last_lock;\n    struct lastlog last_login;\n    time_t ll_time;\n    const void *void_remote_host = NULL;\n    const char *remote_host;\n    const char *terminal_line;\n    int retval = PAM_SUCCESS;\n\n    /* rewind */\n    if (lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    memset(&last_login, 0, sizeof(last_login));\n\n    /* set this login date */\n    D((\"set the most recent login time\"));\n    (void) time(&ll_time);    /* set the time */\n    last_login.ll_time = ll_time;\n\n    /* set the remote host */\n    if (pam_get_item(pamh, PAM_RHOST, &void_remote_host) != PAM_SUCCESS\n\t|| void_remote_host == NULL) {\n\tremote_host = DEFAULT_HOST;\n    } else {\n\tremote_host = void_remote_host;\n    }\n\n    /* copy to last_login */\n    strncat(last_login.ll_host, remote_host, sizeof(last_login.ll_host)-1);\n\n    /* set the terminal line */\n    terminal_line = get_tty(pamh);\n\n    /* copy to last_login */\n    strncat(last_login.ll_line, terminal_line, sizeof(last_login.ll_line)-1);\n    terminal_line = NULL;\n\n    D((\"locking lastlog file\"));\n\n    /* now we try to lock this file-record exclusively; non-blocking */\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_WRLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n\tD((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING, \"file %s is locked/write\", _PATH_LASTLOG);\n        sleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    /*\n     * Failing to set the 'fsize' limit is not a fatal error. We try to write\n     * lastlog anyway, under the risk of dying due to a SIGXFSZ.\n     */\n    D((\"setting limit for 'fsize'\"));\n\n    if ((announce & LASTLOG_UNLIMITED) == 0) {    /* don't set to unlimited */\n\tsetrlimit_res = -1;\n    } else if (getrlimit(RLIMIT_FSIZE, &old_limit) == 0) {\n\tif (old_limit.rlim_cur == RLIM_INFINITY) {    /* already unlimited */\n\t    setrlimit_res = -1;\n\t} else {\n\t    setrlimit_res = setrlimit(RLIMIT_FSIZE, &no_limit);\n\t    if (setrlimit_res != 0)\n\t\tpam_syslog(pamh, LOG_WARNING, \"Could not set limit for 'fsize': %m\");\n\t}\n    } else {\n\tsetrlimit_res = -1;\n\tif (errno == EINVAL) {\n\t    pam_syslog(pamh, LOG_INFO, \"Limit for 'fsize' not supported: %m\");\n\t} else {\n\t    pam_syslog(pamh, LOG_WARNING, \"Could not get limit for 'fsize': %m\");\n\t}\n    }\n\n    D((\"writing to the lastlog file\"));\n    if (pam_modutil_write (last_fd, (char *) &last_login,\n\t\t\t   sizeof (last_login)) != sizeof(last_login)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to write %s: %m\", _PATH_LASTLOG);\n\tretval = PAM_SERVICE_ERR;\n    }\n\n    /*\n     * Failing to restore the 'fsize' limit is a fatal error.\n     */\n    D((\"restoring limit for 'fsize'\"));\n    if (setrlimit_res == 0) {\n\tsetrlimit_res = setrlimit(RLIMIT_FSIZE, &old_limit);\n\tif (setrlimit_res != 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not restore limit for 'fsize': %m\");\n\t    retval = PAM_SERVICE_ERR;\n\t}\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n    D((\"unlocked\"));\n\n    if (announce & LASTLOG_WTMP) {\n\t/* write wtmp entry for user */\n\tlogwtmp(last_login.ll_line, user, remote_host);\n    }\n\n    /* cleanup */\n    memset(&last_login, 0, sizeof(last_login));\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */",
      "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */",
      "#define DEFAULT_HOST     \"\"  /* \"[no.where]\" */",
      "#define LASTLOG_IGNORE_LOCK_TIME     1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_login",
            "0",
            "sizeof(last_login)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logwtmp",
          "args": [
            "last_login.ll_line",
            "user",
            "remote_host"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"unlocked\")"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "last_fd",
            "F_SETLK",
            "&last_lock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Could not restore limit for 'fsize': %m\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_FSIZE",
            "&old_limit"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to write %s: %m\"",
            "_PATH_LASTLOG"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "last_fd",
            "(char *) &last_login",
            "sizeof (last_login)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Could not get limit for 'fsize': %m\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_INFO",
            "\"Limit for 'fsize' not supported: %m\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"Could not set limit for 'fsize': %m\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_FSIZE",
            "&no_limit"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_FSIZE",
            "&old_limit"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "LASTLOG_IGNORE_LOCK_TIME"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"file %s is locked/write\"",
            "_PATH_LASTLOG"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "last_fd",
            "F_SETLK",
            "&last_lock"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_lock",
            "0",
            "sizeof(last_lock)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "last_login.ll_line",
            "terminal_line",
            "sizeof(last_login.ll_line)-1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tty",
          "args": [
            "pamh"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "get_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "172-193",
          "snippet": "static const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_TERM     \"\"  /* \"tt???\" */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define DEFAULT_TERM     \"\"  /* \"tt???\" */\n\nstatic const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "last_login.ll_host",
            "remote_host",
            "sizeof(last_login.ll_host)-1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_RHOST",
            "&void_remote_host"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&ll_time"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_login",
            "0",
            "sizeof(last_login)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to lseek %s: %m\"",
            "_PATH_LASTLOG"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "last_fd",
            "sizeof(last_login) * (off_t) uid",
            "SEEK_SET"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n#define DEFAULT_HOST     \"\"  /* \"[no.where]\" */\n#define LASTLOG_IGNORE_LOCK_TIME     1\n\nstatic int\nlast_login_write(pam_handle_t *pamh, int announce, int last_fd,\n\t\t uid_t uid, const char *user)\n{\n    static struct rlimit no_limit = {\n\tRLIM_INFINITY,\n\tRLIM_INFINITY\n    };\n    struct rlimit old_limit;\n    int setrlimit_res;\n    struct flock last_lock;\n    struct lastlog last_login;\n    time_t ll_time;\n    const void *void_remote_host = NULL;\n    const char *remote_host;\n    const char *terminal_line;\n    int retval = PAM_SUCCESS;\n\n    /* rewind */\n    if (lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    memset(&last_login, 0, sizeof(last_login));\n\n    /* set this login date */\n    D((\"set the most recent login time\"));\n    (void) time(&ll_time);    /* set the time */\n    last_login.ll_time = ll_time;\n\n    /* set the remote host */\n    if (pam_get_item(pamh, PAM_RHOST, &void_remote_host) != PAM_SUCCESS\n\t|| void_remote_host == NULL) {\n\tremote_host = DEFAULT_HOST;\n    } else {\n\tremote_host = void_remote_host;\n    }\n\n    /* copy to last_login */\n    strncat(last_login.ll_host, remote_host, sizeof(last_login.ll_host)-1);\n\n    /* set the terminal line */\n    terminal_line = get_tty(pamh);\n\n    /* copy to last_login */\n    strncat(last_login.ll_line, terminal_line, sizeof(last_login.ll_line)-1);\n    terminal_line = NULL;\n\n    D((\"locking lastlog file\"));\n\n    /* now we try to lock this file-record exclusively; non-blocking */\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_WRLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n\tD((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING, \"file %s is locked/write\", _PATH_LASTLOG);\n        sleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    /*\n     * Failing to set the 'fsize' limit is not a fatal error. We try to write\n     * lastlog anyway, under the risk of dying due to a SIGXFSZ.\n     */\n    D((\"setting limit for 'fsize'\"));\n\n    if ((announce & LASTLOG_UNLIMITED) == 0) {    /* don't set to unlimited */\n\tsetrlimit_res = -1;\n    } else if (getrlimit(RLIMIT_FSIZE, &old_limit) == 0) {\n\tif (old_limit.rlim_cur == RLIM_INFINITY) {    /* already unlimited */\n\t    setrlimit_res = -1;\n\t} else {\n\t    setrlimit_res = setrlimit(RLIMIT_FSIZE, &no_limit);\n\t    if (setrlimit_res != 0)\n\t\tpam_syslog(pamh, LOG_WARNING, \"Could not set limit for 'fsize': %m\");\n\t}\n    } else {\n\tsetrlimit_res = -1;\n\tif (errno == EINVAL) {\n\t    pam_syslog(pamh, LOG_INFO, \"Limit for 'fsize' not supported: %m\");\n\t} else {\n\t    pam_syslog(pamh, LOG_WARNING, \"Could not get limit for 'fsize': %m\");\n\t}\n    }\n\n    D((\"writing to the lastlog file\"));\n    if (pam_modutil_write (last_fd, (char *) &last_login,\n\t\t\t   sizeof (last_login)) != sizeof(last_login)) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to write %s: %m\", _PATH_LASTLOG);\n\tretval = PAM_SERVICE_ERR;\n    }\n\n    /*\n     * Failing to restore the 'fsize' limit is a fatal error.\n     */\n    D((\"restoring limit for 'fsize'\"));\n    if (setrlimit_res == 0) {\n\tsetrlimit_res = setrlimit(RLIMIT_FSIZE, &old_limit);\n\tif (setrlimit_res != 0) {\n\t    pam_syslog(pamh, LOG_ERR, \"Could not restore limit for 'fsize': %m\");\n\t    retval = PAM_SERVICE_ERR;\n\t}\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n    D((\"unlocked\"));\n\n    if (announce & LASTLOG_WTMP) {\n\t/* write wtmp entry for user */\n\tlogwtmp(last_login.ll_line, user, remote_host);\n    }\n\n    /* cleanup */\n    memset(&last_login, 0, sizeof(last_login));\n\n    return retval;\n}"
  },
  {
    "function_name": "last_login_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "264-369",
    "snippet": "static int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_QUIET        040  /* keep quiet about things */",
      "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
      "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
      "#define LASTLOG_LINE          04  /* display the last terminal used */",
      "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
      "#define LASTLOG_DATE          01  /* display the date of the last login */",
      "#define LASTLOG_IGNORE_LOCK_TIME     1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "line"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "line"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "host"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "host"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "date"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_login",
            "0",
            "sizeof(last_login)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "\"%s\"",
            "_(\"Welcome to your new account!\")"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Welcome to your new account!\""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "get_lastlog_uid_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "197-224",
          "snippet": "static uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "# include <lastlog.h>",
            "# include <utmp.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_UID_VALUE 0xFFFFFFFFUL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"this is the first time this user has logged in\")"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Last login:%s%s%s\")",
            "date ? date : \"\"",
            "host ? host : \"\"",
            "line ? line : \"\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "_(\" on %.*s\")",
            "UT_LINESIZE",
            "last_login.ll_line"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&host",
            "_(\" from %.*s\")",
            "UT_HOSTSIZE",
            "last_login.ll_host"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "the_time",
            "sizeof (the_time)",
            "/* TRANSLATORS: \"strftime options for date of last login\" */_(\" %a %b %e %H:%M:%S %Z %Y\")",
            "tm"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&ll_time",
            "&tm_buf"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"first login for user with uid %lu\"",
            "(unsigned long int)uid"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "last_fd",
            "F_SETLK",
            "&last_lock"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_login",
            "0",
            "sizeof(last_login)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_read",
          "args": [
            "last_fd",
            "(char *) &last_login",
            "sizeof(last_login)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "LASTLOG_IGNORE_LOCK_TIME"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"file %s is locked/read\"",
            "_PATH_LASTLOG"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "last_fd",
            "F_SETLK",
            "&last_lock"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_lock",
            "0",
            "sizeof(last_lock)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n#define LASTLOG_IGNORE_LOCK_TIME     1\n\nstatic int\nlast_login_read(pam_handle_t *pamh, int announce, int last_fd, uid_t uid, time_t *lltime)\n{\n    struct flock last_lock;\n    struct lastlog last_login;\n    int retval = PAM_SUCCESS;\n    char the_time[256];\n    char *date = NULL;\n    char *host = NULL;\n    char *line = NULL;\n\n    memset(&last_lock, 0, sizeof(last_lock));\n    last_lock.l_type = F_RDLCK;\n    last_lock.l_whence = SEEK_SET;\n    last_lock.l_start = sizeof(last_login) * (off_t) uid;\n    last_lock.l_len = sizeof(last_login);\n\n    if (fcntl(last_fd, F_SETLK, &last_lock) < 0) {\n        D((\"locking %s failed..(waiting a little)\", _PATH_LASTLOG));\n\tpam_syslog(pamh, LOG_WARNING,\n\t\t   \"file %s is locked/read\", _PATH_LASTLOG);\n\tsleep(LASTLOG_IGNORE_LOCK_TIME);\n    }\n\n    if (pam_modutil_read(last_fd, (char *) &last_login,\n\t\t\t sizeof(last_login)) != sizeof(last_login)) {\n        memset(&last_login, 0, sizeof(last_login));\n    }\n\n    last_lock.l_type = F_UNLCK;\n    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */\n\n    *lltime = last_login.ll_time;\n    if (!last_login.ll_time) {\n        if (announce & LASTLOG_DEBUG) {\n\t    pam_syslog(pamh, LOG_DEBUG,\n\t\t       \"first login for user with uid %lu\",\n\t\t       (unsigned long int)uid);\n\t}\n    }\n\n    if (!(announce & LASTLOG_QUIET)) {\n\n\tif (last_login.ll_time) {\n\n\t    /* we want the date? */\n\t    if (announce & LASTLOG_DATE) {\n\t        struct tm *tm, tm_buf;\n\t\ttime_t ll_time;\n\n\t\tll_time = last_login.ll_time;\n\t\tif ((tm = localtime_r (&ll_time, &tm_buf)) != NULL) {\n\t\t\tstrftime (the_time, sizeof (the_time),\n\t\t        /* TRANSLATORS: \"strftime options for date of last login\" */\n\t\t\t\t  _(\" %a %b %e %H:%M:%S %Z %Y\"), tm);\n\t\t\tdate = the_time;\n\t\t}\n\t    }\n\n\t    /* we want & have the host? */\n\t    if ((announce & LASTLOG_HOST)\n\t\t&& (last_login.ll_host[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" from <host>\" */\n\t\tif (asprintf(&host, _(\" from %.*s\"), UT_HOSTSIZE,\n\t\t\t     last_login.ll_host) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    /* we want and have the terminal? */\n\t    if ((announce & LASTLOG_LINE)\n\t\t&& (last_login.ll_line[0] != '\\0')) {\n\t\t/* TRANSLATORS: \" on <terminal>\" */\n\t\tif (asprintf(&line, _(\" on %.*s\"), UT_LINESIZE,\n\t\t\t     last_login.ll_line) < 0) {\n\t\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t\t    retval = PAM_BUF_ERR;\n\t\t    goto cleanup;\n\t\t}\n\t    }\n\n\t    if (date != NULL || host != NULL || line != NULL)\n\t\t    /* TRANSLATORS: \"Last login: <date> from <host> on <terminal>\" */\n\t\t    retval = pam_info(pamh, _(\"Last login:%s%s%s\"),\n\t\t\t      date ? date : \"\",\n\t\t\t      host ? host : \"\",\n\t\t\t      line ? line : \"\");\n\t} else if (announce & LASTLOG_NEVER) {\n\t\tD((\"this is the first time this user has logged in\"));\n\t\tretval = pam_info(pamh, \"%s\", _(\"Welcome to your new account!\"));\n\t}\n    }\n\n    /* cleanup */\n cleanup:\n    memset(&last_login, 0, sizeof(last_login));\n    _pam_overwrite(date);\n    _pam_overwrite(host);\n    _pam_drop(host);\n    _pam_overwrite(line);\n    _pam_drop(line);\n\n    return retval;\n}"
  },
  {
    "function_name": "last_login_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "226-261",
    "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "last_fd"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"unable to lseek %s file\", _PATH_LASTLOG)"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"failed to lseek %s: %m\"",
            "_PATH_LASTLOG"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "last_fd",
            "sizeof(struct lastlog) * (off_t) uid",
            "SEEK_SET"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to open %s: %m\"",
            "_PATH_LASTLOG"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"file %s created\"",
            "_PATH_LASTLOG"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unable to create %s: %m\"",
            "_PATH_LASTLOG"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_LASTLOG",
            "O_RDWR|O_CREAT",
            "S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "last_login_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
          "lines": "226-261",
          "snippet": "static int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_LASTLOG",
            "announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n\nstatic int\nlast_login_open(pam_handle_t *pamh, int announce, uid_t uid)\n{\n    int last_fd;\n\n    /* obtain the last login date and all the relevant info */\n    last_fd = open(_PATH_LASTLOG, announce&LASTLOG_UPDATE ? O_RDWR : O_RDONLY);\n    if (last_fd < 0) {\n        if (errno == ENOENT && (announce & LASTLOG_UPDATE)) {\n\t     last_fd = open(_PATH_LASTLOG, O_RDWR|O_CREAT,\n                            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n             if (last_fd < 0) {\n\t          pam_syslog(pamh, LOG_ERR,\n                             \"unable to create %s: %m\", _PATH_LASTLOG);\n\t\t  D((\"unable to create %s file\", _PATH_LASTLOG));\n\t\t  return -1;\n\t     }\n\t     pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\"file %s created\", _PATH_LASTLOG);\n\t     D((\"file %s created\", _PATH_LASTLOG));\n\t} else {\n\t  pam_syslog(pamh, LOG_ERR, \"unable to open %s: %m\", _PATH_LASTLOG);\n\t  D((\"unable to open %s file\", _PATH_LASTLOG));\n\t  return -1;\n\t}\n    }\n\n    if (lseek(last_fd, sizeof(struct lastlog) * (off_t) uid, SEEK_SET) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"failed to lseek %s: %m\", _PATH_LASTLOG);\n\tD((\"unable to lseek %s file\", _PATH_LASTLOG));\n        close(last_fd);\n\treturn -1;\n    }\n\n    return last_fd;\n}"
  },
  {
    "function_name": "get_lastlog_uid_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "197-224",
    "snippet": "static uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_UID_VALUE 0xFFFFFFFFUL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "s",
            "&ep",
            "10"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*(--ep)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "PATH_LOGIN_DEFS",
            "\"LASTLOG_UID_MAX\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define MAX_UID_VALUE 0xFFFFFFFFUL\n\nstatic uid_t\nget_lastlog_uid_max(pam_handle_t *pamh)\n{\n    uid_t uid_max = MAX_UID_VALUE;\n    unsigned long ul;\n    char *s, *ep;\n\n    s = pam_modutil_search_key(pamh, PATH_LOGIN_DEFS, \"LASTLOG_UID_MAX\");\n    if (s == NULL)\n\treturn uid_max;\n\n    ep = s + strlen(s);\n    while (ep > s && isspace(*(--ep))) {\n\t*ep = '\\0';\n    }\n    errno = 0;\n    ul = strtoul(s, &ep, 10);\n    if (!(ul >= MAX_UID_VALUE\n\t|| (uid_t)ul >= MAX_UID_VALUE\n\t|| (errno != 0 && ul == 0)\n\t|| s == ep\n\t|| *ep != '\\0')) {\n\tuid_max = (uid_t)ul;\n    }\n    free(s);\n\n    return uid_max;\n}"
  },
  {
    "function_name": "get_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "172-193",
    "snippet": "static const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_TERM     \"\"  /* \"tt???\" */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"terminal = %s\", terminal_line)"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "terminal_line",
            "\"/dev/\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_TTY",
            "&void_terminal_line"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define DEFAULT_TERM     \"\"  /* \"tt???\" */\n\nstatic const char *\nget_tty(pam_handle_t *pamh)\n{\n    const void *void_terminal_line = NULL;\n    const char *terminal_line;\n    const char *str;\n\n    if (pam_get_item(pamh, PAM_TTY, &void_terminal_line) != PAM_SUCCESS\n\t|| void_terminal_line == NULL) {\n\tterminal_line = DEFAULT_TERM;\n    } else {\n\tterminal_line = void_terminal_line;\n    }\n\n    /* strip leading \"/dev/\" from tty. */\n    str = pam_str_skip_prefix(terminal_line, \"/dev/\");\n    if (str != NULL)\n\tterminal_line = str;\n\n    D((\"terminal = %s\", terminal_line));\n    return terminal_line;\n}"
  },
  {
    "function_name": "_pam_session_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "127-170",
    "snippet": "static int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */",
      "#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */",
      "#define LASTLOG_BTMP        0200  /* display failed login info from btmp */",
      "#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */",
      "#define LASTLOG_QUIET        040  /* keep quiet about things */",
      "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
      "#define LASTLOG_NEVER        010  /* display a welcome message for first login */",
      "#define LASTLOG_LINE          04  /* display the last terminal used */",
      "#define LASTLOG_HOST          02  /* display the last host used (if set) */",
      "#define LASTLOG_DATE          01  /* display the date of the last login */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"ctrl = %o\", ctrl)"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"unlimited\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"showfailed\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noupdate\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"nowtmp\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"never\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"silent\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"nohost\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noterm\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"nodate\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_UNLIMITED  01000  /* unlimited file size (ignore 'fsize' limit) */\n#define LASTLOG_UPDATE      0400  /* update the lastlog and wtmp files (default) */\n#define LASTLOG_BTMP        0200  /* display failed login info from btmp */\n#define LASTLOG_WTMP        0100  /* log to wtmp as well as lastlog */\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define LASTLOG_NEVER        010  /* display a welcome message for first login */\n#define LASTLOG_LINE          04  /* display the last terminal used */\n#define LASTLOG_HOST          02  /* display the last host used (if set) */\n#define LASTLOG_DATE          01  /* display the date of the last login */\n\nstatic int\n_pam_session_parse(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP|LASTLOG_UPDATE);\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n\n\t/* generic options */\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"nodate\")) {\n\t    ctrl &= ~LASTLOG_DATE;\n\t} else if (!strcmp(*argv,\"noterm\")) {\n\t    ctrl &= ~LASTLOG_LINE;\n\t} else if (!strcmp(*argv,\"nohost\")) {\n\t    ctrl &= ~LASTLOG_HOST;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if (!strcmp(*argv,\"never\")) {\n\t    ctrl |= LASTLOG_NEVER;\n\t} else if (!strcmp(*argv,\"nowtmp\")) {\n\t    ctrl &= ~LASTLOG_WTMP;\n\t} else if (!strcmp(*argv,\"noupdate\")) {\n\t    ctrl &= ~(LASTLOG_WTMP|LASTLOG_UPDATE);\n\t} else if (!strcmp(*argv,\"showfailed\")) {\n\t    ctrl |= LASTLOG_BTMP;\n\t} else if (!strcmp(*argv,\"unlimited\")) {\n\t    ctrl |= LASTLOG_UNLIMITED;\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n\tctrl &= ~LASTLOG_BTMP;\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}"
  },
  {
    "function_name": "_pam_auth_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_lastlog/pam_lastlog.c",
    "lines": "88-125",
    "snippet": "static int\n_pam_auth_parse(pam_handle_t *pamh, int flags, int argc, const char **argv,\n    time_t *inactive)\n{\n    int ctrl = 0;\n\n    *inactive = DEFAULT_INACTIVE_DAYS;\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n    }\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n        const char *str;\n        char *ep = NULL;\n        long l;\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"inactive=\")) != NULL) {\n            l = strtol(str, &ep, 10);\n            if (ep != str && l > 0 && l < MAX_INACTIVE_DAYS)\n                *inactive = l;\n            else {\n                pam_syslog(pamh, LOG_ERR, \"bad option value: %s\", *argv);\n            }\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/_pam_macros.h>",
      "#include <security/pam_modules.h>",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <pwd.h>",
      "# include <lastlog.h>",
      "# include <utmp.h>",
      "#include <errno.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LASTLOG_QUIET        040  /* keep quiet about things */",
      "#define LASTLOG_DEBUG        020  /* send info to syslog(3) */",
      "#define MAX_INACTIVE_DAYS 100000",
      "#define DEFAULT_INACTIVE_DAYS 90"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"ctrl = %o\", ctrl)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option: %s\"",
            "*argv"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"bad option value: %s\"",
            "*argv"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "&ep",
            "10"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"inactive=\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"silent\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"debug\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pwd.h>\n# include <lastlog.h>\n# include <utmp.h>\n#include <errno.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"config.h\"\n\n#define LASTLOG_QUIET        040  /* keep quiet about things */\n#define LASTLOG_DEBUG        020  /* send info to syslog(3) */\n#define MAX_INACTIVE_DAYS 100000\n#define DEFAULT_INACTIVE_DAYS 90\n\nstatic int\n_pam_auth_parse(pam_handle_t *pamh, int flags, int argc, const char **argv,\n    time_t *inactive)\n{\n    int ctrl = 0;\n\n    *inactive = DEFAULT_INACTIVE_DAYS;\n\n    /* does the application require quiet? */\n    if (flags & PAM_SILENT) {\n\tctrl |= LASTLOG_QUIET;\n    }\n\n    /* step through arguments */\n    for (; argc-- > 0; ++argv) {\n        const char *str;\n        char *ep = NULL;\n        long l;\n\n\tif (!strcmp(*argv,\"debug\")) {\n\t    ctrl |= LASTLOG_DEBUG;\n\t} else if (!strcmp(*argv,\"silent\")) {\n\t    ctrl |= LASTLOG_QUIET;\n\t} else if ((str = pam_str_skip_prefix(*argv, \"inactive=\")) != NULL) {\n            l = strtol(str, &ep, 10);\n            if (ep != str && l > 0 && l < MAX_INACTIVE_DAYS)\n                *inactive = l;\n            else {\n                pam_syslog(pamh, LOG_ERR, \"bad option value: %s\", *argv);\n            }\n\t} else {\n\t    pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n\t}\n    }\n\n    D((\"ctrl = %o\", ctrl));\n    return ctrl;\n}"
  }
]