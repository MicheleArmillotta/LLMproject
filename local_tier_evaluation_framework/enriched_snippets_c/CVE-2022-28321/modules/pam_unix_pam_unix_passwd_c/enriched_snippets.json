[
  {
    "function_name": "pam_sm_chauthtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "604-875",
    "snippet": "int\npam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl, lctrl;\n\tint retval;\n\tint remember = -1;\n\tint rounds = 0;\n\tint pass_min_len = 0;\n\n\t/* <DO NOT free() THESE> */\n\tconst char *user;\n\tconst void *item;\n\tconst char *pass_old, *pass_new;\n\t/* </DO NOT free() THESE> */\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, &remember, &rounds, &pass_min_len,\n\t                 argc, argv);\n\n\t/*\n\t * First get the name of a user\n\t */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tif (retval == PAM_SUCCESS) {\n\t\t/*\n\t\t * Various libraries at various times have had bugs related to\n\t\t * '+' or '-' as the first character of a user name. Don't\n\t\t * allow them.\n\t\t */\n\t\tif (user[0] == '-' || user[0] == '+') {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"bad username [%s]\", user);\n\t\t\treturn PAM_USER_UNKNOWN;\n\t\t}\n\t\tif (retval == PAM_SUCCESS && on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"username [%s] obtained\",\n\t\t\t         user);\n\t} else {\n\t\tif (on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t         \"password - could not identify user\");\n\t\treturn retval;\n\t}\n\n\tD((\"Got username of %s\", user));\n\n\t/*\n\t * Before we do anything else, check to make sure that the user's\n\t * info is in one of the databases we can modify from this module,\n\t * which currently is 'files' and 'nis'.  We have to do this because\n\t * getpwnam() doesn't tell you *where* the information it gives you\n\t * came from, nor should it.  That's our job.\n\t */\n\tif (_unix_comesfromsource(pamh, user, 1, on(UNIX_NIS, ctrl)) == 0) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t \"user \\\"%s\\\" does not exist in /etc/passwd%s\",\n\t\t\t user, on(UNIX_NIS, ctrl) ? \" or NIS\" : \"\");\n\t\treturn PAM_USER_UNKNOWN;\n\t} else {\n\t\tstruct passwd *pwd;\n\t\t_unix_getpwnam(pamh, user, 1, 1, &pwd);\n\t\tif (pwd == NULL) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"user \\\"%s\\\" has corrupted passwd entry\",\n\t\t\t\tuser);\n\t\t\treturn PAM_USER_UNKNOWN;\n\t\t}\n\t}\n\n\t/*\n\t * This is not an AUTH module!\n\t */\n\tif (on(UNIX__NONULL, ctrl))\n\t\tset(UNIX__NULLOK, ctrl);\n\n\tif (on(UNIX__PRELIM, ctrl)) {\n\t\t/*\n\t\t * obtain and verify the current password (OLDAUTHTOK) for\n\t\t * the user.\n\t\t */\n\t\tD((\"prelim check\"));\n\n\t\tif (_unix_blankpasswd(pamh, ctrl, user)) {\n\t\t\treturn PAM_SUCCESS;\n\t\t} else if (off(UNIX__IAMROOT, ctrl) ||\n\t\t\t   (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, user, 0, 1))) {\n\t\t\t/* instruct user what is happening */\n\t\t\tif (off(UNIX__QUIET, ctrl)) {\n\t\t\t\tretval = pam_info(pamh, _(\"Changing password for %s.\"), user);\n\t\t\t\tif (retval != PAM_SUCCESS)\n\t\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tretval = pam_get_authtok(pamh, PAM_OLDAUTHTOK, &pass_old, NULL);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t    \"password - (old) token not obtained\");\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\t/* verify that this is the password for this user */\n\n\t\t\tretval = _unix_verify_password(pamh, user, pass_old, ctrl);\n\t\t} else {\n\t\t\tD((\"process run by root so do nothing this time around\"));\n\t\t\tpass_old = NULL;\n\t\t\tretval = PAM_SUCCESS;\t/* root doesn't have too */\n\t\t}\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tD((\"Authentication failed\"));\n\t\t\tpass_old = NULL;\n\t\t\treturn retval;\n\t\t}\n\t\tpass_old = NULL;\n\t\tretval = _unix_verify_shadow(pamh,user, ctrl);\n\t\tif (retval == PAM_AUTHTOK_ERR) {\n\t\t\tif (off(UNIX__IAMROOT, ctrl))\n\t\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t\t     _(\"You must wait longer to change your password.\"));\n\t\t\telse\n\t\t\t\tretval = PAM_SUCCESS;\n\t\t}\n\t} else if (on(UNIX__UPDATE, ctrl)) {\n\t\t/*\n\t\t * tpass is used below to store the _pam_md() return; it\n\t\t * should be _pam_delete()'d.\n\t\t */\n\n\t\tchar *tpass = NULL;\n\t\tint retry = 0;\n\n\t\t/*\n\t\t * obtain the proposed password\n\t\t */\n\n\t\tD((\"do update\"));\n\n\t\t/*\n\t\t * get the old token back. NULL was ok only if root [at this\n\t\t * point we assume that this has already been enforced on a\n\t\t * previous call to this function].\n\t\t */\n\n\t\tretval = pam_get_item(pamh, PAM_OLDAUTHTOK, &item);\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user not authenticated\");\n\t\t\treturn retval;\n\t\t}\n\t\tpass_old = item;\n\t\tD((\"pass_old [%s]\", pass_old));\n\n\t\tD((\"get new password now\"));\n\n\t\tlctrl = ctrl;\n\n\t\tif (on(UNIX_USE_AUTHTOK, lctrl)) {\n\t\t\tset(UNIX_USE_FIRST_PASS, lctrl);\n\t\t}\n\t\tif (on(UNIX_USE_FIRST_PASS, lctrl)) {\n\t\t\tretry = MAX_PASSWD_TRIES-1;\n\t\t}\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\twhile ((retval != PAM_SUCCESS) && (retry++ < MAX_PASSWD_TRIES)) {\n\t\t\t/*\n\t\t\t * use_authtok is to force the use of a previously entered\n\t\t\t * password -- needed for pluggable password strength checking\n\t\t\t */\n\n\t\t\tretval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass_new, NULL);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\t \"password - new password not obtained\");\n\t\t\t\t}\n\t\t\t\tpass_old = NULL;\t/* tidy up */\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tD((\"returned to _unix_chauthtok\"));\n\n\t\t\t/*\n\t\t\t * At this point we know who the user is and what they\n\t\t\t * propose as their new password. Verify that the new\n\t\t\t * password is acceptable.\n\t\t\t */\n\n\t\t\tif (*(const char *)pass_new == '\\0') {\t/* \"\\0\" password = NULL */\n\t\t\t\tpass_new = NULL;\n\t\t\t}\n\t\t\tretval = _pam_unix_approve_pass(pamh, ctrl, pass_old,\n\t\t\t                                pass_new, pass_min_len);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t         \"new password not acceptable\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\treturn retval;\n\t\t}\n\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t}\n\n\t\tif (pass_old) {\n\t\t\tretval = _unix_verify_password(pamh, user, pass_old, ctrl);\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user password changed by another process\");\n\t\t\t\tunlock_pwdf();\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\tretval = _unix_verify_shadow(pamh, user, ctrl);\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user shadow entry expired\");\n\t\t\tunlock_pwdf();\n\t\t\treturn retval;\n\t\t}\n\n\t\tretval = _pam_unix_approve_pass(pamh, ctrl, pass_old, pass_new,\n\t\t                                pass_min_len);\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t         \"new password not acceptable 2\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\tunlock_pwdf();\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * By reaching here we have approved the passwords and must now\n\t\t * rebuild the password database file.\n\t\t */\n\n\t\t/*\n\t\t * First we encrypt the new password.\n\t\t */\n\n\t\ttpass = create_password_hash(pamh, pass_new, ctrl, rounds);\n\t\tif (tpass == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t\"crypt() failure or out of memory for password\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\tunlock_pwdf();\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\tD((\"password processed\"));\n\n\t\t/* update the password database(s) -- race conditions..? */\n\n\t\tretval = _do_setpass(pamh, user, pass_old, tpass, ctrl,\n\t\t                     remember);\n\t        /* _do_setpass has called unlock_pwdf for us */\n\n\t\t_pam_delete(tpass);\n\t\tpass_old = pass_new = NULL;\n\t} else {\t\t/* something has broken with the module */\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t         \"password received unknown request\");\n\t\tretval = PAM_ABORT;\n\t}\n\n\tD((\"retval was %d\", retval));\n\n\treturn retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_PASSWD_TRIES\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"retval was %d\", retval)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"password received unknown request\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "tpass"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_do_setpass",
          "args": [
            "pamh",
            "user",
            "pass_old",
            "tpass",
            "ctrl",
            "remember"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "_do_setpass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "388-513",
          "snippet": "static int _do_setpass(pam_handle_t* pamh, const char *forwho,\n\t\t       const char *fromwhat,\n\t\t       char *towhat, unsigned long long ctrl, int remember)\n{\n\tstruct passwd *pwd = NULL;\n\tint retval = 0;\n\tint unlocked = 0;\n\n\tD((\"called\"));\n\n\tpwd = getpwnam(forwho);\n\n\tif (pwd == NULL) {\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\tgoto done;\n\t}\n\n\tif (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, forwho, 0, 1)) {\n#ifdef HAVE_NIS\n\t  char *master;\n\n\t  if ((master=getNISserver(pamh, ctrl)) != NULL) {\n\t\tstruct timeval timeout;\n\t\tstruct yppasswd yppwd;\n\t\tCLIENT *clnt;\n\t\tint status;\n\t\tenum clnt_stat err;\n\n\t\t/* Unlock passwd file to avoid deadlock */\n\t\tunlock_pwdf();\n\t\tunlocked = 1;\n\n\t\t/* Initialize password information */\n\t\typpwd.newpw.pw_passwd = pwd->pw_passwd;\n\t\typpwd.newpw.pw_name = pwd->pw_name;\n\t\typpwd.newpw.pw_uid = pwd->pw_uid;\n\t\typpwd.newpw.pw_gid = pwd->pw_gid;\n\t\typpwd.newpw.pw_gecos = pwd->pw_gecos;\n\t\typpwd.newpw.pw_dir = pwd->pw_dir;\n\t\typpwd.newpw.pw_shell = pwd->pw_shell;\n\t\typpwd.oldpass = fromwhat ? strdup (fromwhat) : strdup (\"\");\n\t\typpwd.newpw.pw_passwd = towhat;\n\n\t\tD((\"Set password %s for %s\", yppwd.newpw.pw_passwd, forwho));\n\n\t\t/* The yppasswd.x file said `unix authentication required',\n\t\t * so I added it. This is the only reason it is in here.\n\t\t * My yppasswdd doesn't use it, but maybe some others out there\n\t\t * do.                                        --okir\n\t\t */\n\t\tclnt = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, \"udp\");\n\t\tclnt->cl_auth = authunix_create_default();\n\t\tmemset((char *) &status, '\\0', sizeof(status));\n\t\ttimeout.tv_sec = 25;\n\t\ttimeout.tv_usec = 0;\n\t\terr = clnt_call(clnt, YPPASSWDPROC_UPDATE,\n\t\t\t\t(xdrproc_t) xdr_yppasswd, (char *) &yppwd,\n\t\t\t\t(xdrproc_t) xdr_int, (char *) &status,\n\t\t\t\ttimeout);\n\n\t\tfree (yppwd.oldpass);\n\n\t\tif (err) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\tclnt_sperrno(err));\n\t\t} else if (status) {\n\t\t\tD((\"Error while changing NIS password.\\n\"));\n\t\t}\n\t\tD((\"The password has%s been changed on %s.\",\n\t\t   (err || status) ? \" not\" : \"\", master));\n\t\tpam_syslog(pamh, LOG_NOTICE, \"password%s changed for %s on %s\",\n\t\t\t (err || status) ? \" not\" : \"\", pwd->pw_name, master);\n\n\t\tauth_destroy(clnt->cl_auth);\n\t\tclnt_destroy(clnt);\n\t\tif (err || status) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\t_(\"NIS password could not be changed.\"));\n\t\t\tretval = PAM_TRY_AGAIN;\n\t\t}\n#ifdef PAM_DEBUG\n\t\tsleep(5);\n#endif\n\t    } else {\n\t\t    retval = PAM_TRY_AGAIN;\n\t    }\n#else\n          if (on(UNIX_DEBUG, ctrl)) {\n            pam_syslog(pamh, LOG_DEBUG, \"No NIS support available\");\n          }\n\n          retval = PAM_TRY_AGAIN;\n#endif\n\t}\n\n\tif (_unix_comesfromsource(pamh, forwho, 1, 0)) {\n\t\tif(unlocked) {\n\t\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t\t}\n\t\t}\n#ifdef WITH_SELINUX\n\t        if (unix_selinux_confined())\n\t\t\t  return _unix_run_update_binary(pamh, ctrl, forwho, fromwhat, towhat, remember);\n#endif\n\t\t/* first, save old password */\n\t\tif (save_old_password(pamh, forwho, fromwhat, remember)) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto done;\n\t\t}\n\t\tif (on(UNIX_SHADOW, ctrl) || is_pwd_shadowed(pwd)) {\n\t\t\tretval = unix_update_shadow(pamh, forwho, towhat);\n\t\t\tif (retval == PAM_SUCCESS)\n\t\t\t\tif (!is_pwd_shadowed(pwd))\n\t\t\t\t\tretval = unix_update_passwd(pamh, forwho, \"x\");\n\t\t} else {\n\t\t\tretval = unix_update_passwd(pamh, forwho, towhat);\n\t\t}\n\t}\n\n\ndone:\n\tunlock_pwdf();\n\n\treturn retval;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _do_setpass(pam_handle_t* pamh, const char *forwho,\n\t\t       const char *fromwhat,\n\t\t       char *towhat, unsigned long long ctrl, int remember)\n{\n\tstruct passwd *pwd = NULL;\n\tint retval = 0;\n\tint unlocked = 0;\n\n\tD((\"called\"));\n\n\tpwd = getpwnam(forwho);\n\n\tif (pwd == NULL) {\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\tgoto done;\n\t}\n\n\tif (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, forwho, 0, 1)) {\n#ifdef HAVE_NIS\n\t  char *master;\n\n\t  if ((master=getNISserver(pamh, ctrl)) != NULL) {\n\t\tstruct timeval timeout;\n\t\tstruct yppasswd yppwd;\n\t\tCLIENT *clnt;\n\t\tint status;\n\t\tenum clnt_stat err;\n\n\t\t/* Unlock passwd file to avoid deadlock */\n\t\tunlock_pwdf();\n\t\tunlocked = 1;\n\n\t\t/* Initialize password information */\n\t\typpwd.newpw.pw_passwd = pwd->pw_passwd;\n\t\typpwd.newpw.pw_name = pwd->pw_name;\n\t\typpwd.newpw.pw_uid = pwd->pw_uid;\n\t\typpwd.newpw.pw_gid = pwd->pw_gid;\n\t\typpwd.newpw.pw_gecos = pwd->pw_gecos;\n\t\typpwd.newpw.pw_dir = pwd->pw_dir;\n\t\typpwd.newpw.pw_shell = pwd->pw_shell;\n\t\typpwd.oldpass = fromwhat ? strdup (fromwhat) : strdup (\"\");\n\t\typpwd.newpw.pw_passwd = towhat;\n\n\t\tD((\"Set password %s for %s\", yppwd.newpw.pw_passwd, forwho));\n\n\t\t/* The yppasswd.x file said `unix authentication required',\n\t\t * so I added it. This is the only reason it is in here.\n\t\t * My yppasswdd doesn't use it, but maybe some others out there\n\t\t * do.                                        --okir\n\t\t */\n\t\tclnt = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, \"udp\");\n\t\tclnt->cl_auth = authunix_create_default();\n\t\tmemset((char *) &status, '\\0', sizeof(status));\n\t\ttimeout.tv_sec = 25;\n\t\ttimeout.tv_usec = 0;\n\t\terr = clnt_call(clnt, YPPASSWDPROC_UPDATE,\n\t\t\t\t(xdrproc_t) xdr_yppasswd, (char *) &yppwd,\n\t\t\t\t(xdrproc_t) xdr_int, (char *) &status,\n\t\t\t\ttimeout);\n\n\t\tfree (yppwd.oldpass);\n\n\t\tif (err) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\tclnt_sperrno(err));\n\t\t} else if (status) {\n\t\t\tD((\"Error while changing NIS password.\\n\"));\n\t\t}\n\t\tD((\"The password has%s been changed on %s.\",\n\t\t   (err || status) ? \" not\" : \"\", master));\n\t\tpam_syslog(pamh, LOG_NOTICE, \"password%s changed for %s on %s\",\n\t\t\t (err || status) ? \" not\" : \"\", pwd->pw_name, master);\n\n\t\tauth_destroy(clnt->cl_auth);\n\t\tclnt_destroy(clnt);\n\t\tif (err || status) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\t_(\"NIS password could not be changed.\"));\n\t\t\tretval = PAM_TRY_AGAIN;\n\t\t}\n#ifdef PAM_DEBUG\n\t\tsleep(5);\n#endif\n\t    } else {\n\t\t    retval = PAM_TRY_AGAIN;\n\t    }\n#else\n          if (on(UNIX_DEBUG, ctrl)) {\n            pam_syslog(pamh, LOG_DEBUG, \"No NIS support available\");\n          }\n\n          retval = PAM_TRY_AGAIN;\n#endif\n\t}\n\n\tif (_unix_comesfromsource(pamh, forwho, 1, 0)) {\n\t\tif(unlocked) {\n\t\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t\t}\n\t\t}\n#ifdef WITH_SELINUX\n\t        if (unix_selinux_confined())\n\t\t\t  return _unix_run_update_binary(pamh, ctrl, forwho, fromwhat, towhat, remember);\n#endif\n\t\t/* first, save old password */\n\t\tif (save_old_password(pamh, forwho, fromwhat, remember)) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto done;\n\t\t}\n\t\tif (on(UNIX_SHADOW, ctrl) || is_pwd_shadowed(pwd)) {\n\t\t\tretval = unix_update_shadow(pamh, forwho, towhat);\n\t\t\tif (retval == PAM_SUCCESS)\n\t\t\t\tif (!is_pwd_shadowed(pwd))\n\t\t\t\t\tretval = unix_update_passwd(pamh, forwho, \"x\");\n\t\t} else {\n\t\t\tretval = unix_update_passwd(pamh, forwho, towhat);\n\t\t}\n\t}\n\n\ndone:\n\tunlock_pwdf();\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_pwdf",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_pwdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "607-611",
          "snippet": "void\nunlock_pwdf(void)\n{\n\treturn;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nvoid\nunlock_pwdf(void)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"crypt() failure or out of memory for password\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_password_hash",
          "args": [
            "pamh",
            "pass_new",
            "ctrl",
            "rounds"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"new password not acceptable 2\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_unix_approve_pass",
          "args": [
            "pamh",
            "ctrl",
            "pass_old",
            "pass_new",
            "pass_min_len"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "_pam_unix_approve_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "544-602",
          "snippet": "static int _pam_unix_approve_pass(pam_handle_t * pamh\n\t\t\t\t  ,unsigned long long ctrl\n\t\t\t\t  ,const char *pass_old\n\t\t\t\t  ,const char *pass_new,\n                                  int pass_min_len)\n{\n\tconst void *user;\n\tconst char *remark = NULL;\n\tint retval = PAM_SUCCESS;\n\n\tD((\"&new=%p, &old=%p\", pass_old, pass_new));\n\tD((\"new=[%s]\", pass_new));\n\tD((\"old=[%s]\", pass_old));\n\n\tif (pass_new == NULL || (pass_old && !strcmp(pass_old, pass_new))) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"bad authentication token\");\n\t\t}\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, pass_new == NULL ?\n\t\t\t_(\"No password has been supplied.\") :\n\t\t\t_(\"The password has not been changed.\"));\n\t\treturn PAM_AUTHTOK_ERR;\n\t}\n\t/*\n\t * if one wanted to hardwire authentication token strength\n\t * checking this would be the place - AGM\n\t */\n\n\tretval = pam_get_item(pamh, PAM_USER, &user);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Can not get username\");\n\t\t\treturn PAM_AUTHTOK_ERR;\n\t\t}\n\t}\n\n\tif (strlen(pass_new) > PAM_MAX_RESP_SIZE) {\n\t\tremark = _(\"You must choose a shorter password.\");\n\t\tD((\"length exceeded [%s]\", remark));\n\t} else if (off(UNIX__IAMROOT, ctrl)) {\n\t\tif ((int)strlen(pass_new) < pass_min_len)\n\t\t  remark = _(\"You must choose a longer password.\");\n\t\tD((\"length check [%s]\", remark));\n\t\tif (on(UNIX_REMEMBER_PASSWD, ctrl)) {\n\t\t\tif ((retval = check_old_password(user, pass_new)) == PAM_AUTHTOK_ERR)\n\t\t\t  remark = _(\"Password has been already used. Choose another.\");\n\t\t\tif (retval == PAM_ABORT) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR, \"can't open %s file to check old passwords\",\n\t\t\t\t\tOLD_PASSWORDS_FILE);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tif (remark) {\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, remark);\n\t\tretval = PAM_AUTHTOK_ERR;\n\t}\n\treturn retval;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _pam_unix_approve_pass(pam_handle_t * pamh\n\t\t\t\t  ,unsigned long long ctrl\n\t\t\t\t  ,const char *pass_old\n\t\t\t\t  ,const char *pass_new,\n                                  int pass_min_len)\n{\n\tconst void *user;\n\tconst char *remark = NULL;\n\tint retval = PAM_SUCCESS;\n\n\tD((\"&new=%p, &old=%p\", pass_old, pass_new));\n\tD((\"new=[%s]\", pass_new));\n\tD((\"old=[%s]\", pass_old));\n\n\tif (pass_new == NULL || (pass_old && !strcmp(pass_old, pass_new))) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"bad authentication token\");\n\t\t}\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, pass_new == NULL ?\n\t\t\t_(\"No password has been supplied.\") :\n\t\t\t_(\"The password has not been changed.\"));\n\t\treturn PAM_AUTHTOK_ERR;\n\t}\n\t/*\n\t * if one wanted to hardwire authentication token strength\n\t * checking this would be the place - AGM\n\t */\n\n\tretval = pam_get_item(pamh, PAM_USER, &user);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Can not get username\");\n\t\t\treturn PAM_AUTHTOK_ERR;\n\t\t}\n\t}\n\n\tif (strlen(pass_new) > PAM_MAX_RESP_SIZE) {\n\t\tremark = _(\"You must choose a shorter password.\");\n\t\tD((\"length exceeded [%s]\", remark));\n\t} else if (off(UNIX__IAMROOT, ctrl)) {\n\t\tif ((int)strlen(pass_new) < pass_min_len)\n\t\t  remark = _(\"You must choose a longer password.\");\n\t\tD((\"length check [%s]\", remark));\n\t\tif (on(UNIX_REMEMBER_PASSWD, ctrl)) {\n\t\t\tif ((retval = check_old_password(user, pass_new)) == PAM_AUTHTOK_ERR)\n\t\t\t  remark = _(\"Password has been already used. Choose another.\");\n\t\t\tif (retval == PAM_ABORT) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR, \"can't open %s file to check old passwords\",\n\t\t\t\t\tOLD_PASSWORDS_FILE);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tif (remark) {\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, remark);\n\t\tretval = PAM_AUTHTOK_ERR;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user shadow entry expired\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_verify_shadow",
          "args": [
            "pamh",
            "user",
            "ctrl"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_verify_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "515-542",
          "snippet": "static int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned long long ctrl)\n{\n\tstruct passwd *pwent = NULL;\t/* Password and shadow password */\n\tstruct spwd *spent = NULL;\t/* file entries for the user */\n\tint daysleft;\n\tint retval;\n\n\tretval = get_account_info(pamh, user, &pwent, &spent);\n\tif (retval == PAM_USER_UNKNOWN) {\n\t\treturn retval;\n\t}\n\n\tif (retval == PAM_SUCCESS && spent == NULL)\n\t\treturn PAM_SUCCESS;\n\n\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\tretval = _unix_run_verify_binary(pamh, ctrl, user, &daysleft);\n\t\tif (retval == PAM_AUTH_ERR || retval == PAM_USER_UNKNOWN)\n\t\t\treturn retval;\n\t}\n\telse if (retval == PAM_SUCCESS)\n\t\tretval = check_shadow_expiry(pamh, spent, &daysleft);\n\n\tif (on(UNIX__IAMROOT, ctrl) || retval == PAM_NEW_AUTHTOK_REQD)\n\t\treturn PAM_SUCCESS;\n\n\treturn retval;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned long long ctrl)\n{\n\tstruct passwd *pwent = NULL;\t/* Password and shadow password */\n\tstruct spwd *spent = NULL;\t/* file entries for the user */\n\tint daysleft;\n\tint retval;\n\n\tretval = get_account_info(pamh, user, &pwent, &spent);\n\tif (retval == PAM_USER_UNKNOWN) {\n\t\treturn retval;\n\t}\n\n\tif (retval == PAM_SUCCESS && spent == NULL)\n\t\treturn PAM_SUCCESS;\n\n\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\tretval = _unix_run_verify_binary(pamh, ctrl, user, &daysleft);\n\t\tif (retval == PAM_AUTH_ERR || retval == PAM_USER_UNKNOWN)\n\t\t\treturn retval;\n\t}\n\telse if (retval == PAM_SUCCESS)\n\t\tretval = check_shadow_expiry(pamh, spent, &daysleft);\n\n\tif (on(UNIX__IAMROOT, ctrl) || retval == PAM_NEW_AUTHTOK_REQD)\n\t\treturn PAM_SUCCESS;\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user password changed by another process\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_verify_password",
          "args": [
            "pamh",
            "user",
            "pass_old",
            "ctrl"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_verify_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "661-817",
          "snippet": "int _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define UNIX_MAX_RETRIES              3",
            "#define FAIL_PREFIX                   \"-UN*X-FAIL-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\n#define UNIX_MAX_RETRIES              3\n#define FAIL_PREFIX                   \"-UN*X-FAIL-\"\n\nint _unix_verify_password(pam_handle_t * pamh, const char *name\n\t\t\t  ,const char *p, unsigned long long ctrl)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tchar *data_name;\n\tchar pw[PAM_MAX_RESP_SIZE + 1];\n\tint retval;\n\n\n\tD((\"called\"));\n\n#ifdef HAVE_PAM_FAIL_DELAY\n\tif (off(UNIX_NODELAY, ctrl)) {\n\t\tD((\"setting delay\"));\n\t\t(void) pam_fail_delay(pamh, 2000000);\t/* 2 sec delay for on failure */\n\t}\n#endif\n\n\t/* locate the entry for this user */\n\n\tD((\"locating user's record\"));\n\n\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\tdata_name = (char *) malloc(sizeof(FAIL_PREFIX) + strlen(name));\n\tif (data_name == NULL) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"no memory for data-name\");\n\t} else {\n\t\tstrcpy(data_name, FAIL_PREFIX);\n\t\tstrcpy(data_name + sizeof(FAIL_PREFIX) - 1, name);\n\t}\n\n\tif (p != NULL && strlen(p) > PAM_MAX_RESP_SIZE) {\n\t\tmemset(pw, 0, sizeof(pw));\n\t\tp = strncpy(pw, p, sizeof(pw) - 1);\n\t}\n\n\tif (retval != PAM_SUCCESS) {\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tD((\"running helper binary\"));\n\t\t\tretval = _unix_run_helper_binary(pamh, p, ctrl, name);\n\t\t} else {\n\t\t\tD((\"user's record unavailable\"));\n\t\t\tp = NULL;\n\t\t\tif (on(UNIX_AUDIT, ctrl)) {\n\t\t\t\t/* this might be a typo and the user has given a password\n\t\t\t\t   instead of a username. Careful with this. */\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t         \"check pass; user (%s) unknown\", name);\n\t\t\t} else {\n\t\t\t\tname = NULL;\n\t\t\t\tif (on(UNIX_DEBUG, ctrl) || pwd == NULL) {\n\t\t\t\t    pam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t            \"check pass; user unknown\");\n\t\t\t\t} else {\n\t\t\t\t    /* don't log failure as another pam module can succeed */\n\t\t\t\t    goto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tretval = verify_pwd_hash(pamh, p, salt, off(UNIX__NONULL, ctrl));\n\t}\n\n\tif (retval == PAM_SUCCESS) {\n\t\tif (data_name)\t/* reset failures */\n\t\t\tpam_set_data(pamh, data_name, NULL, _cleanup_failures);\n\t} else {\n\t\tif (data_name != NULL) {\n\t\t\tstruct _pam_failed_auth *new = NULL;\n\t\t\tconst struct _pam_failed_auth *old = NULL;\n\n\t\t\t/* get a failure recorder */\n\n\t\t\tnew = (struct _pam_failed_auth *)\n\t\t\t    malloc(sizeof(struct _pam_failed_auth));\n\n\t\t\tif (new != NULL) {\n\n\t\t\t    const char *login_name;\n\t\t\t    const void *void_old;\n\n\n\t\t\t    login_name = pam_modutil_getlogin(pamh);\n\t\t\t    if (login_name == NULL) {\n\t\t\t\tlogin_name = \"\";\n\t\t\t    }\n\n\t\t\t        new->user = strdup(name ? name : \"\");\n\t\t\t\tnew->uid = getuid();\n\t\t\t\tnew->euid = geteuid();\n\t\t\t\tnew->name = strdup(login_name);\n\n\t\t\t\t/* any previous failures for this user ? */\n\t\t\t\tif (pam_get_data(pamh, data_name, &void_old)\n\t\t\t\t    == PAM_SUCCESS)\n\t\t\t\t        old = void_old;\n\t\t\t\telse\n\t\t\t\t        old = NULL;\n\n\t\t\t\tif (old != NULL) {\n\t\t\t\t\tnew->count = old->count + 1;\n\t\t\t\t\tif (new->count >= UNIX_MAX_RETRIES) {\n\t\t\t\t\t\tretval = PAM_MAXTRIES;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst void *service=NULL;\n\t\t\t\t\tconst void *ruser=NULL;\n\t\t\t\t\tconst void *rhost=NULL;\n\t\t\t\t\tconst void *tty=NULL;\n\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_SERVICE,\n\t\t\t\t\t\t\t    &service);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RUSER,\n\t\t\t\t\t\t\t    &ruser);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_RHOST,\n\t\t\t\t\t\t\t    &rhost);\n\t\t\t\t\t(void) pam_get_item(pamh, PAM_TTY,\n\t\t\t\t\t\t\t    &tty);\n\n\t\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t\t         \"authentication failure; \"\n\t\t\t\t\t         \"logname=%s uid=%d euid=%d \"\n\t\t\t\t\t         \"tty=%s ruser=%s rhost=%s \"\n\t\t\t\t\t         \"%s%s\",\n\t\t\t\t\t         new->name, new->uid, new->euid,\n\t\t\t\t\t         tty ? (const char *)tty : \"\",\n\t\t\t\t\t         ruser ? (const char *)ruser : \"\",\n\t\t\t\t\t         rhost ? (const char *)rhost : \"\",\n\t\t\t\t\t         (new->user && new->user[0] != '\\0')\n\t\t\t\t\t          ? \" user=\" : \"\",\n\t\t\t\t\t         new->user\n\t\t\t\t\t);\n\t\t\t\t\tnew->count = 1;\n\t\t\t\t}\n\n\t\t\t\tpam_set_data(pamh, data_name, new, _cleanup_failures);\n\n\t\t\t} else {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t         \"no memory for failure recorder\");\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tmemset(pw, 0, sizeof(pw)); /* clear memory of the password */\n\tif (data_name)\n\t\t_pam_delete(data_name);\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\tD((\"done [%d].\", retval));\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"new password not acceptable\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "NULL"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"password - new password not obtained\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_DEBUG",
            "ctrl"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_get_authtok",
          "args": [
            "pamh",
            "PAM_AUTHTOK",
            "&pass_new",
            "NULL"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "UNIX_USE_FIRST_PASS",
            "lctrl"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "set_exec_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "422-430",
          "snippet": "static int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nset_exec_context(const pam_handle_t *pamh, const char *context)\n{\n  if (setexeccon(context) == 0)\n    return 0;\n  pam_syslog(pamh, LOG_ERR, \"Setting executable context \\\"%s\\\" failed: %m\",\n\t     context ? context : \"\");\n  return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"user not authenticated\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_OLDAUTHTOK",
            "&item"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_make_remark",
          "args": [
            "pamh",
            "ctrl",
            "PAM_ERROR_MSG",
            "_(\"You must wait longer to change your password.\")"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "_make_remark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "38-47",
          "snippet": "int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"You must wait longer to change your password.\""
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "_check_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_chkpwd.c",
          "lines": "38-60",
          "snippet": "static int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"passverify.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <libaudit.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <libaudit.h>\n#include <errno.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__IAMROOT",
            "ctrl"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"password - (old) token not obtained\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_authtok",
          "args": [
            "pamh",
            "PAM_OLDAUTHTOK",
            "&pass_old",
            "NULL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_info",
          "args": [
            "pamh",
            "_(\"Changing password for %s.\")",
            "user"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__QUIET",
            "ctrl"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_comesfromsource",
          "args": [
            "pamh",
            "user",
            "0",
            "1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_comesfromsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "456-460",
          "snippet": "int _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__IAMROOT",
            "ctrl"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_blankpasswd",
          "args": [
            "pamh",
            "ctrl",
            "user"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_blankpasswd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "597-659",
          "snippet": "int\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint\n_unix_blankpasswd (pam_handle_t *pamh, unsigned long long ctrl, const char *name)\n{\n\tstruct passwd *pwd = NULL;\n\tchar *salt = NULL;\n\tint daysleft;\n\tint retval;\n\tint blank = 0;\n\tint execloop;\n\tint nonexistent_check = 1;\n\n\tD((\"called\"));\n\n\t/*\n\t * This function does not have to be too smart if something goes\n\t * wrong, return FALSE and let this case to be treated somewhere\n\t * else (CG)\n\t */\n\n\tif (on(UNIX_NULLRESETOK, ctrl)) {\n\t    retval = _unix_verify_user(pamh, ctrl, name, &daysleft);\n\t    if (retval == PAM_NEW_AUTHTOK_REQD) {\n\t        /* password reset is enforced, allow authentication with empty password */\n\t        pam_syslog(pamh, LOG_DEBUG, \"user [%s] has expired blank password, enabling nullok\", name);\n\t        set(UNIX__NULLOK, ctrl);\n\t    }\n\t}\n\n\tif (on(UNIX__NONULL, ctrl))\n\t\treturn 0;\t/* will fail but don't let on yet */\n\n\t/* UNIX passwords area */\n\n\t/*\n\t * Execute this loop twice: one checking the password hash of an existing\n\t * user and another one for a non-existing user. This way the runtimes\n\t * are equal, making it more difficult to differentiate existing from\n\t * non-existing users.\n\t */\n\tfor (execloop = 0; execloop < 2; ++execloop) {\n\t\tretval = get_pwd_hash(pamh, name, &pwd, &salt);\n\n\t\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\t\tif (_unix_run_helper_binary(pamh, NULL, ctrl, name) == PAM_SUCCESS)\n\t\t\t\tblank = nonexistent_check;\n\t\t} else if (retval == PAM_USER_UNKNOWN) {\n\t\t\tname = \"root\";\n\t\t\tnonexistent_check = 0;\n\t\t\tcontinue;\n\t\t} else if (salt != NULL) {\n\t\t\tif (strlen(salt) == 0)\n\t\t\t\tblank = nonexistent_check;\n\t\t}\n\t\tname = \"pam_unix_non_existent:\";\n\t\t/* non-existent user check will not affect the blank value */\n\t}\n\n\t/* tidy up */\n\tif (salt)\n\t\t_pam_delete(salt);\n\n\treturn blank;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user \\\"%s\\\" has corrupted passwd entry\"",
            "user"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_getpwnam",
          "args": [
            "pamh",
            "user",
            "1",
            "1",
            "&pwd"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_getpwnam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "308-449",
          "snippet": "int _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_getpwnam(pam_handle_t *pamh, const char *name,\n\t\t   int files, int nis, struct passwd **ret)\n{\n\tFILE *passwd;\n\tchar buf[16384];\n\tint matched = 0, buflen;\n\tchar *slogin, *spasswd, *suid, *sgid, *sgecos, *shome, *sshell, *p;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (!matched && files) {\n\t\tint userlen = strlen(name);\n\t\tpasswd = fopen(\"/etc/passwd\", \"r\");\n\t\tif (passwd != NULL) {\n\t\t\twhile (fgets(buf, sizeof(buf), passwd) != NULL) {\n\t\t\t\tif ((buf[userlen] == ':') &&\n\t\t\t\t    (strncmp(name, buf, userlen) == 0)) {\n\t\t\t\t\tp = buf + strlen(buf) - 1;\n\t\t\t\t\twhile (isspace(*p) && (p >= buf)) {\n\t\t\t\t\t\t*p-- = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(passwd);\n\t\t}\n\t}\n\n#if defined(HAVE_YP_GET_DEFAULT_DOMAIN) && defined (HAVE_YP_BIND) && defined (HAVE_YP_MATCH) && defined (HAVE_YP_UNBIND)\n\tif (!matched && nis) {\n\t\tchar *userinfo = NULL, *domain = NULL;\n\t\tint len = 0, i;\n\t\tlen = yp_get_default_domain(&domain);\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\tlen = yp_bind(domain);\n\t\t}\n\t\tif (len == YPERR_SUCCESS) {\n\t\t\ti = yp_match(domain, \"passwd.byname\", name,\n\t\t\t\t     strlen(name), &userinfo, &len);\n\t\t\typ_unbind(domain);\n\t\t\tif ((i == YPERR_SUCCESS) && ((size_t)len < sizeof(buf))) {\n\t\t\t\tstrncpy(buf, userinfo, sizeof(buf) - 1);\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tmatched = 1;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t/* we don't have NIS support, make compiler happy. */\n\t(void) nis;\n#endif\n\n\tif (matched && (ret != NULL)) {\n\t\t*ret = NULL;\n\n\t\tslogin = buf;\n\n\t\tspasswd = strchr(slogin, ':');\n\t\tif (spasswd == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*spasswd++ = '\\0';\n\n\t\tsuid = strchr(spasswd, ':');\n\t\tif (suid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*suid++ = '\\0';\n\n\t\tsgid = strchr(suid, ':');\n\t\tif (sgid == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgid++ = '\\0';\n\n\t\tsgecos = strchr(sgid, ':');\n\t\tif (sgecos == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sgecos++ = '\\0';\n\n\t\tshome = strchr(sgecos, ':');\n\t\tif (shome == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*shome++ = '\\0';\n\n\t\tsshell = strchr(shome, ':');\n\t\tif (sshell == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\t*sshell++ = '\\0';\n\n\t\tbuflen = sizeof(struct passwd) +\n\t\t\t strlen(slogin) + 1 +\n\t\t\t strlen(spasswd) + 1 +\n\t\t\t strlen(sgecos) + 1 +\n\t\t\t strlen(shome) + 1 +\n\t\t\t strlen(sshell) + 1;\n\t\t*ret = malloc(buflen);\n\t\tif (*ret == NULL) {\n\t\t\treturn matched;\n\t\t}\n\t\tmemset(*ret, '\\0', buflen);\n\n\t\t(*ret)->pw_uid = strtol(suid, &p, 10);\n\t\tif ((strlen(suid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\t(*ret)->pw_gid = strtol(sgid, &p, 10);\n\t\tif ((strlen(sgid) == 0) || (*p != '\\0')) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t\treturn matched;\n\t\t}\n\n\t\tp = ((char*)(*ret)) + sizeof(struct passwd);\n\t\t(*ret)->pw_name = strcpy(p, slogin);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_passwd = strcpy(p, spasswd);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_gecos = strcpy(p, sgecos);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_dir = strcpy(p, shome);\n\t\tp += strlen(p) + 1;\n\t\t(*ret)->pw_shell = strcpy(p, sshell);\n\n\t\tsnprintf(buf, sizeof(buf), \"_pam_unix_getpwnam_%s\", name);\n\n\t\tif (pam_set_data(pamh, buf,\n\t\t\t\t *ret, _unix_cleanup) != PAM_SUCCESS) {\n\t\t\tfree(*ret);\n\t\t\t*ret = NULL;\n\t\t}\n\t}\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"user \\\"%s\\\" does not exist in /etc/passwd%s\"",
            "user",
            "on(UNIX_NIS, ctrl) ? \" or NIS\" : \"\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"password - could not identify user\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"username [%s] obtained\"",
            "user"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"bad username [%s]\"",
            "user"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_ctrl",
          "args": [
            "pamh",
            "flags",
            "&remember",
            "&rounds",
            "&pass_min_len",
            "argc",
            "argv"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "_set_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "53-217",
          "snippet": "unsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nunsigned long long _set_ctrl(pam_handle_t *pamh, int flags, int *remember,\n\t\t\t     int *rounds, int *pass_min_len, int argc,\n\t\t\t     const char **argv)\n{\n\tunsigned long long ctrl;\n\tchar *val;\n\tint j;\n\n\tD((\"called.\"));\n\n\tctrl = UNIX_DEFAULTS;\t/* the default selection of options */\n\n\t/* set some flags manually */\n\n\tif (getuid() == 0 && !(flags & PAM_CHANGE_EXPIRED_AUTHTOK)) {\n\t\tD((\"IAMROOT\"));\n\t\tset(UNIX__IAMROOT, ctrl);\n\t}\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tD((\"UPDATE_AUTHTOK\"));\n\t\tset(UNIX__UPDATE, ctrl);\n\t}\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tD((\"PRELIM_CHECK\"));\n\t\tset(UNIX__PRELIM, ctrl);\n\t}\n\tif (flags & PAM_SILENT) {\n\t\tD((\"SILENT\"));\n\t\tset(UNIX__QUIET, ctrl);\n\t}\n\n\t/* preset encryption method with value from /etc/login.defs */\n\tval = pam_modutil_search_key(pamh, LOGIN_DEFS, \"ENCRYPT_METHOD\");\n\tif (val) {\n\t  for (j = 0; j < UNIX_CTRLS_; ++j) {\n\t    if (unix_args[j].token && unix_args[j].is_hash_algo\n\t\t&& !strncasecmp(val, unix_args[j].token, strlen(unix_args[j].token))) {\n\t      break;\n\t    }\n\t  }\n\t  if (j >= UNIX_CTRLS_) {\n\t    pam_syslog(pamh, LOG_WARNING, \"unrecognized ENCRYPT_METHOD value [%s]\", val);\n\t  } else {\n\t    ctrl &= unix_args[j].mask;\t/* for turning things off */\n\t    ctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t  }\n\t  free (val);\n\n\t  /* read number of rounds for crypt algo */\n\t  if (rounds && (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl))) {\n\t    val = pam_modutil_search_key(pamh, LOGIN_DEFS, \"SHA_CRYPT_MAX_ROUNDS\");\n\n\t    if (val) {\n\t      *rounds = strtol(val, NULL, 10);\n\t      set(UNIX_ALGO_ROUNDS, ctrl);\n\t      free (val);\n\t    }\n\t  }\n\t}\n\n\t/* now parse the arguments to this module */\n\n\tfor (; argc-- > 0; ++argv) {\n\t\tconst char *str = NULL;\n\n\t\tD((\"pam_unix arg: %s\", *argv));\n\n\t\tfor (j = 0; j < UNIX_CTRLS_; ++j) {\n\t\t\tif (unix_args[j].token\n\t\t\t    && (str = pam_str_skip_prefix_len(*argv,\n\t\t\t\t\t\t\t      unix_args[j].token,\n\t\t\t\t\t\t\t      strlen(unix_args[j].token))) != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (str == NULL) {\n\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t         \"unrecognized option [%s]\", *argv);\n\t\t} else {\n\t\t\t/* special cases */\n\t\t\tif (j == UNIX_REMEMBER_PASSWD) {\n\t\t\t\tif (remember == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option remember not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*remember = strtol(str, NULL, 10);\n\t\t\t\tif ((*remember == INT_MIN) || (*remember == INT_MAX))\n\t\t\t\t\t*remember = -1;\n\t\t\t\tif (*remember > 400)\n\t\t\t\t\t*remember = 400;\n\t\t\t} else if (j == UNIX_MIN_PASS_LEN) {\n\t\t\t\tif (pass_min_len == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option minlen not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*pass_min_len = atoi(str);\n\t\t\t} else if (j == UNIX_ALGO_ROUNDS) {\n\t\t\t\tif (rounds == NULL) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t    \"option rounds not allowed for this module type\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*rounds = strtol(str, NULL, 10);\n\t\t\t}\n\n\t\t\tctrl &= unix_args[j].mask;\t/* for turning things off */\n\t\t\tctrl |= unix_args[j].flag;\t/* for turning things on  */\n\t\t}\n\t}\n\n\tif (UNIX_DES_CRYPT(ctrl)\n\t    && pass_min_len && *pass_min_len > 8)\n\t  {\n\t    pam_syslog (pamh, LOG_NOTICE, \"Password minlen reset to 8 characters\");\n\t    *pass_min_len = 8;\n\t  }\n\n\tif (flags & PAM_DISALLOW_NULL_AUTHTOK) {\n\t\tD((\"DISALLOW_NULL_AUTHTOK\"));\n\t\tset(UNIX__NONULL, ctrl);\n\t}\n\n\t/* Set default rounds for blowfish, gost-yescrypt and yescrypt */\n\tif (off(UNIX_ALGO_ROUNDS, ctrl) && rounds != NULL) {\n\t\tif (on(UNIX_BLOWFISH_PASS, ctrl) ||\n\t\t    on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\t*rounds = 5;\n\t\t\tset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t}\n\t}\n\n\t/* Enforce sane \"rounds\" values */\n\tif (on(UNIX_ALGO_ROUNDS, ctrl)) {\n\t\tif (on(UNIX_GOST_YESCRYPT_PASS, ctrl) ||\n\t\t    on(UNIX_YESCRYPT_PASS, ctrl)) {\n\t\t\tif (*rounds < 3 || *rounds > 11)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_BLOWFISH_PASS, ctrl)) {\n\t\t\tif (*rounds < 4 || *rounds > 31)\n\t\t\t\t*rounds = 5;\n\t\t} else if (on(UNIX_SHA256_PASS, ctrl) || on(UNIX_SHA512_PASS, ctrl)) {\n\t\t\tif ((*rounds < 1000) || (*rounds == INT_MAX)) {\n\t\t\t\t/* don't care about bogus values */\n\t\t\t\t*rounds = 0;\n\t\t\t\tunset(UNIX_ALGO_ROUNDS, ctrl);\n\t\t\t} else if (*rounds >= 10000000) {\n\t\t\t\t*rounds = 9999999;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* auditing is a more sensitive version of debug */\n\n\tif (on(UNIX_AUDIT, ctrl)) {\n\t\tset(UNIX_DEBUG, ctrl);\n\t}\n\t/* return the set of flags */\n\n\tD((\"done.\"));\n\treturn ctrl;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MAX_PASSWD_TRIES\t3\n\nint\npam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n\tunsigned long long ctrl, lctrl;\n\tint retval;\n\tint remember = -1;\n\tint rounds = 0;\n\tint pass_min_len = 0;\n\n\t/* <DO NOT free() THESE> */\n\tconst char *user;\n\tconst void *item;\n\tconst char *pass_old, *pass_new;\n\t/* </DO NOT free() THESE> */\n\n\tD((\"called.\"));\n\n\tctrl = _set_ctrl(pamh, flags, &remember, &rounds, &pass_min_len,\n\t                 argc, argv);\n\n\t/*\n\t * First get the name of a user\n\t */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tif (retval == PAM_SUCCESS) {\n\t\t/*\n\t\t * Various libraries at various times have had bugs related to\n\t\t * '+' or '-' as the first character of a user name. Don't\n\t\t * allow them.\n\t\t */\n\t\tif (user[0] == '-' || user[0] == '+') {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"bad username [%s]\", user);\n\t\t\treturn PAM_USER_UNKNOWN;\n\t\t}\n\t\tif (retval == PAM_SUCCESS && on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"username [%s] obtained\",\n\t\t\t         user);\n\t} else {\n\t\tif (on(UNIX_DEBUG, ctrl))\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t         \"password - could not identify user\");\n\t\treturn retval;\n\t}\n\n\tD((\"Got username of %s\", user));\n\n\t/*\n\t * Before we do anything else, check to make sure that the user's\n\t * info is in one of the databases we can modify from this module,\n\t * which currently is 'files' and 'nis'.  We have to do this because\n\t * getpwnam() doesn't tell you *where* the information it gives you\n\t * came from, nor should it.  That's our job.\n\t */\n\tif (_unix_comesfromsource(pamh, user, 1, on(UNIX_NIS, ctrl)) == 0) {\n\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t \"user \\\"%s\\\" does not exist in /etc/passwd%s\",\n\t\t\t user, on(UNIX_NIS, ctrl) ? \" or NIS\" : \"\");\n\t\treturn PAM_USER_UNKNOWN;\n\t} else {\n\t\tstruct passwd *pwd;\n\t\t_unix_getpwnam(pamh, user, 1, 1, &pwd);\n\t\tif (pwd == NULL) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\"user \\\"%s\\\" has corrupted passwd entry\",\n\t\t\t\tuser);\n\t\t\treturn PAM_USER_UNKNOWN;\n\t\t}\n\t}\n\n\t/*\n\t * This is not an AUTH module!\n\t */\n\tif (on(UNIX__NONULL, ctrl))\n\t\tset(UNIX__NULLOK, ctrl);\n\n\tif (on(UNIX__PRELIM, ctrl)) {\n\t\t/*\n\t\t * obtain and verify the current password (OLDAUTHTOK) for\n\t\t * the user.\n\t\t */\n\t\tD((\"prelim check\"));\n\n\t\tif (_unix_blankpasswd(pamh, ctrl, user)) {\n\t\t\treturn PAM_SUCCESS;\n\t\t} else if (off(UNIX__IAMROOT, ctrl) ||\n\t\t\t   (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, user, 0, 1))) {\n\t\t\t/* instruct user what is happening */\n\t\t\tif (off(UNIX__QUIET, ctrl)) {\n\t\t\t\tretval = pam_info(pamh, _(\"Changing password for %s.\"), user);\n\t\t\t\tif (retval != PAM_SUCCESS)\n\t\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tretval = pam_get_authtok(pamh, PAM_OLDAUTHTOK, &pass_old, NULL);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t\t    \"password - (old) token not obtained\");\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\t/* verify that this is the password for this user */\n\n\t\t\tretval = _unix_verify_password(pamh, user, pass_old, ctrl);\n\t\t} else {\n\t\t\tD((\"process run by root so do nothing this time around\"));\n\t\t\tpass_old = NULL;\n\t\t\tretval = PAM_SUCCESS;\t/* root doesn't have too */\n\t\t}\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tD((\"Authentication failed\"));\n\t\t\tpass_old = NULL;\n\t\t\treturn retval;\n\t\t}\n\t\tpass_old = NULL;\n\t\tretval = _unix_verify_shadow(pamh,user, ctrl);\n\t\tif (retval == PAM_AUTHTOK_ERR) {\n\t\t\tif (off(UNIX__IAMROOT, ctrl))\n\t\t\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG,\n\t\t\t\t\t     _(\"You must wait longer to change your password.\"));\n\t\t\telse\n\t\t\t\tretval = PAM_SUCCESS;\n\t\t}\n\t} else if (on(UNIX__UPDATE, ctrl)) {\n\t\t/*\n\t\t * tpass is used below to store the _pam_md() return; it\n\t\t * should be _pam_delete()'d.\n\t\t */\n\n\t\tchar *tpass = NULL;\n\t\tint retry = 0;\n\n\t\t/*\n\t\t * obtain the proposed password\n\t\t */\n\n\t\tD((\"do update\"));\n\n\t\t/*\n\t\t * get the old token back. NULL was ok only if root [at this\n\t\t * point we assume that this has already been enforced on a\n\t\t * previous call to this function].\n\t\t */\n\n\t\tretval = pam_get_item(pamh, PAM_OLDAUTHTOK, &item);\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user not authenticated\");\n\t\t\treturn retval;\n\t\t}\n\t\tpass_old = item;\n\t\tD((\"pass_old [%s]\", pass_old));\n\n\t\tD((\"get new password now\"));\n\n\t\tlctrl = ctrl;\n\n\t\tif (on(UNIX_USE_AUTHTOK, lctrl)) {\n\t\t\tset(UNIX_USE_FIRST_PASS, lctrl);\n\t\t}\n\t\tif (on(UNIX_USE_FIRST_PASS, lctrl)) {\n\t\t\tretry = MAX_PASSWD_TRIES-1;\n\t\t}\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\twhile ((retval != PAM_SUCCESS) && (retry++ < MAX_PASSWD_TRIES)) {\n\t\t\t/*\n\t\t\t * use_authtok is to force the use of a previously entered\n\t\t\t * password -- needed for pluggable password strength checking\n\t\t\t */\n\n\t\t\tretval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass_new, NULL);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\t\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t\t\t\t \"password - new password not obtained\");\n\t\t\t\t}\n\t\t\t\tpass_old = NULL;\t/* tidy up */\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tD((\"returned to _unix_chauthtok\"));\n\n\t\t\t/*\n\t\t\t * At this point we know who the user is and what they\n\t\t\t * propose as their new password. Verify that the new\n\t\t\t * password is acceptable.\n\t\t\t */\n\n\t\t\tif (*(const char *)pass_new == '\\0') {\t/* \"\\0\" password = NULL */\n\t\t\t\tpass_new = NULL;\n\t\t\t}\n\t\t\tretval = _pam_unix_approve_pass(pamh, ctrl, pass_old,\n\t\t\t                                pass_new, pass_min_len);\n\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_set_item(pamh, PAM_AUTHTOK, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t         \"new password not acceptable\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\treturn retval;\n\t\t}\n\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t}\n\n\t\tif (pass_old) {\n\t\t\tretval = _unix_verify_password(pamh, user, pass_old, ctrl);\n\t\t\tif (retval != PAM_SUCCESS) {\n\t\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user password changed by another process\");\n\t\t\t\tunlock_pwdf();\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\tretval = _unix_verify_shadow(pamh, user, ctrl);\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE, \"user shadow entry expired\");\n\t\t\tunlock_pwdf();\n\t\t\treturn retval;\n\t\t}\n\n\t\tretval = _pam_unix_approve_pass(pamh, ctrl, pass_old, pass_new,\n\t\t                                pass_min_len);\n\t\tif (retval != PAM_SUCCESS) {\n\t\t\tpam_syslog(pamh, LOG_NOTICE,\n\t\t\t         \"new password not acceptable 2\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\tunlock_pwdf();\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * By reaching here we have approved the passwords and must now\n\t\t * rebuild the password database file.\n\t\t */\n\n\t\t/*\n\t\t * First we encrypt the new password.\n\t\t */\n\n\t\ttpass = create_password_hash(pamh, pass_new, ctrl, rounds);\n\t\tif (tpass == NULL) {\n\t\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t\t\t\"crypt() failure or out of memory for password\");\n\t\t\tpass_new = pass_old = NULL;\t/* tidy up */\n\t\t\tunlock_pwdf();\n\t\t\treturn PAM_BUF_ERR;\n\t\t}\n\n\t\tD((\"password processed\"));\n\n\t\t/* update the password database(s) -- race conditions..? */\n\n\t\tretval = _do_setpass(pamh, user, pass_old, tpass, ctrl,\n\t\t                     remember);\n\t        /* _do_setpass has called unlock_pwdf for us */\n\n\t\t_pam_delete(tpass);\n\t\tpass_old = pass_new = NULL;\n\t} else {\t\t/* something has broken with the module */\n\t\tpam_syslog(pamh, LOG_CRIT,\n\t\t         \"password received unknown request\");\n\t\tretval = PAM_ABORT;\n\t}\n\n\tD((\"retval was %d\", retval));\n\n\treturn retval;\n}"
  },
  {
    "function_name": "_pam_unix_approve_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "544-602",
    "snippet": "static int _pam_unix_approve_pass(pam_handle_t * pamh\n\t\t\t\t  ,unsigned long long ctrl\n\t\t\t\t  ,const char *pass_old\n\t\t\t\t  ,const char *pass_new,\n                                  int pass_min_len)\n{\n\tconst void *user;\n\tconst char *remark = NULL;\n\tint retval = PAM_SUCCESS;\n\n\tD((\"&new=%p, &old=%p\", pass_old, pass_new));\n\tD((\"new=[%s]\", pass_new));\n\tD((\"old=[%s]\", pass_old));\n\n\tif (pass_new == NULL || (pass_old && !strcmp(pass_old, pass_new))) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"bad authentication token\");\n\t\t}\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, pass_new == NULL ?\n\t\t\t_(\"No password has been supplied.\") :\n\t\t\t_(\"The password has not been changed.\"));\n\t\treturn PAM_AUTHTOK_ERR;\n\t}\n\t/*\n\t * if one wanted to hardwire authentication token strength\n\t * checking this would be the place - AGM\n\t */\n\n\tretval = pam_get_item(pamh, PAM_USER, &user);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Can not get username\");\n\t\t\treturn PAM_AUTHTOK_ERR;\n\t\t}\n\t}\n\n\tif (strlen(pass_new) > PAM_MAX_RESP_SIZE) {\n\t\tremark = _(\"You must choose a shorter password.\");\n\t\tD((\"length exceeded [%s]\", remark));\n\t} else if (off(UNIX__IAMROOT, ctrl)) {\n\t\tif ((int)strlen(pass_new) < pass_min_len)\n\t\t  remark = _(\"You must choose a longer password.\");\n\t\tD((\"length check [%s]\", remark));\n\t\tif (on(UNIX_REMEMBER_PASSWD, ctrl)) {\n\t\t\tif ((retval = check_old_password(user, pass_new)) == PAM_AUTHTOK_ERR)\n\t\t\t  remark = _(\"Password has been already used. Choose another.\");\n\t\t\tif (retval == PAM_ABORT) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR, \"can't open %s file to check old passwords\",\n\t\t\t\t\tOLD_PASSWORDS_FILE);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tif (remark) {\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, remark);\n\t\tretval = PAM_AUTHTOK_ERR;\n\t}\n\treturn retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_make_remark",
          "args": [
            "pamh",
            "ctrl",
            "PAM_ERROR_MSG",
            "remark"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_make_remark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "38-47",
          "snippet": "int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"can't open %s file to check old passwords\"",
            "OLD_PASSWORDS_FILE"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Password has been already used. Choose another.\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "_check_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_chkpwd.c",
          "lines": "38-60",
          "snippet": "static int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"passverify.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <libaudit.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <libaudit.h>\n#include <errno.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_old_password",
          "args": [
            "user",
            "pass_new"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "check_old_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "349-386",
          "snippet": "static int check_old_password(const char *forwho, const char *newpass)\n{\n\tstatic char buf[16384];\n\tchar *s_pas;\n\tint retval = PAM_SUCCESS;\n\tFILE *opwfile;\n\tsize_t len = strlen(forwho);\n\n\topwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n\tif (opwfile == NULL)\n\t\treturn PAM_ABORT;\n\n\twhile (fgets(buf, 16380, opwfile)) {\n\t\tif (!strncmp(buf, forwho, len) && (buf[len] == ':' ||\n\t\t\tbuf[len] == ',')) {\n\t\t\tchar *sptr;\n\t\t\tbuf[strlen(buf) - 1] = '\\0';\n\t\t\t/* s_luser = */ strtok_r(buf, \":,\", &sptr);\n\t\t\t/* s_uid = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\t/* s_npas = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\twhile (s_pas != NULL) {\n\t\t\t\tchar *md5pass = Goodcrypt_md5(newpass, s_pas);\n\t\t\t\tif (md5pass == NULL || !strcmp(md5pass, s_pas)) {\n\t\t\t\t\t_pam_delete(md5pass);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\t\t_pam_delete(md5pass);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(opwfile);\n\n\treturn retval;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int check_old_password(const char *forwho, const char *newpass)\n{\n\tstatic char buf[16384];\n\tchar *s_pas;\n\tint retval = PAM_SUCCESS;\n\tFILE *opwfile;\n\tsize_t len = strlen(forwho);\n\n\topwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n\tif (opwfile == NULL)\n\t\treturn PAM_ABORT;\n\n\twhile (fgets(buf, 16380, opwfile)) {\n\t\tif (!strncmp(buf, forwho, len) && (buf[len] == ':' ||\n\t\t\tbuf[len] == ',')) {\n\t\t\tchar *sptr;\n\t\t\tbuf[strlen(buf) - 1] = '\\0';\n\t\t\t/* s_luser = */ strtok_r(buf, \":,\", &sptr);\n\t\t\t/* s_uid = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\t/* s_npas = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\twhile (s_pas != NULL) {\n\t\t\t\tchar *md5pass = Goodcrypt_md5(newpass, s_pas);\n\t\t\t\tif (md5pass == NULL || !strcmp(md5pass, s_pas)) {\n\t\t\t\t\t_pam_delete(md5pass);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\t\t_pam_delete(md5pass);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(opwfile);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_REMEMBER_PASSWD",
            "ctrl"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"length check [%s]\", remark)"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass_new"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX__IAMROOT",
            "ctrl"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass_new"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Can not get username\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER",
            "&user"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"bad authentication token\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pass_old",
            "pass_new"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _pam_unix_approve_pass(pam_handle_t * pamh\n\t\t\t\t  ,unsigned long long ctrl\n\t\t\t\t  ,const char *pass_old\n\t\t\t\t  ,const char *pass_new,\n                                  int pass_min_len)\n{\n\tconst void *user;\n\tconst char *remark = NULL;\n\tint retval = PAM_SUCCESS;\n\n\tD((\"&new=%p, &old=%p\", pass_old, pass_new));\n\tD((\"new=[%s]\", pass_new));\n\tD((\"old=[%s]\", pass_old));\n\n\tif (pass_new == NULL || (pass_old && !strcmp(pass_old, pass_new))) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"bad authentication token\");\n\t\t}\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, pass_new == NULL ?\n\t\t\t_(\"No password has been supplied.\") :\n\t\t\t_(\"The password has not been changed.\"));\n\t\treturn PAM_AUTHTOK_ERR;\n\t}\n\t/*\n\t * if one wanted to hardwire authentication token strength\n\t * checking this would be the place - AGM\n\t */\n\n\tretval = pam_get_item(pamh, PAM_USER, &user);\n\tif (retval != PAM_SUCCESS) {\n\t\tif (on(UNIX_DEBUG, ctrl)) {\n\t\t\tpam_syslog(pamh, LOG_ERR, \"Can not get username\");\n\t\t\treturn PAM_AUTHTOK_ERR;\n\t\t}\n\t}\n\n\tif (strlen(pass_new) > PAM_MAX_RESP_SIZE) {\n\t\tremark = _(\"You must choose a shorter password.\");\n\t\tD((\"length exceeded [%s]\", remark));\n\t} else if (off(UNIX__IAMROOT, ctrl)) {\n\t\tif ((int)strlen(pass_new) < pass_min_len)\n\t\t  remark = _(\"You must choose a longer password.\");\n\t\tD((\"length check [%s]\", remark));\n\t\tif (on(UNIX_REMEMBER_PASSWD, ctrl)) {\n\t\t\tif ((retval = check_old_password(user, pass_new)) == PAM_AUTHTOK_ERR)\n\t\t\t  remark = _(\"Password has been already used. Choose another.\");\n\t\t\tif (retval == PAM_ABORT) {\n\t\t\t\tpam_syslog(pamh, LOG_ERR, \"can't open %s file to check old passwords\",\n\t\t\t\t\tOLD_PASSWORDS_FILE);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tif (remark) {\n\t\t_make_remark(pamh, ctrl, PAM_ERROR_MSG, remark);\n\t\tretval = PAM_AUTHTOK_ERR;\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "_unix_verify_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "515-542",
    "snippet": "static int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned long long ctrl)\n{\n\tstruct passwd *pwent = NULL;\t/* Password and shadow password */\n\tstruct spwd *spent = NULL;\t/* file entries for the user */\n\tint daysleft;\n\tint retval;\n\n\tretval = get_account_info(pamh, user, &pwent, &spent);\n\tif (retval == PAM_USER_UNKNOWN) {\n\t\treturn retval;\n\t}\n\n\tif (retval == PAM_SUCCESS && spent == NULL)\n\t\treturn PAM_SUCCESS;\n\n\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\tretval = _unix_run_verify_binary(pamh, ctrl, user, &daysleft);\n\t\tif (retval == PAM_AUTH_ERR || retval == PAM_USER_UNKNOWN)\n\t\t\treturn retval;\n\t}\n\telse if (retval == PAM_SUCCESS)\n\t\tretval = check_shadow_expiry(pamh, spent, &daysleft);\n\n\tif (on(UNIX__IAMROOT, ctrl) || retval == PAM_NEW_AUTHTOK_REQD)\n\t\treturn PAM_SUCCESS;\n\n\treturn retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX__IAMROOT",
            "ctrl"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_shadow_expiry",
          "args": [
            "pamh",
            "spent",
            "&daysleft"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unix_run_verify_binary",
          "args": [
            "pamh",
            "ctrl",
            "user",
            "&daysleft"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_run_verify_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_acct.c",
          "lines": "64-179",
          "snippet": "int _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}",
          "includes": [
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_run_verify_binary(pam_handle_t *pamh, unsigned long long ctrl,\n\tconst char *user, int *daysleft)\n{\n  int retval=0, child, fds[2];\n  struct sigaction newsa, oldsa;\n  D((\"running verify_binary\"));\n\n  /* create a pipe for the messages */\n  if (pipe(fds) != 0) {\n    D((\"could not make pipe\"));\n    pam_syslog(pamh, LOG_ERR, \"Could not make pipe: %m\");\n    return PAM_AUTH_ERR;\n  }\n  D((\"called.\"));\n\n  if (off(UNIX_NOREAP, ctrl)) {\n    /*\n     * This code arranges that the demise of the child does not cause\n     * the application to receive a signal it is not expecting - which\n     * may kill the application or worse.\n     *\n     * The \"noreap\" module argument is provided so that the admin can\n     * override this behavior.\n     */\n     memset(&newsa, '\\0', sizeof(newsa));\n     newsa.sa_handler = SIG_DFL;\n     sigaction(SIGCHLD, &newsa, &oldsa);\n  }\n\n  /* fork */\n  child = fork();\n  if (child == 0) {\n    static char *envp[] = { NULL };\n    const char *args[] = { NULL, NULL, NULL, NULL };\n\n    /* XXX - should really tidy up PAM here too */\n\n    /* reopen stdout as pipe */\n    if (dup2(fds[1], STDOUT_FILENO) != STDOUT_FILENO) {\n      pam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdout\");\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\tPAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\tPAM_MODUTIL_PIPE_FD) < 0) {\n      _exit(PAM_AUTHINFO_UNAVAIL);\n    }\n\n    if (geteuid() == 0) {\n      /* must set the real uid to 0 so the helper will not error\n         out if pam is called from setuid binary (su, sudo...) */\n      if (setuid(0) == -1) {\n          pam_syslog(pamh, LOG_ERR, \"setuid failed: %m\");\n          printf(\"-1\\n\");\n          fflush(stdout);\n          _exit(PAM_AUTHINFO_UNAVAIL);\n      }\n    }\n\n    /* exec binary helper */\n    args[0] = CHKPWD_HELPER;\n    args[1] = user;\n    args[2] = \"chkexpiry\";\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    execve(CHKPWD_HELPER, (char *const *) args, envp);\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    pam_syslog(pamh, LOG_ERR, \"helper binary execve failed: %m\");\n    /* should not get here: exit with error */\n    D((\"helper binary is not available\"));\n    printf(\"-1\\n\");\n    fflush(stdout);\n    _exit(PAM_AUTHINFO_UNAVAIL);\n  } else {\n    close(fds[1]);\n    if (child > 0) {\n      char buf[32];\n      int rc=0;\n      /* wait for helper to complete: */\n      while ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n      if (rc<0) {\n\tpam_syslog(pamh, LOG_ERR, \"unix_chkpwd waitpid returned %d: %m\", rc);\n\tretval = PAM_AUTH_ERR;\n      } else if (!WIFEXITED(retval)) {\n        pam_syslog(pamh, LOG_ERR, \"unix_chkpwd abnormal exit: %d\", retval);\n        retval = PAM_AUTH_ERR;\n      } else {\n\tretval = WEXITSTATUS(retval);\n        rc = pam_modutil_read(fds[0], buf, sizeof(buf) - 1);\n\tif(rc > 0) {\n\t      buf[rc] = '\\0';\n\t      if (sscanf(buf,\"%d\", daysleft) != 1 )\n\t        retval = PAM_AUTH_ERR;\n\t    }\n\telse {\n\t    pam_syslog(pamh, LOG_ERR, \"read unix_chkpwd output error %d: %m\", rc);\n\t    retval = PAM_AUTH_ERR;\n\t  }\n      }\n    } else {\n      pam_syslog(pamh, LOG_ERR, \"Fork failed: %m\");\n      D((\"fork failed\"));\n      retval = PAM_AUTH_ERR;\n    }\n    close(fds[0]);\n  }\n\n  if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n  }\n\n  D((\"Returning %d\",retval));\n  return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_account_info",
          "args": [
            "pamh",
            "user",
            "&pwent",
            "&spent"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned long long ctrl)\n{\n\tstruct passwd *pwent = NULL;\t/* Password and shadow password */\n\tstruct spwd *spent = NULL;\t/* file entries for the user */\n\tint daysleft;\n\tint retval;\n\n\tretval = get_account_info(pamh, user, &pwent, &spent);\n\tif (retval == PAM_USER_UNKNOWN) {\n\t\treturn retval;\n\t}\n\n\tif (retval == PAM_SUCCESS && spent == NULL)\n\t\treturn PAM_SUCCESS;\n\n\tif (retval == PAM_UNIX_RUN_HELPER) {\n\t\tretval = _unix_run_verify_binary(pamh, ctrl, user, &daysleft);\n\t\tif (retval == PAM_AUTH_ERR || retval == PAM_USER_UNKNOWN)\n\t\t\treturn retval;\n\t}\n\telse if (retval == PAM_SUCCESS)\n\t\tretval = check_shadow_expiry(pamh, spent, &daysleft);\n\n\tif (on(UNIX__IAMROOT, ctrl) || retval == PAM_NEW_AUTHTOK_REQD)\n\t\treturn PAM_SUCCESS;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "_do_setpass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "388-513",
    "snippet": "static int _do_setpass(pam_handle_t* pamh, const char *forwho,\n\t\t       const char *fromwhat,\n\t\t       char *towhat, unsigned long long ctrl, int remember)\n{\n\tstruct passwd *pwd = NULL;\n\tint retval = 0;\n\tint unlocked = 0;\n\n\tD((\"called\"));\n\n\tpwd = getpwnam(forwho);\n\n\tif (pwd == NULL) {\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\tgoto done;\n\t}\n\n\tif (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, forwho, 0, 1)) {\n#ifdef HAVE_NIS\n\t  char *master;\n\n\t  if ((master=getNISserver(pamh, ctrl)) != NULL) {\n\t\tstruct timeval timeout;\n\t\tstruct yppasswd yppwd;\n\t\tCLIENT *clnt;\n\t\tint status;\n\t\tenum clnt_stat err;\n\n\t\t/* Unlock passwd file to avoid deadlock */\n\t\tunlock_pwdf();\n\t\tunlocked = 1;\n\n\t\t/* Initialize password information */\n\t\typpwd.newpw.pw_passwd = pwd->pw_passwd;\n\t\typpwd.newpw.pw_name = pwd->pw_name;\n\t\typpwd.newpw.pw_uid = pwd->pw_uid;\n\t\typpwd.newpw.pw_gid = pwd->pw_gid;\n\t\typpwd.newpw.pw_gecos = pwd->pw_gecos;\n\t\typpwd.newpw.pw_dir = pwd->pw_dir;\n\t\typpwd.newpw.pw_shell = pwd->pw_shell;\n\t\typpwd.oldpass = fromwhat ? strdup (fromwhat) : strdup (\"\");\n\t\typpwd.newpw.pw_passwd = towhat;\n\n\t\tD((\"Set password %s for %s\", yppwd.newpw.pw_passwd, forwho));\n\n\t\t/* The yppasswd.x file said `unix authentication required',\n\t\t * so I added it. This is the only reason it is in here.\n\t\t * My yppasswdd doesn't use it, but maybe some others out there\n\t\t * do.                                        --okir\n\t\t */\n\t\tclnt = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, \"udp\");\n\t\tclnt->cl_auth = authunix_create_default();\n\t\tmemset((char *) &status, '\\0', sizeof(status));\n\t\ttimeout.tv_sec = 25;\n\t\ttimeout.tv_usec = 0;\n\t\terr = clnt_call(clnt, YPPASSWDPROC_UPDATE,\n\t\t\t\t(xdrproc_t) xdr_yppasswd, (char *) &yppwd,\n\t\t\t\t(xdrproc_t) xdr_int, (char *) &status,\n\t\t\t\ttimeout);\n\n\t\tfree (yppwd.oldpass);\n\n\t\tif (err) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\tclnt_sperrno(err));\n\t\t} else if (status) {\n\t\t\tD((\"Error while changing NIS password.\\n\"));\n\t\t}\n\t\tD((\"The password has%s been changed on %s.\",\n\t\t   (err || status) ? \" not\" : \"\", master));\n\t\tpam_syslog(pamh, LOG_NOTICE, \"password%s changed for %s on %s\",\n\t\t\t (err || status) ? \" not\" : \"\", pwd->pw_name, master);\n\n\t\tauth_destroy(clnt->cl_auth);\n\t\tclnt_destroy(clnt);\n\t\tif (err || status) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\t_(\"NIS password could not be changed.\"));\n\t\t\tretval = PAM_TRY_AGAIN;\n\t\t}\n#ifdef PAM_DEBUG\n\t\tsleep(5);\n#endif\n\t    } else {\n\t\t    retval = PAM_TRY_AGAIN;\n\t    }\n#else\n          if (on(UNIX_DEBUG, ctrl)) {\n            pam_syslog(pamh, LOG_DEBUG, \"No NIS support available\");\n          }\n\n          retval = PAM_TRY_AGAIN;\n#endif\n\t}\n\n\tif (_unix_comesfromsource(pamh, forwho, 1, 0)) {\n\t\tif(unlocked) {\n\t\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t\t}\n\t\t}\n#ifdef WITH_SELINUX\n\t        if (unix_selinux_confined())\n\t\t\t  return _unix_run_update_binary(pamh, ctrl, forwho, fromwhat, towhat, remember);\n#endif\n\t\t/* first, save old password */\n\t\tif (save_old_password(pamh, forwho, fromwhat, remember)) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto done;\n\t\t}\n\t\tif (on(UNIX_SHADOW, ctrl) || is_pwd_shadowed(pwd)) {\n\t\t\tretval = unix_update_shadow(pamh, forwho, towhat);\n\t\t\tif (retval == PAM_SUCCESS)\n\t\t\t\tif (!is_pwd_shadowed(pwd))\n\t\t\t\t\tretval = unix_update_passwd(pamh, forwho, \"x\");\n\t\t} else {\n\t\t\tretval = unix_update_passwd(pamh, forwho, towhat);\n\t\t}\n\t}\n\n\ndone:\n\tunlock_pwdf();\n\n\treturn retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_pwdf",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_pwdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "607-611",
          "snippet": "void\nunlock_pwdf(void)\n{\n\treturn;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nvoid\nunlock_pwdf(void)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_update_passwd",
          "args": [
            "pamh",
            "forwho",
            "towhat"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_update_passwd",
          "args": [
            "pamh",
            "forwho",
            "\"x\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pwd_shadowed",
          "args": [
            "pwd"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "is_pwd_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "176-190",
          "snippet": "int\nis_pwd_shadowed(const struct passwd *pwd)\n{\n\tif (pwd != NULL) {\n\t\tif (strcmp(pwd->pw_passwd, \"x\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pwd->pw_passwd[0] == '#') &&\n\t\t    (pwd->pw_passwd[1] == '#') &&\n\t\t    (strcmp(pwd->pw_name, pwd->pw_passwd + 2) == 0)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "PAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nPAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);\n\nint\nis_pwd_shadowed(const struct passwd *pwd)\n{\n\tif (pwd != NULL) {\n\t\tif (strcmp(pwd->pw_passwd, \"x\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pwd->pw_passwd[0] == '#') &&\n\t\t    (pwd->pw_passwd[1] == '#') &&\n\t\t    (strcmp(pwd->pw_name, pwd->pw_passwd + 2) == 0)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_update_shadow",
          "args": [
            "pamh",
            "forwho",
            "towhat"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_SHADOW",
            "ctrl"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_old_password",
          "args": [
            "pamh",
            "forwho",
            "fromwhat",
            "remember"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "save_old_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "619-796",
          "snippet": "int\nsave_old_password(pam_handle_t *pamh, const char *forwho, const char *oldpass,\n\t\t  int howmany)\n#endif\n{\n    static char buf[16384];\n    static char nbuf[16384];\n    char *s_luser, *s_uid, *s_npas, *s_pas, *pass;\n    int npas;\n    FILE *pwfile, *opwfile;\n    int err = 0;\n    int oldmask;\n    int found = 0;\n    struct passwd *pwd = NULL;\n    struct stat st;\n    size_t len = strlen(forwho);\n#ifdef WITH_SELINUX\n    char *prev_context_raw = NULL;\n#endif\n\n    if (howmany < 0) {\n\treturn PAM_SUCCESS;\n    }\n\n    if (oldpass == NULL) {\n\treturn PAM_SUCCESS;\n    }\n\n    oldmask = umask(077);\n\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      char *passwd_context_raw = NULL;\n      if (getfilecon_raw(\"/etc/passwd\",&passwd_context_raw)<0) {\n        return PAM_AUTHTOK_ERR;\n      };\n      if (getfscreatecon_raw(&prev_context_raw)<0) {\n        freecon(passwd_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      if (setfscreatecon_raw(passwd_context_raw)) {\n        freecon(passwd_context_raw);\n        freecon(prev_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      freecon(passwd_context_raw);\n    }\n#endif\n    pwfile = fopen(OPW_TMPFILE, \"w\");\n    umask(oldmask);\n    if (pwfile == NULL) {\n      err = 1;\n      goto done;\n    }\n\n    opwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n    if (opwfile == NULL) {\n\tfclose(pwfile);\n      err = 1;\n      goto done;\n    }\n\n    if (fstat(fileno(opwfile), &st) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    if (fchown(fileno(pwfile), st.st_uid, st.st_gid) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n    if (fchmod(fileno(pwfile), st.st_mode) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    while (fgets(buf, 16380, opwfile)) {\n\tif (!strncmp(buf, forwho, len) && strchr(\":,\\n\", buf[len]) != NULL) {\n\t    char *sptr = NULL;\n\t    found = 1;\n\t    if (howmany == 0)\n\t\tcontinue;\n\t    buf[strlen(buf) - 1] = '\\0';\n\t    s_luser = strtok_r(buf, \":\", &sptr);\n\t    if (s_luser == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_uid = strtok_r(NULL, \":\", &sptr);\n\t    if (s_uid == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_npas = strtok_r(NULL, \":\", &sptr);\n\t    if (s_npas == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_pas = strtok_r(NULL, \":\", &sptr);\n\t    npas = strtol(s_npas, NULL, 10) + 1;\n\t    while (npas > howmany && s_pas != NULL) {\n\t\ts_pas = strpbrk(s_pas, \",\");\n\t\tif (s_pas != NULL)\n\t\t    s_pas++;\n\t\tnpas--;\n\t    }\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    if (s_pas == NULL)\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s:%s:%d:%s\\n\",\n\t\t\t s_luser, s_uid, npas, pass);\n\t    else\n\t\tsnprintf(nbuf, sizeof(nbuf),\"%s:%s:%d:%s,%s\\n\",\n\t\t\t s_luser, s_uid, npas, s_pas, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t\tbreak;\n\t    }\n\t} else if (fputs(buf, pwfile) < 0) {\n\t    err = 1;\n\t    break;\n\t}\n    }\n    fclose(opwfile);\n\n    if (!found) {\n\tpwd = pam_modutil_getpwnam(pamh, forwho);\n\tif (pwd == NULL) {\n\t    err = 1;\n\t} else {\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    snprintf(nbuf, sizeof(nbuf), \"%s:%lu:1:%s\\n\",\n\t\t     forwho, (unsigned long)pwd->pw_uid, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t    }\n\t}\n    }\n\n    if (fflush(pwfile) || fsync(fileno(pwfile))) {\n\tD((\"fflush or fsync error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\n    if (fclose(pwfile)) {\n\tD((\"fclose error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\ndone:\n    if (!err) {\n\tif (rename(OPW_TMPFILE, OLD_PASSWORDS_FILE))\n\t    err = 1;\n    }\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      if (setfscreatecon_raw(prev_context_raw)) {\n        err = 1;\n      }\n      if (prev_context_raw)\n        freecon(prev_context_raw);\n      prev_context_raw = NULL;\n    }\n#endif\n    if (!err) {\n\treturn PAM_SUCCESS;\n    } else {\n\tunlink(OPW_TMPFILE);\n\treturn PAM_AUTHTOK_ERR;\n    }\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define OPW_TMPFILE             SCONFIGDIR \"/nopasswd\"",
            "#define SELINUX_ENABLED 0",
            "#define SELINUX_ENABLED (is_selinux_enabled()>0)"
          ],
          "globals_used": [
            "PAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\n#define OPW_TMPFILE             SCONFIGDIR \"/nopasswd\"\n#define SELINUX_ENABLED 0\n#define SELINUX_ENABLED (is_selinux_enabled()>0)\n\nPAMH_ARG_DECL(int get_account_info,\n\tconst char *name, struct passwd **pwd, struct spwd **spwdent)\n{\n\t/* UNIX passwords area */\n\t*pwd = pam_modutil_getpwnam(pamh, name);\n\nint\nsave_old_password(pam_handle_t *pamh, const char *forwho, const char *oldpass,\n\t\t  int howmany)\n#endif\n{\n    static char buf[16384];\n    static char nbuf[16384];\n    char *s_luser, *s_uid, *s_npas, *s_pas, *pass;\n    int npas;\n    FILE *pwfile, *opwfile;\n    int err = 0;\n    int oldmask;\n    int found = 0;\n    struct passwd *pwd = NULL;\n    struct stat st;\n    size_t len = strlen(forwho);\n#ifdef WITH_SELINUX\n    char *prev_context_raw = NULL;\n#endif\n\n    if (howmany < 0) {\n\treturn PAM_SUCCESS;\n    }\n\n    if (oldpass == NULL) {\n\treturn PAM_SUCCESS;\n    }\n\n    oldmask = umask(077);\n\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      char *passwd_context_raw = NULL;\n      if (getfilecon_raw(\"/etc/passwd\",&passwd_context_raw)<0) {\n        return PAM_AUTHTOK_ERR;\n      };\n      if (getfscreatecon_raw(&prev_context_raw)<0) {\n        freecon(passwd_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      if (setfscreatecon_raw(passwd_context_raw)) {\n        freecon(passwd_context_raw);\n        freecon(prev_context_raw);\n        return PAM_AUTHTOK_ERR;\n      }\n      freecon(passwd_context_raw);\n    }\n#endif\n    pwfile = fopen(OPW_TMPFILE, \"w\");\n    umask(oldmask);\n    if (pwfile == NULL) {\n      err = 1;\n      goto done;\n    }\n\n    opwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n    if (opwfile == NULL) {\n\tfclose(pwfile);\n      err = 1;\n      goto done;\n    }\n\n    if (fstat(fileno(opwfile), &st) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    if (fchown(fileno(pwfile), st.st_uid, st.st_gid) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n    if (fchmod(fileno(pwfile), st.st_mode) == -1) {\n\tfclose(opwfile);\n\tfclose(pwfile);\n\terr = 1;\n\tgoto done;\n    }\n\n    while (fgets(buf, 16380, opwfile)) {\n\tif (!strncmp(buf, forwho, len) && strchr(\":,\\n\", buf[len]) != NULL) {\n\t    char *sptr = NULL;\n\t    found = 1;\n\t    if (howmany == 0)\n\t\tcontinue;\n\t    buf[strlen(buf) - 1] = '\\0';\n\t    s_luser = strtok_r(buf, \":\", &sptr);\n\t    if (s_luser == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_uid = strtok_r(NULL, \":\", &sptr);\n\t    if (s_uid == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_npas = strtok_r(NULL, \":\", &sptr);\n\t    if (s_npas == NULL) {\n\t\tfound = 0;\n\t\tcontinue;\n\t    }\n\t    s_pas = strtok_r(NULL, \":\", &sptr);\n\t    npas = strtol(s_npas, NULL, 10) + 1;\n\t    while (npas > howmany && s_pas != NULL) {\n\t\ts_pas = strpbrk(s_pas, \",\");\n\t\tif (s_pas != NULL)\n\t\t    s_pas++;\n\t\tnpas--;\n\t    }\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    if (s_pas == NULL)\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s:%s:%d:%s\\n\",\n\t\t\t s_luser, s_uid, npas, pass);\n\t    else\n\t\tsnprintf(nbuf, sizeof(nbuf),\"%s:%s:%d:%s,%s\\n\",\n\t\t\t s_luser, s_uid, npas, s_pas, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t\tbreak;\n\t    }\n\t} else if (fputs(buf, pwfile) < 0) {\n\t    err = 1;\n\t    break;\n\t}\n    }\n    fclose(opwfile);\n\n    if (!found) {\n\tpwd = pam_modutil_getpwnam(pamh, forwho);\n\tif (pwd == NULL) {\n\t    err = 1;\n\t} else {\n\t    pass = crypt_md5_wrapper(oldpass);\n\t    snprintf(nbuf, sizeof(nbuf), \"%s:%lu:1:%s\\n\",\n\t\t     forwho, (unsigned long)pwd->pw_uid, pass);\n\t    _pam_delete(pass);\n\t    if (fputs(nbuf, pwfile) < 0) {\n\t\terr = 1;\n\t    }\n\t}\n    }\n\n    if (fflush(pwfile) || fsync(fileno(pwfile))) {\n\tD((\"fflush or fsync error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\n    if (fclose(pwfile)) {\n\tD((\"fclose error writing entries to old passwords file: %m\"));\n\terr = 1;\n    }\n\ndone:\n    if (!err) {\n\tif (rename(OPW_TMPFILE, OLD_PASSWORDS_FILE))\n\t    err = 1;\n    }\n#ifdef WITH_SELINUX\n    if (SELINUX_ENABLED) {\n      if (setfscreatecon_raw(prev_context_raw)) {\n        err = 1;\n      }\n      if (prev_context_raw)\n        freecon(prev_context_raw);\n      prev_context_raw = NULL;\n    }\n#endif\n    if (!err) {\n\treturn PAM_SUCCESS;\n    } else {\n\tunlink(OPW_TMPFILE);\n\treturn PAM_AUTHTOK_ERR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unix_run_update_binary",
          "args": [
            "pamh",
            "ctrl",
            "forwho",
            "fromwhat",
            "towhat",
            "remember"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_run_update_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "233-346",
          "snippet": "static int _unix_run_update_binary(pam_handle_t *pamh, unsigned long long ctrl, const char *user,\n    const char *fromwhat, const char *towhat, int remember)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n        sigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n        char buffer[16];\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\t/* exec binary helper */\n\targs[0] = UPDATE_HELPER;\n\targs[1] = user;\n\targs[2] = \"update\";\n\tif (on(UNIX_SHADOW, ctrl))\n\t\targs[3] = \"1\";\n\telse\n\t\targs[3] = \"0\";\n\n        snprintf(buffer, sizeof(buffer), \"%d\", remember);\n        args[4] = buffer;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(UPDATE_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (fromwhat) {\n\t    int len = strlen(fromwhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], fromwhat, len);\n\t}\n        pam_modutil_write(fds[1], \"\", 1);\n\tif (towhat) {\n\t    int len = strlen(towhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], towhat, len);\n        }\n        pam_modutil_write(fds[1], \"\", 1);\n\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_update waitpid failed: %m\");\n\t  retval = PAM_AUTHTOK_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"unix_update abnormal exit: %d\", retval);\n          retval = PAM_AUTHTOK_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    return retval;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _unix_run_update_binary(pam_handle_t *pamh, unsigned long long ctrl, const char *user,\n    const char *fromwhat, const char *towhat, int remember)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n        sigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n        char buffer[16];\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\t/* exec binary helper */\n\targs[0] = UPDATE_HELPER;\n\targs[1] = user;\n\targs[2] = \"update\";\n\tif (on(UNIX_SHADOW, ctrl))\n\t\targs[3] = \"1\";\n\telse\n\t\targs[3] = \"0\";\n\n        snprintf(buffer, sizeof(buffer), \"%d\", remember);\n        args[4] = buffer;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(UPDATE_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (fromwhat) {\n\t    int len = strlen(fromwhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], fromwhat, len);\n\t}\n        pam_modutil_write(fds[1], \"\", 1);\n\tif (towhat) {\n\t    int len = strlen(towhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], towhat, len);\n        }\n        pam_modutil_write(fds[1], \"\", 1);\n\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_update waitpid failed: %m\");\n\t  retval = PAM_AUTHTOK_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"unix_update abnormal exit: %d\", retval);\n          retval = PAM_AUTHTOK_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_selinux_confined",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "unix_selinux_confined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/passverify.c",
          "lines": "554-558",
          "snippet": "int\nunix_selinux_confined(void)\n{\n    return 0;\n}",
          "includes": [
            "# include \"./lckpwdf.-c\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <selinux/selinux.h>",
            "#include \"passverify.h\"",
            "#include \"bigcrypt.h\"",
            "#include \"md5.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <crypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"support.h\"",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"./lckpwdf.-c\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <selinux/selinux.h>\n#include \"passverify.h\"\n#include \"bigcrypt.h\"\n#include \"md5.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <crypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include \"support.h\"\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include \"config.h\"\n\nint\nunix_selinux_confined(void)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unix_comesfromsource",
          "args": [
            "pamh",
            "forwho",
            "1",
            "0"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "_unix_comesfromsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "456-460",
          "snippet": "int _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _unix_comesfromsource(pam_handle_t *pamh,\n\t\t\t  const char *name, int files, int nis)\n{\n\treturn _unix_getpwnam(pamh, name, files, nis, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"No NIS support available\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "5"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_make_remark",
          "args": [
            "pamh",
            "ctrl",
            "PAM_TEXT_INFO",
            "_(\"NIS password could not be changed.\")"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "_make_remark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/support.c",
          "lines": "38-47",
          "snippet": "int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <rpcsvc/ypclnt.h>",
            "#include <sys/resource.h>",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <utmp.h>",
            "#include <limits.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/types.h>\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <rpcsvc/ypclnt.h>\n#include <sys/resource.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <errno.h>\n#include <utmp.h>\n#include <limits.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _make_remark(pam_handle_t * pamh, unsigned long long ctrl,\n\t\t    int type, const char *text)\n{\n\tint retval = PAM_SUCCESS;\n\n\tif (off(UNIX__QUIET, ctrl)) {\n\t\tretval = pam_prompt(pamh, type, NULL, \"%s\", text);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NIS password could not be changed.\""
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "_check_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/unix_chkpwd.c",
          "lines": "38-60",
          "snippet": "static int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"passverify.h\"",
            "#include <security/_pam_macros.h>",
            "#include <security/_pam_types.h>",
            "#include <libaudit.h>",
            "#include <errno.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <shadow.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"passverify.h\"\n#include <security/_pam_macros.h>\n#include <security/_pam_types.h>\n#include <libaudit.h>\n#include <errno.h>\n#include <time.h>\n#include <signal.h>\n#include <shadow.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _check_expiry(const char *uname)\n{\n\tstruct spwd *spent;\n\tstruct passwd *pwent;\n\tint retval;\n\tint daysleft;\n\n\tretval = get_account_info(uname, &pwent, &spent);\n\tif (retval != PAM_SUCCESS) {\n\t\thelper_log_err(LOG_ERR, \"could not obtain user info (%s)\", uname);\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tif (spent == NULL) {\n\t\tprintf(\"-1\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = check_shadow_expiry(spent, &daysleft);\n\tprintf(\"%d\\n\", daysleft);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clnt_destroy",
          "args": [
            "clnt"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_destroy",
          "args": [
            "clnt->cl_auth"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"password%s changed for %s on %s\"",
            "(err || status) ? \" not\" : \"\"",
            "pwd->pw_name",
            "master"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"The password has%s been changed on %s.\",\n\t\t   (err || status) ? \" not\" : \"\", master)"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clnt_sperrno",
          "args": [
            "err"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "yppwd.oldpass"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clnt_call",
          "args": [
            "clnt",
            "YPPASSWDPROC_UPDATE",
            "(xdrproc_t) xdr_yppasswd",
            "(char *) &yppwd",
            "(xdrproc_t) xdr_int",
            "(char *) &status",
            "timeout"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &status",
            "'\\0'",
            "sizeof(status)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authunix_create_default",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clnt_create",
          "args": [
            "master",
            "YPPASSWDPROG",
            "YPPASSWDVERS",
            "\"udp\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fromwhat"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getNISserver",
          "args": [
            "pamh",
            "ctrl"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "getNISserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "138-228",
          "snippet": "static char *getNISserver(pam_handle_t *pamh, unsigned long long ctrl)\n{\n\tchar *master;\n\tchar *domainname;\n\tint port, err;\n#if defined(HAVE_RPCB_GETADDR)\n\tstruct netconfig *nconf;\n\tstruct netbuf svcaddr;\n\tchar addrbuf[INET6_ADDRSTRLEN];\n\tvoid *handle;\n\tint found;\n#endif\n\n\n#ifdef HAVE_YP_GET_DEFAULT_DOMAIN\n\tif ((err = yp_get_default_domain(&domainname)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't get local yp domain: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#elif defined(HAVE_GETDOMAINNAME)\n\tchar domainname_res[256];\n\n\tif (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n\t  {\n\t    if (strcmp (domainname_res, \"(none)\") == 0)\n\t      {\n\t\t/* If domainname is not set, some systems will return \"(none)\" */\n\t\tdomainname_res[0] = '\\0';\n\t      }\n\t    domainname = domainname_res;\n\t  }\n\telse domainname = NULL;\n#endif\n\n\tif ((err = yp_master(domainname, \"passwd.byname\", &master)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't find the master ypserver: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#ifdef HAVE_RPCB_GETADDR\n\tsvcaddr.len = 0;\n\tsvcaddr.maxlen = sizeof (addrbuf);\n\tsvcaddr.buf = addrbuf;\n\tport = 0;\n\tfound = 0;\n\n\thandle = setnetconfig();\n\twhile ((nconf = getnetconfig(handle)) != NULL) {\n\t  if (!strcmp(nconf->nc_proto, \"udp\")) {\n\t    if (rpcb_getaddr(YPPASSWDPROG, YPPASSWDPROC_UPDATE,\n\t\t\t     nconf, &svcaddr, master)) {\n              port = __taddr2port (nconf, &svcaddr);\n              endnetconfig (handle);\n              found=1;\n              break;\n            }\n\n\t    if (rpc_createerr.cf_stat != RPC_UNKNOWNHOST) {\n\t      clnt_pcreateerror (master);\n              pam_syslog (pamh, LOG_ERR,\n\t\t\t  \"rpcb_getaddr (%s) failed!\", master);\n              return NULL;\n            }\n\t  }\n\t}\n\n\tif (!found) {\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"Cannot find suitable transport for protocol 'udp'\");\n\t  return NULL;\n\t}\n#else\n\tport = getrpcport(master, YPPASSWDPROG, YPPASSWDPROC_UPDATE, IPPROTO_UDP);\n#endif\n\tif (port == 0) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswdd not running on NIS master host\");\n\t\treturn NULL;\n\t}\n\tif (port >= IPPORT_RESERVED) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswd daemon running on illegal port\");\n\t\treturn NULL;\n\t}\n\tif (on(UNIX_DEBUG, ctrl)) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"Use NIS server on %s with port %d\",\n\t\t     master, port);\n\t}\n\treturn master;\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *getNISserver(pam_handle_t *pamh, unsigned long long ctrl)\n{\n\tchar *master;\n\tchar *domainname;\n\tint port, err;\n#if defined(HAVE_RPCB_GETADDR)\n\tstruct netconfig *nconf;\n\tstruct netbuf svcaddr;\n\tchar addrbuf[INET6_ADDRSTRLEN];\n\tvoid *handle;\n\tint found;\n#endif\n\n\n#ifdef HAVE_YP_GET_DEFAULT_DOMAIN\n\tif ((err = yp_get_default_domain(&domainname)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't get local yp domain: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#elif defined(HAVE_GETDOMAINNAME)\n\tchar domainname_res[256];\n\n\tif (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n\t  {\n\t    if (strcmp (domainname_res, \"(none)\") == 0)\n\t      {\n\t\t/* If domainname is not set, some systems will return \"(none)\" */\n\t\tdomainname_res[0] = '\\0';\n\t      }\n\t    domainname = domainname_res;\n\t  }\n\telse domainname = NULL;\n#endif\n\n\tif ((err = yp_master(domainname, \"passwd.byname\", &master)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't find the master ypserver: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#ifdef HAVE_RPCB_GETADDR\n\tsvcaddr.len = 0;\n\tsvcaddr.maxlen = sizeof (addrbuf);\n\tsvcaddr.buf = addrbuf;\n\tport = 0;\n\tfound = 0;\n\n\thandle = setnetconfig();\n\twhile ((nconf = getnetconfig(handle)) != NULL) {\n\t  if (!strcmp(nconf->nc_proto, \"udp\")) {\n\t    if (rpcb_getaddr(YPPASSWDPROG, YPPASSWDPROC_UPDATE,\n\t\t\t     nconf, &svcaddr, master)) {\n              port = __taddr2port (nconf, &svcaddr);\n              endnetconfig (handle);\n              found=1;\n              break;\n            }\n\n\t    if (rpc_createerr.cf_stat != RPC_UNKNOWNHOST) {\n\t      clnt_pcreateerror (master);\n              pam_syslog (pamh, LOG_ERR,\n\t\t\t  \"rpcb_getaddr (%s) failed!\", master);\n              return NULL;\n            }\n\t  }\n\t}\n\n\tif (!found) {\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"Cannot find suitable transport for protocol 'udp'\");\n\t  return NULL;\n\t}\n#else\n\tport = getrpcport(master, YPPASSWDPROG, YPPASSWDPROC_UPDATE, IPPROTO_UDP);\n#endif\n\tif (port == 0) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswdd not running on NIS master host\");\n\t\treturn NULL;\n\t}\n\tif (port >= IPPORT_RESERVED) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswd daemon running on illegal port\");\n\t\treturn NULL;\n\t}\n\tif (on(UNIX_DEBUG, ctrl)) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"Use NIS server on %s with port %d\",\n\t\t     master, port);\n\t}\n\treturn master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "forwho"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _do_setpass(pam_handle_t* pamh, const char *forwho,\n\t\t       const char *fromwhat,\n\t\t       char *towhat, unsigned long long ctrl, int remember)\n{\n\tstruct passwd *pwd = NULL;\n\tint retval = 0;\n\tint unlocked = 0;\n\n\tD((\"called\"));\n\n\tpwd = getpwnam(forwho);\n\n\tif (pwd == NULL) {\n\t\tretval = PAM_AUTHTOK_ERR;\n\t\tgoto done;\n\t}\n\n\tif (on(UNIX_NIS, ctrl) && _unix_comesfromsource(pamh, forwho, 0, 1)) {\n#ifdef HAVE_NIS\n\t  char *master;\n\n\t  if ((master=getNISserver(pamh, ctrl)) != NULL) {\n\t\tstruct timeval timeout;\n\t\tstruct yppasswd yppwd;\n\t\tCLIENT *clnt;\n\t\tint status;\n\t\tenum clnt_stat err;\n\n\t\t/* Unlock passwd file to avoid deadlock */\n\t\tunlock_pwdf();\n\t\tunlocked = 1;\n\n\t\t/* Initialize password information */\n\t\typpwd.newpw.pw_passwd = pwd->pw_passwd;\n\t\typpwd.newpw.pw_name = pwd->pw_name;\n\t\typpwd.newpw.pw_uid = pwd->pw_uid;\n\t\typpwd.newpw.pw_gid = pwd->pw_gid;\n\t\typpwd.newpw.pw_gecos = pwd->pw_gecos;\n\t\typpwd.newpw.pw_dir = pwd->pw_dir;\n\t\typpwd.newpw.pw_shell = pwd->pw_shell;\n\t\typpwd.oldpass = fromwhat ? strdup (fromwhat) : strdup (\"\");\n\t\typpwd.newpw.pw_passwd = towhat;\n\n\t\tD((\"Set password %s for %s\", yppwd.newpw.pw_passwd, forwho));\n\n\t\t/* The yppasswd.x file said `unix authentication required',\n\t\t * so I added it. This is the only reason it is in here.\n\t\t * My yppasswdd doesn't use it, but maybe some others out there\n\t\t * do.                                        --okir\n\t\t */\n\t\tclnt = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, \"udp\");\n\t\tclnt->cl_auth = authunix_create_default();\n\t\tmemset((char *) &status, '\\0', sizeof(status));\n\t\ttimeout.tv_sec = 25;\n\t\ttimeout.tv_usec = 0;\n\t\terr = clnt_call(clnt, YPPASSWDPROC_UPDATE,\n\t\t\t\t(xdrproc_t) xdr_yppasswd, (char *) &yppwd,\n\t\t\t\t(xdrproc_t) xdr_int, (char *) &status,\n\t\t\t\ttimeout);\n\n\t\tfree (yppwd.oldpass);\n\n\t\tif (err) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\tclnt_sperrno(err));\n\t\t} else if (status) {\n\t\t\tD((\"Error while changing NIS password.\\n\"));\n\t\t}\n\t\tD((\"The password has%s been changed on %s.\",\n\t\t   (err || status) ? \" not\" : \"\", master));\n\t\tpam_syslog(pamh, LOG_NOTICE, \"password%s changed for %s on %s\",\n\t\t\t (err || status) ? \" not\" : \"\", pwd->pw_name, master);\n\n\t\tauth_destroy(clnt->cl_auth);\n\t\tclnt_destroy(clnt);\n\t\tif (err || status) {\n\t\t\t_make_remark(pamh, ctrl, PAM_TEXT_INFO,\n\t\t\t\t_(\"NIS password could not be changed.\"));\n\t\t\tretval = PAM_TRY_AGAIN;\n\t\t}\n#ifdef PAM_DEBUG\n\t\tsleep(5);\n#endif\n\t    } else {\n\t\t    retval = PAM_TRY_AGAIN;\n\t    }\n#else\n          if (on(UNIX_DEBUG, ctrl)) {\n            pam_syslog(pamh, LOG_DEBUG, \"No NIS support available\");\n          }\n\n          retval = PAM_TRY_AGAIN;\n#endif\n\t}\n\n\tif (_unix_comesfromsource(pamh, forwho, 1, 0)) {\n\t\tif(unlocked) {\n\t\t\tif (lock_pwdf() != PAM_SUCCESS) {\n\t\t\t\treturn PAM_AUTHTOK_LOCK_BUSY;\n\t\t\t}\n\t\t}\n#ifdef WITH_SELINUX\n\t        if (unix_selinux_confined())\n\t\t\t  return _unix_run_update_binary(pamh, ctrl, forwho, fromwhat, towhat, remember);\n#endif\n\t\t/* first, save old password */\n\t\tif (save_old_password(pamh, forwho, fromwhat, remember)) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto done;\n\t\t}\n\t\tif (on(UNIX_SHADOW, ctrl) || is_pwd_shadowed(pwd)) {\n\t\t\tretval = unix_update_shadow(pamh, forwho, towhat);\n\t\t\tif (retval == PAM_SUCCESS)\n\t\t\t\tif (!is_pwd_shadowed(pwd))\n\t\t\t\t\tretval = unix_update_passwd(pamh, forwho, \"x\");\n\t\t} else {\n\t\t\tretval = unix_update_passwd(pamh, forwho, towhat);\n\t\t}\n\t}\n\n\ndone:\n\tunlock_pwdf();\n\n\treturn retval;\n}"
  },
  {
    "function_name": "check_old_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "349-386",
    "snippet": "static int check_old_password(const char *forwho, const char *newpass)\n{\n\tstatic char buf[16384];\n\tchar *s_pas;\n\tint retval = PAM_SUCCESS;\n\tFILE *opwfile;\n\tsize_t len = strlen(forwho);\n\n\topwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n\tif (opwfile == NULL)\n\t\treturn PAM_ABORT;\n\n\twhile (fgets(buf, 16380, opwfile)) {\n\t\tif (!strncmp(buf, forwho, len) && (buf[len] == ':' ||\n\t\t\tbuf[len] == ',')) {\n\t\t\tchar *sptr;\n\t\t\tbuf[strlen(buf) - 1] = '\\0';\n\t\t\t/* s_luser = */ strtok_r(buf, \":,\", &sptr);\n\t\t\t/* s_uid = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\t/* s_npas = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\twhile (s_pas != NULL) {\n\t\t\t\tchar *md5pass = Goodcrypt_md5(newpass, s_pas);\n\t\t\t\tif (md5pass == NULL || !strcmp(md5pass, s_pas)) {\n\t\t\t\t\t_pam_delete(md5pass);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\t\t_pam_delete(md5pass);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(opwfile);\n\n\treturn retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "opwfile"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "md5pass"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":,\"",
            "&sptr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_delete",
          "args": [
            "md5pass"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "md5pass",
            "s_pas"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Goodcrypt_md5",
          "args": [
            "newpass",
            "s_pas"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":,\"",
            "&sptr"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":,\"",
            "&sptr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":,\"",
            "&sptr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "buf",
            "\":,\"",
            "&sptr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "forwho",
            "len"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "16380",
            "opwfile"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "OLD_PASSWORDS_FILE",
            "\"r\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "forwho"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int check_old_password(const char *forwho, const char *newpass)\n{\n\tstatic char buf[16384];\n\tchar *s_pas;\n\tint retval = PAM_SUCCESS;\n\tFILE *opwfile;\n\tsize_t len = strlen(forwho);\n\n\topwfile = fopen(OLD_PASSWORDS_FILE, \"r\");\n\tif (opwfile == NULL)\n\t\treturn PAM_ABORT;\n\n\twhile (fgets(buf, 16380, opwfile)) {\n\t\tif (!strncmp(buf, forwho, len) && (buf[len] == ':' ||\n\t\t\tbuf[len] == ',')) {\n\t\t\tchar *sptr;\n\t\t\tbuf[strlen(buf) - 1] = '\\0';\n\t\t\t/* s_luser = */ strtok_r(buf, \":,\", &sptr);\n\t\t\t/* s_uid = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\t/* s_npas = */ strtok_r(NULL, \":,\", &sptr);\n\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\twhile (s_pas != NULL) {\n\t\t\t\tchar *md5pass = Goodcrypt_md5(newpass, s_pas);\n\t\t\t\tif (md5pass == NULL || !strcmp(md5pass, s_pas)) {\n\t\t\t\t\t_pam_delete(md5pass);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts_pas = strtok_r(NULL, \":,\", &sptr);\n\t\t\t\t_pam_delete(md5pass);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(opwfile);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "_unix_run_update_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "233-346",
    "snippet": "static int _unix_run_update_binary(pam_handle_t *pamh, unsigned long long ctrl, const char *user,\n    const char *fromwhat, const char *towhat, int remember)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n        sigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n        char buffer[16];\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\t/* exec binary helper */\n\targs[0] = UPDATE_HELPER;\n\targs[1] = user;\n\targs[2] = \"update\";\n\tif (on(UNIX_SHADOW, ctrl))\n\t\targs[3] = \"1\";\n\telse\n\t\targs[3] = \"0\";\n\n        snprintf(buffer, sizeof(buffer), \"%d\", remember);\n        args[4] = buffer;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(UPDATE_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (fromwhat) {\n\t    int len = strlen(fromwhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], fromwhat, len);\n\t}\n        pam_modutil_write(fds[1], \"\", 1);\n\tif (towhat) {\n\t    int len = strlen(towhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], towhat, len);\n        }\n        pam_modutil_write(fds[1], \"\", 1);\n\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_update waitpid failed: %m\");\n\t  retval = PAM_AUTHTOK_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"unix_update abnormal exit: %d\", retval);\n          retval = PAM_AUTHTOK_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    return retval;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&oldsa",
            "NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"fork failed\")"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "retval"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_update abnormal exit: %d\"",
            "retval"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "retval"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unix_update waitpid failed: %m\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&retval",
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fds[1]",
            "\"\"",
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fds[1]",
            "towhat",
            "len"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "towhat"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fds[1]",
            "\"\"",
            "1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_write",
          "args": [
            "fds[1]",
            "fromwhat",
            "len"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fromwhat"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "UPDATE_HELPER",
            "(char *const *) args",
            "envp"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%d\"",
            "remember"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_SHADOW",
            "ctrl"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_sanitize_helper_fds",
          "args": [
            "pamh",
            "PAM_MODUTIL_IGNORE_FD",
            "PAM_MODUTIL_PIPE_FD",
            "PAM_MODUTIL_PIPE_FD"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "PAM_AUTHINFO_UNAVAIL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"dup2 of %s failed: %m\"",
            "\"stdin\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fds[0]",
            "STDIN_FILENO"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGCHLD",
            "&newsa",
            "&oldsa"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newsa",
            "'\\0'",
            "sizeof(newsa)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "off",
          "args": [
            "UNIX_NOREAP",
            "ctrl"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int _unix_run_update_binary(pam_handle_t *pamh, unsigned long long ctrl, const char *user,\n    const char *fromwhat, const char *towhat, int remember)\n{\n    int retval, child, fds[2];\n    struct sigaction newsa, oldsa;\n\n    D((\"called.\"));\n    /* create a pipe for the password */\n    if (pipe(fds) != 0) {\n\tD((\"could not make pipe\"));\n\treturn PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n\t/*\n\t * This code arranges that the demise of the child does not cause\n\t * the application to receive a signal it is not expecting - which\n\t * may kill the application or worse.\n\t *\n\t * The \"noreap\" module argument is provided so that the admin can\n\t * override this behavior.\n\t */\n        memset(&newsa, '\\0', sizeof(newsa));\n        newsa.sa_handler = SIG_DFL;\n        sigaction(SIGCHLD, &newsa, &oldsa);\n    }\n\n    /* fork */\n    child = fork();\n    if (child == 0) {\n\tstatic char *envp[] = { NULL };\n\tconst char *args[] = { NULL, NULL, NULL, NULL, NULL, NULL };\n        char buffer[16];\n\n\t/* XXX - should really tidy up PAM here too */\n\n\t/* reopen stdin as pipe */\n\tif (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) {\n\t\tpam_syslog(pamh, LOG_ERR, \"dup2 of %s failed: %m\", \"stdin\");\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\tif (pam_modutil_sanitize_helper_fds(pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD,\n\t\t\t\t\t    PAM_MODUTIL_PIPE_FD) < 0) {\n\t\t_exit(PAM_AUTHINFO_UNAVAIL);\n\t}\n\n\t/* exec binary helper */\n\targs[0] = UPDATE_HELPER;\n\targs[1] = user;\n\targs[2] = \"update\";\n\tif (on(UNIX_SHADOW, ctrl))\n\t\targs[3] = \"1\";\n\telse\n\t\targs[3] = \"0\";\n\n        snprintf(buffer, sizeof(buffer), \"%d\", remember);\n        args[4] = buffer;\n\n\tDIAG_PUSH_IGNORE_CAST_QUAL;\n\texecve(UPDATE_HELPER, (char *const *) args, envp);\n\tDIAG_POP_IGNORE_CAST_QUAL;\n\n\t/* should not get here: exit with error */\n\tD((\"helper binary is not available\"));\n\t_exit(PAM_AUTHINFO_UNAVAIL);\n    } else if (child > 0) {\n\t/* wait for child */\n\t/* if the stored password is NULL */\n        int rc=0;\n\tif (fromwhat) {\n\t    int len = strlen(fromwhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], fromwhat, len);\n\t}\n        pam_modutil_write(fds[1], \"\", 1);\n\tif (towhat) {\n\t    int len = strlen(towhat);\n\n\t    if (len > PAM_MAX_RESP_SIZE)\n\t      len = PAM_MAX_RESP_SIZE;\n\t    pam_modutil_write(fds[1], towhat, len);\n        }\n        pam_modutil_write(fds[1], \"\", 1);\n\n\tclose(fds[0]);       /* close here to avoid possible SIGPIPE above */\n\tclose(fds[1]);\n\t/* wait for helper to complete: */\n\twhile ((rc=waitpid(child, &retval, 0)) < 0 && errno == EINTR);\n\tif (rc<0) {\n\t  pam_syslog(pamh, LOG_ERR, \"unix_update waitpid failed: %m\");\n\t  retval = PAM_AUTHTOK_ERR;\n\t} else if (!WIFEXITED(retval)) {\n          pam_syslog(pamh, LOG_ERR, \"unix_update abnormal exit: %d\", retval);\n          retval = PAM_AUTHTOK_ERR;\n        } else {\n\t  retval = WEXITSTATUS(retval);\n\t}\n    } else {\n\tD((\"fork failed\"));\n\tclose(fds[0]);\n\tclose(fds[1]);\n\tretval = PAM_AUTH_ERR;\n    }\n\n    if (off(UNIX_NOREAP, ctrl)) {\n        sigaction(SIGCHLD, &oldsa, NULL);   /* restore old signal handler */\n    }\n\n    return retval;\n}"
  },
  {
    "function_name": "getNISserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "138-228",
    "snippet": "static char *getNISserver(pam_handle_t *pamh, unsigned long long ctrl)\n{\n\tchar *master;\n\tchar *domainname;\n\tint port, err;\n#if defined(HAVE_RPCB_GETADDR)\n\tstruct netconfig *nconf;\n\tstruct netbuf svcaddr;\n\tchar addrbuf[INET6_ADDRSTRLEN];\n\tvoid *handle;\n\tint found;\n#endif\n\n\n#ifdef HAVE_YP_GET_DEFAULT_DOMAIN\n\tif ((err = yp_get_default_domain(&domainname)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't get local yp domain: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#elif defined(HAVE_GETDOMAINNAME)\n\tchar domainname_res[256];\n\n\tif (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n\t  {\n\t    if (strcmp (domainname_res, \"(none)\") == 0)\n\t      {\n\t\t/* If domainname is not set, some systems will return \"(none)\" */\n\t\tdomainname_res[0] = '\\0';\n\t      }\n\t    domainname = domainname_res;\n\t  }\n\telse domainname = NULL;\n#endif\n\n\tif ((err = yp_master(domainname, \"passwd.byname\", &master)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't find the master ypserver: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#ifdef HAVE_RPCB_GETADDR\n\tsvcaddr.len = 0;\n\tsvcaddr.maxlen = sizeof (addrbuf);\n\tsvcaddr.buf = addrbuf;\n\tport = 0;\n\tfound = 0;\n\n\thandle = setnetconfig();\n\twhile ((nconf = getnetconfig(handle)) != NULL) {\n\t  if (!strcmp(nconf->nc_proto, \"udp\")) {\n\t    if (rpcb_getaddr(YPPASSWDPROG, YPPASSWDPROC_UPDATE,\n\t\t\t     nconf, &svcaddr, master)) {\n              port = __taddr2port (nconf, &svcaddr);\n              endnetconfig (handle);\n              found=1;\n              break;\n            }\n\n\t    if (rpc_createerr.cf_stat != RPC_UNKNOWNHOST) {\n\t      clnt_pcreateerror (master);\n              pam_syslog (pamh, LOG_ERR,\n\t\t\t  \"rpcb_getaddr (%s) failed!\", master);\n              return NULL;\n            }\n\t  }\n\t}\n\n\tif (!found) {\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"Cannot find suitable transport for protocol 'udp'\");\n\t  return NULL;\n\t}\n#else\n\tport = getrpcport(master, YPPASSWDPROG, YPPASSWDPROC_UPDATE, IPPROTO_UDP);\n#endif\n\tif (port == 0) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswdd not running on NIS master host\");\n\t\treturn NULL;\n\t}\n\tif (port >= IPPORT_RESERVED) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswd daemon running on illegal port\");\n\t\treturn NULL;\n\t}\n\tif (on(UNIX_DEBUG, ctrl)) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"Use NIS server on %s with port %d\",\n\t\t     master, port);\n\t}\n\treturn master;\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"Use NIS server on %s with port %d\"",
            "master",
            "port"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on",
          "args": [
            "UNIX_DEBUG",
            "ctrl"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tty_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "518-582",
          "snippet": "static int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\ncompute_tty_context(const pam_handle_t *pamh, module_data_t *data)\n{\n  const char *tty = get_item(pamh, PAM_TTY);\n  security_class_t tclass;\n\n  if (!tty || !*tty || !strcmp(tty, \"ssh\")\n      || pam_str_skip_prefix(tty, \"NODEV\") != NULL) {\n    tty = ttyname(STDIN_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDOUT_FILENO);\n    if (!tty || !*tty)\n      tty = ttyname(STDERR_FILENO);\n    if (!tty || !*tty)\n      return PAM_SUCCESS;\n  }\n\n  if (pam_str_skip_prefix(tty, \"/dev/\") == NULL) {\n    if (asprintf(&data->tty_path, \"%s%s\", \"/dev/\", tty) < 0)\n      data->tty_path = NULL;\n  } else {\n    data->tty_path = strdup(tty);\n  }\n\n  if (!data->tty_path) {\n    pam_syslog(pamh, LOG_CRIT, \"Out of memory\");\n    return PAM_BUF_ERR;\n  }\n\n  if (getfilecon(data->tty_path, &data->prev_tty_context) < 0) {\n    data->prev_tty_context = NULL;\n    if (errno == ENOENT) {\n      free(data->tty_path);\n      data->tty_path = NULL;\n      return PAM_SUCCESS;\n    }\n    pam_syslog(pamh, LOG_ERR, \"Failed to get current context for %s: %m\",\n\t       data->tty_path);\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  tclass = string_to_security_class(\"chr_file\");\n  if (tclass == 0) {\n    pam_syslog(pamh, LOG_ERR, \"Failed to get chr_file security class\");\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  if (security_compute_relabel(data->exec_context, data->prev_tty_context,\n\t\t\t       tclass, &data->tty_context)) {\n    data->tty_context = NULL;\n    pam_syslog(pamh, LOG_ERR, \"Failed to compute new context for %s: %m\",\n\t       data->tty_path);\n    freecon(data->prev_tty_context);\n    data->prev_tty_context = NULL;\n    free(data->tty_path);\n    data->tty_path = NULL;\n    return (security_getenforce() == 1) ? PAM_SESSION_ERR : PAM_SUCCESS;\n  }\n\n  return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"yppasswd daemon running on illegal port\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"yppasswdd not running on NIS master host\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getrpcport",
          "args": [
            "master",
            "YPPASSWDPROG",
            "YPPASSWDPROC_UPDATE",
            "IPPROTO_UDP"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Cannot find suitable transport for protocol 'udp'\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"rpcb_getaddr (%s) failed!\"",
            "master"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clnt_pcreateerror",
          "args": [
            "master"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endnetconfig",
          "args": [
            "handle"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__taddr2port",
          "args": [
            "nconf",
            "&svcaddr"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__taddr2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
          "lines": "110-135",
          "snippet": "static unsigned short\n__taddr2port (const struct netconfig *nconf, const struct netbuf *nbuf)\n{\n  unsigned short port = 0;\n  struct __rpc_sockinfo si;\n  struct sockaddr_in *sin;\n  struct sockaddr_in6 *sin6;\n  if (!__rpc_nconf2sockinfo(nconf, &si))\n    return 0;\n\n  switch (si.si_af)\n    {\n    case AF_INET:\n      sin = nbuf->buf;\n      port = sin->sin_port;\n      break;\n    case AF_INET6:\n      sin6 = nbuf->buf;\n      port = sin6->sin6_port;\n      break;\n    default:\n      break;\n    }\n\n  return htons (port);\n}",
          "includes": [
            "# include \"yppasswd.h\"",
            "#  include <rpcsvc/ypclnt.h>",
            "#  include <rpcsvc/yp_prot.h>",
            "# include <rpc/rpc.h>",
            "#include \"bigcrypt.h\"",
            "#include \"passverify.h\"",
            "#include \"support.h\"",
            "#include \"md5.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <sys/resource.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <time.h>\t\t/* for time() */",
            "#include <shadow.h>",
            "#include <syslog.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <malloc.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic unsigned short\n__taddr2port (const struct netconfig *nconf, const struct netbuf *nbuf)\n{\n  unsigned short port = 0;\n  struct __rpc_sockinfo si;\n  struct sockaddr_in *sin;\n  struct sockaddr_in6 *sin6;\n  if (!__rpc_nconf2sockinfo(nconf, &si))\n    return 0;\n\n  switch (si.si_af)\n    {\n    case AF_INET:\n      sin = nbuf->buf;\n      port = sin->sin_port;\n      break;\n    case AF_INET6:\n      sin6 = nbuf->buf;\n      port = sin6->sin6_port;\n      break;\n    default:\n      break;\n    }\n\n  return htons (port);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpcb_getaddr",
          "args": [
            "YPPASSWDPROG",
            "YPPASSWDPROC_UPDATE",
            "nconf",
            "&svcaddr",
            "master"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nconf->nc_proto",
            "\"udp\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnetconfig",
          "args": [
            "handle"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setnetconfig",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"can't find the master ypserver: %s\"",
            "yperr_string(err)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yperr_string",
          "args": [
            "err"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_master",
          "args": [
            "domainname",
            "\"passwd.byname\"",
            "&master"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname_res",
            "\"(none)\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdomainname",
          "args": [
            "domainname_res",
            "sizeof (domainname_res)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"can't get local yp domain: %s\"",
            "yperr_string(err)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yperr_string",
          "args": [
            "err"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yp_get_default_domain",
          "args": [
            "&domainname"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic char *getNISserver(pam_handle_t *pamh, unsigned long long ctrl)\n{\n\tchar *master;\n\tchar *domainname;\n\tint port, err;\n#if defined(HAVE_RPCB_GETADDR)\n\tstruct netconfig *nconf;\n\tstruct netbuf svcaddr;\n\tchar addrbuf[INET6_ADDRSTRLEN];\n\tvoid *handle;\n\tint found;\n#endif\n\n\n#ifdef HAVE_YP_GET_DEFAULT_DOMAIN\n\tif ((err = yp_get_default_domain(&domainname)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't get local yp domain: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#elif defined(HAVE_GETDOMAINNAME)\n\tchar domainname_res[256];\n\n\tif (getdomainname (domainname_res, sizeof (domainname_res)) == 0)\n\t  {\n\t    if (strcmp (domainname_res, \"(none)\") == 0)\n\t      {\n\t\t/* If domainname is not set, some systems will return \"(none)\" */\n\t\tdomainname_res[0] = '\\0';\n\t      }\n\t    domainname = domainname_res;\n\t  }\n\telse domainname = NULL;\n#endif\n\n\tif ((err = yp_master(domainname, \"passwd.byname\", &master)) != 0) {\n\t\tpam_syslog(pamh, LOG_WARNING, \"can't find the master ypserver: %s\",\n\t\t\t yperr_string(err));\n\t\treturn NULL;\n\t}\n#ifdef HAVE_RPCB_GETADDR\n\tsvcaddr.len = 0;\n\tsvcaddr.maxlen = sizeof (addrbuf);\n\tsvcaddr.buf = addrbuf;\n\tport = 0;\n\tfound = 0;\n\n\thandle = setnetconfig();\n\twhile ((nconf = getnetconfig(handle)) != NULL) {\n\t  if (!strcmp(nconf->nc_proto, \"udp\")) {\n\t    if (rpcb_getaddr(YPPASSWDPROG, YPPASSWDPROC_UPDATE,\n\t\t\t     nconf, &svcaddr, master)) {\n              port = __taddr2port (nconf, &svcaddr);\n              endnetconfig (handle);\n              found=1;\n              break;\n            }\n\n\t    if (rpc_createerr.cf_stat != RPC_UNKNOWNHOST) {\n\t      clnt_pcreateerror (master);\n              pam_syslog (pamh, LOG_ERR,\n\t\t\t  \"rpcb_getaddr (%s) failed!\", master);\n              return NULL;\n            }\n\t  }\n\t}\n\n\tif (!found) {\n\t  pam_syslog (pamh, LOG_ERR,\n\t\t      \"Cannot find suitable transport for protocol 'udp'\");\n\t  return NULL;\n\t}\n#else\n\tport = getrpcport(master, YPPASSWDPROG, YPPASSWDPROC_UPDATE, IPPROTO_UDP);\n#endif\n\tif (port == 0) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswdd not running on NIS master host\");\n\t\treturn NULL;\n\t}\n\tif (port >= IPPORT_RESERVED) {\n\t\tpam_syslog(pamh, LOG_WARNING,\n\t\t         \"yppasswd daemon running on illegal port\");\n\t\treturn NULL;\n\t}\n\tif (on(UNIX_DEBUG, ctrl)) {\n\t  pam_syslog(pamh, LOG_DEBUG, \"Use NIS server on %s with port %d\",\n\t\t     master, port);\n\t}\n\treturn master;\n}"
  },
  {
    "function_name": "__taddr2port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/pam_unix_passwd.c",
    "lines": "110-135",
    "snippet": "static unsigned short\n__taddr2port (const struct netconfig *nconf, const struct netbuf *nbuf)\n{\n  unsigned short port = 0;\n  struct __rpc_sockinfo si;\n  struct sockaddr_in *sin;\n  struct sockaddr_in6 *sin6;\n  if (!__rpc_nconf2sockinfo(nconf, &si))\n    return 0;\n\n  switch (si.si_af)\n    {\n    case AF_INET:\n      sin = nbuf->buf;\n      port = sin->sin_port;\n      break;\n    case AF_INET6:\n      sin6 = nbuf->buf;\n      port = sin6->sin6_port;\n      break;\n    default:\n      break;\n    }\n\n  return htons (port);\n}",
    "includes": [
      "# include \"yppasswd.h\"",
      "#  include <rpcsvc/ypclnt.h>",
      "#  include <rpcsvc/yp_prot.h>",
      "# include <rpc/rpc.h>",
      "#include \"bigcrypt.h\"",
      "#include \"passverify.h\"",
      "#include \"support.h\"",
      "#include \"md5.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <sys/resource.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <ctype.h>",
      "#include <fcntl.h>",
      "#include <time.h>\t\t/* for time() */",
      "#include <shadow.h>",
      "#include <syslog.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <malloc.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rpc_nconf2sockinfo",
          "args": [
            "nconf",
            "&si"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"yppasswd.h\"\n#  include <rpcsvc/ypclnt.h>\n#  include <rpcsvc/yp_prot.h>\n# include <rpc/rpc.h>\n#include \"bigcrypt.h\"\n#include \"passverify.h\"\n#include \"support.h\"\n#include \"md5.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\t\t/* for time() */\n#include <shadow.h>\n#include <syslog.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic unsigned short\n__taddr2port (const struct netconfig *nconf, const struct netbuf *nbuf)\n{\n  unsigned short port = 0;\n  struct __rpc_sockinfo si;\n  struct sockaddr_in *sin;\n  struct sockaddr_in6 *sin6;\n  if (!__rpc_nconf2sockinfo(nconf, &si))\n    return 0;\n\n  switch (si.si_af)\n    {\n    case AF_INET:\n      sin = nbuf->buf;\n      port = sin->sin_port;\n      break;\n    case AF_INET6:\n      sin6 = nbuf->buf;\n      port = sin6->sin6_port;\n      break;\n    default:\n      break;\n    }\n\n  return htons (port);\n}"
  }
]