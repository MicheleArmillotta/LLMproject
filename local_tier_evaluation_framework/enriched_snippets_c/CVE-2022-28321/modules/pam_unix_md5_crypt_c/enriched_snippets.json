[
  {
    "function_name": "MD5Name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5_crypt.c",
    "lines": "37-157",
    "snippet": "char *MD5Name(crypt_md5)(const char *pw, const char *salt)\n{\n\tconst char *magic = \"$1$\";\n\t/* This string is magic for this algorithm.  Having\n\t * it this way, we can get get better later on */\n\tchar *passwd, *p;\n\tconst char *sp, *ep;\n\tunsigned char final[16];\n\tint sl, pl, i, j;\n\tMD5_CTX ctx, ctx1;\n\tunsigned long l;\n\n\t/* Refine the Salt first */\n\tsp = salt;\n\n\t/* TODO: now that we're using malloc'ed memory, get rid of the\n\t   strange constant buffer size. */\n\tpasswd = malloc(120);\n\tif (passwd == NULL)\n\t\treturn NULL;\n\n\t/* If it starts with the magic string, then skip that */\n\tif ((ep = pam_str_skip_prefix_len(sp, magic, strlen(magic))) != NULL)\n\t\tsp = ep;\n\n\t/* It stops at the first '$', max 8 chars */\n\tfor (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ep++)\n\t\tcontinue;\n\n\t/* get the length of the true salt */\n\tsl = ep - sp;\n\n\tMD5Name(MD5Init)(&ctx);\n\n\t/* The password first, since that is what is most unknown */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)pw,strlen(pw));\n\n\t/* Then our magic string */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)magic,strlen(magic));\n\n\t/* Then the raw salt */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)sp,sl);\n\n\t/* Then just as many characters of the MD5(pw,salt,pw) */\n\tMD5Name(MD5Init)(&ctx1);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Final)(final,&ctx1);\n\tfor (pl = strlen(pw); pl > 0; pl -= 16)\n\t\tMD5Name(MD5Update)(&ctx,(unsigned const char *)final,pl>16 ? 16 : pl);\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\t/* Then something really weird... */\n\tfor (j = 0, i = strlen(pw); i; i >>= 1)\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)final+j, 1);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)pw+j, 1);\n\n\t/* Now make the output string */\n\tstrcpy(passwd, magic);\n\tstrncat(passwd, sp, sl);\n\tstrcat(passwd, \"$\");\n\n\tMD5Name(MD5Final)(final,&ctx);\n\n\t/*\n\t * and now, just to make sure things don't run too fast\n\t * On a 60 Mhz Pentium this takes 34 msec, so you would\n\t * need 30 seconds to build a 1000 entry dictionary...\n\t */\n\tfor (i = 0; i < 1000; i++) {\n\t\tMD5Name(MD5Init)(&ctx1);\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\n\t\tif (i % 3)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\n\t\tif (i % 7)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\tMD5Name(MD5Final)(final,&ctx1);\n\t}\n\n\tp = passwd + strlen(passwd);\n\n\tl = (final[0] << 16) | (final[6] << 8) | final[12];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[1] << 16) | (final[7] << 8) | final[13];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[2] << 16) | (final[8] << 8) | final[14];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[3] << 16) | (final[9] << 8) | final[15];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[4] << 16) | (final[10] << 8) | final[5];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = final[11];\n\tto64(p, l, 2);\n\tp += 2;\n\t*p = '\\0';\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\treturn passwd;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"md5.h\"",
      "#include <stdlib.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "final",
            "0",
            "sizeof final"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to64",
          "args": [
            "p",
            "l",
            "2"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "to64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5_crypt.c",
          "lines": "23-29",
          "snippet": "static void to64(char *s, unsigned long v, int n)\n{\n\twhile (--n >= 0) {\n\t\t*s++ = itoa64[v & 0x3f];\n\t\tv >>= 6;\n\t}\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"md5.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char itoa64[] =\t/* 0 ... 63 => ascii - 64 */\n\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"md5.h\"\n#include <stdlib.h>\n#include <string.h>\n\nstatic unsigned char itoa64[] =\t/* 0 ... 63 => ascii - 64 */\n\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nstatic void to64(char *s, unsigned long v, int n)\n{\n\twhile (--n >= 0) {\n\t\t*s++ = itoa64[v & 0x3f];\n\t\tv >>= 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passwd"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MD5Name",
          "args": [
            "final",
            "&ctx1"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5_crypt.c",
          "lines": "37-157",
          "snippet": "char *MD5Name(crypt_md5)(const char *pw, const char *salt)\n{\n\tconst char *magic = \"$1$\";\n\t/* This string is magic for this algorithm.  Having\n\t * it this way, we can get get better later on */\n\tchar *passwd, *p;\n\tconst char *sp, *ep;\n\tunsigned char final[16];\n\tint sl, pl, i, j;\n\tMD5_CTX ctx, ctx1;\n\tunsigned long l;\n\n\t/* Refine the Salt first */\n\tsp = salt;\n\n\t/* TODO: now that we're using malloc'ed memory, get rid of the\n\t   strange constant buffer size. */\n\tpasswd = malloc(120);\n\tif (passwd == NULL)\n\t\treturn NULL;\n\n\t/* If it starts with the magic string, then skip that */\n\tif ((ep = pam_str_skip_prefix_len(sp, magic, strlen(magic))) != NULL)\n\t\tsp = ep;\n\n\t/* It stops at the first '$', max 8 chars */\n\tfor (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ep++)\n\t\tcontinue;\n\n\t/* get the length of the true salt */\n\tsl = ep - sp;\n\n\tMD5Name(MD5Init)(&ctx);\n\n\t/* The password first, since that is what is most unknown */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)pw,strlen(pw));\n\n\t/* Then our magic string */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)magic,strlen(magic));\n\n\t/* Then the raw salt */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)sp,sl);\n\n\t/* Then just as many characters of the MD5(pw,salt,pw) */\n\tMD5Name(MD5Init)(&ctx1);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Final)(final,&ctx1);\n\tfor (pl = strlen(pw); pl > 0; pl -= 16)\n\t\tMD5Name(MD5Update)(&ctx,(unsigned const char *)final,pl>16 ? 16 : pl);\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\t/* Then something really weird... */\n\tfor (j = 0, i = strlen(pw); i; i >>= 1)\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)final+j, 1);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)pw+j, 1);\n\n\t/* Now make the output string */\n\tstrcpy(passwd, magic);\n\tstrncat(passwd, sp, sl);\n\tstrcat(passwd, \"$\");\n\n\tMD5Name(MD5Final)(final,&ctx);\n\n\t/*\n\t * and now, just to make sure things don't run too fast\n\t * On a 60 Mhz Pentium this takes 34 msec, so you would\n\t * need 30 seconds to build a 1000 entry dictionary...\n\t */\n\tfor (i = 0; i < 1000; i++) {\n\t\tMD5Name(MD5Init)(&ctx1);\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\n\t\tif (i % 3)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\n\t\tif (i % 7)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\tMD5Name(MD5Final)(final,&ctx1);\n\t}\n\n\tp = passwd + strlen(passwd);\n\n\tl = (final[0] << 16) | (final[6] << 8) | final[12];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[1] << 16) | (final[7] << 8) | final[13];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[2] << 16) | (final[8] << 8) | final[14];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[3] << 16) | (final[9] << 8) | final[15];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[4] << 16) | (final[10] << 8) | final[5];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = final[11];\n\tto64(p, l, 2);\n\tp += 2;\n\t*p = '\\0';\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\treturn passwd;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "passwd",
            "\"$\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "passwd",
            "sp",
            "sl"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "passwd",
            "magic"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "final",
            "0",
            "sizeof final"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "magic"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix_len",
          "args": [
            "sp",
            "magic",
            "strlen(magic)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "magic"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "120"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"md5.h\"\n#include <stdlib.h>\n#include <string.h>\n\nchar *MD5Name(crypt_md5)(const char *pw, const char *salt)\n{\n\tconst char *magic = \"$1$\";\n\t/* This string is magic for this algorithm.  Having\n\t * it this way, we can get get better later on */\n\tchar *passwd, *p;\n\tconst char *sp, *ep;\n\tunsigned char final[16];\n\tint sl, pl, i, j;\n\tMD5_CTX ctx, ctx1;\n\tunsigned long l;\n\n\t/* Refine the Salt first */\n\tsp = salt;\n\n\t/* TODO: now that we're using malloc'ed memory, get rid of the\n\t   strange constant buffer size. */\n\tpasswd = malloc(120);\n\tif (passwd == NULL)\n\t\treturn NULL;\n\n\t/* If it starts with the magic string, then skip that */\n\tif ((ep = pam_str_skip_prefix_len(sp, magic, strlen(magic))) != NULL)\n\t\tsp = ep;\n\n\t/* It stops at the first '$', max 8 chars */\n\tfor (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ep++)\n\t\tcontinue;\n\n\t/* get the length of the true salt */\n\tsl = ep - sp;\n\n\tMD5Name(MD5Init)(&ctx);\n\n\t/* The password first, since that is what is most unknown */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)pw,strlen(pw));\n\n\t/* Then our magic string */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)magic,strlen(magic));\n\n\t/* Then the raw salt */\n\tMD5Name(MD5Update)(&ctx,(unsigned const char *)sp,sl);\n\n\t/* Then just as many characters of the MD5(pw,salt,pw) */\n\tMD5Name(MD5Init)(&ctx1);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\tMD5Name(MD5Final)(final,&ctx1);\n\tfor (pl = strlen(pw); pl > 0; pl -= 16)\n\t\tMD5Name(MD5Update)(&ctx,(unsigned const char *)final,pl>16 ? 16 : pl);\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\t/* Then something really weird... */\n\tfor (j = 0, i = strlen(pw); i; i >>= 1)\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)final+j, 1);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx, (unsigned const char *)pw+j, 1);\n\n\t/* Now make the output string */\n\tstrcpy(passwd, magic);\n\tstrncat(passwd, sp, sl);\n\tstrcat(passwd, \"$\");\n\n\tMD5Name(MD5Final)(final,&ctx);\n\n\t/*\n\t * and now, just to make sure things don't run too fast\n\t * On a 60 Mhz Pentium this takes 34 msec, so you would\n\t * need 30 seconds to build a 1000 entry dictionary...\n\t */\n\tfor (i = 0; i < 1000; i++) {\n\t\tMD5Name(MD5Init)(&ctx1);\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\n\t\tif (i % 3)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)sp,sl);\n\n\t\tif (i % 7)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\n\t\tif (i & 1)\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)final,16);\n\t\telse\n\t\t\tMD5Name(MD5Update)(&ctx1,(unsigned const char *)pw,strlen(pw));\n\t\tMD5Name(MD5Final)(final,&ctx1);\n\t}\n\n\tp = passwd + strlen(passwd);\n\n\tl = (final[0] << 16) | (final[6] << 8) | final[12];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[1] << 16) | (final[7] << 8) | final[13];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[2] << 16) | (final[8] << 8) | final[14];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[3] << 16) | (final[9] << 8) | final[15];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = (final[4] << 16) | (final[10] << 8) | final[5];\n\tto64(p, l, 4);\n\tp += 4;\n\tl = final[11];\n\tto64(p, l, 2);\n\tp += 2;\n\t*p = '\\0';\n\n\t/* Don't leave anything around in vm they could use. */\n\tmemset(final, 0, sizeof final);\n\n\treturn passwd;\n}"
  },
  {
    "function_name": "to64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5_crypt.c",
    "lines": "23-29",
    "snippet": "static void to64(char *s, unsigned long v, int n)\n{\n\twhile (--n >= 0) {\n\t\t*s++ = itoa64[v & 0x3f];\n\t\tv >>= 6;\n\t}\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"md5.h\"",
      "#include <stdlib.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char itoa64[] =\t/* 0 ... 63 => ascii - 64 */\n\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"md5.h\"\n#include <stdlib.h>\n#include <string.h>\n\nstatic unsigned char itoa64[] =\t/* 0 ... 63 => ascii - 64 */\n\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nstatic void to64(char *s, unsigned long v, int n)\n{\n\twhile (--n >= 0) {\n\t\t*s++ = itoa64[v & 0x3f];\n\t\tv >>= 6;\n\t}\n}"
  }
]