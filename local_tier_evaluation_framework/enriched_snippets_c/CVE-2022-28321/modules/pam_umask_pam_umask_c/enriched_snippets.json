[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "231-236",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nint\npam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "191-229",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n                     int argc, const char **argv)\n{\n  struct passwd *pw;\n  options_t options;\n  const char *name;\n  int retval = PAM_SUCCESS;\n\n  get_options (pamh, &options, argc, argv);\n  if (flags & PAM_SILENT)\n    options.silent = 1;\n\n  /* get the user name. */\n  if ((retval = pam_get_user (pamh, &name, NULL)) != PAM_SUCCESS)\n    {\n      pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t pam_strerror(pamh, retval));\n      return (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE:retval);\n    }\n\n  pw = pam_modutil_getpwnam (pamh, name);\n  if (pw == NULL)\n    {\n      pam_syslog (pamh, LOG_NOTICE, \"account for %s not found\", name);\n      return PAM_USER_UNKNOWN;\n    }\n\n  if (options.umask != NULL)\n    {\n      set_umask (options.umask);\n      free (options.login_umask);\n      options.umask = options.login_umask = NULL;\n    }\n\n  setup_limits_from_gecos (pamh, &options, pw);\n\n  return retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_limits_from_gecos",
          "args": [
            "pamh",
            "&options",
            "pw"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "setup_limits_from_gecos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "133-188",
          "snippet": "static void\nsetup_limits_from_gecos (pam_handle_t *pamh, options_t *options,\n\t\t\t struct passwd *pw)\n{\n  char *cp;\n\n  if (options->usergroups)\n    {\n      /* if not root and username is the same as primary group name,\n         set umask group bits to be the same as owner bits\n\t (examples: 022 -> 002, 077 -> 007).  */\n      if (pw->pw_uid != 0)\n\t{\n\t  struct group *grp = pam_modutil_getgrgid (pamh, pw->pw_gid);\n\t  if (grp && (strcmp (pw->pw_name, grp->gr_name) == 0))\n\t    {\n\t      mode_t oldmask = umask (0777);\n\t      umask ((oldmask & ~070) | ((oldmask >> 3) & 070));\n\t    }\n        }\n    }\n\n  /* See if the GECOS field contains values for NICE, UMASK or ULIMIT.  */\n  for (cp = pw->pw_gecos; cp != NULL; cp = strchr (cp, ','))\n    {\n      const char *str;\n\n      if (*cp == ',')\n\tcp++;\n\n      if ((str = pam_str_skip_icase_prefix (cp, \"umask=\")) != NULL)\n\tumask (strtol (str, NULL, 8) & 0777);\n      else if ((str = pam_str_skip_icase_prefix (cp, \"pri=\")) != NULL)\n\t{\n\t  errno = 0;\n\t  if (nice (strtol (str, NULL, 10)) == -1 && errno != 0)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"nice failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"nice failed: %m\");\n\t    }\n\t}\n      else if ((str = pam_str_skip_icase_prefix (cp, \"ulimit=\")) != NULL)\n\t{\n\t  struct rlimit rlimit_fsize;\n\t  rlimit_fsize.rlim_cur = 512L * strtol (str, NULL, 10);\n\t  rlimit_fsize.rlim_max = rlimit_fsize.rlim_cur;\n\t  if (setrlimit (RLIMIT_FSIZE, &rlimit_fsize) == -1)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"setrlimit failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"setrlimit failed: %m\");\n\t    }\n        }\n    }\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nsetup_limits_from_gecos (pam_handle_t *pamh, options_t *options,\n\t\t\t struct passwd *pw)\n{\n  char *cp;\n\n  if (options->usergroups)\n    {\n      /* if not root and username is the same as primary group name,\n         set umask group bits to be the same as owner bits\n\t (examples: 022 -> 002, 077 -> 007).  */\n      if (pw->pw_uid != 0)\n\t{\n\t  struct group *grp = pam_modutil_getgrgid (pamh, pw->pw_gid);\n\t  if (grp && (strcmp (pw->pw_name, grp->gr_name) == 0))\n\t    {\n\t      mode_t oldmask = umask (0777);\n\t      umask ((oldmask & ~070) | ((oldmask >> 3) & 070));\n\t    }\n        }\n    }\n\n  /* See if the GECOS field contains values for NICE, UMASK or ULIMIT.  */\n  for (cp = pw->pw_gecos; cp != NULL; cp = strchr (cp, ','))\n    {\n      const char *str;\n\n      if (*cp == ',')\n\tcp++;\n\n      if ((str = pam_str_skip_icase_prefix (cp, \"umask=\")) != NULL)\n\tumask (strtol (str, NULL, 8) & 0777);\n      else if ((str = pam_str_skip_icase_prefix (cp, \"pri=\")) != NULL)\n\t{\n\t  errno = 0;\n\t  if (nice (strtol (str, NULL, 10)) == -1 && errno != 0)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"nice failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"nice failed: %m\");\n\t    }\n\t}\n      else if ((str = pam_str_skip_icase_prefix (cp, \"ulimit=\")) != NULL)\n\t{\n\t  struct rlimit rlimit_fsize;\n\t  rlimit_fsize.rlim_cur = 512L * strtol (str, NULL, 10);\n\t  rlimit_fsize.rlim_max = rlimit_fsize.rlim_cur;\n\t  if (setrlimit (RLIMIT_FSIZE, &rlimit_fsize) == -1)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"setrlimit failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"setrlimit failed: %m\");\n\t    }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options.login_umask"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_umask",
          "args": [
            "options.umask"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "set_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "116-129",
          "snippet": "static void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"account for %s not found\"",
            "name"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "name"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name: %s\"",
            "pam_strerror(pamh, retval)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "retval"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&name",
            "NULL"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_options",
          "args": [
            "pamh",
            "&options",
            "argc",
            "argv"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "get_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "94-114",
          "snippet": "static int\nget_options (pam_handle_t *pamh, options_t *options,\n\t     int argc, const char **argv)\n{\n  memset (options, 0, sizeof (options_t));\n\n  options->usergroups = DEFAULT_USERGROUPS_SETTING;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, options);\n\n  if (options->umask == NULL) {\n    options->login_umask = pam_modutil_search_key (pamh, LOGIN_DEFS, \"UMASK\");\n    if (options->login_umask == NULL)\n      options->login_umask = pam_modutil_search_key (pamh, LOGIN_CONF, \"UMASK\");\n    options->umask = options->login_umask;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define LOGIN_CONF \"/etc/default/login\"",
            "#define LOGIN_DEFS \"/etc/login.defs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\n#define LOGIN_CONF \"/etc/default/login\"\n#define LOGIN_DEFS \"/etc/login.defs\"\n\nstatic int\nget_options (pam_handle_t *pamh, options_t *options,\n\t     int argc, const char **argv)\n{\n  memset (options, 0, sizeof (options_t));\n\n  options->usergroups = DEFAULT_USERGROUPS_SETTING;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, options);\n\n  if (options->umask == NULL) {\n    options->login_umask = pam_modutil_search_key (pamh, LOGIN_DEFS, \"UMASK\");\n    if (options->login_umask == NULL)\n      options->login_umask = pam_modutil_search_key (pamh, LOGIN_CONF, \"UMASK\");\n    options->umask = options->login_umask;\n  }\n\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n                     int argc, const char **argv)\n{\n  struct passwd *pw;\n  options_t options;\n  const char *name;\n  int retval = PAM_SUCCESS;\n\n  get_options (pamh, &options, argc, argv);\n  if (flags & PAM_SILENT)\n    options.silent = 1;\n\n  /* get the user name. */\n  if ((retval = pam_get_user (pamh, &name, NULL)) != PAM_SUCCESS)\n    {\n      pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name: %s\",\n\t\t pam_strerror(pamh, retval));\n      return (retval == PAM_CONV_AGAIN ? PAM_INCOMPLETE:retval);\n    }\n\n  pw = pam_modutil_getpwnam (pamh, name);\n  if (pw == NULL)\n    {\n      pam_syslog (pamh, LOG_NOTICE, \"account for %s not found\", name);\n      return PAM_USER_UNKNOWN;\n    }\n\n  if (options.umask != NULL)\n    {\n      set_umask (options.umask);\n      free (options.login_umask);\n      options.umask = options.login_umask = NULL;\n    }\n\n  setup_limits_from_gecos (pamh, &options, pw);\n\n  return retval;\n}"
  },
  {
    "function_name": "setup_limits_from_gecos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "133-188",
    "snippet": "static void\nsetup_limits_from_gecos (pam_handle_t *pamh, options_t *options,\n\t\t\t struct passwd *pw)\n{\n  char *cp;\n\n  if (options->usergroups)\n    {\n      /* if not root and username is the same as primary group name,\n         set umask group bits to be the same as owner bits\n\t (examples: 022 -> 002, 077 -> 007).  */\n      if (pw->pw_uid != 0)\n\t{\n\t  struct group *grp = pam_modutil_getgrgid (pamh, pw->pw_gid);\n\t  if (grp && (strcmp (pw->pw_name, grp->gr_name) == 0))\n\t    {\n\t      mode_t oldmask = umask (0777);\n\t      umask ((oldmask & ~070) | ((oldmask >> 3) & 070));\n\t    }\n        }\n    }\n\n  /* See if the GECOS field contains values for NICE, UMASK or ULIMIT.  */\n  for (cp = pw->pw_gecos; cp != NULL; cp = strchr (cp, ','))\n    {\n      const char *str;\n\n      if (*cp == ',')\n\tcp++;\n\n      if ((str = pam_str_skip_icase_prefix (cp, \"umask=\")) != NULL)\n\tumask (strtol (str, NULL, 8) & 0777);\n      else if ((str = pam_str_skip_icase_prefix (cp, \"pri=\")) != NULL)\n\t{\n\t  errno = 0;\n\t  if (nice (strtol (str, NULL, 10)) == -1 && errno != 0)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"nice failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"nice failed: %m\");\n\t    }\n\t}\n      else if ((str = pam_str_skip_icase_prefix (cp, \"ulimit=\")) != NULL)\n\t{\n\t  struct rlimit rlimit_fsize;\n\t  rlimit_fsize.rlim_cur = 512L * strtol (str, NULL, 10);\n\t  rlimit_fsize.rlim_max = rlimit_fsize.rlim_cur;\n\t  if (setrlimit (RLIMIT_FSIZE, &rlimit_fsize) == -1)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"setrlimit failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"setrlimit failed: %m\");\n\t    }\n        }\n    }\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"setrlimit failed: %m\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "\"setrlimit failed: %m\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_FSIZE",
            "&rlimit_fsize"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "cp",
            "\"ulimit=\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"nice failed: %m\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_error",
          "args": [
            "pamh",
            "\"nice failed: %m\\n\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nice",
          "args": [
            "strtol (str, NULL, 10)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "cp",
            "\"pri=\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "strtol (str, NULL, 8) & 0777"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "set_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "116-129",
          "snippet": "static void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "8"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "cp",
            "\"umask=\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "','"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pw->pw_name",
            "grp->gr_name"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getgrgid",
          "args": [
            "pamh",
            "pw->pw_gid"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nsetup_limits_from_gecos (pam_handle_t *pamh, options_t *options,\n\t\t\t struct passwd *pw)\n{\n  char *cp;\n\n  if (options->usergroups)\n    {\n      /* if not root and username is the same as primary group name,\n         set umask group bits to be the same as owner bits\n\t (examples: 022 -> 002, 077 -> 007).  */\n      if (pw->pw_uid != 0)\n\t{\n\t  struct group *grp = pam_modutil_getgrgid (pamh, pw->pw_gid);\n\t  if (grp && (strcmp (pw->pw_name, grp->gr_name) == 0))\n\t    {\n\t      mode_t oldmask = umask (0777);\n\t      umask ((oldmask & ~070) | ((oldmask >> 3) & 070));\n\t    }\n        }\n    }\n\n  /* See if the GECOS field contains values for NICE, UMASK or ULIMIT.  */\n  for (cp = pw->pw_gecos; cp != NULL; cp = strchr (cp, ','))\n    {\n      const char *str;\n\n      if (*cp == ',')\n\tcp++;\n\n      if ((str = pam_str_skip_icase_prefix (cp, \"umask=\")) != NULL)\n\tumask (strtol (str, NULL, 8) & 0777);\n      else if ((str = pam_str_skip_icase_prefix (cp, \"pri=\")) != NULL)\n\t{\n\t  errno = 0;\n\t  if (nice (strtol (str, NULL, 10)) == -1 && errno != 0)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"nice failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"nice failed: %m\");\n\t    }\n\t}\n      else if ((str = pam_str_skip_icase_prefix (cp, \"ulimit=\")) != NULL)\n\t{\n\t  struct rlimit rlimit_fsize;\n\t  rlimit_fsize.rlim_cur = 512L * strtol (str, NULL, 10);\n\t  rlimit_fsize.rlim_max = rlimit_fsize.rlim_cur;\n\t  if (setrlimit (RLIMIT_FSIZE, &rlimit_fsize) == -1)\n\t    {\n\t      if (!options->silent || options->debug)\n\t\tpam_error (pamh, \"setrlimit failed: %m\\n\");\n\t      pam_syslog (pamh, LOG_ERR, \"setrlimit failed: %m\");\n\t    }\n        }\n    }\n}"
  },
  {
    "function_name": "set_umask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "116-129",
    "snippet": "static void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "mask"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "set_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "116-129",
          "snippet": "static void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "&endptr",
            "8"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nset_umask (const char *value)\n{\n  const char *value_orig = value;\n  mode_t mask;\n  char *endptr;\n\n  mask = strtoul (value, &endptr, 8) & 0777;\n  if (((mask == 0) && (value_orig == endptr)) ||\n      ((mask == UINT_MAX) && (errno == ERANGE)))\n    return;\n  umask (mask);\n  return;\n}"
  },
  {
    "function_name": "get_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "94-114",
    "snippet": "static int\nget_options (pam_handle_t *pamh, options_t *options,\n\t     int argc, const char **argv)\n{\n  memset (options, 0, sizeof (options_t));\n\n  options->usergroups = DEFAULT_USERGROUPS_SETTING;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, options);\n\n  if (options->umask == NULL) {\n    options->login_umask = pam_modutil_search_key (pamh, LOGIN_DEFS, \"UMASK\");\n    if (options->login_umask == NULL)\n      options->login_umask = pam_modutil_search_key (pamh, LOGIN_CONF, \"UMASK\");\n    options->umask = options->login_umask;\n  }\n\n  return 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LOGIN_CONF \"/etc/default/login\"",
      "#define LOGIN_DEFS \"/etc/login.defs\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_CONF",
            "\"UMASK\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_search_key",
          "args": [
            "pamh",
            "LOGIN_DEFS",
            "\"UMASK\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_option",
          "args": [
            "pamh",
            "*argv",
            "options"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "parse_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
          "lines": "72-92",
          "snippet": "static void\nparse_option (const pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (argv == NULL || argv[0] == '\\0')\n    return;\n\n  if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix (argv, \"umask=\")) != NULL)\n    options->umask = str;\n  else if (strcasecmp (argv, \"usergroups\") == 0)\n    options->usergroups = 1;\n  else if (strcasecmp (argv, \"nousergroups\") == 0)\n    options->usergroups = 0;\n  else if (strcasecmp (argv, \"silent\") == 0)\n    options->silent = 1;\n  else\n    pam_syslog (pamh, LOG_ERR, \"Unknown option: `%s'\", argv);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <sys/resource.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nparse_option (const pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (argv == NULL || argv[0] == '\\0')\n    return;\n\n  if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix (argv, \"umask=\")) != NULL)\n    options->umask = str;\n  else if (strcasecmp (argv, \"usergroups\") == 0)\n    options->usergroups = 1;\n  else if (strcasecmp (argv, \"nousergroups\") == 0)\n    options->usergroups = 0;\n  else if (strcasecmp (argv, \"silent\") == 0)\n    options->silent = 1;\n  else\n    pam_syslog (pamh, LOG_ERR, \"Unknown option: `%s'\", argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "options",
            "0",
            "sizeof (options_t)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\n#define LOGIN_CONF \"/etc/default/login\"\n#define LOGIN_DEFS \"/etc/login.defs\"\n\nstatic int\nget_options (pam_handle_t *pamh, options_t *options,\n\t     int argc, const char **argv)\n{\n  memset (options, 0, sizeof (options_t));\n\n  options->usergroups = DEFAULT_USERGROUPS_SETTING;\n\n  /* Parse parameters for module */\n  for ( ; argc-- > 0; argv++)\n    parse_option (pamh, *argv, options);\n\n  if (options->umask == NULL) {\n    options->login_umask = pam_modutil_search_key (pamh, LOGIN_DEFS, \"UMASK\");\n    if (options->login_umask == NULL)\n      options->login_umask = pam_modutil_search_key (pamh, LOGIN_CONF, \"UMASK\");\n    options->umask = options->login_umask;\n  }\n\n  return 0;\n}"
  },
  {
    "function_name": "parse_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_umask/pam_umask.c",
    "lines": "72-92",
    "snippet": "static void\nparse_option (const pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (argv == NULL || argv[0] == '\\0')\n    return;\n\n  if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix (argv, \"umask=\")) != NULL)\n    options->umask = str;\n  else if (strcasecmp (argv, \"usergroups\") == 0)\n    options->usergroups = 1;\n  else if (strcasecmp (argv, \"nousergroups\") == 0)\n    options->usergroups = 0;\n  else if (strcasecmp (argv, \"silent\") == 0)\n    options->silent = 1;\n  else\n    pam_syslog (pamh, LOG_ERR, \"Unknown option: `%s'\", argv);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <syslog.h>",
      "#include <sys/resource.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <stdio.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"Unknown option: `%s'\"",
            "argv"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"silent\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"nousergroups\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"usergroups\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_icase_prefix",
          "args": [
            "argv",
            "\"umask=\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv",
            "\"debug\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <grp.h>\n#include <pwd.h>\n#include \"config.h\"\n\nstatic void\nparse_option (const pam_handle_t *pamh, const char *argv, options_t *options)\n{\n  const char *str;\n\n  if (argv == NULL || argv[0] == '\\0')\n    return;\n\n  if (strcasecmp (argv, \"debug\") == 0)\n    options->debug = 1;\n  else if ((str = pam_str_skip_icase_prefix (argv, \"umask=\")) != NULL)\n    options->umask = str;\n  else if (strcasecmp (argv, \"usergroups\") == 0)\n    options->usergroups = 1;\n  else if (strcasecmp (argv, \"nousergroups\") == 0)\n    options->usergroups = 0;\n  else if (strcasecmp (argv, \"silent\") == 0)\n    options->silent = 1;\n  else\n    pam_syslog (pamh, LOG_ERR, \"Unknown option: `%s'\", argv);\n}"
  }
]